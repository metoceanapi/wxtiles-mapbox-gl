var wxtilesGl = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __require = typeof require !== "undefined" ? require : (x2) => {
    throw new Error('Dynamic require of "' + x2 + '" is not supported');
  };
  var __commonJS = (cb2, mod) => function __require2() {
    return mod || (0, cb2[Object.keys(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __reExport = (target, module2, desc) => {
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
      for (let key of __getOwnPropNames(module2))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module2) => {
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
  };

  // node_modules/mapbox-gl/dist/mapbox-gl.js
  var require_mapbox_gl = __commonJS({
    "node_modules/mapbox-gl/dist/mapbox-gl.js"(exports, module2) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.mapboxgl = factory());
      })(exports, function() {
        "use strict";
        var shared, worker, mapboxgl2;
        function define2(_, chunk) {
          if (!shared) {
            shared = chunk;
          } else if (!worker) {
            worker = chunk;
          } else {
            var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/api/#transpiling-v2'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
            var sharedChunk = {};
            shared(sharedChunk);
            mapboxgl2 = chunk(sharedChunk);
            if (typeof window !== "undefined") {
              mapboxgl2.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
            }
          }
        }
        define2(["exports"], function(t) {
          "use strict";
          var e = "2.4.1", r2 = n;
          function n(t2, e2, r3, n2) {
            this.cx = 3 * t2, this.bx = 3 * (r3 - t2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t2, this.p1y = n2, this.p2x = r3, this.p2y = n2;
          }
          n.prototype.sampleCurveX = function(t2) {
            return ((this.ax * t2 + this.bx) * t2 + this.cx) * t2;
          }, n.prototype.sampleCurveY = function(t2) {
            return ((this.ay * t2 + this.by) * t2 + this.cy) * t2;
          }, n.prototype.sampleCurveDerivativeX = function(t2) {
            return (3 * this.ax * t2 + 2 * this.bx) * t2 + this.cx;
          }, n.prototype.solveCurveX = function(t2, e2) {
            var r3, n2, i2, s2, a2;
            for (e2 === void 0 && (e2 = 1e-6), i2 = t2, a2 = 0; a2 < 8; a2++) {
              if (s2 = this.sampleCurveX(i2) - t2, Math.abs(s2) < e2)
                return i2;
              var o2 = this.sampleCurveDerivativeX(i2);
              if (Math.abs(o2) < 1e-6)
                break;
              i2 -= s2 / o2;
            }
            if ((i2 = t2) < (r3 = 0))
              return r3;
            if (i2 > (n2 = 1))
              return n2;
            for (; r3 < n2; ) {
              if (s2 = this.sampleCurveX(i2), Math.abs(s2 - t2) < e2)
                return i2;
              t2 > s2 ? r3 = i2 : n2 = i2, i2 = 0.5 * (n2 - r3) + r3;
            }
            return i2;
          }, n.prototype.solve = function(t2, e2) {
            return this.sampleCurveY(this.solveCurveX(t2, e2));
          };
          var i = s;
          function s(t2, e2) {
            this.x = t2, this.y = e2;
          }
          s.prototype = { clone: function() {
            return new s(this.x, this.y);
          }, add: function(t2) {
            return this.clone()._add(t2);
          }, sub: function(t2) {
            return this.clone()._sub(t2);
          }, multByPoint: function(t2) {
            return this.clone()._multByPoint(t2);
          }, divByPoint: function(t2) {
            return this.clone()._divByPoint(t2);
          }, mult: function(t2) {
            return this.clone()._mult(t2);
          }, div: function(t2) {
            return this.clone()._div(t2);
          }, rotate: function(t2) {
            return this.clone()._rotate(t2);
          }, rotateAround: function(t2, e2) {
            return this.clone()._rotateAround(t2, e2);
          }, matMult: function(t2) {
            return this.clone()._matMult(t2);
          }, unit: function() {
            return this.clone()._unit();
          }, perp: function() {
            return this.clone()._perp();
          }, round: function() {
            return this.clone()._round();
          }, mag: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          }, equals: function(t2) {
            return this.x === t2.x && this.y === t2.y;
          }, dist: function(t2) {
            return Math.sqrt(this.distSqr(t2));
          }, distSqr: function(t2) {
            var e2 = t2.x - this.x, r3 = t2.y - this.y;
            return e2 * e2 + r3 * r3;
          }, angle: function() {
            return Math.atan2(this.y, this.x);
          }, angleTo: function(t2) {
            return Math.atan2(this.y - t2.y, this.x - t2.x);
          }, angleWith: function(t2) {
            return this.angleWithSep(t2.x, t2.y);
          }, angleWithSep: function(t2, e2) {
            return Math.atan2(this.x * e2 - this.y * t2, this.x * t2 + this.y * e2);
          }, _matMult: function(t2) {
            var e2 = t2[2] * this.x + t2[3] * this.y;
            return this.x = t2[0] * this.x + t2[1] * this.y, this.y = e2, this;
          }, _add: function(t2) {
            return this.x += t2.x, this.y += t2.y, this;
          }, _sub: function(t2) {
            return this.x -= t2.x, this.y -= t2.y, this;
          }, _mult: function(t2) {
            return this.x *= t2, this.y *= t2, this;
          }, _div: function(t2) {
            return this.x /= t2, this.y /= t2, this;
          }, _multByPoint: function(t2) {
            return this.x *= t2.x, this.y *= t2.y, this;
          }, _divByPoint: function(t2) {
            return this.x /= t2.x, this.y /= t2.y, this;
          }, _unit: function() {
            return this._div(this.mag()), this;
          }, _perp: function() {
            var t2 = this.y;
            return this.y = this.x, this.x = -t2, this;
          }, _rotate: function(t2) {
            var e2 = Math.cos(t2), r3 = Math.sin(t2), n2 = r3 * this.x + e2 * this.y;
            return this.x = e2 * this.x - r3 * this.y, this.y = n2, this;
          }, _rotateAround: function(t2, e2) {
            var r3 = Math.cos(t2), n2 = Math.sin(t2), i2 = e2.y + n2 * (this.x - e2.x) + r3 * (this.y - e2.y);
            return this.x = e2.x + r3 * (this.x - e2.x) - n2 * (this.y - e2.y), this.y = i2, this;
          }, _round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
          } }, s.convert = function(t2) {
            return t2 instanceof s ? t2 : Array.isArray(t2) ? new s(t2[0], t2[1]) : t2;
          };
          var a = typeof self != "undefined" ? self : {};
          const o = Math.pow(2, 53) - 1, l = Math.PI / 180, u = 180 / Math.PI;
          function c(t2) {
            return t2 * l;
          }
          const h = [[0, 0], [1, 0], [1, 1], [0, 1]];
          function p(t2) {
            if (t2 <= 0)
              return 0;
            if (t2 >= 1)
              return 1;
            const e2 = t2 * t2, r3 = e2 * t2;
            return 4 * (t2 < 0.5 ? r3 : 3 * (t2 - e2) + r3 - 0.75);
          }
          function d(t2, e2, n2, i2) {
            const s2 = new r2(t2, e2, n2, i2);
            return function(t3) {
              return s2.solve(t3);
            };
          }
          const f = d(0.25, 0.1, 0.25, 1);
          function y(t2, e2, r3) {
            return Math.min(r3, Math.max(e2, t2));
          }
          function m(t2, e2, r3) {
            const n2 = r3 - e2, i2 = ((t2 - e2) % n2 + n2) % n2 + e2;
            return i2 === e2 ? r3 : i2;
          }
          function g(t2, e2, r3) {
            if (!t2.length)
              return r3(null, []);
            let n2 = t2.length;
            const i2 = new Array(t2.length);
            let s2 = null;
            t2.forEach((t3, a2) => {
              e2(t3, (t4, e3) => {
                t4 && (s2 = t4), i2[a2] = e3, --n2 == 0 && r3(s2, i2);
              });
            });
          }
          function x2(t2) {
            const e2 = [];
            for (const r3 in t2)
              e2.push(t2[r3]);
            return e2;
          }
          function v(t2, ...e2) {
            for (const r3 of e2)
              for (const e3 in r3)
                t2[e3] = r3[e3];
            return t2;
          }
          let b = 1;
          function w2() {
            return b++;
          }
          function _() {
            return function t2(e2) {
              return e2 ? (e2 ^ 16 * Math.random() >> e2 / 4).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t2);
            }();
          }
          function k2(t2) {
            return t2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
          }
          function A(t2) {
            return !!t2 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t2);
          }
          function S(t2, e2) {
            t2.forEach((t3) => {
              e2[t3] && (e2[t3] = e2[t3].bind(e2));
            });
          }
          function I2(t2, e2) {
            return t2.indexOf(e2, t2.length - e2.length) !== -1;
          }
          function z(t2, e2, r3) {
            const n2 = {};
            for (const i2 in t2)
              n2[i2] = e2.call(r3 || this, t2[i2], i2, t2);
            return n2;
          }
          function T(t2, e2, r3) {
            const n2 = {};
            for (const i2 in t2)
              e2.call(r3 || this, t2[i2], i2, t2) && (n2[i2] = t2[i2]);
            return n2;
          }
          function M2(t2) {
            return Array.isArray(t2) ? t2.map(M2) : typeof t2 == "object" && t2 ? z(t2, M2) : t2;
          }
          const E = {};
          function B(t2) {
            E[t2] || (typeof console != "undefined" && console.warn(t2), E[t2] = true);
          }
          function C(t2, e2, r3) {
            return (r3.y - t2.y) * (e2.x - t2.x) > (e2.y - t2.y) * (r3.x - t2.x);
          }
          function P(t2) {
            let e2 = 0;
            for (let r3, n2, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
              r3 = t2[i2], n2 = t2[a2], e2 += (n2.x - r3.x) * (r3.y + n2.y);
            return e2;
          }
          function D() {
            return typeof WorkerGlobalScope != "undefined" && typeof self != "undefined" && self instanceof WorkerGlobalScope;
          }
          function V(t2) {
            const e2 = {};
            if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t3, r3, n2, i2) => {
              const s2 = n2 || i2;
              return e2[r3] = !s2 || s2.toLowerCase(), "";
            }), e2["max-age"]) {
              const t3 = parseInt(e2["max-age"], 10);
              isNaN(t3) ? delete e2["max-age"] : e2["max-age"] = t3;
            }
            return e2;
          }
          let L2, F2, R, U2 = null;
          function $2(t2) {
            if (U2 == null) {
              const e2 = t2.navigator ? t2.navigator.userAgent : null;
              U2 = !!t2.safari || !(!e2 || !(/\b(iPad|iPhone|iPod)\b/.test(e2) || e2.match("Safari") && !e2.match("Chrome")));
            }
            return U2;
          }
          function O(t2) {
            try {
              const e2 = a[t2];
              return e2.setItem("_mapbox_test_", 1), e2.removeItem("_mapbox_test_"), true;
            } catch (t3) {
              return false;
            }
          }
          const q = { now: () => R !== void 0 ? R : a.performance.now(), setNow(t2) {
            R = t2;
          }, restoreNow() {
            R = void 0;
          }, frame(t2) {
            const e2 = a.requestAnimationFrame(t2);
            return { cancel: () => a.cancelAnimationFrame(e2) };
          }, getImageData(t2, e2 = 0) {
            const r3 = a.document.createElement("canvas"), n2 = r3.getContext("2d");
            if (!n2)
              throw new Error("failed to create canvas 2d context");
            return r3.width = t2.width, r3.height = t2.height, n2.drawImage(t2, 0, 0, t2.width, t2.height), n2.getImageData(-e2, -e2, t2.width + 2 * e2, t2.height + 2 * e2);
          }, resolveURL: (t2) => (L2 || (L2 = a.document.createElement("a")), L2.href = t2, L2.href), get devicePixelRatio() {
            return a.devicePixelRatio;
          }, get prefersReducedMotion() {
            return !!a.matchMedia && (F2 == null && (F2 = a.matchMedia("(prefers-reduced-motion: reduce)")), F2.matches);
          } };
          let N;
          const j2 = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
            if (N == null) {
              const t2 = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
              try {
                N = process.env.API_URL_REGEX != null ? new RegExp(process.env.API_URL_REGEX) : t2;
              } catch (e2) {
                N = t2;
              }
            }
            return N;
          }, get EVENTS_URL() {
            return this.API_URL ? this.API_URL.indexOf("https://api.mapbox.cn") === 0 ? "https://events.mapbox.cn/events/v2" : this.API_URL.indexOf("https://api.mapbox.com") === 0 ? "https://events.mapbox.com/events/v2" : null : null;
          }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", REQUIRE_ACCESS_TOKEN: true, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 }, G2 = { supported: false, testSupport: function(t2) {
            !K2 && X && (H ? Y(t2) : Z2 = t2);
          } };
          let Z2, X, K2 = false, H = false;
          function Y(t2) {
            const e2 = t2.createTexture();
            t2.bindTexture(t2.TEXTURE_2D, e2);
            try {
              if (t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, X), t2.isContextLost())
                return;
              G2.supported = true;
            } catch (t3) {
            }
            t2.deleteTexture(e2), K2 = true;
          }
          a.document && (X = a.document.createElement("img"), X.onload = function() {
            Z2 && Y(Z2), Z2 = null, H = true;
          }, X.onerror = function() {
            K2 = true, Z2 = null;
          }, X.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
          const J = "01", W = "NO_ACCESS_TOKEN";
          function Q2(t2) {
            return t2.indexOf("mapbox:") === 0;
          }
          function tt(t2) {
            return j2.API_URL_REGEX.test(t2);
          }
          const et = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
          function rt(t2) {
            const e2 = t2.match(et);
            if (!e2)
              throw new Error("Unable to parse URL object");
            return { protocol: e2[1], authority: e2[2], path: e2[3] || "/", params: e2[4] ? e2[4].split("&") : [] };
          }
          function nt2(t2) {
            const e2 = t2.params.length ? `?${t2.params.join("&")}` : "";
            return `${t2.protocol}://${t2.authority}${t2.path}${e2}`;
          }
          function it2(t2) {
            if (!t2)
              return null;
            const e2 = t2.split(".");
            if (!e2 || e2.length !== 3)
              return null;
            try {
              return JSON.parse(decodeURIComponent(a.atob(e2[1]).split("").map((t3) => "%" + ("00" + t3.charCodeAt(0).toString(16)).slice(-2)).join("")));
            } catch (t3) {
              return null;
            }
          }
          class st2 {
            constructor(t2) {
              this.type = t2, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
            }
            getStorageKey(t2) {
              const e2 = it2(j2.ACCESS_TOKEN);
              let r3 = "";
              return r3 = e2 && e2.u ? a.btoa(encodeURIComponent(e2.u).replace(/%([0-9A-F]{2})/g, (t3, e3) => String.fromCharCode(Number("0x" + e3)))) : j2.ACCESS_TOKEN || "", t2 ? `mapbox.eventData.${t2}:${r3}` : `mapbox.eventData:${r3}`;
            }
            fetchEventData() {
              const t2 = O("localStorage"), e2 = this.getStorageKey(), r3 = this.getStorageKey("uuid");
              if (t2)
                try {
                  const t3 = a.localStorage.getItem(e2);
                  t3 && (this.eventData = JSON.parse(t3));
                  const n2 = a.localStorage.getItem(r3);
                  n2 && (this.anonId = n2);
                } catch (t3) {
                  B("Unable to read from LocalStorage");
                }
            }
            saveEventData() {
              const t2 = O("localStorage"), e2 = this.getStorageKey(), r3 = this.getStorageKey("uuid");
              if (t2)
                try {
                  a.localStorage.setItem(r3, this.anonId), Object.keys(this.eventData).length >= 1 && a.localStorage.setItem(e2, JSON.stringify(this.eventData));
                } catch (t3) {
                  B("Unable to write to LocalStorage");
                }
            }
            processRequests(t2) {
            }
            postEvent(t2, r3, n2, i2) {
              if (!j2.EVENTS_URL)
                return;
              const s2 = rt(j2.EVENTS_URL);
              s2.params.push(`access_token=${i2 || j2.ACCESS_TOKEN || ""}`);
              const a2 = { event: this.type, created: new Date(t2).toISOString(), sdkIdentifier: "mapbox-gl-js", sdkVersion: e, skuId: J, userId: this.anonId }, o2 = r3 ? v(a2, r3) : a2, l2 = { url: nt2(s2), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([o2]) };
              this.pendingRequest = It2(l2, (t3) => {
                this.pendingRequest = null, n2(t3), this.saveEventData(), this.processRequests(i2);
              });
            }
            queueRequest(t2, e2) {
              this.queue.push(t2), this.processRequests(e2);
            }
          }
          const at2 = new class extends st2 {
            constructor(t2) {
              super("appUserTurnstile"), this._customAccessToken = t2;
            }
            postTurnstileEvent(t2, e2) {
              j2.EVENTS_URL && j2.ACCESS_TOKEN && Array.isArray(t2) && t2.some((t3) => Q2(t3) || tt(t3)) && this.queueRequest(Date.now(), e2);
            }
            processRequests(t2) {
              if (this.pendingRequest || this.queue.length === 0)
                return;
              this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
              const e2 = it2(j2.ACCESS_TOKEN), r3 = e2 ? e2.u : j2.ACCESS_TOKEN;
              let n2 = r3 !== this.eventData.tokenU;
              A(this.anonId) || (this.anonId = _(), n2 = true);
              const i2 = this.queue.shift();
              if (this.eventData.lastSuccess) {
                const t3 = new Date(this.eventData.lastSuccess), e3 = new Date(i2), r4 = (i2 - this.eventData.lastSuccess) / 864e5;
                n2 = n2 || r4 >= 1 || r4 < -1 || t3.getDate() !== e3.getDate();
              } else
                n2 = true;
              if (!n2)
                return this.processRequests();
              this.postEvent(i2, { "enabled.telemetry": false }, (t3) => {
                t3 || (this.eventData.lastSuccess = i2, this.eventData.tokenU = r3);
              }, t2);
            }
          }(), ot2 = at2.postTurnstileEvent.bind(at2), lt2 = new class extends st2 {
            constructor() {
              super("map.load"), this.success = {}, this.skuToken = "";
            }
            postMapLoadEvent(t2, e2, r3, n2) {
              this.skuToken = e2, this.errorCb = n2, j2.EVENTS_URL && (r3 || j2.ACCESS_TOKEN ? this.queueRequest({ id: t2, timestamp: Date.now() }, r3) : this.errorCb(new Error(W)));
            }
            processRequests(t2) {
              if (this.pendingRequest || this.queue.length === 0)
                return;
              const { id: e2, timestamp: r3 } = this.queue.shift();
              e2 && this.success[e2] || (this.anonId || this.fetchEventData(), A(this.anonId) || (this.anonId = _()), this.postEvent(r3, { skuToken: this.skuToken }, (t3) => {
                t3 ? this.errorCb(t3) : e2 && (this.success[e2] = true);
              }, t2));
            }
          }(), ut2 = lt2.postMapLoadEvent.bind(lt2), ct2 = new class extends st2 {
            constructor() {
              super("map.auth"), this.success = {}, this.skuToken = "";
            }
            getSession(t2, e2, r3, n2) {
              if (!j2.API_URL || !j2.SESSION_PATH)
                return;
              const i2 = rt(j2.API_URL + j2.SESSION_PATH);
              i2.params.push(`sku=${e2 || ""}`), i2.params.push(`access_token=${n2 || j2.ACCESS_TOKEN || ""}`);
              const s2 = { url: nt2(i2), headers: { "Content-Type": "text/plain" } };
              this.pendingRequest = zt2(s2, (t3) => {
                this.pendingRequest = null, r3(t3), this.saveEventData(), this.processRequests(n2);
              });
            }
            getSessionAPI(t2, e2, r3, n2) {
              this.skuToken = e2, this.errorCb = n2, j2.SESSION_PATH && j2.API_URL && (r3 || j2.ACCESS_TOKEN ? this.queueRequest({ id: t2, timestamp: Date.now() }, r3) : this.errorCb(new Error(W)));
            }
            processRequests(t2) {
              if (this.pendingRequest || this.queue.length === 0)
                return;
              const { id: e2, timestamp: r3 } = this.queue.shift();
              e2 && this.success[e2] || this.getSession(r3, this.skuToken, (t3) => {
                t3 ? this.errorCb(t3) : e2 && (this.success[e2] = true);
              }, t2);
            }
          }(), ht2 = ct2.getSessionAPI.bind(ct2), pt2 = new Set(), dt = "mapbox-tiles";
          let ft2, yt2, mt2 = 500, gt2 = 50;
          function xt2() {
            a.caches && !ft2 && (ft2 = a.caches.open(dt));
          }
          function vt2(t2) {
            const e2 = t2.indexOf("?");
            return e2 < 0 ? t2 : t2.slice(0, e2);
          }
          let bt2 = 1 / 0;
          const wt2 = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
          typeof Object.freeze == "function" && Object.freeze(wt2);
          class _t extends Error {
            constructor(t2, e2, r3) {
              e2 === 401 && tt(r3) && (t2 += ": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"), super(t2), this.status = e2, this.url = r3;
            }
            toString() {
              return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
            }
          }
          const kt2 = D() ? () => self.worker && self.worker.referrer : () => (a.location.protocol === "blob:" ? a.parent : a).location.href;
          const At2 = function(t2, e2) {
            if (!(/^file:/.test(r3 = t2.url) || /^file:/.test(kt2()) && !/^\w+:/.test(r3))) {
              if (a.fetch && a.Request && a.AbortController && a.Request.prototype.hasOwnProperty("signal"))
                return function(t3, e3) {
                  const r4 = new a.AbortController(), n2 = new a.Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, referrer: kt2(), signal: r4.signal });
                  let i2 = false, s2 = false;
                  const o2 = (l2 = n2.url).indexOf("sku=") > 0 && tt(l2);
                  var l2;
                  t3.type === "json" && n2.headers.set("Accept", "application/json");
                  const u2 = (r5, i3, l3) => {
                    if (s2)
                      return;
                    if (r5 && r5.message !== "SecurityError" && B(r5), i3 && l3)
                      return c2(i3);
                    const u3 = Date.now();
                    a.fetch(n2).then((r6) => {
                      if (r6.ok) {
                        const t4 = o2 ? r6.clone() : null;
                        return c2(r6, t4, u3);
                      }
                      return e3(new _t(r6.statusText, r6.status, t3.url));
                    }).catch((t4) => {
                      t4.code !== 20 && e3(new Error(t4.message));
                    });
                  }, c2 = (r5, o3, l3) => {
                    (t3.type === "arrayBuffer" ? r5.arrayBuffer() : t3.type === "json" ? r5.json() : r5.text()).then((t4) => {
                      s2 || (o3 && l3 && function(t5, e4, r6) {
                        if (xt2(), !ft2)
                          return;
                        const n3 = { status: e4.status, statusText: e4.statusText, headers: new a.Headers() };
                        e4.headers.forEach((t6, e5) => n3.headers.set(e5, t6));
                        const i3 = V(e4.headers.get("Cache-Control") || "");
                        i3["no-store"] || (i3["max-age"] && n3.headers.set("Expires", new Date(r6 + 1e3 * i3["max-age"]).toUTCString()), new Date(n3.headers.get("Expires")).getTime() - r6 < 42e4 || function(t6, e5) {
                          if (yt2 === void 0)
                            try {
                              new Response(new ReadableStream()), yt2 = true;
                            } catch (t7) {
                              yt2 = false;
                            }
                          yt2 ? e5(t6.body) : t6.blob().then(e5);
                        }(e4, (e5) => {
                          const r7 = new a.Response(e5, n3);
                          xt2(), ft2 && ft2.then((e6) => e6.put(vt2(t5.url), r7)).catch((t6) => B(t6.message));
                        }));
                      }(n2, o3, l3), i2 = true, e3(null, t4, r5.headers.get("Cache-Control"), r5.headers.get("Expires")));
                    }).catch((t4) => {
                      s2 || e3(new Error(t4.message));
                    });
                  };
                  return o2 ? function(t4, e4) {
                    if (xt2(), !ft2)
                      return e4(null);
                    const r5 = vt2(t4.url);
                    ft2.then((t5) => {
                      t5.match(r5).then((n3) => {
                        const i3 = function(t6) {
                          if (!t6)
                            return false;
                          const e5 = new Date(t6.headers.get("Expires") || 0), r6 = V(t6.headers.get("Cache-Control") || "");
                          return e5 > Date.now() && !r6["no-cache"];
                        }(n3);
                        t5.delete(r5), i3 && t5.put(r5, n3.clone()), e4(null, n3, i3);
                      }).catch(e4);
                    }).catch(e4);
                  }(n2, u2) : u2(null, null), { cancel: () => {
                    s2 = true, i2 || r4.abort();
                  } };
                }(t2, e2);
              if (D() && self.worker && self.worker.actor)
                return self.worker.actor.send("getResource", t2, e2, void 0, true);
            }
            var r3;
            return function(t3, e3) {
              const r4 = new a.XMLHttpRequest();
              r4.open(t3.method || "GET", t3.url, true), t3.type === "arrayBuffer" && (r4.responseType = "arraybuffer");
              for (const e4 in t3.headers)
                r4.setRequestHeader(e4, t3.headers[e4]);
              return t3.type === "json" && (r4.responseType = "text", r4.setRequestHeader("Accept", "application/json")), r4.withCredentials = t3.credentials === "include", r4.onerror = () => {
                e3(new Error(r4.statusText));
              }, r4.onload = () => {
                if ((r4.status >= 200 && r4.status < 300 || r4.status === 0) && r4.response !== null) {
                  let n2 = r4.response;
                  if (t3.type === "json")
                    try {
                      n2 = JSON.parse(r4.response);
                    } catch (t4) {
                      return e3(t4);
                    }
                  e3(null, n2, r4.getResponseHeader("Cache-Control"), r4.getResponseHeader("Expires"));
                } else
                  e3(new _t(r4.statusText, r4.status, t3.url));
              }, r4.send(t3.body), { cancel: () => r4.abort() };
            }(t2, e2);
          }, St2 = function(t2, e2) {
            return At2(v(t2, { type: "arrayBuffer" }), e2);
          }, It2 = function(t2, e2) {
            return At2(v(t2, { method: "POST" }), e2);
          }, zt2 = function(t2, e2) {
            return At2(v(t2, { method: "GET" }), e2);
          };
          function Tt2(t2) {
            const e2 = a.document.createElement("a");
            return e2.href = t2, e2.protocol === a.document.location.protocol && e2.host === a.document.location.host;
          }
          const Mt2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
          let Et2, Bt2;
          Et2 = [], Bt2 = 0;
          const Ct = function(t2, e2) {
            if (G2.supported && (t2.headers || (t2.headers = {}), t2.headers.accept = "image/webp,*/*"), Bt2 >= j2.MAX_PARALLEL_IMAGE_REQUESTS) {
              const r4 = { requestParameters: t2, callback: e2, cancelled: false, cancel() {
                this.cancelled = true;
              } };
              return Et2.push(r4), r4;
            }
            Bt2++;
            let r3 = false;
            const n2 = () => {
              if (!r3)
                for (r3 = true, Bt2--; Et2.length && Bt2 < j2.MAX_PARALLEL_IMAGE_REQUESTS; ) {
                  const t3 = Et2.shift(), { requestParameters: e3, callback: r4, cancelled: n3 } = t3;
                  n3 || (t3.cancel = Ct(e3, r4).cancel);
                }
            }, i2 = St2(t2, (t3, r4, i3, s2) => {
              n2(), t3 ? e2(t3) : r4 && (a.createImageBitmap ? function(t4, e3) {
                const r5 = new a.Blob([new Uint8Array(t4)], { type: "image/png" });
                a.createImageBitmap(r5).then((t5) => {
                  e3(null, t5);
                }).catch((t5) => {
                  e3(new Error(`Could not load image because of ${t5.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
                });
              }(r4, (t4, r5) => e2(t4, r5, i3, s2)) : function(t4, e3) {
                const r5 = new a.Image(), n3 = a.URL;
                r5.onload = () => {
                  e3(null, r5), n3.revokeObjectURL(r5.src), r5.onload = null, a.requestAnimationFrame(() => {
                    r5.src = Mt2;
                  });
                }, r5.onerror = () => e3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                const i4 = new a.Blob([new Uint8Array(t4)], { type: "image/png" });
                r5.src = t4.byteLength ? n3.createObjectURL(i4) : Mt2;
              }(r4, (t4, r5) => e2(t4, r5, i3, s2)));
            });
            return { cancel: () => {
              i2.cancel(), n2();
            } };
          };
          function Pt2(t2, e2, r3) {
            r3[t2] && r3[t2].indexOf(e2) !== -1 || (r3[t2] = r3[t2] || [], r3[t2].push(e2));
          }
          function Dt2(t2, e2, r3) {
            if (r3 && r3[t2]) {
              const n2 = r3[t2].indexOf(e2);
              n2 !== -1 && r3[t2].splice(n2, 1);
            }
          }
          class Vt2 {
            constructor(t2, e2 = {}) {
              v(this, e2), this.type = t2;
            }
          }
          class Lt extends Vt2 {
            constructor(t2, e2 = {}) {
              super("error", v({ error: t2 }, e2));
            }
          }
          class Ft2 {
            on(t2, e2) {
              return this._listeners = this._listeners || {}, Pt2(t2, e2, this._listeners), this;
            }
            off(t2, e2) {
              return Dt2(t2, e2, this._listeners), Dt2(t2, e2, this._oneTimeListeners), this;
            }
            once(t2, e2) {
              return e2 ? (this._oneTimeListeners = this._oneTimeListeners || {}, Pt2(t2, e2, this._oneTimeListeners), this) : new Promise((e3) => this.once(t2, e3));
            }
            fire(t2, e2) {
              typeof t2 == "string" && (t2 = new Vt2(t2, e2 || {}));
              const r3 = t2.type;
              if (this.listens(r3)) {
                t2.target = this;
                const e3 = this._listeners && this._listeners[r3] ? this._listeners[r3].slice() : [];
                for (const r4 of e3)
                  r4.call(this, t2);
                const n2 = this._oneTimeListeners && this._oneTimeListeners[r3] ? this._oneTimeListeners[r3].slice() : [];
                for (const e4 of n2)
                  Dt2(r3, e4, this._oneTimeListeners), e4.call(this, t2);
                const i2 = this._eventedParent;
                i2 && (v(t2, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), i2.fire(t2));
              } else
                t2 instanceof Lt && console.error(t2.error);
              return this;
            }
            listens(t2) {
              return !!(this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2));
            }
            setEventedParent(t2, e2) {
              return this._eventedParent = t2, this._eventedParentData = e2, this;
            }
          }
          var Rt = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, terrain: { type: "terrain" }, fog: { type: "fog" }, sources: { required: true, type: "sources" }, sprite: { type: "string" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {} }, default: "mapbox" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {}, sky: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background", "layout_sky"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_sky: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, fog: { range: { type: "array", default: [0.5, 10], minimum: -20, maximum: 20, length: 2, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-blend": { type: "number", "property-type": "data-constant", default: 0.1, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", "property-type": "data-constant", default: 1, minimum: 0, maximum: 1e3, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background", "paint_sky"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_sky: { "sky-type": { type: "enum", values: { gradient: {}, atmosphere: {} }, default: "atmosphere", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "sky-atmosphere-sun": { type: "array", value: "number", length: 2, units: "degrees", minimum: [0, 0], maximum: [360, 180], transition: false, requires: [{ "sky-type": "atmosphere" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "sky-atmosphere-sun-intensity": { type: "number", requires: [{ "sky-type": "atmosphere" }], default: 10, minimum: 0, maximum: 100, transition: false, "property-type": "data-constant" }, "sky-gradient-center": { type: "array", requires: [{ "sky-type": "gradient" }], value: "number", default: [0, 0], length: 2, units: "degrees", minimum: [0, 0], maximum: [360, 180], transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "sky-gradient-radius": { type: "number", requires: [{ "sky-type": "gradient" }], default: 90, minimum: 0, maximum: 180, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "sky-gradient": { type: "color", default: ["interpolate", ["linear"], ["sky-radial-progress"], 0.8, "#87ceeb", 1, "white"], transition: false, requires: [{ "sky-type": "gradient" }], expression: { interpolated: true, parameters: ["sky-radial-progress"] }, "property-type": "color-ramp" }, "sky-atmosphere-halo-color": { type: "color", default: "white", transition: false, requires: [{ "sky-type": "atmosphere" }], "property-type": "data-constant" }, "sky-atmosphere-color": { type: "color", default: "white", transition: false, requires: [{ "sky-type": "atmosphere" }], "property-type": "data-constant" }, "sky-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
          class Ut2 {
            constructor(t2, e2, r3, n2) {
              this.message = (t2 ? `${t2}: ` : "") + r3, n2 && (this.identifier = n2), e2 != null && e2.__line__ && (this.line = e2.__line__);
            }
          }
          function $t2(t2) {
            const e2 = t2.value;
            return e2 ? [new Ut2(t2.key, e2, "constants have been deprecated as of v8")] : [];
          }
          function Ot2(t2, ...e2) {
            for (const r3 of e2)
              for (const e3 in r3)
                t2[e3] = r3[e3];
            return t2;
          }
          function qt2(t2) {
            return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
          }
          function Nt2(t2) {
            if (Array.isArray(t2))
              return t2.map(Nt2);
            if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
              const e2 = {};
              for (const r3 in t2)
                e2[r3] = Nt2(t2[r3]);
              return e2;
            }
            return qt2(t2);
          }
          class jt extends Error {
            constructor(t2, e2) {
              super(e2), this.message = e2, this.key = t2;
            }
          }
          class Gt2 {
            constructor(t2, e2 = []) {
              this.parent = t2, this.bindings = {};
              for (const [t3, r3] of e2)
                this.bindings[t3] = r3;
            }
            concat(t2) {
              return new Gt2(this, t2);
            }
            get(t2) {
              if (this.bindings[t2])
                return this.bindings[t2];
              if (this.parent)
                return this.parent.get(t2);
              throw new Error(`${t2} not found in scope.`);
            }
            has(t2) {
              return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
            }
          }
          const Zt2 = { kind: "null" }, Xt = { kind: "number" }, Kt2 = { kind: "string" }, Ht = { kind: "boolean" }, Yt = { kind: "color" }, Jt2 = { kind: "object" }, Wt = { kind: "value" }, Qt2 = { kind: "collator" }, te2 = { kind: "formatted" }, ee2 = { kind: "resolvedImage" };
          function re2(t2, e2) {
            return { kind: "array", itemType: t2, N: e2 };
          }
          function ne2(t2) {
            if (t2.kind === "array") {
              const e2 = ne2(t2.itemType);
              return typeof t2.N == "number" ? `array<${e2}, ${t2.N}>` : t2.itemType.kind === "value" ? "array" : `array<${e2}>`;
            }
            return t2.kind;
          }
          const ie = [Zt2, Xt, Kt2, Ht, Yt, te2, Jt2, re2(Wt), ee2];
          function se2(t2, e2) {
            if (e2.kind === "error")
              return null;
            if (t2.kind === "array") {
              if (e2.kind === "array" && (e2.N === 0 && e2.itemType.kind === "value" || !se2(t2.itemType, e2.itemType)) && (typeof t2.N != "number" || t2.N === e2.N))
                return null;
            } else {
              if (t2.kind === e2.kind)
                return null;
              if (t2.kind === "value") {
                for (const t3 of ie)
                  if (!se2(t3, e2))
                    return null;
              }
            }
            return `Expected ${ne2(t2)} but found ${ne2(e2)} instead.`;
          }
          function ae2(t2, e2) {
            return e2.some((e3) => e3.kind === t2.kind);
          }
          function oe2(t2, e2) {
            return e2.some((e3) => e3 === "null" ? t2 === null : e3 === "array" ? Array.isArray(t2) : e3 === "object" ? t2 && !Array.isArray(t2) && typeof t2 == "object" : e3 === typeof t2);
          }
          function le2(t2) {
            var e2 = { exports: {} };
            return t2(e2, e2.exports), e2.exports;
          }
          var ue2 = le2(function(t2, e2) {
            var r3 = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
            function n2(t3) {
              return (t3 = Math.round(t3)) < 0 ? 0 : t3 > 255 ? 255 : t3;
            }
            function i2(t3) {
              return n2(t3[t3.length - 1] === "%" ? parseFloat(t3) / 100 * 255 : parseInt(t3));
            }
            function s2(t3) {
              return (e3 = t3[t3.length - 1] === "%" ? parseFloat(t3) / 100 : parseFloat(t3)) < 0 ? 0 : e3 > 1 ? 1 : e3;
              var e3;
            }
            function a2(t3, e3, r4) {
              return r4 < 0 ? r4 += 1 : r4 > 1 && (r4 -= 1), 6 * r4 < 1 ? t3 + (e3 - t3) * r4 * 6 : 2 * r4 < 1 ? e3 : 3 * r4 < 2 ? t3 + (e3 - t3) * (2 / 3 - r4) * 6 : t3;
            }
            try {
              e2.parseCSSColor = function(t3) {
                var e3, o2 = t3.replace(/ /g, "").toLowerCase();
                if (o2 in r3)
                  return r3[o2].slice();
                if (o2[0] === "#")
                  return o2.length === 4 ? (e3 = parseInt(o2.substr(1), 16)) >= 0 && e3 <= 4095 ? [(3840 & e3) >> 4 | (3840 & e3) >> 8, 240 & e3 | (240 & e3) >> 4, 15 & e3 | (15 & e3) << 4, 1] : null : o2.length === 7 && (e3 = parseInt(o2.substr(1), 16)) >= 0 && e3 <= 16777215 ? [(16711680 & e3) >> 16, (65280 & e3) >> 8, 255 & e3, 1] : null;
                var l2 = o2.indexOf("("), u2 = o2.indexOf(")");
                if (l2 !== -1 && u2 + 1 === o2.length) {
                  var c2 = o2.substr(0, l2), h2 = o2.substr(l2 + 1, u2 - (l2 + 1)).split(","), p2 = 1;
                  switch (c2) {
                    case "rgba":
                      if (h2.length !== 4)
                        return null;
                      p2 = s2(h2.pop());
                    case "rgb":
                      return h2.length !== 3 ? null : [i2(h2[0]), i2(h2[1]), i2(h2[2]), p2];
                    case "hsla":
                      if (h2.length !== 4)
                        return null;
                      p2 = s2(h2.pop());
                    case "hsl":
                      if (h2.length !== 3)
                        return null;
                      var d2 = (parseFloat(h2[0]) % 360 + 360) % 360 / 360, f2 = s2(h2[1]), y2 = s2(h2[2]), m2 = y2 <= 0.5 ? y2 * (f2 + 1) : y2 + f2 - y2 * f2, g2 = 2 * y2 - m2;
                      return [n2(255 * a2(g2, m2, d2 + 1 / 3)), n2(255 * a2(g2, m2, d2)), n2(255 * a2(g2, m2, d2 - 1 / 3)), p2];
                    default:
                      return null;
                  }
                }
                return null;
              };
            } catch (t3) {
            }
          });
          class ce2 {
            constructor(t2, e2, r3, n2 = 1) {
              this.r = t2, this.g = e2, this.b = r3, this.a = n2;
            }
            static parse(t2) {
              if (!t2)
                return;
              if (t2 instanceof ce2)
                return t2;
              if (typeof t2 != "string")
                return;
              const e2 = ue2.parseCSSColor(t2);
              return e2 ? new ce2(e2[0] / 255 * e2[3], e2[1] / 255 * e2[3], e2[2] / 255 * e2[3], e2[3]) : void 0;
            }
            toString() {
              const [t2, e2, r3, n2] = this.toArray();
              return `rgba(${Math.round(t2)},${Math.round(e2)},${Math.round(r3)},${n2})`;
            }
            toArray() {
              const { r: t2, g: e2, b: r3, a: n2 } = this;
              return n2 === 0 ? [0, 0, 0, 0] : [255 * t2 / n2, 255 * e2 / n2, 255 * r3 / n2, n2];
            }
          }
          ce2.black = new ce2(0, 0, 0, 1), ce2.white = new ce2(1, 1, 1, 1), ce2.transparent = new ce2(0, 0, 0, 0), ce2.red = new ce2(1, 0, 0, 1), ce2.blue = new ce2(0, 0, 1, 1);
          class he2 {
            constructor(t2, e2, r3) {
              this.sensitivity = t2 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r3, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
            }
            compare(t2, e2) {
              return this.collator.compare(t2, e2);
            }
            resolvedLocale() {
              return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
            }
          }
          class pe {
            constructor(t2, e2, r3, n2, i2) {
              this.text = t2, this.image = e2, this.scale = r3, this.fontStack = n2, this.textColor = i2;
            }
          }
          class de2 {
            constructor(t2) {
              this.sections = t2;
            }
            static fromString(t2) {
              return new de2([new pe(t2, null, null, null, null)]);
            }
            isEmpty() {
              return this.sections.length === 0 || !this.sections.some((t2) => t2.text.length !== 0 || t2.image && t2.image.name.length !== 0);
            }
            static factory(t2) {
              return t2 instanceof de2 ? t2 : de2.fromString(t2);
            }
            toString() {
              return this.sections.length === 0 ? "" : this.sections.map((t2) => t2.text).join("");
            }
            serialize() {
              const t2 = ["format"];
              for (const e2 of this.sections) {
                if (e2.image) {
                  t2.push(["image", e2.image.name]);
                  continue;
                }
                t2.push(e2.text);
                const r3 = {};
                e2.fontStack && (r3["text-font"] = ["literal", e2.fontStack.split(",")]), e2.scale && (r3["font-scale"] = e2.scale), e2.textColor && (r3["text-color"] = ["rgba"].concat(e2.textColor.toArray())), t2.push(r3);
              }
              return t2;
            }
          }
          class fe2 {
            constructor(t2) {
              this.name = t2.name, this.available = t2.available;
            }
            toString() {
              return this.name;
            }
            static fromString(t2) {
              return t2 ? new fe2({ name: t2, available: false }) : null;
            }
            serialize() {
              return ["image", this.name];
            }
          }
          function ye2(t2, e2, r3, n2) {
            return typeof t2 == "number" && t2 >= 0 && t2 <= 255 && typeof e2 == "number" && e2 >= 0 && e2 <= 255 && typeof r3 == "number" && r3 >= 0 && r3 <= 255 ? n2 === void 0 || typeof n2 == "number" && n2 >= 0 && n2 <= 1 ? null : `Invalid rgba value [${[t2, e2, r3, n2].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n2 == "number" ? [t2, e2, r3, n2] : [t2, e2, r3]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
          }
          function me2(t2) {
            if (t2 === null)
              return true;
            if (typeof t2 == "string")
              return true;
            if (typeof t2 == "boolean")
              return true;
            if (typeof t2 == "number")
              return true;
            if (t2 instanceof ce2)
              return true;
            if (t2 instanceof he2)
              return true;
            if (t2 instanceof de2)
              return true;
            if (t2 instanceof fe2)
              return true;
            if (Array.isArray(t2)) {
              for (const e2 of t2)
                if (!me2(e2))
                  return false;
              return true;
            }
            if (typeof t2 == "object") {
              for (const e2 in t2)
                if (!me2(t2[e2]))
                  return false;
              return true;
            }
            return false;
          }
          function ge2(t2) {
            if (t2 === null)
              return Zt2;
            if (typeof t2 == "string")
              return Kt2;
            if (typeof t2 == "boolean")
              return Ht;
            if (typeof t2 == "number")
              return Xt;
            if (t2 instanceof ce2)
              return Yt;
            if (t2 instanceof he2)
              return Qt2;
            if (t2 instanceof de2)
              return te2;
            if (t2 instanceof fe2)
              return ee2;
            if (Array.isArray(t2)) {
              const e2 = t2.length;
              let r3;
              for (const e3 of t2) {
                const t3 = ge2(e3);
                if (r3) {
                  if (r3 === t3)
                    continue;
                  r3 = Wt;
                  break;
                }
                r3 = t3;
              }
              return re2(r3 || Wt, e2);
            }
            return Jt2;
          }
          function xe2(t2) {
            const e2 = typeof t2;
            return t2 === null ? "" : e2 === "string" || e2 === "number" || e2 === "boolean" ? String(t2) : t2 instanceof ce2 || t2 instanceof de2 || t2 instanceof fe2 ? t2.toString() : JSON.stringify(t2);
          }
          class ve2 {
            constructor(t2, e2) {
              this.type = t2, this.value = e2;
            }
            static parse(t2, e2) {
              if (t2.length !== 2)
                return e2.error(`'literal' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
              if (!me2(t2[1]))
                return e2.error("invalid value");
              const r3 = t2[1];
              let n2 = ge2(r3);
              const i2 = e2.expectedType;
              return n2.kind !== "array" || n2.N !== 0 || !i2 || i2.kind !== "array" || typeof i2.N == "number" && i2.N !== 0 || (n2 = i2), new ve2(n2, r3);
            }
            evaluate() {
              return this.value;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
            serialize() {
              return this.type.kind === "array" || this.type.kind === "object" ? ["literal", this.value] : this.value instanceof ce2 ? ["rgba"].concat(this.value.toArray()) : this.value instanceof de2 ? this.value.serialize() : this.value;
            }
          }
          class be2 {
            constructor(t2) {
              this.name = "ExpressionEvaluationError", this.message = t2;
            }
            toJSON() {
              return this.message;
            }
          }
          const we2 = { string: Kt2, number: Xt, boolean: Ht, object: Jt2 };
          class _e2 {
            constructor(t2, e2) {
              this.type = t2, this.args = e2;
            }
            static parse(t2, e2) {
              if (t2.length < 2)
                return e2.error("Expected at least one argument.");
              let r3, n2 = 1;
              const i2 = t2[0];
              if (i2 === "array") {
                let i3, s3;
                if (t2.length > 2) {
                  const r4 = t2[1];
                  if (typeof r4 != "string" || !(r4 in we2) || r4 === "object")
                    return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
                  i3 = we2[r4], n2++;
                } else
                  i3 = Wt;
                if (t2.length > 3) {
                  if (t2[2] !== null && (typeof t2[2] != "number" || t2[2] < 0 || t2[2] !== Math.floor(t2[2])))
                    return e2.error('The length argument to "array" must be a positive integer literal', 2);
                  s3 = t2[2], n2++;
                }
                r3 = re2(i3, s3);
              } else
                r3 = we2[i2];
              const s2 = [];
              for (; n2 < t2.length; n2++) {
                const r4 = e2.parse(t2[n2], n2, Wt);
                if (!r4)
                  return null;
                s2.push(r4);
              }
              return new _e2(r3, s2);
            }
            evaluate(t2) {
              for (let e2 = 0; e2 < this.args.length; e2++) {
                const r3 = this.args[e2].evaluate(t2);
                if (!se2(this.type, ge2(r3)))
                  return r3;
                if (e2 === this.args.length - 1)
                  throw new be2(`Expected value to be of type ${ne2(this.type)}, but found ${ne2(ge2(r3))} instead.`);
              }
              return null;
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return this.args.every((t2) => t2.outputDefined());
            }
            serialize() {
              const t2 = this.type, e2 = [t2.kind];
              if (t2.kind === "array") {
                const r3 = t2.itemType;
                if (r3.kind === "string" || r3.kind === "number" || r3.kind === "boolean") {
                  e2.push(r3.kind);
                  const n2 = t2.N;
                  (typeof n2 == "number" || this.args.length > 1) && e2.push(n2);
                }
              }
              return e2.concat(this.args.map((t3) => t3.serialize()));
            }
          }
          class ke {
            constructor(t2) {
              this.type = te2, this.sections = t2;
            }
            static parse(t2, e2) {
              if (t2.length < 2)
                return e2.error("Expected at least one argument.");
              const r3 = t2[1];
              if (!Array.isArray(r3) && typeof r3 == "object")
                return e2.error("First argument must be an image or text section.");
              const n2 = [];
              let i2 = false;
              for (let r4 = 1; r4 <= t2.length - 1; ++r4) {
                const s2 = t2[r4];
                if (i2 && typeof s2 == "object" && !Array.isArray(s2)) {
                  i2 = false;
                  let t3 = null;
                  if (s2["font-scale"] && (t3 = e2.parse(s2["font-scale"], 1, Xt), !t3))
                    return null;
                  let r5 = null;
                  if (s2["text-font"] && (r5 = e2.parse(s2["text-font"], 1, re2(Kt2)), !r5))
                    return null;
                  let a2 = null;
                  if (s2["text-color"] && (a2 = e2.parse(s2["text-color"], 1, Yt), !a2))
                    return null;
                  const o2 = n2[n2.length - 1];
                  o2.scale = t3, o2.font = r5, o2.textColor = a2;
                } else {
                  const s3 = e2.parse(t2[r4], 1, Wt);
                  if (!s3)
                    return null;
                  const a2 = s3.type.kind;
                  if (a2 !== "string" && a2 !== "value" && a2 !== "null" && a2 !== "resolvedImage")
                    return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                  i2 = true, n2.push({ content: s3, scale: null, font: null, textColor: null });
                }
              }
              return new ke(n2);
            }
            evaluate(t2) {
              return new de2(this.sections.map((e2) => {
                const r3 = e2.content.evaluate(t2);
                return ge2(r3) === ee2 ? new pe("", r3, null, null, null) : new pe(xe2(r3), null, e2.scale ? e2.scale.evaluate(t2) : null, e2.font ? e2.font.evaluate(t2).join(",") : null, e2.textColor ? e2.textColor.evaluate(t2) : null);
              }));
            }
            eachChild(t2) {
              for (const e2 of this.sections)
                t2(e2.content), e2.scale && t2(e2.scale), e2.font && t2(e2.font), e2.textColor && t2(e2.textColor);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              const t2 = ["format"];
              for (const e2 of this.sections) {
                t2.push(e2.content.serialize());
                const r3 = {};
                e2.scale && (r3["font-scale"] = e2.scale.serialize()), e2.font && (r3["text-font"] = e2.font.serialize()), e2.textColor && (r3["text-color"] = e2.textColor.serialize()), t2.push(r3);
              }
              return t2;
            }
          }
          class Ae2 {
            constructor(t2) {
              this.type = ee2, this.input = t2;
            }
            static parse(t2, e2) {
              if (t2.length !== 2)
                return e2.error("Expected two arguments.");
              const r3 = e2.parse(t2[1], 1, Kt2);
              return r3 ? new Ae2(r3) : e2.error("No image name provided.");
            }
            evaluate(t2) {
              const e2 = this.input.evaluate(t2), r3 = fe2.fromString(e2);
              return r3 && t2.availableImages && (r3.available = t2.availableImages.indexOf(e2) > -1), r3;
            }
            eachChild(t2) {
              t2(this.input);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return ["image", this.input.serialize()];
            }
          }
          const Se = { "to-boolean": Ht, "to-color": Yt, "to-number": Xt, "to-string": Kt2 };
          class Ie2 {
            constructor(t2, e2) {
              this.type = t2, this.args = e2;
            }
            static parse(t2, e2) {
              if (t2.length < 2)
                return e2.error("Expected at least one argument.");
              const r3 = t2[0];
              if ((r3 === "to-boolean" || r3 === "to-string") && t2.length !== 2)
                return e2.error("Expected one argument.");
              const n2 = Se[r3], i2 = [];
              for (let r4 = 1; r4 < t2.length; r4++) {
                const n3 = e2.parse(t2[r4], r4, Wt);
                if (!n3)
                  return null;
                i2.push(n3);
              }
              return new Ie2(n2, i2);
            }
            evaluate(t2) {
              if (this.type.kind === "boolean")
                return Boolean(this.args[0].evaluate(t2));
              if (this.type.kind === "color") {
                let e2, r3;
                for (const n2 of this.args) {
                  if (e2 = n2.evaluate(t2), r3 = null, e2 instanceof ce2)
                    return e2;
                  if (typeof e2 == "string") {
                    const r4 = t2.parseColor(e2);
                    if (r4)
                      return r4;
                  } else if (Array.isArray(e2) && (r3 = e2.length < 3 || e2.length > 4 ? `Invalid rbga value ${JSON.stringify(e2)}: expected an array containing either three or four numeric values.` : ye2(e2[0], e2[1], e2[2], e2[3]), !r3))
                    return new ce2(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
                }
                throw new be2(r3 || `Could not parse color from value '${typeof e2 == "string" ? e2 : String(JSON.stringify(e2))}'`);
              }
              if (this.type.kind === "number") {
                let e2 = null;
                for (const r3 of this.args) {
                  if (e2 = r3.evaluate(t2), e2 === null)
                    return 0;
                  const n2 = Number(e2);
                  if (!isNaN(n2))
                    return n2;
                }
                throw new be2(`Could not convert ${JSON.stringify(e2)} to number.`);
              }
              return this.type.kind === "formatted" ? de2.fromString(xe2(this.args[0].evaluate(t2))) : this.type.kind === "resolvedImage" ? fe2.fromString(xe2(this.args[0].evaluate(t2))) : xe2(this.args[0].evaluate(t2));
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return this.args.every((t2) => t2.outputDefined());
            }
            serialize() {
              if (this.type.kind === "formatted")
                return new ke([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
              if (this.type.kind === "resolvedImage")
                return new Ae2(this.args[0]).serialize();
              const t2 = [`to-${this.type.kind}`];
              return this.eachChild((e2) => {
                t2.push(e2.serialize());
              }), t2;
            }
          }
          const ze2 = ["Unknown", "Point", "LineString", "Polygon"];
          class Te {
            constructor() {
              this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
            }
            id() {
              return this.feature && "id" in this.feature ? this.feature.id : null;
            }
            geometryType() {
              return this.feature ? typeof this.feature.type == "number" ? ze2[this.feature.type] : this.feature.type : null;
            }
            geometry() {
              return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
            }
            canonicalID() {
              return this.canonical;
            }
            properties() {
              return this.feature && this.feature.properties || {};
            }
            parseColor(t2) {
              let e2 = this._parseColorCache[t2];
              return e2 || (e2 = this._parseColorCache[t2] = ce2.parse(t2)), e2;
            }
          }
          class Me2 {
            constructor(t2, e2, r3, n2) {
              this.name = t2, this.type = e2, this._evaluate = r3, this.args = n2;
            }
            evaluate(t2) {
              return this._evaluate(t2, this.args);
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return [this.name].concat(this.args.map((t2) => t2.serialize()));
            }
            static parse(t2, e2) {
              const r3 = t2[0], n2 = Me2.definitions[r3];
              if (!n2)
                return e2.error(`Unknown expression "${r3}". If you wanted a literal array, use ["literal", [...]].`, 0);
              const i2 = Array.isArray(n2) ? n2[0] : n2.type, s2 = Array.isArray(n2) ? [[n2[1], n2[2]]] : n2.overloads, a2 = s2.filter(([e3]) => !Array.isArray(e3) || e3.length === t2.length - 1);
              let o2 = null;
              for (const [n3, s3] of a2) {
                o2 = new We(e2.registry, e2.path, null, e2.scope);
                const a3 = [];
                let l2 = false;
                for (let e3 = 1; e3 < t2.length; e3++) {
                  const r4 = t2[e3], i3 = Array.isArray(n3) ? n3[e3 - 1] : n3.type, s4 = o2.parse(r4, 1 + a3.length, i3);
                  if (!s4) {
                    l2 = true;
                    break;
                  }
                  a3.push(s4);
                }
                if (!l2)
                  if (Array.isArray(n3) && n3.length !== a3.length)
                    o2.error(`Expected ${n3.length} arguments, but found ${a3.length} instead.`);
                  else {
                    for (let t3 = 0; t3 < a3.length; t3++) {
                      const e3 = Array.isArray(n3) ? n3[t3] : n3.type, r4 = a3[t3];
                      o2.concat(t3 + 1).checkSubtype(e3, r4.type);
                    }
                    if (o2.errors.length === 0)
                      return new Me2(r3, i2, s3, a3);
                  }
              }
              if (a2.length === 1)
                e2.errors.push(...o2.errors);
              else {
                const r4 = (a2.length ? a2 : s2).map(([t3]) => {
                  return e3 = t3, Array.isArray(e3) ? `(${e3.map(ne2).join(", ")})` : `(${ne2(e3.type)}...)`;
                  var e3;
                }).join(" | "), n3 = [];
                for (let r5 = 1; r5 < t2.length; r5++) {
                  const i3 = e2.parse(t2[r5], 1 + n3.length);
                  if (!i3)
                    return null;
                  n3.push(ne2(i3.type));
                }
                e2.error(`Expected arguments of type ${r4}, but found (${n3.join(", ")}) instead.`);
              }
              return null;
            }
            static register(t2, e2) {
              Me2.definitions = e2;
              for (const r3 in e2)
                t2[r3] = Me2;
            }
          }
          class Ee {
            constructor(t2, e2, r3) {
              this.type = Qt2, this.locale = r3, this.caseSensitive = t2, this.diacriticSensitive = e2;
            }
            static parse(t2, e2) {
              if (t2.length !== 2)
                return e2.error("Expected one argument.");
              const r3 = t2[1];
              if (typeof r3 != "object" || Array.isArray(r3))
                return e2.error("Collator options argument must be an object.");
              const n2 = e2.parse(r3["case-sensitive"] !== void 0 && r3["case-sensitive"], 1, Ht);
              if (!n2)
                return null;
              const i2 = e2.parse(r3["diacritic-sensitive"] !== void 0 && r3["diacritic-sensitive"], 1, Ht);
              if (!i2)
                return null;
              let s2 = null;
              return r3.locale && (s2 = e2.parse(r3.locale, 1, Kt2), !s2) ? null : new Ee(n2, i2, s2);
            }
            evaluate(t2) {
              return new he2(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
            }
            eachChild(t2) {
              t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              const t2 = {};
              return t2["case-sensitive"] = this.caseSensitive.serialize(), t2["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t2.locale = this.locale.serialize()), ["collator", t2];
            }
          }
          const Be2 = 8192;
          function Ce2(t2, e2) {
            t2[0] = Math.min(t2[0], e2[0]), t2[1] = Math.min(t2[1], e2[1]), t2[2] = Math.max(t2[2], e2[0]), t2[3] = Math.max(t2[3], e2[1]);
          }
          function Pe2(t2, e2) {
            return !(t2[0] <= e2[0] || t2[2] >= e2[2] || t2[1] <= e2[1] || t2[3] >= e2[3]);
          }
          function De2(t2, e2) {
            const r3 = (180 + t2[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e2.z);
            return [Math.round(r3 * i2 * Be2), Math.round(n2 * i2 * Be2)];
          }
          function Ve2(t2, e2, r3) {
            const n2 = t2[0] - e2[0], i2 = t2[1] - e2[1], s2 = t2[0] - r3[0], a2 = t2[1] - r3[1];
            return n2 * a2 - s2 * i2 == 0 && n2 * s2 <= 0 && i2 * a2 <= 0;
          }
          function Le2(t2, e2) {
            let r3 = false;
            for (let a2 = 0, o2 = e2.length; a2 < o2; a2++) {
              const o3 = e2[a2];
              for (let e3 = 0, a3 = o3.length; e3 < a3 - 1; e3++) {
                if (Ve2(t2, o3[e3], o3[e3 + 1]))
                  return false;
                (i2 = o3[e3])[1] > (n2 = t2)[1] != (s2 = o3[e3 + 1])[1] > n2[1] && n2[0] < (s2[0] - i2[0]) * (n2[1] - i2[1]) / (s2[1] - i2[1]) + i2[0] && (r3 = !r3);
              }
            }
            var n2, i2, s2;
            return r3;
          }
          function Fe(t2, e2) {
            for (let r3 = 0; r3 < e2.length; r3++)
              if (Le2(t2, e2[r3]))
                return true;
            return false;
          }
          function Re2(t2, e2, r3, n2) {
            const i2 = n2[0] - r3[0], s2 = n2[1] - r3[1], a2 = (t2[0] - r3[0]) * s2 - i2 * (t2[1] - r3[1]), o2 = (e2[0] - r3[0]) * s2 - i2 * (e2[1] - r3[1]);
            return a2 > 0 && o2 < 0 || a2 < 0 && o2 > 0;
          }
          function Ue(t2, e2, r3) {
            for (const u2 of r3)
              for (let r4 = 0; r4 < u2.length - 1; ++r4)
                if ((o2 = [(a2 = u2[r4 + 1])[0] - (s2 = u2[r4])[0], a2[1] - s2[1]])[0] * (l2 = [(i2 = e2)[0] - (n2 = t2)[0], i2[1] - n2[1]])[1] - o2[1] * l2[0] != 0 && Re2(n2, i2, s2, a2) && Re2(s2, a2, n2, i2))
                  return true;
            var n2, i2, s2, a2, o2, l2;
            return false;
          }
          function $e2(t2, e2) {
            for (let r3 = 0; r3 < t2.length; ++r3)
              if (!Le2(t2[r3], e2))
                return false;
            for (let r3 = 0; r3 < t2.length - 1; ++r3)
              if (Ue(t2[r3], t2[r3 + 1], e2))
                return false;
            return true;
          }
          function Oe2(t2, e2) {
            for (let r3 = 0; r3 < e2.length; r3++)
              if ($e2(t2, e2[r3]))
                return true;
            return false;
          }
          function qe2(t2, e2, r3) {
            const n2 = [];
            for (let i2 = 0; i2 < t2.length; i2++) {
              const s2 = [];
              for (let n3 = 0; n3 < t2[i2].length; n3++) {
                const a2 = De2(t2[i2][n3], r3);
                Ce2(e2, a2), s2.push(a2);
              }
              n2.push(s2);
            }
            return n2;
          }
          function Ne(t2, e2, r3) {
            const n2 = [];
            for (let i2 = 0; i2 < t2.length; i2++) {
              const s2 = qe2(t2[i2], e2, r3);
              n2.push(s2);
            }
            return n2;
          }
          function je2(t2, e2, r3, n2) {
            if (t2[0] < r3[0] || t2[0] > r3[2]) {
              const e3 = 0.5 * n2;
              let i2 = t2[0] - r3[0] > e3 ? -n2 : r3[0] - t2[0] > e3 ? n2 : 0;
              i2 === 0 && (i2 = t2[0] - r3[2] > e3 ? -n2 : r3[2] - t2[0] > e3 ? n2 : 0), t2[0] += i2;
            }
            Ce2(e2, t2);
          }
          function Ge2(t2, e2, r3, n2) {
            const i2 = Math.pow(2, n2.z) * Be2, s2 = [n2.x * Be2, n2.y * Be2], a2 = [];
            for (const n3 of t2)
              for (const t3 of n3) {
                const n4 = [t3.x + s2[0], t3.y + s2[1]];
                je2(n4, e2, r3, i2), a2.push(n4);
              }
            return a2;
          }
          function Ze2(t2, e2, r3, n2) {
            const i2 = Math.pow(2, n2.z) * Be2, s2 = [n2.x * Be2, n2.y * Be2], a2 = [];
            for (const r4 of t2) {
              const t3 = [];
              for (const n3 of r4) {
                const r5 = [n3.x + s2[0], n3.y + s2[1]];
                Ce2(e2, r5), t3.push(r5);
              }
              a2.push(t3);
            }
            if (e2[2] - e2[0] <= i2 / 2) {
              (o2 = e2)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
              for (const t3 of a2)
                for (const n3 of t3)
                  je2(n3, e2, r3, i2);
            }
            var o2;
            return a2;
          }
          class Xe2 {
            constructor(t2, e2) {
              this.type = Ht, this.geojson = t2, this.geometries = e2;
            }
            static parse(t2, e2) {
              if (t2.length !== 2)
                return e2.error(`'within' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
              if (me2(t2[1])) {
                const e3 = t2[1];
                if (e3.type === "FeatureCollection")
                  for (let t3 = 0; t3 < e3.features.length; ++t3) {
                    const r3 = e3.features[t3].geometry.type;
                    if (r3 === "Polygon" || r3 === "MultiPolygon")
                      return new Xe2(e3, e3.features[t3].geometry);
                  }
                else if (e3.type === "Feature") {
                  const t3 = e3.geometry.type;
                  if (t3 === "Polygon" || t3 === "MultiPolygon")
                    return new Xe2(e3, e3.geometry);
                } else if (e3.type === "Polygon" || e3.type === "MultiPolygon")
                  return new Xe2(e3, e3);
              }
              return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
            }
            evaluate(t2) {
              if (t2.geometry() != null && t2.canonicalID() != null) {
                if (t2.geometryType() === "Point")
                  return function(t3, e2) {
                    const r3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                    if (e2.type === "Polygon") {
                      const s2 = qe2(e2.coordinates, n2, i2), a2 = Ge2(t3.geometry(), r3, n2, i2);
                      if (!Pe2(r3, n2))
                        return false;
                      for (const t4 of a2)
                        if (!Le2(t4, s2))
                          return false;
                    }
                    if (e2.type === "MultiPolygon") {
                      const s2 = Ne(e2.coordinates, n2, i2), a2 = Ge2(t3.geometry(), r3, n2, i2);
                      if (!Pe2(r3, n2))
                        return false;
                      for (const t4 of a2)
                        if (!Fe(t4, s2))
                          return false;
                    }
                    return true;
                  }(t2, this.geometries);
                if (t2.geometryType() === "LineString")
                  return function(t3, e2) {
                    const r3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                    if (e2.type === "Polygon") {
                      const s2 = qe2(e2.coordinates, n2, i2), a2 = Ze2(t3.geometry(), r3, n2, i2);
                      if (!Pe2(r3, n2))
                        return false;
                      for (const t4 of a2)
                        if (!$e2(t4, s2))
                          return false;
                    }
                    if (e2.type === "MultiPolygon") {
                      const s2 = Ne(e2.coordinates, n2, i2), a2 = Ze2(t3.geometry(), r3, n2, i2);
                      if (!Pe2(r3, n2))
                        return false;
                      for (const t4 of a2)
                        if (!Oe2(t4, s2))
                          return false;
                    }
                    return true;
                  }(t2, this.geometries);
              }
              return false;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
            serialize() {
              return ["within", this.geojson];
            }
          }
          function Ke2(t2) {
            if (t2 instanceof Me2) {
              if (t2.name === "get" && t2.args.length === 1)
                return false;
              if (t2.name === "feature-state")
                return false;
              if (t2.name === "has" && t2.args.length === 1)
                return false;
              if (t2.name === "properties" || t2.name === "geometry-type" || t2.name === "id")
                return false;
              if (/^filter-/.test(t2.name))
                return false;
            }
            if (t2 instanceof Xe2)
              return false;
            let e2 = true;
            return t2.eachChild((t3) => {
              e2 && !Ke2(t3) && (e2 = false);
            }), e2;
          }
          function He(t2) {
            if (t2 instanceof Me2 && t2.name === "feature-state")
              return false;
            let e2 = true;
            return t2.eachChild((t3) => {
              e2 && !He(t3) && (e2 = false);
            }), e2;
          }
          function Ye2(t2, e2) {
            if (t2 instanceof Me2 && e2.indexOf(t2.name) >= 0)
              return false;
            let r3 = true;
            return t2.eachChild((t3) => {
              r3 && !Ye2(t3, e2) && (r3 = false);
            }), r3;
          }
          class Je2 {
            constructor(t2, e2) {
              this.type = e2.type, this.name = t2, this.boundExpression = e2;
            }
            static parse(t2, e2) {
              if (t2.length !== 2 || typeof t2[1] != "string")
                return e2.error("'var' expression requires exactly one string literal argument.");
              const r3 = t2[1];
              return e2.scope.has(r3) ? new Je2(r3, e2.scope.get(r3)) : e2.error(`Unknown variable "${r3}". Make sure "${r3}" has been bound in an enclosing "let" expression before using it.`, 1);
            }
            evaluate(t2) {
              return this.boundExpression.evaluate(t2);
            }
            eachChild() {
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return ["var", this.name];
            }
          }
          class We {
            constructor(t2, e2 = [], r3, n2 = new Gt2(), i2 = []) {
              this.registry = t2, this.path = e2, this.key = e2.map((t3) => `[${t3}]`).join(""), this.scope = n2, this.errors = i2, this.expectedType = r3;
            }
            parse(t2, e2, r3, n2, i2 = {}) {
              return e2 ? this.concat(e2, r3, n2)._parse(t2, i2) : this._parse(t2, i2);
            }
            _parse(t2, e2) {
              function r3(t3, e3, r4) {
                return r4 === "assert" ? new _e2(e3, [t3]) : r4 === "coerce" ? new Ie2(e3, [t3]) : t3;
              }
              if (t2 !== null && typeof t2 != "string" && typeof t2 != "boolean" && typeof t2 != "number" || (t2 = ["literal", t2]), Array.isArray(t2)) {
                if (t2.length === 0)
                  return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                const n2 = t2[0];
                if (typeof n2 != "string")
                  return this.error(`Expression name must be a string, but found ${typeof n2} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
                const i2 = this.registry[n2];
                if (i2) {
                  let n3 = i2.parse(t2, this);
                  if (!n3)
                    return null;
                  if (this.expectedType) {
                    const t3 = this.expectedType, i3 = n3.type;
                    if (t3.kind !== "string" && t3.kind !== "number" && t3.kind !== "boolean" && t3.kind !== "object" && t3.kind !== "array" || i3.kind !== "value")
                      if (t3.kind !== "color" && t3.kind !== "formatted" && t3.kind !== "resolvedImage" || i3.kind !== "value" && i3.kind !== "string") {
                        if (this.checkSubtype(t3, i3))
                          return null;
                      } else
                        n3 = r3(n3, t3, e2.typeAnnotation || "coerce");
                    else
                      n3 = r3(n3, t3, e2.typeAnnotation || "assert");
                  }
                  if (!(n3 instanceof ve2) && n3.type.kind !== "resolvedImage" && Qe2(n3)) {
                    const t3 = new Te();
                    try {
                      n3 = new ve2(n3.type, n3.evaluate(t3));
                    } catch (t4) {
                      return this.error(t4.message), null;
                    }
                  }
                  return n3;
                }
                return this.error(`Unknown expression "${n2}". If you wanted a literal array, use ["literal", [...]].`, 0);
              }
              return this.error(t2 === void 0 ? "'undefined' value invalid. Use null instead." : typeof t2 == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t2} instead.`);
            }
            concat(t2, e2, r3) {
              const n2 = typeof t2 == "number" ? this.path.concat(t2) : this.path, i2 = r3 ? this.scope.concat(r3) : this.scope;
              return new We(this.registry, n2, e2 || null, i2, this.errors);
            }
            error(t2, ...e2) {
              const r3 = `${this.key}${e2.map((t3) => `[${t3}]`).join("")}`;
              this.errors.push(new jt(r3, t2));
            }
            checkSubtype(t2, e2) {
              const r3 = se2(t2, e2);
              return r3 && this.error(r3), r3;
            }
          }
          function Qe2(t2) {
            if (t2 instanceof Je2)
              return Qe2(t2.boundExpression);
            if (t2 instanceof Me2 && t2.name === "error")
              return false;
            if (t2 instanceof Ee)
              return false;
            if (t2 instanceof Xe2)
              return false;
            const e2 = t2 instanceof Ie2 || t2 instanceof _e2;
            let r3 = true;
            return t2.eachChild((t3) => {
              r3 = e2 ? r3 && Qe2(t3) : r3 && t3 instanceof ve2;
            }), !!r3 && Ke2(t2) && Ye2(t2, ["zoom", "heatmap-density", "line-progress", "sky-radial-progress", "accumulated", "is-supported-script"]);
          }
          function tr2(t2, e2) {
            const r3 = t2.length - 1;
            let n2, i2, s2 = 0, a2 = r3, o2 = 0;
            for (; s2 <= a2; )
              if (o2 = Math.floor((s2 + a2) / 2), n2 = t2[o2], i2 = t2[o2 + 1], n2 <= e2) {
                if (o2 === r3 || e2 < i2)
                  return o2;
                s2 = o2 + 1;
              } else {
                if (!(n2 > e2))
                  throw new be2("Input is not a number.");
                a2 = o2 - 1;
              }
            return 0;
          }
          class er2 {
            constructor(t2, e2, r3) {
              this.type = t2, this.input = e2, this.labels = [], this.outputs = [];
              for (const [t3, e3] of r3)
                this.labels.push(t3), this.outputs.push(e3);
            }
            static parse(t2, e2) {
              if (t2.length - 1 < 4)
                return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
              if ((t2.length - 1) % 2 != 0)
                return e2.error("Expected an even number of arguments.");
              const r3 = e2.parse(t2[1], 1, Xt);
              if (!r3)
                return null;
              const n2 = [];
              let i2 = null;
              e2.expectedType && e2.expectedType.kind !== "value" && (i2 = e2.expectedType);
              for (let r4 = 1; r4 < t2.length; r4 += 2) {
                const s2 = r4 === 1 ? -1 / 0 : t2[r4], a2 = t2[r4 + 1], o2 = r4, l2 = r4 + 1;
                if (typeof s2 != "number")
                  return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
                if (n2.length && n2[n2.length - 1][0] >= s2)
                  return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
                const u2 = e2.parse(a2, l2, i2);
                if (!u2)
                  return null;
                i2 = i2 || u2.type, n2.push([s2, u2]);
              }
              return new er2(i2, r3, n2);
            }
            evaluate(t2) {
              const e2 = this.labels, r3 = this.outputs;
              if (e2.length === 1)
                return r3[0].evaluate(t2);
              const n2 = this.input.evaluate(t2);
              if (n2 <= e2[0])
                return r3[0].evaluate(t2);
              const i2 = e2.length;
              return n2 >= e2[i2 - 1] ? r3[i2 - 1].evaluate(t2) : r3[tr2(e2, n2)].evaluate(t2);
            }
            eachChild(t2) {
              t2(this.input);
              for (const e2 of this.outputs)
                t2(e2);
            }
            outputDefined() {
              return this.outputs.every((t2) => t2.outputDefined());
            }
            serialize() {
              const t2 = ["step", this.input.serialize()];
              for (let e2 = 0; e2 < this.labels.length; e2++)
                e2 > 0 && t2.push(this.labels[e2]), t2.push(this.outputs[e2].serialize());
              return t2;
            }
          }
          function rr2(t2, e2, r3) {
            return t2 * (1 - r3) + e2 * r3;
          }
          var nr2 = Object.freeze({ __proto__: null, number: rr2, color: function(t2, e2, r3) {
            return new ce2(rr2(t2.r, e2.r, r3), rr2(t2.g, e2.g, r3), rr2(t2.b, e2.b, r3), rr2(t2.a, e2.a, r3));
          }, array: function(t2, e2, r3) {
            return t2.map((t3, n2) => rr2(t3, e2[n2], r3));
          } });
          const ir2 = 0.95047, sr2 = 1.08883, ar2 = 4 / 29, or2 = 6 / 29, lr = 3 * or2 * or2, ur2 = Math.PI / 180, cr = 180 / Math.PI;
          function hr2(t2) {
            return t2 > 0.008856451679035631 ? Math.pow(t2, 1 / 3) : t2 / lr + ar2;
          }
          function pr2(t2) {
            return t2 > or2 ? t2 * t2 * t2 : lr * (t2 - ar2);
          }
          function dr2(t2) {
            return 255 * (t2 <= 31308e-7 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055);
          }
          function fr2(t2) {
            return (t2 /= 255) <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
          }
          function yr2(t2) {
            const e2 = fr2(t2.r), r3 = fr2(t2.g), n2 = fr2(t2.b), i2 = hr2((0.4124564 * e2 + 0.3575761 * r3 + 0.1804375 * n2) / ir2), s2 = hr2((0.2126729 * e2 + 0.7151522 * r3 + 0.072175 * n2) / 1);
            return { l: 116 * s2 - 16, a: 500 * (i2 - s2), b: 200 * (s2 - hr2((0.0193339 * e2 + 0.119192 * r3 + 0.9503041 * n2) / sr2)), alpha: t2.a };
          }
          function mr2(t2) {
            let e2 = (t2.l + 16) / 116, r3 = isNaN(t2.a) ? e2 : e2 + t2.a / 500, n2 = isNaN(t2.b) ? e2 : e2 - t2.b / 200;
            return e2 = 1 * pr2(e2), r3 = ir2 * pr2(r3), n2 = sr2 * pr2(n2), new ce2(dr2(3.2404542 * r3 - 1.5371385 * e2 - 0.4985314 * n2), dr2(-0.969266 * r3 + 1.8760108 * e2 + 0.041556 * n2), dr2(0.0556434 * r3 - 0.2040259 * e2 + 1.0572252 * n2), t2.alpha);
          }
          function gr2(t2, e2, r3) {
            const n2 = e2 - t2;
            return t2 + r3 * (n2 > 180 || n2 < -180 ? n2 - 360 * Math.round(n2 / 360) : n2);
          }
          const xr2 = { forward: yr2, reverse: mr2, interpolate: function(t2, e2, r3) {
            return { l: rr2(t2.l, e2.l, r3), a: rr2(t2.a, e2.a, r3), b: rr2(t2.b, e2.b, r3), alpha: rr2(t2.alpha, e2.alpha, r3) };
          } }, vr2 = { forward: function(t2) {
            const { l: e2, a: r3, b: n2 } = yr2(t2), i2 = Math.atan2(n2, r3) * cr;
            return { h: i2 < 0 ? i2 + 360 : i2, c: Math.sqrt(r3 * r3 + n2 * n2), l: e2, alpha: t2.a };
          }, reverse: function(t2) {
            const e2 = t2.h * ur2, r3 = t2.c;
            return mr2({ l: t2.l, a: Math.cos(e2) * r3, b: Math.sin(e2) * r3, alpha: t2.alpha });
          }, interpolate: function(t2, e2, r3) {
            return { h: gr2(t2.h, e2.h, r3), c: rr2(t2.c, e2.c, r3), l: rr2(t2.l, e2.l, r3), alpha: rr2(t2.alpha, e2.alpha, r3) };
          } };
          var br2 = Object.freeze({ __proto__: null, lab: xr2, hcl: vr2 });
          class wr2 {
            constructor(t2, e2, r3, n2, i2) {
              this.type = t2, this.operator = e2, this.interpolation = r3, this.input = n2, this.labels = [], this.outputs = [];
              for (const [t3, e3] of i2)
                this.labels.push(t3), this.outputs.push(e3);
            }
            static interpolationFactor(t2, e2, n2, i2) {
              let s2 = 0;
              if (t2.name === "exponential")
                s2 = _r2(e2, t2.base, n2, i2);
              else if (t2.name === "linear")
                s2 = _r2(e2, 1, n2, i2);
              else if (t2.name === "cubic-bezier") {
                const a2 = t2.controlPoints;
                s2 = new r2(a2[0], a2[1], a2[2], a2[3]).solve(_r2(e2, 1, n2, i2));
              }
              return s2;
            }
            static parse(t2, e2) {
              let [r3, n2, i2, ...s2] = t2;
              if (!Array.isArray(n2) || n2.length === 0)
                return e2.error("Expected an interpolation type expression.", 1);
              if (n2[0] === "linear")
                n2 = { name: "linear" };
              else if (n2[0] === "exponential") {
                const t3 = n2[1];
                if (typeof t3 != "number")
                  return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
                n2 = { name: "exponential", base: t3 };
              } else {
                if (n2[0] !== "cubic-bezier")
                  return e2.error(`Unknown interpolation type ${String(n2[0])}`, 1, 0);
                {
                  const t3 = n2.slice(1);
                  if (t3.length !== 4 || t3.some((t4) => typeof t4 != "number" || t4 < 0 || t4 > 1))
                    return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                  n2 = { name: "cubic-bezier", controlPoints: t3 };
                }
              }
              if (t2.length - 1 < 4)
                return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
              if ((t2.length - 1) % 2 != 0)
                return e2.error("Expected an even number of arguments.");
              if (i2 = e2.parse(i2, 2, Xt), !i2)
                return null;
              const a2 = [];
              let o2 = null;
              r3 === "interpolate-hcl" || r3 === "interpolate-lab" ? o2 = Yt : e2.expectedType && e2.expectedType.kind !== "value" && (o2 = e2.expectedType);
              for (let t3 = 0; t3 < s2.length; t3 += 2) {
                const r4 = s2[t3], n3 = s2[t3 + 1], i3 = t3 + 3, l2 = t3 + 4;
                if (typeof r4 != "number")
                  return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
                if (a2.length && a2[a2.length - 1][0] >= r4)
                  return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
                const u2 = e2.parse(n3, l2, o2);
                if (!u2)
                  return null;
                o2 = o2 || u2.type, a2.push([r4, u2]);
              }
              return o2.kind === "number" || o2.kind === "color" || o2.kind === "array" && o2.itemType.kind === "number" && typeof o2.N == "number" ? new wr2(o2, r3, n2, i2, a2) : e2.error(`Type ${ne2(o2)} is not interpolatable.`);
            }
            evaluate(t2) {
              const e2 = this.labels, r3 = this.outputs;
              if (e2.length === 1)
                return r3[0].evaluate(t2);
              const n2 = this.input.evaluate(t2);
              if (n2 <= e2[0])
                return r3[0].evaluate(t2);
              const i2 = e2.length;
              if (n2 >= e2[i2 - 1])
                return r3[i2 - 1].evaluate(t2);
              const s2 = tr2(e2, n2), a2 = wr2.interpolationFactor(this.interpolation, n2, e2[s2], e2[s2 + 1]), o2 = r3[s2].evaluate(t2), l2 = r3[s2 + 1].evaluate(t2);
              return this.operator === "interpolate" ? nr2[this.type.kind.toLowerCase()](o2, l2, a2) : this.operator === "interpolate-hcl" ? vr2.reverse(vr2.interpolate(vr2.forward(o2), vr2.forward(l2), a2)) : xr2.reverse(xr2.interpolate(xr2.forward(o2), xr2.forward(l2), a2));
            }
            eachChild(t2) {
              t2(this.input);
              for (const e2 of this.outputs)
                t2(e2);
            }
            outputDefined() {
              return this.outputs.every((t2) => t2.outputDefined());
            }
            serialize() {
              let t2;
              t2 = this.interpolation.name === "linear" ? ["linear"] : this.interpolation.name === "exponential" ? this.interpolation.base === 1 ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
              const e2 = [this.operator, t2, this.input.serialize()];
              for (let t3 = 0; t3 < this.labels.length; t3++)
                e2.push(this.labels[t3], this.outputs[t3].serialize());
              return e2;
            }
          }
          function _r2(t2, e2, r3, n2) {
            const i2 = n2 - r3, s2 = t2 - r3;
            return i2 === 0 ? 0 : e2 === 1 ? s2 / i2 : (Math.pow(e2, s2) - 1) / (Math.pow(e2, i2) - 1);
          }
          class kr2 {
            constructor(t2, e2) {
              this.type = t2, this.args = e2;
            }
            static parse(t2, e2) {
              if (t2.length < 2)
                return e2.error("Expectected at least one argument.");
              let r3 = null;
              const n2 = e2.expectedType;
              n2 && n2.kind !== "value" && (r3 = n2);
              const i2 = [];
              for (const n3 of t2.slice(1)) {
                const t3 = e2.parse(n3, 1 + i2.length, r3, void 0, { typeAnnotation: "omit" });
                if (!t3)
                  return null;
                r3 = r3 || t3.type, i2.push(t3);
              }
              const s2 = n2 && i2.some((t3) => se2(n2, t3.type));
              return new kr2(s2 ? Wt : r3, i2);
            }
            evaluate(t2) {
              let e2, r3 = null, n2 = 0;
              for (const i2 of this.args)
                if (n2++, r3 = i2.evaluate(t2), r3 && r3 instanceof fe2 && !r3.available && (e2 || (e2 = r3.name), r3 = null, n2 === this.args.length && (r3 = e2)), r3 !== null)
                  break;
              return r3;
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return this.args.every((t2) => t2.outputDefined());
            }
            serialize() {
              const t2 = ["coalesce"];
              return this.eachChild((e2) => {
                t2.push(e2.serialize());
              }), t2;
            }
          }
          class Ar2 {
            constructor(t2, e2) {
              this.type = e2.type, this.bindings = [].concat(t2), this.result = e2;
            }
            evaluate(t2) {
              return this.result.evaluate(t2);
            }
            eachChild(t2) {
              for (const e2 of this.bindings)
                t2(e2[1]);
              t2(this.result);
            }
            static parse(t2, e2) {
              if (t2.length < 4)
                return e2.error(`Expected at least 3 arguments, but found ${t2.length - 1} instead.`);
              const r3 = [];
              for (let n3 = 1; n3 < t2.length - 1; n3 += 2) {
                const i2 = t2[n3];
                if (typeof i2 != "string")
                  return e2.error(`Expected string, but found ${typeof i2} instead.`, n3);
                if (/[^a-zA-Z0-9_]/.test(i2))
                  return e2.error("Variable names must contain only alphanumeric characters or '_'.", n3);
                const s2 = e2.parse(t2[n3 + 1], n3 + 1);
                if (!s2)
                  return null;
                r3.push([i2, s2]);
              }
              const n2 = e2.parse(t2[t2.length - 1], t2.length - 1, e2.expectedType, r3);
              return n2 ? new Ar2(r3, n2) : null;
            }
            outputDefined() {
              return this.result.outputDefined();
            }
            serialize() {
              const t2 = ["let"];
              for (const [e2, r3] of this.bindings)
                t2.push(e2, r3.serialize());
              return t2.push(this.result.serialize()), t2;
            }
          }
          class Sr2 {
            constructor(t2, e2, r3) {
              this.type = t2, this.index = e2, this.input = r3;
            }
            static parse(t2, e2) {
              if (t2.length !== 3)
                return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
              const r3 = e2.parse(t2[1], 1, Xt), n2 = e2.parse(t2[2], 2, re2(e2.expectedType || Wt));
              return r3 && n2 ? new Sr2(n2.type.itemType, r3, n2) : null;
            }
            evaluate(t2) {
              const e2 = this.index.evaluate(t2), r3 = this.input.evaluate(t2);
              if (e2 < 0)
                throw new be2(`Array index out of bounds: ${e2} < 0.`);
              if (e2 >= r3.length)
                throw new be2(`Array index out of bounds: ${e2} > ${r3.length - 1}.`);
              if (e2 !== Math.floor(e2))
                throw new be2(`Array index must be an integer, but found ${e2} instead.`);
              return r3[e2];
            }
            eachChild(t2) {
              t2(this.index), t2(this.input);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return ["at", this.index.serialize(), this.input.serialize()];
            }
          }
          class Ir2 {
            constructor(t2, e2) {
              this.type = Ht, this.needle = t2, this.haystack = e2;
            }
            static parse(t2, e2) {
              if (t2.length !== 3)
                return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
              const r3 = e2.parse(t2[1], 1, Wt), n2 = e2.parse(t2[2], 2, Wt);
              return r3 && n2 ? ae2(r3.type, [Ht, Kt2, Xt, Zt2, Wt]) ? new Ir2(r3, n2) : e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${ne2(r3.type)} instead`) : null;
            }
            evaluate(t2) {
              const e2 = this.needle.evaluate(t2), r3 = this.haystack.evaluate(t2);
              if (!r3)
                return false;
              if (!oe2(e2, ["boolean", "string", "number", "null"]))
                throw new be2(`Expected first argument to be of type boolean, string, number or null, but found ${ne2(ge2(e2))} instead.`);
              if (!oe2(r3, ["string", "array"]))
                throw new be2(`Expected second argument to be of type array or string, but found ${ne2(ge2(r3))} instead.`);
              return r3.indexOf(e2) >= 0;
            }
            eachChild(t2) {
              t2(this.needle), t2(this.haystack);
            }
            outputDefined() {
              return true;
            }
            serialize() {
              return ["in", this.needle.serialize(), this.haystack.serialize()];
            }
          }
          class zr {
            constructor(t2, e2, r3) {
              this.type = Xt, this.needle = t2, this.haystack = e2, this.fromIndex = r3;
            }
            static parse(t2, e2) {
              if (t2.length <= 2 || t2.length >= 5)
                return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
              const r3 = e2.parse(t2[1], 1, Wt), n2 = e2.parse(t2[2], 2, Wt);
              if (!r3 || !n2)
                return null;
              if (!ae2(r3.type, [Ht, Kt2, Xt, Zt2, Wt]))
                return e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${ne2(r3.type)} instead`);
              if (t2.length === 4) {
                const i2 = e2.parse(t2[3], 3, Xt);
                return i2 ? new zr(r3, n2, i2) : null;
              }
              return new zr(r3, n2);
            }
            evaluate(t2) {
              const e2 = this.needle.evaluate(t2), r3 = this.haystack.evaluate(t2);
              if (!oe2(e2, ["boolean", "string", "number", "null"]))
                throw new be2(`Expected first argument to be of type boolean, string, number or null, but found ${ne2(ge2(e2))} instead.`);
              if (!oe2(r3, ["string", "array"]))
                throw new be2(`Expected second argument to be of type array or string, but found ${ne2(ge2(r3))} instead.`);
              if (this.fromIndex) {
                const n2 = this.fromIndex.evaluate(t2);
                return r3.indexOf(e2, n2);
              }
              return r3.indexOf(e2);
            }
            eachChild(t2) {
              t2(this.needle), t2(this.haystack), this.fromIndex && t2(this.fromIndex);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              if (this.fromIndex != null && this.fromIndex !== void 0) {
                const t2 = this.fromIndex.serialize();
                return ["index-of", this.needle.serialize(), this.haystack.serialize(), t2];
              }
              return ["index-of", this.needle.serialize(), this.haystack.serialize()];
            }
          }
          class Tr2 {
            constructor(t2, e2, r3, n2, i2, s2) {
              this.inputType = t2, this.type = e2, this.input = r3, this.cases = n2, this.outputs = i2, this.otherwise = s2;
            }
            static parse(t2, e2) {
              if (t2.length < 5)
                return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
              if (t2.length % 2 != 1)
                return e2.error("Expected an even number of arguments.");
              let r3, n2;
              e2.expectedType && e2.expectedType.kind !== "value" && (n2 = e2.expectedType);
              const i2 = {}, s2 = [];
              for (let a3 = 2; a3 < t2.length - 1; a3 += 2) {
                let o3 = t2[a3];
                const l2 = t2[a3 + 1];
                Array.isArray(o3) || (o3 = [o3]);
                const u2 = e2.concat(a3);
                if (o3.length === 0)
                  return u2.error("Expected at least one branch label.");
                for (const t3 of o3) {
                  if (typeof t3 != "number" && typeof t3 != "string")
                    return u2.error("Branch labels must be numbers or strings.");
                  if (typeof t3 == "number" && Math.abs(t3) > Number.MAX_SAFE_INTEGER)
                    return u2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                  if (typeof t3 == "number" && Math.floor(t3) !== t3)
                    return u2.error("Numeric branch labels must be integer values.");
                  if (r3) {
                    if (u2.checkSubtype(r3, ge2(t3)))
                      return null;
                  } else
                    r3 = ge2(t3);
                  if (i2[String(t3)] !== void 0)
                    return u2.error("Branch labels must be unique.");
                  i2[String(t3)] = s2.length;
                }
                const c2 = e2.parse(l2, a3, n2);
                if (!c2)
                  return null;
                n2 = n2 || c2.type, s2.push(c2);
              }
              const a2 = e2.parse(t2[1], 1, Wt);
              if (!a2)
                return null;
              const o2 = e2.parse(t2[t2.length - 1], t2.length - 1, n2);
              return o2 ? a2.type.kind !== "value" && e2.concat(1).checkSubtype(r3, a2.type) ? null : new Tr2(r3, n2, a2, i2, s2, o2) : null;
            }
            evaluate(t2) {
              const e2 = this.input.evaluate(t2);
              return (ge2(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t2);
            }
            eachChild(t2) {
              t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
            }
            outputDefined() {
              return this.outputs.every((t2) => t2.outputDefined()) && this.otherwise.outputDefined();
            }
            serialize() {
              const t2 = ["match", this.input.serialize()], e2 = Object.keys(this.cases).sort(), r3 = [], n2 = {};
              for (const t3 of e2) {
                const e3 = n2[this.cases[t3]];
                e3 === void 0 ? (n2[this.cases[t3]] = r3.length, r3.push([this.cases[t3], [t3]])) : r3[e3][1].push(t3);
              }
              const i2 = (t3) => this.inputType.kind === "number" ? Number(t3) : t3;
              for (const [e3, n3] of r3)
                t2.push(n3.length === 1 ? i2(n3[0]) : n3.map(i2)), t2.push(this.outputs[e3].serialize());
              return t2.push(this.otherwise.serialize()), t2;
            }
          }
          class Mr2 {
            constructor(t2, e2, r3) {
              this.type = t2, this.branches = e2, this.otherwise = r3;
            }
            static parse(t2, e2) {
              if (t2.length < 4)
                return e2.error(`Expected at least 3 arguments, but found only ${t2.length - 1}.`);
              if (t2.length % 2 != 0)
                return e2.error("Expected an odd number of arguments.");
              let r3;
              e2.expectedType && e2.expectedType.kind !== "value" && (r3 = e2.expectedType);
              const n2 = [];
              for (let i3 = 1; i3 < t2.length - 1; i3 += 2) {
                const s2 = e2.parse(t2[i3], i3, Ht);
                if (!s2)
                  return null;
                const a2 = e2.parse(t2[i3 + 1], i3 + 1, r3);
                if (!a2)
                  return null;
                n2.push([s2, a2]), r3 = r3 || a2.type;
              }
              const i2 = e2.parse(t2[t2.length - 1], t2.length - 1, r3);
              return i2 ? new Mr2(r3, n2, i2) : null;
            }
            evaluate(t2) {
              for (const [e2, r3] of this.branches)
                if (e2.evaluate(t2))
                  return r3.evaluate(t2);
              return this.otherwise.evaluate(t2);
            }
            eachChild(t2) {
              for (const [e2, r3] of this.branches)
                t2(e2), t2(r3);
              t2(this.otherwise);
            }
            outputDefined() {
              return this.branches.every(([t2, e2]) => e2.outputDefined()) && this.otherwise.outputDefined();
            }
            serialize() {
              const t2 = ["case"];
              return this.eachChild((e2) => {
                t2.push(e2.serialize());
              }), t2;
            }
          }
          class Er2 {
            constructor(t2, e2, r3, n2) {
              this.type = t2, this.input = e2, this.beginIndex = r3, this.endIndex = n2;
            }
            static parse(t2, e2) {
              if (t2.length <= 2 || t2.length >= 5)
                return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
              const r3 = e2.parse(t2[1], 1, Wt), n2 = e2.parse(t2[2], 2, Xt);
              if (!r3 || !n2)
                return null;
              if (!ae2(r3.type, [re2(Wt), Kt2, Wt]))
                return e2.error(`Expected first argument to be of type array or string, but found ${ne2(r3.type)} instead`);
              if (t2.length === 4) {
                const i2 = e2.parse(t2[3], 3, Xt);
                return i2 ? new Er2(r3.type, r3, n2, i2) : null;
              }
              return new Er2(r3.type, r3, n2);
            }
            evaluate(t2) {
              const e2 = this.input.evaluate(t2), r3 = this.beginIndex.evaluate(t2);
              if (!oe2(e2, ["string", "array"]))
                throw new be2(`Expected first argument to be of type array or string, but found ${ne2(ge2(e2))} instead.`);
              if (this.endIndex) {
                const n2 = this.endIndex.evaluate(t2);
                return e2.slice(r3, n2);
              }
              return e2.slice(r3);
            }
            eachChild(t2) {
              t2(this.input), t2(this.beginIndex), this.endIndex && t2(this.endIndex);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              if (this.endIndex != null && this.endIndex !== void 0) {
                const t2 = this.endIndex.serialize();
                return ["slice", this.input.serialize(), this.beginIndex.serialize(), t2];
              }
              return ["slice", this.input.serialize(), this.beginIndex.serialize()];
            }
          }
          function Br2(t2, e2) {
            return t2 === "==" || t2 === "!=" ? e2.kind === "boolean" || e2.kind === "string" || e2.kind === "number" || e2.kind === "null" || e2.kind === "value" : e2.kind === "string" || e2.kind === "number" || e2.kind === "value";
          }
          function Cr2(t2, e2, r3, n2) {
            return n2.compare(e2, r3) === 0;
          }
          function Pr2(t2, e2, r3) {
            const n2 = t2 !== "==" && t2 !== "!=";
            return class i2 {
              constructor(t3, e3, r4) {
                this.type = Ht, this.lhs = t3, this.rhs = e3, this.collator = r4, this.hasUntypedArgument = t3.type.kind === "value" || e3.type.kind === "value";
              }
              static parse(t3, e3) {
                if (t3.length !== 3 && t3.length !== 4)
                  return e3.error("Expected two or three arguments.");
                const r4 = t3[0];
                let s2 = e3.parse(t3[1], 1, Wt);
                if (!s2)
                  return null;
                if (!Br2(r4, s2.type))
                  return e3.concat(1).error(`"${r4}" comparisons are not supported for type '${ne2(s2.type)}'.`);
                let a2 = e3.parse(t3[2], 2, Wt);
                if (!a2)
                  return null;
                if (!Br2(r4, a2.type))
                  return e3.concat(2).error(`"${r4}" comparisons are not supported for type '${ne2(a2.type)}'.`);
                if (s2.type.kind !== a2.type.kind && s2.type.kind !== "value" && a2.type.kind !== "value")
                  return e3.error(`Cannot compare types '${ne2(s2.type)}' and '${ne2(a2.type)}'.`);
                n2 && (s2.type.kind === "value" && a2.type.kind !== "value" ? s2 = new _e2(a2.type, [s2]) : s2.type.kind !== "value" && a2.type.kind === "value" && (a2 = new _e2(s2.type, [a2])));
                let o2 = null;
                if (t3.length === 4) {
                  if (s2.type.kind !== "string" && a2.type.kind !== "string" && s2.type.kind !== "value" && a2.type.kind !== "value")
                    return e3.error("Cannot use collator to compare non-string types.");
                  if (o2 = e3.parse(t3[3], 3, Qt2), !o2)
                    return null;
                }
                return new i2(s2, a2, o2);
              }
              evaluate(i3) {
                const s2 = this.lhs.evaluate(i3), a2 = this.rhs.evaluate(i3);
                if (n2 && this.hasUntypedArgument) {
                  const e3 = ge2(s2), r4 = ge2(a2);
                  if (e3.kind !== r4.kind || e3.kind !== "string" && e3.kind !== "number")
                    throw new be2(`Expected arguments for "${t2}" to be (string, string) or (number, number), but found (${e3.kind}, ${r4.kind}) instead.`);
                }
                if (this.collator && !n2 && this.hasUntypedArgument) {
                  const t3 = ge2(s2), r4 = ge2(a2);
                  if (t3.kind !== "string" || r4.kind !== "string")
                    return e2(i3, s2, a2);
                }
                return this.collator ? r3(i3, s2, a2, this.collator.evaluate(i3)) : e2(i3, s2, a2);
              }
              eachChild(t3) {
                t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
              }
              outputDefined() {
                return true;
              }
              serialize() {
                const e3 = [t2];
                return this.eachChild((t3) => {
                  e3.push(t3.serialize());
                }), e3;
              }
            };
          }
          const Dr = Pr2("==", function(t2, e2, r3) {
            return e2 === r3;
          }, Cr2), Vr = Pr2("!=", function(t2, e2, r3) {
            return e2 !== r3;
          }, function(t2, e2, r3, n2) {
            return !Cr2(0, e2, r3, n2);
          }), Lr2 = Pr2("<", function(t2, e2, r3) {
            return e2 < r3;
          }, function(t2, e2, r3, n2) {
            return n2.compare(e2, r3) < 0;
          }), Fr2 = Pr2(">", function(t2, e2, r3) {
            return e2 > r3;
          }, function(t2, e2, r3, n2) {
            return n2.compare(e2, r3) > 0;
          }), Rr2 = Pr2("<=", function(t2, e2, r3) {
            return e2 <= r3;
          }, function(t2, e2, r3, n2) {
            return n2.compare(e2, r3) <= 0;
          }), Ur2 = Pr2(">=", function(t2, e2, r3) {
            return e2 >= r3;
          }, function(t2, e2, r3, n2) {
            return n2.compare(e2, r3) >= 0;
          });
          class $r2 {
            constructor(t2, e2, r3, n2, i2) {
              this.type = Kt2, this.number = t2, this.locale = e2, this.currency = r3, this.minFractionDigits = n2, this.maxFractionDigits = i2;
            }
            static parse(t2, e2) {
              if (t2.length !== 3)
                return e2.error("Expected two arguments.");
              const r3 = e2.parse(t2[1], 1, Xt);
              if (!r3)
                return null;
              const n2 = t2[2];
              if (typeof n2 != "object" || Array.isArray(n2))
                return e2.error("NumberFormat options argument must be an object.");
              let i2 = null;
              if (n2.locale && (i2 = e2.parse(n2.locale, 1, Kt2), !i2))
                return null;
              let s2 = null;
              if (n2.currency && (s2 = e2.parse(n2.currency, 1, Kt2), !s2))
                return null;
              let a2 = null;
              if (n2["min-fraction-digits"] && (a2 = e2.parse(n2["min-fraction-digits"], 1, Xt), !a2))
                return null;
              let o2 = null;
              return n2["max-fraction-digits"] && (o2 = e2.parse(n2["max-fraction-digits"], 1, Xt), !o2) ? null : new $r2(r3, i2, s2, a2, o2);
            }
            evaluate(t2) {
              return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t2) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : void 0 }).format(this.number.evaluate(t2));
            }
            eachChild(t2) {
              t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              const t2 = {};
              return this.locale && (t2.locale = this.locale.serialize()), this.currency && (t2.currency = this.currency.serialize()), this.minFractionDigits && (t2["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t2["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t2];
            }
          }
          class Or2 {
            constructor(t2) {
              this.type = Xt, this.input = t2;
            }
            static parse(t2, e2) {
              if (t2.length !== 2)
                return e2.error(`Expected 1 argument, but found ${t2.length - 1} instead.`);
              const r3 = e2.parse(t2[1], 1);
              return r3 ? r3.type.kind !== "array" && r3.type.kind !== "string" && r3.type.kind !== "value" ? e2.error(`Expected argument of type string or array, but found ${ne2(r3.type)} instead.`) : new Or2(r3) : null;
            }
            evaluate(t2) {
              const e2 = this.input.evaluate(t2);
              if (typeof e2 == "string")
                return e2.length;
              if (Array.isArray(e2))
                return e2.length;
              throw new be2(`Expected value to be of type string or array, but found ${ne2(ge2(e2))} instead.`);
            }
            eachChild(t2) {
              t2(this.input);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              const t2 = ["length"];
              return this.eachChild((e2) => {
                t2.push(e2.serialize());
              }), t2;
            }
          }
          const qr2 = { "==": Dr, "!=": Vr, ">": Fr2, "<": Lr2, ">=": Ur2, "<=": Rr2, array: _e2, at: Sr2, boolean: _e2, case: Mr2, coalesce: kr2, collator: Ee, format: ke, image: Ae2, in: Ir2, "index-of": zr, interpolate: wr2, "interpolate-hcl": wr2, "interpolate-lab": wr2, length: Or2, let: Ar2, literal: ve2, match: Tr2, number: _e2, "number-format": $r2, object: _e2, slice: Er2, step: er2, string: _e2, "to-boolean": Ie2, "to-color": Ie2, "to-number": Ie2, "to-string": Ie2, var: Je2, within: Xe2 };
          function Nr2(t2, [e2, r3, n2, i2]) {
            e2 = e2.evaluate(t2), r3 = r3.evaluate(t2), n2 = n2.evaluate(t2);
            const s2 = i2 ? i2.evaluate(t2) : 1, a2 = ye2(e2, r3, n2, s2);
            if (a2)
              throw new be2(a2);
            return new ce2(e2 / 255 * s2, r3 / 255 * s2, n2 / 255 * s2, s2);
          }
          function jr2(t2, e2) {
            return t2 in e2;
          }
          function Gr(t2, e2) {
            const r3 = e2[t2];
            return r3 === void 0 ? null : r3;
          }
          function Zr2(t2) {
            return { type: t2 };
          }
          function Xr2(t2) {
            return { result: "success", value: t2 };
          }
          function Kr2(t2) {
            return { result: "error", value: t2 };
          }
          function Hr2(t2) {
            return t2["property-type"] === "data-driven" || t2["property-type"] === "cross-faded-data-driven";
          }
          function Yr2(t2) {
            return !!t2.expression && t2.expression.parameters.indexOf("zoom") > -1;
          }
          function Jr2(t2) {
            return !!t2.expression && t2.expression.interpolated;
          }
          function Wr2(t2) {
            return t2 instanceof Number ? "number" : t2 instanceof String ? "string" : t2 instanceof Boolean ? "boolean" : Array.isArray(t2) ? "array" : t2 === null ? "null" : typeof t2;
          }
          function Qr2(t2) {
            return typeof t2 == "object" && t2 !== null && !Array.isArray(t2);
          }
          function tn2(t2) {
            return t2;
          }
          function en2(t2, e2) {
            const r3 = e2.type === "color", n2 = t2.stops && typeof t2.stops[0][0] == "object", i2 = n2 || !(n2 || t2.property !== void 0), s2 = t2.type || (Jr2(e2) ? "exponential" : "interval");
            if (r3 && ((t2 = Ot2({}, t2)).stops && (t2.stops = t2.stops.map((t3) => [t3[0], ce2.parse(t3[1])])), t2.default = ce2.parse(t2.default ? t2.default : e2.default)), t2.colorSpace && t2.colorSpace !== "rgb" && !br2[t2.colorSpace])
              throw new Error(`Unknown color space: ${t2.colorSpace}`);
            let a2, o2, l2;
            if (s2 === "exponential")
              a2 = an2;
            else if (s2 === "interval")
              a2 = sn2;
            else if (s2 === "categorical") {
              a2 = nn2, o2 = Object.create(null);
              for (const e3 of t2.stops)
                o2[e3[0]] = e3[1];
              l2 = typeof t2.stops[0][0];
            } else {
              if (s2 !== "identity")
                throw new Error(`Unknown function type "${s2}"`);
              a2 = on2;
            }
            if (n2) {
              const r4 = {}, n3 = [];
              for (let e3 = 0; e3 < t2.stops.length; e3++) {
                const i4 = t2.stops[e3], s4 = i4[0].zoom;
                r4[s4] === void 0 && (r4[s4] = { zoom: s4, type: t2.type, property: t2.property, default: t2.default, stops: [] }, n3.push(s4)), r4[s4].stops.push([i4[0].value, i4[1]]);
              }
              const i3 = [];
              for (const t3 of n3)
                i3.push([r4[t3].zoom, en2(r4[t3], e2)]);
              const s3 = { name: "linear" };
              return { kind: "composite", interpolationType: s3, interpolationFactor: wr2.interpolationFactor.bind(void 0, s3), zoomStops: i3.map((t3) => t3[0]), evaluate: ({ zoom: r5 }, n4) => an2({ stops: i3, base: t2.base }, e2, r5).evaluate(r5, n4) };
            }
            if (i2) {
              const r4 = s2 === "exponential" ? { name: "exponential", base: t2.base !== void 0 ? t2.base : 1 } : null;
              return { kind: "camera", interpolationType: r4, interpolationFactor: wr2.interpolationFactor.bind(void 0, r4), zoomStops: t2.stops.map((t3) => t3[0]), evaluate: ({ zoom: r5 }) => a2(t2, e2, r5, o2, l2) };
            }
            return { kind: "source", evaluate(r4, n3) {
              const i3 = n3 && n3.properties ? n3.properties[t2.property] : void 0;
              return i3 === void 0 ? rn2(t2.default, e2.default) : a2(t2, e2, i3, o2, l2);
            } };
          }
          function rn2(t2, e2, r3) {
            return t2 !== void 0 ? t2 : e2 !== void 0 ? e2 : r3 !== void 0 ? r3 : void 0;
          }
          function nn2(t2, e2, r3, n2, i2) {
            return rn2(typeof r3 === i2 ? n2[r3] : void 0, t2.default, e2.default);
          }
          function sn2(t2, e2, r3) {
            if (Wr2(r3) !== "number")
              return rn2(t2.default, e2.default);
            const n2 = t2.stops.length;
            if (n2 === 1)
              return t2.stops[0][1];
            if (r3 <= t2.stops[0][0])
              return t2.stops[0][1];
            if (r3 >= t2.stops[n2 - 1][0])
              return t2.stops[n2 - 1][1];
            const i2 = tr2(t2.stops.map((t3) => t3[0]), r3);
            return t2.stops[i2][1];
          }
          function an2(t2, e2, r3) {
            const n2 = t2.base !== void 0 ? t2.base : 1;
            if (Wr2(r3) !== "number")
              return rn2(t2.default, e2.default);
            const i2 = t2.stops.length;
            if (i2 === 1)
              return t2.stops[0][1];
            if (r3 <= t2.stops[0][0])
              return t2.stops[0][1];
            if (r3 >= t2.stops[i2 - 1][0])
              return t2.stops[i2 - 1][1];
            const s2 = tr2(t2.stops.map((t3) => t3[0]), r3), a2 = function(t3, e3, r4, n3) {
              const i3 = n3 - r4, s3 = t3 - r4;
              return i3 === 0 ? 0 : e3 === 1 ? s3 / i3 : (Math.pow(e3, s3) - 1) / (Math.pow(e3, i3) - 1);
            }(r3, n2, t2.stops[s2][0], t2.stops[s2 + 1][0]), o2 = t2.stops[s2][1], l2 = t2.stops[s2 + 1][1];
            let u2 = nr2[e2.type] || tn2;
            if (t2.colorSpace && t2.colorSpace !== "rgb") {
              const e3 = br2[t2.colorSpace];
              u2 = (t3, r4) => e3.reverse(e3.interpolate(e3.forward(t3), e3.forward(r4), a2));
            }
            return typeof o2.evaluate == "function" ? { evaluate(...t3) {
              const e3 = o2.evaluate.apply(void 0, t3), r4 = l2.evaluate.apply(void 0, t3);
              if (e3 !== void 0 && r4 !== void 0)
                return u2(e3, r4, a2);
            } } : u2(o2, l2, a2);
          }
          function on2(t2, e2, r3) {
            return e2.type === "color" ? r3 = ce2.parse(r3) : e2.type === "formatted" ? r3 = de2.fromString(r3.toString()) : e2.type === "resolvedImage" ? r3 = fe2.fromString(r3.toString()) : Wr2(r3) === e2.type || e2.type === "enum" && e2.values[r3] || (r3 = void 0), rn2(r3, t2.default, e2.default);
          }
          Me2.register(qr2, { error: [{ kind: "error" }, [Kt2], (t2, [e2]) => {
            throw new be2(e2.evaluate(t2));
          }], typeof: [Kt2, [Wt], (t2, [e2]) => ne2(ge2(e2.evaluate(t2)))], "to-rgba": [re2(Xt, 4), [Yt], (t2, [e2]) => e2.evaluate(t2).toArray()], rgb: [Yt, [Xt, Xt, Xt], Nr2], rgba: [Yt, [Xt, Xt, Xt, Xt], Nr2], has: { type: Ht, overloads: [[[Kt2], (t2, [e2]) => jr2(e2.evaluate(t2), t2.properties())], [[Kt2, Jt2], (t2, [e2, r3]) => jr2(e2.evaluate(t2), r3.evaluate(t2))]] }, get: { type: Wt, overloads: [[[Kt2], (t2, [e2]) => Gr(e2.evaluate(t2), t2.properties())], [[Kt2, Jt2], (t2, [e2, r3]) => Gr(e2.evaluate(t2), r3.evaluate(t2))]] }, "feature-state": [Wt, [Kt2], (t2, [e2]) => Gr(e2.evaluate(t2), t2.featureState || {})], properties: [Jt2, [], (t2) => t2.properties()], "geometry-type": [Kt2, [], (t2) => t2.geometryType()], id: [Wt, [], (t2) => t2.id()], zoom: [Xt, [], (t2) => t2.globals.zoom], "heatmap-density": [Xt, [], (t2) => t2.globals.heatmapDensity || 0], "line-progress": [Xt, [], (t2) => t2.globals.lineProgress || 0], "sky-radial-progress": [Xt, [], (t2) => t2.globals.skyRadialProgress || 0], accumulated: [Wt, [], (t2) => t2.globals.accumulated === void 0 ? null : t2.globals.accumulated], "+": [Xt, Zr2(Xt), (t2, e2) => {
            let r3 = 0;
            for (const n2 of e2)
              r3 += n2.evaluate(t2);
            return r3;
          }], "*": [Xt, Zr2(Xt), (t2, e2) => {
            let r3 = 1;
            for (const n2 of e2)
              r3 *= n2.evaluate(t2);
            return r3;
          }], "-": { type: Xt, overloads: [[[Xt, Xt], (t2, [e2, r3]) => e2.evaluate(t2) - r3.evaluate(t2)], [[Xt], (t2, [e2]) => -e2.evaluate(t2)]] }, "/": [Xt, [Xt, Xt], (t2, [e2, r3]) => e2.evaluate(t2) / r3.evaluate(t2)], "%": [Xt, [Xt, Xt], (t2, [e2, r3]) => e2.evaluate(t2) % r3.evaluate(t2)], ln2: [Xt, [], () => Math.LN2], pi: [Xt, [], () => Math.PI], e: [Xt, [], () => Math.E], "^": [Xt, [Xt, Xt], (t2, [e2, r3]) => Math.pow(e2.evaluate(t2), r3.evaluate(t2))], sqrt: [Xt, [Xt], (t2, [e2]) => Math.sqrt(e2.evaluate(t2))], log10: [Xt, [Xt], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN10], ln: [Xt, [Xt], (t2, [e2]) => Math.log(e2.evaluate(t2))], log2: [Xt, [Xt], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN2], sin: [Xt, [Xt], (t2, [e2]) => Math.sin(e2.evaluate(t2))], cos: [Xt, [Xt], (t2, [e2]) => Math.cos(e2.evaluate(t2))], tan: [Xt, [Xt], (t2, [e2]) => Math.tan(e2.evaluate(t2))], asin: [Xt, [Xt], (t2, [e2]) => Math.asin(e2.evaluate(t2))], acos: [Xt, [Xt], (t2, [e2]) => Math.acos(e2.evaluate(t2))], atan: [Xt, [Xt], (t2, [e2]) => Math.atan(e2.evaluate(t2))], min: [Xt, Zr2(Xt), (t2, e2) => Math.min(...e2.map((e3) => e3.evaluate(t2)))], max: [Xt, Zr2(Xt), (t2, e2) => Math.max(...e2.map((e3) => e3.evaluate(t2)))], abs: [Xt, [Xt], (t2, [e2]) => Math.abs(e2.evaluate(t2))], round: [Xt, [Xt], (t2, [e2]) => {
            const r3 = e2.evaluate(t2);
            return r3 < 0 ? -Math.round(-r3) : Math.round(r3);
          }], floor: [Xt, [Xt], (t2, [e2]) => Math.floor(e2.evaluate(t2))], ceil: [Xt, [Xt], (t2, [e2]) => Math.ceil(e2.evaluate(t2))], "filter-==": [Ht, [Kt2, Wt], (t2, [e2, r3]) => t2.properties()[e2.value] === r3.value], "filter-id-==": [Ht, [Wt], (t2, [e2]) => t2.id() === e2.value], "filter-type-==": [Ht, [Kt2], (t2, [e2]) => t2.geometryType() === e2.value], "filter-<": [Ht, [Kt2, Wt], (t2, [e2, r3]) => {
            const n2 = t2.properties()[e2.value], i2 = r3.value;
            return typeof n2 == typeof i2 && n2 < i2;
          }], "filter-id-<": [Ht, [Wt], (t2, [e2]) => {
            const r3 = t2.id(), n2 = e2.value;
            return typeof r3 == typeof n2 && r3 < n2;
          }], "filter->": [Ht, [Kt2, Wt], (t2, [e2, r3]) => {
            const n2 = t2.properties()[e2.value], i2 = r3.value;
            return typeof n2 == typeof i2 && n2 > i2;
          }], "filter-id->": [Ht, [Wt], (t2, [e2]) => {
            const r3 = t2.id(), n2 = e2.value;
            return typeof r3 == typeof n2 && r3 > n2;
          }], "filter-<=": [Ht, [Kt2, Wt], (t2, [e2, r3]) => {
            const n2 = t2.properties()[e2.value], i2 = r3.value;
            return typeof n2 == typeof i2 && n2 <= i2;
          }], "filter-id-<=": [Ht, [Wt], (t2, [e2]) => {
            const r3 = t2.id(), n2 = e2.value;
            return typeof r3 == typeof n2 && r3 <= n2;
          }], "filter->=": [Ht, [Kt2, Wt], (t2, [e2, r3]) => {
            const n2 = t2.properties()[e2.value], i2 = r3.value;
            return typeof n2 == typeof i2 && n2 >= i2;
          }], "filter-id->=": [Ht, [Wt], (t2, [e2]) => {
            const r3 = t2.id(), n2 = e2.value;
            return typeof r3 == typeof n2 && r3 >= n2;
          }], "filter-has": [Ht, [Wt], (t2, [e2]) => e2.value in t2.properties()], "filter-has-id": [Ht, [], (t2) => t2.id() !== null && t2.id() !== void 0], "filter-type-in": [Ht, [re2(Kt2)], (t2, [e2]) => e2.value.indexOf(t2.geometryType()) >= 0], "filter-id-in": [Ht, [re2(Wt)], (t2, [e2]) => e2.value.indexOf(t2.id()) >= 0], "filter-in-small": [Ht, [Kt2, re2(Wt)], (t2, [e2, r3]) => r3.value.indexOf(t2.properties()[e2.value]) >= 0], "filter-in-large": [Ht, [Kt2, re2(Wt)], (t2, [e2, r3]) => function(t3, e3, r4, n2) {
            for (; r4 <= n2; ) {
              const i2 = r4 + n2 >> 1;
              if (e3[i2] === t3)
                return true;
              e3[i2] > t3 ? n2 = i2 - 1 : r4 = i2 + 1;
            }
            return false;
          }(t2.properties()[e2.value], r3.value, 0, r3.value.length - 1)], all: { type: Ht, overloads: [[[Ht, Ht], (t2, [e2, r3]) => e2.evaluate(t2) && r3.evaluate(t2)], [Zr2(Ht), (t2, e2) => {
            for (const r3 of e2)
              if (!r3.evaluate(t2))
                return false;
            return true;
          }]] }, any: { type: Ht, overloads: [[[Ht, Ht], (t2, [e2, r3]) => e2.evaluate(t2) || r3.evaluate(t2)], [Zr2(Ht), (t2, e2) => {
            for (const r3 of e2)
              if (r3.evaluate(t2))
                return true;
            return false;
          }]] }, "!": [Ht, [Ht], (t2, [e2]) => !e2.evaluate(t2)], "is-supported-script": [Ht, [Kt2], (t2, [e2]) => {
            const r3 = t2.globals && t2.globals.isSupportedScript;
            return !r3 || r3(e2.evaluate(t2));
          }], upcase: [Kt2, [Kt2], (t2, [e2]) => e2.evaluate(t2).toUpperCase()], downcase: [Kt2, [Kt2], (t2, [e2]) => e2.evaluate(t2).toLowerCase()], concat: [Kt2, Zr2(Wt), (t2, e2) => e2.map((e3) => xe2(e3.evaluate(t2))).join("")], "resolved-locale": [Kt2, [Qt2], (t2, [e2]) => e2.evaluate(t2).resolvedLocale()] });
          class ln2 {
            constructor(t2, e2) {
              this.expression = t2, this._warningHistory = {}, this._evaluator = new Te(), this._defaultValue = e2 ? function(t3) {
                return t3.type === "color" && Qr2(t3.default) ? new ce2(0, 0, 0, 0) : t3.type === "color" ? ce2.parse(t3.default) || null : t3.default === void 0 ? null : t3.default;
              }(e2) : null, this._enumValues = e2 && e2.type === "enum" ? e2.values : null;
            }
            evaluateWithoutErrorHandling(t2, e2, r3, n2, i2, s2) {
              return this._evaluator.globals = t2, this._evaluator.feature = e2, this._evaluator.featureState = r3, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2, this.expression.evaluate(this._evaluator);
            }
            evaluate(t2, e2, r3, n2, i2, s2) {
              this._evaluator.globals = t2, this._evaluator.feature = e2 || null, this._evaluator.featureState = r3 || null, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2 || null;
              try {
                const t3 = this.expression.evaluate(this._evaluator);
                if (t3 == null || typeof t3 == "number" && t3 != t3)
                  return this._defaultValue;
                if (this._enumValues && !(t3 in this._enumValues))
                  throw new be2(`Expected value to be one of ${Object.keys(this._enumValues).map((t4) => JSON.stringify(t4)).join(", ")}, but found ${JSON.stringify(t3)} instead.`);
                return t3;
              } catch (t3) {
                return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, typeof console != "undefined" && console.warn(t3.message)), this._defaultValue;
              }
            }
          }
          function un(t2) {
            return Array.isArray(t2) && t2.length > 0 && typeof t2[0] == "string" && t2[0] in qr2;
          }
          function cn2(t2, e2) {
            const r3 = new We(qr2, [], e2 ? function(t3) {
              const e3 = { color: Yt, string: Kt2, number: Xt, enum: Kt2, boolean: Ht, formatted: te2, resolvedImage: ee2 };
              return t3.type === "array" ? re2(e3[t3.value] || Wt, t3.length) : e3[t3.type];
            }(e2) : void 0), n2 = r3.parse(t2, void 0, void 0, void 0, e2 && e2.type === "string" ? { typeAnnotation: "coerce" } : void 0);
            return n2 ? Xr2(new ln2(n2, e2)) : Kr2(r3.errors);
          }
          class hn2 {
            constructor(t2, e2) {
              this.kind = t2, this._styleExpression = e2, this.isStateDependent = t2 !== "constant" && !He(e2.expression);
            }
            evaluateWithoutErrorHandling(t2, e2, r3, n2, i2, s2) {
              return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r3, n2, i2, s2);
            }
            evaluate(t2, e2, r3, n2, i2, s2) {
              return this._styleExpression.evaluate(t2, e2, r3, n2, i2, s2);
            }
          }
          class pn2 {
            constructor(t2, e2, r3, n2) {
              this.kind = t2, this.zoomStops = r3, this._styleExpression = e2, this.isStateDependent = t2 !== "camera" && !He(e2.expression), this.interpolationType = n2;
            }
            evaluateWithoutErrorHandling(t2, e2, r3, n2, i2, s2) {
              return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r3, n2, i2, s2);
            }
            evaluate(t2, e2, r3, n2, i2, s2) {
              return this._styleExpression.evaluate(t2, e2, r3, n2, i2, s2);
            }
            interpolationFactor(t2, e2, r3) {
              return this.interpolationType ? wr2.interpolationFactor(this.interpolationType, t2, e2, r3) : 0;
            }
          }
          function dn2(t2, e2) {
            if ((t2 = cn2(t2, e2)).result === "error")
              return t2;
            const r3 = t2.value.expression, n2 = Ke2(r3);
            if (!n2 && !Hr2(e2))
              return Kr2([new jt("", "data expressions not supported")]);
            const i2 = Ye2(r3, ["zoom"]);
            if (!i2 && !Yr2(e2))
              return Kr2([new jt("", "zoom expressions not supported")]);
            const s2 = yn2(r3);
            return s2 || i2 ? s2 instanceof jt ? Kr2([s2]) : s2 instanceof wr2 && !Jr2(e2) ? Kr2([new jt("", '"interpolate" expressions cannot be used with this property')]) : Xr2(s2 ? new pn2(n2 ? "camera" : "composite", t2.value, s2.labels, s2 instanceof wr2 ? s2.interpolation : void 0) : new hn2(n2 ? "constant" : "source", t2.value)) : Kr2([new jt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
          }
          class fn2 {
            constructor(t2, e2) {
              this._parameters = t2, this._specification = e2, Ot2(this, en2(this._parameters, this._specification));
            }
            static deserialize(t2) {
              return new fn2(t2._parameters, t2._specification);
            }
            static serialize(t2) {
              return { _parameters: t2._parameters, _specification: t2._specification };
            }
          }
          function yn2(t2) {
            let e2 = null;
            if (t2 instanceof Ar2)
              e2 = yn2(t2.result);
            else if (t2 instanceof kr2) {
              for (const r3 of t2.args)
                if (e2 = yn2(r3), e2)
                  break;
            } else
              (t2 instanceof er2 || t2 instanceof wr2) && t2.input instanceof Me2 && t2.input.name === "zoom" && (e2 = t2);
            return e2 instanceof jt || t2.eachChild((t3) => {
              const r3 = yn2(t3);
              r3 instanceof jt ? e2 = r3 : !e2 && r3 ? e2 = new jt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e2 && r3 && e2 !== r3 && (e2 = new jt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            }), e2;
          }
          function mn2(t2) {
            const e2 = t2.key, r3 = t2.value, n2 = t2.valueSpec || {}, i2 = t2.objectElementValidators || {}, s2 = t2.style, a2 = t2.styleSpec;
            let o2 = [];
            const l2 = Wr2(r3);
            if (l2 !== "object")
              return [new Ut2(e2, r3, `object expected, ${l2} found`)];
            for (const t3 in r3) {
              const l3 = t3.split(".")[0], u2 = n2[l3] || n2["*"];
              let c2;
              if (i2[l3])
                c2 = i2[l3];
              else if (n2[l3])
                c2 = Gn2;
              else if (i2["*"])
                c2 = i2["*"];
              else {
                if (!n2["*"]) {
                  o2.push(new Ut2(e2, r3[t3], `unknown property "${t3}"`));
                  continue;
                }
                c2 = Gn2;
              }
              o2 = o2.concat(c2({ key: (e2 ? `${e2}.` : e2) + t3, value: r3[t3], valueSpec: u2, style: s2, styleSpec: a2, object: r3, objectKey: t3 }, r3));
            }
            for (const t3 in n2)
              i2[t3] || n2[t3].required && n2[t3].default === void 0 && r3[t3] === void 0 && o2.push(new Ut2(e2, r3, `missing required property "${t3}"`));
            return o2;
          }
          function gn2(t2) {
            const e2 = t2.value, r3 = t2.valueSpec, n2 = t2.style, i2 = t2.styleSpec, s2 = t2.key, a2 = t2.arrayElementValidator || Gn2;
            if (Wr2(e2) !== "array")
              return [new Ut2(s2, e2, `array expected, ${Wr2(e2)} found`)];
            if (r3.length && e2.length !== r3.length)
              return [new Ut2(s2, e2, `array length ${r3.length} expected, length ${e2.length} found`)];
            if (r3["min-length"] && e2.length < r3["min-length"])
              return [new Ut2(s2, e2, `array length at least ${r3["min-length"]} expected, length ${e2.length} found`)];
            let o2 = { type: r3.value, values: r3.values, minimum: r3.minimum, maximum: r3.maximum };
            i2.$version < 7 && (o2.function = r3.function), Wr2(r3.value) === "object" && (o2 = r3.value);
            let l2 = [];
            for (let t3 = 0; t3 < e2.length; t3++)
              l2 = l2.concat(a2({ array: e2, arrayIndex: t3, value: e2[t3], valueSpec: o2, style: n2, styleSpec: i2, key: `${s2}[${t3}]` }));
            return l2;
          }
          function xn2(t2) {
            const e2 = t2.key, r3 = t2.value, n2 = t2.valueSpec;
            let i2 = Wr2(r3);
            if (i2 === "number" && r3 != r3 && (i2 = "NaN"), i2 !== "number")
              return [new Ut2(e2, r3, `number expected, ${i2} found`)];
            if ("minimum" in n2) {
              let i3 = n2.minimum;
              if (Wr2(n2.minimum) === "array" && (i3 = n2.minimum[t2.arrayIndex]), r3 < i3)
                return [new Ut2(e2, r3, `${r3} is less than the minimum value ${i3}`)];
            }
            if ("maximum" in n2) {
              let i3 = n2.maximum;
              if (Wr2(n2.maximum) === "array" && (i3 = n2.maximum[t2.arrayIndex]), r3 > i3)
                return [new Ut2(e2, r3, `${r3} is greater than the maximum value ${i3}`)];
            }
            return [];
          }
          function vn2(t2) {
            const e2 = t2.valueSpec, r3 = qt2(t2.value.type);
            let n2, i2, s2, a2 = {};
            const o2 = r3 !== "categorical" && t2.value.property === void 0, l2 = !o2, u2 = Wr2(t2.value.stops) === "array" && Wr2(t2.value.stops[0]) === "array" && Wr2(t2.value.stops[0][0]) === "object", c2 = mn2({ key: t2.key, value: t2.value, valueSpec: t2.styleSpec.function, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { stops: function(t3) {
              if (r3 === "identity")
                return [new Ut2(t3.key, t3.value, 'identity function may not have a "stops" property')];
              let e3 = [];
              const n3 = t3.value;
              return e3 = e3.concat(gn2({ key: t3.key, value: n3, valueSpec: t3.valueSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: h2 })), Wr2(n3) === "array" && n3.length === 0 && e3.push(new Ut2(t3.key, n3, "array must have at least one stop")), e3;
            }, default: function(t3) {
              return Gn2({ key: t3.key, value: t3.value, valueSpec: e2, style: t3.style, styleSpec: t3.styleSpec });
            } } });
            return r3 === "identity" && o2 && c2.push(new Ut2(t2.key, t2.value, 'missing required property "property"')), r3 === "identity" || t2.value.stops || c2.push(new Ut2(t2.key, t2.value, 'missing required property "stops"')), r3 === "exponential" && t2.valueSpec.expression && !Jr2(t2.valueSpec) && c2.push(new Ut2(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (l2 && !Hr2(t2.valueSpec) ? c2.push(new Ut2(t2.key, t2.value, "property functions not supported")) : o2 && !Yr2(t2.valueSpec) && c2.push(new Ut2(t2.key, t2.value, "zoom functions not supported"))), r3 !== "categorical" && !u2 || t2.value.property !== void 0 || c2.push(new Ut2(t2.key, t2.value, '"property" property is required')), c2;
            function h2(t3) {
              let r4 = [];
              const n3 = t3.value, o3 = t3.key;
              if (Wr2(n3) !== "array")
                return [new Ut2(o3, n3, `array expected, ${Wr2(n3)} found`)];
              if (n3.length !== 2)
                return [new Ut2(o3, n3, `array length 2 expected, length ${n3.length} found`)];
              if (u2) {
                if (Wr2(n3[0]) !== "object")
                  return [new Ut2(o3, n3, `object expected, ${Wr2(n3[0])} found`)];
                if (n3[0].zoom === void 0)
                  return [new Ut2(o3, n3, "object stop key must have zoom")];
                if (n3[0].value === void 0)
                  return [new Ut2(o3, n3, "object stop key must have value")];
                if (s2 && s2 > qt2(n3[0].zoom))
                  return [new Ut2(o3, n3[0].zoom, "stop zoom values must appear in ascending order")];
                qt2(n3[0].zoom) !== s2 && (s2 = qt2(n3[0].zoom), i2 = void 0, a2 = {}), r4 = r4.concat(mn2({ key: `${o3}[0]`, value: n3[0], valueSpec: { zoom: {} }, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: xn2, value: p2 } }));
              } else
                r4 = r4.concat(p2({ key: `${o3}[0]`, value: n3[0], valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec }, n3));
              return un(Nt2(n3[1])) ? r4.concat([new Ut2(`${o3}[1]`, n3[1], "expressions are not allowed in function stops.")]) : r4.concat(Gn2({ key: `${o3}[1]`, value: n3[1], valueSpec: e2, style: t3.style, styleSpec: t3.styleSpec }));
            }
            function p2(t3, s3) {
              const o3 = Wr2(t3.value), l3 = qt2(t3.value), u3 = t3.value !== null ? t3.value : s3;
              if (n2) {
                if (o3 !== n2)
                  return [new Ut2(t3.key, u3, `${o3} stop domain type must match previous stop domain type ${n2}`)];
              } else
                n2 = o3;
              if (o3 !== "number" && o3 !== "string" && o3 !== "boolean")
                return [new Ut2(t3.key, u3, "stop domain value must be a number, string, or boolean")];
              if (o3 !== "number" && r3 !== "categorical") {
                let n3 = `number expected, ${o3} found`;
                return Hr2(e2) && r3 === void 0 && (n3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Ut2(t3.key, u3, n3)];
              }
              return r3 !== "categorical" || o3 !== "number" || isFinite(l3) && Math.floor(l3) === l3 ? r3 !== "categorical" && o3 === "number" && i2 !== void 0 && l3 < i2 ? [new Ut2(t3.key, u3, "stop domain values must appear in ascending order")] : (i2 = l3, r3 === "categorical" && l3 in a2 ? [new Ut2(t3.key, u3, "stop domain values must be unique")] : (a2[l3] = true, [])) : [new Ut2(t3.key, u3, `integer expected, found ${l3}`)];
            }
          }
          function bn2(t2) {
            const e2 = (t2.expressionContext === "property" ? dn2 : cn2)(Nt2(t2.value), t2.valueSpec);
            if (e2.result === "error")
              return e2.value.map((e3) => new Ut2(`${t2.key}${e3.key}`, t2.value, e3.message));
            const r3 = e2.value.expression || e2.value._styleExpression.expression;
            if (t2.expressionContext === "property" && t2.propertyKey === "text-font" && !r3.outputDefined())
              return [new Ut2(t2.key, t2.value, `Invalid data expression for "${t2.propertyKey}". Output values must be contained as literals within the expression.`)];
            if (t2.expressionContext === "property" && t2.propertyType === "layout" && !He(r3))
              return [new Ut2(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')];
            if (t2.expressionContext === "filter" && !He(r3))
              return [new Ut2(t2.key, t2.value, '"feature-state" data expressions are not supported with filters.')];
            if (t2.expressionContext && t2.expressionContext.indexOf("cluster") === 0) {
              if (!Ye2(r3, ["zoom", "feature-state"]))
                return [new Ut2(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
              if (t2.expressionContext === "cluster-initial" && !Ke2(r3))
                return [new Ut2(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
            }
            return [];
          }
          function wn2(t2) {
            const e2 = t2.key, r3 = t2.value, n2 = t2.valueSpec, i2 = [];
            return Array.isArray(n2.values) ? n2.values.indexOf(qt2(r3)) === -1 && i2.push(new Ut2(e2, r3, `expected one of [${n2.values.join(", ")}], ${JSON.stringify(r3)} found`)) : Object.keys(n2.values).indexOf(qt2(r3)) === -1 && i2.push(new Ut2(e2, r3, `expected one of [${Object.keys(n2.values).join(", ")}], ${JSON.stringify(r3)} found`)), i2;
          }
          function _n(t2) {
            if (t2 === true || t2 === false)
              return true;
            if (!Array.isArray(t2) || t2.length === 0)
              return false;
            switch (t2[0]) {
              case "has":
                return t2.length >= 2 && t2[1] !== "$id" && t2[1] !== "$type";
              case "in":
                return t2.length >= 3 && (typeof t2[1] != "string" || Array.isArray(t2[2]));
              case "!in":
              case "!has":
              case "none":
                return false;
              case "==":
              case "!=":
              case ">":
              case ">=":
              case "<":
              case "<=":
                return t2.length !== 3 || Array.isArray(t2[1]) || Array.isArray(t2[2]);
              case "any":
              case "all":
                for (const e2 of t2.slice(1))
                  if (!_n(e2) && typeof e2 != "boolean")
                    return false;
                return true;
              default:
                return true;
            }
          }
          const kn2 = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
          function An2(t2) {
            if (t2 == null)
              return { filter: () => true, needGeometry: false };
            _n(t2) || (t2 = zn2(t2));
            const e2 = cn2(t2, kn2);
            if (e2.result === "error")
              throw new Error(e2.value.map((t3) => `${t3.key}: ${t3.message}`).join(", "));
            return { filter: (t3, r3, n2) => e2.value.evaluate(t3, r3, {}, n2), needGeometry: In2(t2) };
          }
          function Sn2(t2, e2) {
            return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
          }
          function In2(t2) {
            if (!Array.isArray(t2))
              return false;
            if (t2[0] === "within")
              return true;
            for (let e2 = 1; e2 < t2.length; e2++)
              if (In2(t2[e2]))
                return true;
            return false;
          }
          function zn2(t2) {
            if (!t2)
              return true;
            const e2 = t2[0];
            return t2.length <= 1 ? e2 !== "any" : e2 === "==" ? Tn2(t2[1], t2[2], "==") : e2 === "!=" ? Bn2(Tn2(t2[1], t2[2], "==")) : e2 === "<" || e2 === ">" || e2 === "<=" || e2 === ">=" ? Tn2(t2[1], t2[2], e2) : e2 === "any" ? (r3 = t2.slice(1), ["any"].concat(r3.map(zn2))) : e2 === "all" ? ["all"].concat(t2.slice(1).map(zn2)) : e2 === "none" ? ["all"].concat(t2.slice(1).map(zn2).map(Bn2)) : e2 === "in" ? Mn2(t2[1], t2.slice(2)) : e2 === "!in" ? Bn2(Mn2(t2[1], t2.slice(2))) : e2 === "has" ? En2(t2[1]) : e2 === "!has" ? Bn2(En2(t2[1])) : e2 !== "within" || t2;
            var r3;
          }
          function Tn2(t2, e2, r3) {
            switch (t2) {
              case "$type":
                return [`filter-type-${r3}`, e2];
              case "$id":
                return [`filter-id-${r3}`, e2];
              default:
                return [`filter-${r3}`, t2, e2];
            }
          }
          function Mn2(t2, e2) {
            if (e2.length === 0)
              return false;
            switch (t2) {
              case "$type":
                return ["filter-type-in", ["literal", e2]];
              case "$id":
                return ["filter-id-in", ["literal", e2]];
              default:
                return e2.length > 200 && !e2.some((t3) => typeof t3 != typeof e2[0]) ? ["filter-in-large", t2, ["literal", e2.sort(Sn2)]] : ["filter-in-small", t2, ["literal", e2]];
            }
          }
          function En2(t2) {
            switch (t2) {
              case "$type":
                return true;
              case "$id":
                return ["filter-has-id"];
              default:
                return ["filter-has", t2];
            }
          }
          function Bn2(t2) {
            return ["!", t2];
          }
          function Cn2(t2) {
            return _n(Nt2(t2.value)) ? bn2(Ot2({}, t2, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Pn2(t2);
          }
          function Pn2(t2) {
            const e2 = t2.value, r3 = t2.key;
            if (Wr2(e2) !== "array")
              return [new Ut2(r3, e2, `array expected, ${Wr2(e2)} found`)];
            const n2 = t2.styleSpec;
            let i2, s2 = [];
            if (e2.length < 1)
              return [new Ut2(r3, e2, "filter array must have at least 1 element")];
            switch (s2 = s2.concat(wn2({ key: `${r3}[0]`, value: e2[0], valueSpec: n2.filter_operator, style: t2.style, styleSpec: t2.styleSpec })), qt2(e2[0])) {
              case "<":
              case "<=":
              case ">":
              case ">=":
                e2.length >= 2 && qt2(e2[1]) === "$type" && s2.push(new Ut2(r3, e2, `"$type" cannot be use with operator "${e2[0]}"`));
              case "==":
              case "!=":
                e2.length !== 3 && s2.push(new Ut2(r3, e2, `filter array for operator "${e2[0]}" must have 3 elements`));
              case "in":
              case "!in":
                e2.length >= 2 && (i2 = Wr2(e2[1]), i2 !== "string" && s2.push(new Ut2(`${r3}[1]`, e2[1], `string expected, ${i2} found`)));
                for (let a2 = 2; a2 < e2.length; a2++)
                  i2 = Wr2(e2[a2]), qt2(e2[1]) === "$type" ? s2 = s2.concat(wn2({ key: `${r3}[${a2}]`, value: e2[a2], valueSpec: n2.geometry_type, style: t2.style, styleSpec: t2.styleSpec })) : i2 !== "string" && i2 !== "number" && i2 !== "boolean" && s2.push(new Ut2(`${r3}[${a2}]`, e2[a2], `string, number, or boolean expected, ${i2} found`));
                break;
              case "any":
              case "all":
              case "none":
                for (let n3 = 1; n3 < e2.length; n3++)
                  s2 = s2.concat(Pn2({ key: `${r3}[${n3}]`, value: e2[n3], style: t2.style, styleSpec: t2.styleSpec }));
                break;
              case "has":
              case "!has":
                i2 = Wr2(e2[1]), e2.length !== 2 ? s2.push(new Ut2(r3, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : i2 !== "string" && s2.push(new Ut2(`${r3}[1]`, e2[1], `string expected, ${i2} found`));
                break;
              case "within":
                i2 = Wr2(e2[1]), e2.length !== 2 ? s2.push(new Ut2(r3, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : i2 !== "object" && s2.push(new Ut2(`${r3}[1]`, e2[1], `object expected, ${i2} found`));
            }
            return s2;
          }
          function Dn2(t2, e2) {
            const r3 = t2.key, n2 = t2.style, i2 = t2.styleSpec, s2 = t2.value, a2 = t2.objectKey, o2 = i2[`${e2}_${t2.layerType}`];
            if (!o2)
              return [];
            const l2 = a2.match(/^(.*)-transition$/);
            if (e2 === "paint" && l2 && o2[l2[1]] && o2[l2[1]].transition)
              return Gn2({ key: r3, value: s2, valueSpec: i2.transition, style: n2, styleSpec: i2 });
            const u2 = t2.valueSpec || o2[a2];
            if (!u2)
              return [new Ut2(r3, s2, `unknown property "${a2}"`)];
            let c2;
            if (Wr2(s2) === "string" && Hr2(u2) && !u2.tokens && (c2 = /^{([^}]+)}$/.exec(s2)))
              return [new Ut2(r3, s2, `"${a2}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(c2[1])} }\`.`)];
            const h2 = [];
            return t2.layerType === "symbol" && (a2 === "text-field" && n2 && !n2.glyphs && h2.push(new Ut2(r3, s2, 'use of "text-field" requires a style "glyphs" property')), a2 === "text-font" && Qr2(Nt2(s2)) && qt2(s2.type) === "identity" && h2.push(new Ut2(r3, s2, '"text-font" does not support identity functions'))), h2.concat(Gn2({ key: t2.key, value: s2, valueSpec: u2, style: n2, styleSpec: i2, expressionContext: "property", propertyType: e2, propertyKey: a2 }));
          }
          function Vn2(t2) {
            return Dn2(t2, "paint");
          }
          function Ln2(t2) {
            return Dn2(t2, "layout");
          }
          function Fn2(t2) {
            let e2 = [];
            const r3 = t2.value, n2 = t2.key, i2 = t2.style, s2 = t2.styleSpec;
            r3.type || r3.ref || e2.push(new Ut2(n2, r3, 'either "type" or "ref" is required'));
            let a2 = qt2(r3.type);
            const o2 = qt2(r3.ref);
            if (r3.id) {
              const s3 = qt2(r3.id);
              for (let a3 = 0; a3 < t2.arrayIndex; a3++) {
                const t3 = i2.layers[a3];
                qt2(t3.id) === s3 && e2.push(new Ut2(n2, r3.id, `duplicate layer id "${r3.id}", previously used at line ${t3.id.__line__}`));
              }
            }
            if ("ref" in r3) {
              let t3;
              ["type", "source", "source-layer", "filter", "layout"].forEach((t4) => {
                t4 in r3 && e2.push(new Ut2(n2, r3[t4], `"${t4}" is prohibited for ref layers`));
              }), i2.layers.forEach((e3) => {
                qt2(e3.id) === o2 && (t3 = e3);
              }), t3 ? t3.ref ? e2.push(new Ut2(n2, r3.ref, "ref cannot reference another ref layer")) : a2 = qt2(t3.type) : e2.push(new Ut2(n2, r3.ref, `ref layer "${o2}" not found`));
            } else if (a2 !== "background" && a2 !== "sky")
              if (r3.source) {
                const t3 = i2.sources && i2.sources[r3.source], s3 = t3 && qt2(t3.type);
                t3 ? s3 === "vector" && a2 === "raster" ? e2.push(new Ut2(n2, r3.source, `layer "${r3.id}" requires a raster source`)) : s3 === "raster" && a2 !== "raster" ? e2.push(new Ut2(n2, r3.source, `layer "${r3.id}" requires a vector source`)) : s3 !== "vector" || r3["source-layer"] ? s3 === "raster-dem" && a2 !== "hillshade" ? e2.push(new Ut2(n2, r3.source, "raster-dem source can only be used with layer type 'hillshade'.")) : a2 !== "line" || !r3.paint || !r3.paint["line-gradient"] || s3 === "geojson" && t3.lineMetrics || e2.push(new Ut2(n2, r3, `layer "${r3.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e2.push(new Ut2(n2, r3, `layer "${r3.id}" must specify a "source-layer"`)) : e2.push(new Ut2(n2, r3.source, `source "${r3.source}" not found`));
              } else
                e2.push(new Ut2(n2, r3, 'missing required property "source"'));
            return e2 = e2.concat(mn2({ key: n2, value: r3, valueSpec: s2.layer, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { "*": () => [], type: () => Gn2({ key: `${n2}.type`, value: r3.type, valueSpec: s2.layer.type, style: t2.style, styleSpec: t2.styleSpec, object: r3, objectKey: "type" }), filter: Cn2, layout: (t3) => mn2({ layer: r3, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => Ln2(Ot2({ layerType: a2 }, t4)) } }), paint: (t3) => mn2({ layer: r3, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => Vn2(Ot2({ layerType: a2 }, t4)) } }) } })), e2;
          }
          function Rn2(t2) {
            const e2 = t2.value, r3 = t2.key, n2 = Wr2(e2);
            return n2 !== "string" ? [new Ut2(r3, e2, `string expected, ${n2} found`)] : [];
          }
          const Un2 = { promoteId: function({ key: t2, value: e2 }) {
            if (Wr2(e2) === "string")
              return Rn2({ key: t2, value: e2 });
            {
              const r3 = [];
              for (const n2 in e2)
                r3.push(...Rn2({ key: `${t2}.${n2}`, value: e2[n2] }));
              return r3;
            }
          } };
          function $n2(t2) {
            const e2 = t2.value, r3 = t2.key, n2 = t2.styleSpec, i2 = t2.style;
            if (!e2.type)
              return [new Ut2(r3, e2, '"type" is required')];
            const s2 = qt2(e2.type);
            let a2;
            switch (s2) {
              case "vector":
              case "raster":
              case "raster-dem":
                return a2 = mn2({ key: r3, value: e2, valueSpec: n2[`source_${s2.replace("-", "_")}`], style: t2.style, styleSpec: n2, objectElementValidators: Un2 }), a2;
              case "geojson":
                if (a2 = mn2({ key: r3, value: e2, valueSpec: n2.source_geojson, style: i2, styleSpec: n2, objectElementValidators: Un2 }), e2.cluster)
                  for (const t3 in e2.clusterProperties) {
                    const [n3, i3] = e2.clusterProperties[t3], s3 = typeof n3 == "string" ? [n3, ["accumulated"], ["get", t3]] : n3;
                    a2.push(...bn2({ key: `${r3}.${t3}.map`, value: i3, expressionContext: "cluster-map" })), a2.push(...bn2({ key: `${r3}.${t3}.reduce`, value: s3, expressionContext: "cluster-reduce" }));
                  }
                return a2;
              case "video":
                return mn2({ key: r3, value: e2, valueSpec: n2.source_video, style: i2, styleSpec: n2 });
              case "image":
                return mn2({ key: r3, value: e2, valueSpec: n2.source_image, style: i2, styleSpec: n2 });
              case "canvas":
                return [new Ut2(r3, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
              default:
                return wn2({ key: `${r3}.type`, value: e2.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: i2, styleSpec: n2 });
            }
          }
          function On2(t2) {
            const e2 = t2.value, r3 = t2.styleSpec, n2 = r3.light, i2 = t2.style;
            let s2 = [];
            const a2 = Wr2(e2);
            if (e2 === void 0)
              return s2;
            if (a2 !== "object")
              return s2 = s2.concat([new Ut2("light", e2, `object expected, ${a2} found`)]), s2;
            for (const t3 in e2) {
              const a3 = t3.match(/^(.*)-transition$/);
              s2 = s2.concat(a3 && n2[a3[1]] && n2[a3[1]].transition ? Gn2({ key: t3, value: e2[t3], valueSpec: r3.transition, style: i2, styleSpec: r3 }) : n2[t3] ? Gn2({ key: t3, value: e2[t3], valueSpec: n2[t3], style: i2, styleSpec: r3 }) : [new Ut2(t3, e2[t3], `unknown property "${t3}"`)]);
            }
            return s2;
          }
          function qn2(t2) {
            const e2 = t2.value, r3 = t2.key, n2 = t2.style, i2 = t2.styleSpec, s2 = i2.terrain;
            let a2 = [];
            const o2 = Wr2(e2);
            if (e2 === void 0)
              return a2;
            if (o2 !== "object")
              return a2 = a2.concat([new Ut2("terrain", e2, `object expected, ${o2} found`)]), a2;
            for (const t3 in e2) {
              const r4 = t3.match(/^(.*)-transition$/);
              a2 = a2.concat(r4 && s2[r4[1]] && s2[r4[1]].transition ? Gn2({ key: t3, value: e2[t3], valueSpec: i2.transition, style: n2, styleSpec: i2 }) : s2[t3] ? Gn2({ key: t3, value: e2[t3], valueSpec: s2[t3], style: n2, styleSpec: i2 }) : [new Ut2(t3, e2[t3], `unknown property "${t3}"`)]);
            }
            if (e2.source) {
              const t3 = n2.sources && n2.sources[e2.source], i3 = t3 && qt2(t3.type);
              t3 ? i3 !== "raster-dem" && a2.push(new Ut2(r3, e2.source, `terrain cannot be used with a source of type ${i3}, it only be used with a "raster-dem" source type`)) : a2.push(new Ut2(r3, e2.source, `source "${e2.source}" not found`));
            } else
              a2.push(new Ut2(r3, e2, 'terrain is missing required property "source"'));
            return a2;
          }
          function Nn2(t2) {
            const e2 = t2.value, r3 = t2.style, n2 = t2.styleSpec, i2 = n2.fog;
            let s2 = [];
            const a2 = Wr2(e2);
            if (e2 === void 0)
              return s2;
            if (a2 !== "object")
              return s2 = s2.concat([new Ut2("fog", e2, `object expected, ${a2} found`)]), s2;
            for (const t3 in e2) {
              const a3 = t3.match(/^(.*)-transition$/);
              s2 = s2.concat(a3 && i2[a3[1]] && i2[a3[1]].transition ? Gn2({ key: t3, value: e2[t3], valueSpec: n2.transition, style: r3, styleSpec: n2 }) : i2[t3] ? Gn2({ key: t3, value: e2[t3], valueSpec: i2[t3], style: r3, styleSpec: n2 }) : [new Ut2(t3, e2[t3], `unknown property "${t3}"`)]);
            }
            return s2;
          }
          const jn2 = { "*": () => [], array: gn2, boolean: function(t2) {
            const e2 = t2.value, r3 = t2.key, n2 = Wr2(e2);
            return n2 !== "boolean" ? [new Ut2(r3, e2, `boolean expected, ${n2} found`)] : [];
          }, number: xn2, color: function(t2) {
            const e2 = t2.key, r3 = t2.value, n2 = Wr2(r3);
            return n2 !== "string" ? [new Ut2(e2, r3, `color expected, ${n2} found`)] : ue2.parseCSSColor(r3) === null ? [new Ut2(e2, r3, `color expected, "${r3}" found`)] : [];
          }, constants: $t2, enum: wn2, filter: Cn2, function: vn2, layer: Fn2, object: mn2, source: $n2, light: On2, terrain: qn2, fog: Nn2, string: Rn2, formatted: function(t2) {
            return Rn2(t2).length === 0 ? [] : bn2(t2);
          }, resolvedImage: function(t2) {
            return Rn2(t2).length === 0 ? [] : bn2(t2);
          } };
          function Gn2(t2) {
            const e2 = t2.value, r3 = t2.valueSpec, n2 = t2.styleSpec;
            return r3.expression && Qr2(qt2(e2)) ? vn2(t2) : r3.expression && un(Nt2(e2)) ? bn2(t2) : r3.type && jn2[r3.type] ? jn2[r3.type](t2) : mn2(Ot2({}, t2, { valueSpec: r3.type ? n2[r3.type] : r3 }));
          }
          function Zn2(t2) {
            const e2 = t2.value, r3 = t2.key, n2 = Rn2(t2);
            return n2.length || (e2.indexOf("{fontstack}") === -1 && n2.push(new Ut2(r3, e2, '"glyphs" url must include a "{fontstack}" token')), e2.indexOf("{range}") === -1 && n2.push(new Ut2(r3, e2, '"glyphs" url must include a "{range}" token'))), n2;
          }
          function Xn2(t2, e2 = Rt) {
            let r3 = [];
            return r3 = r3.concat(Gn2({ key: "", value: t2, valueSpec: e2.$root, styleSpec: e2, style: t2, objectElementValidators: { glyphs: Zn2, "*": () => [] } })), t2.constants && (r3 = r3.concat($t2({ key: "constants", value: t2.constants, style: t2, styleSpec: e2 }))), Kn2(r3);
          }
          function Kn2(t2) {
            return [].concat(t2).sort((t3, e2) => t3.line - e2.line);
          }
          function Hn2(t2) {
            return function(...e2) {
              return Kn2(t2.apply(this, e2));
            };
          }
          Xn2.source = Hn2($n2), Xn2.light = Hn2(On2), Xn2.terrain = Hn2(qn2), Xn2.fog = Hn2(Nn2), Xn2.layer = Hn2(Fn2), Xn2.filter = Hn2(Cn2), Xn2.paintProperty = Hn2(Vn2), Xn2.layoutProperty = Hn2(Ln2);
          const Yn2 = Xn2, Jn2 = Yn2.light, Wn2 = Yn2.fog, Qn2 = Yn2.paintProperty, ti2 = Yn2.layoutProperty;
          function ei2(t2, e2) {
            let r3 = false;
            if (e2 && e2.length)
              for (const n2 of e2)
                t2.fire(new Lt(new Error(n2.message))), r3 = true;
            return r3;
          }
          var ri = ni2;
          function ni2(t2, e2, r3) {
            var n2 = this.cells = [];
            if (t2 instanceof ArrayBuffer) {
              this.arrayBuffer = t2;
              var i2 = new Int32Array(this.arrayBuffer);
              t2 = i2[0], this.d = (e2 = i2[1]) + 2 * (r3 = i2[2]);
              for (var s2 = 0; s2 < this.d * this.d; s2++) {
                var a2 = i2[3 + s2], o2 = i2[3 + s2 + 1];
                n2.push(a2 === o2 ? null : i2.subarray(a2, o2));
              }
              var l2 = i2[3 + n2.length + 1];
              this.keys = i2.subarray(i2[3 + n2.length], l2), this.bboxes = i2.subarray(l2), this.insert = this._insertReadonly;
            } else {
              this.d = e2 + 2 * r3;
              for (var u2 = 0; u2 < this.d * this.d; u2++)
                n2.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = e2, this.extent = t2, this.padding = r3, this.scale = e2 / t2, this.uid = 0;
            var c2 = r3 / e2 * t2;
            this.min = -c2, this.max = t2 + c2;
          }
          ni2.prototype.insert = function(t2, e2, r3, n2, i2) {
            this._forEachCell(e2, r3, n2, i2, this._insertCell, this.uid++), this.keys.push(t2), this.bboxes.push(e2), this.bboxes.push(r3), this.bboxes.push(n2), this.bboxes.push(i2);
          }, ni2.prototype._insertReadonly = function() {
            throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
          }, ni2.prototype._insertCell = function(t2, e2, r3, n2, i2, s2) {
            this.cells[i2].push(s2);
          }, ni2.prototype.query = function(t2, e2, r3, n2, i2) {
            var s2 = this.min, a2 = this.max;
            if (t2 <= s2 && e2 <= s2 && a2 <= r3 && a2 <= n2 && !i2)
              return Array.prototype.slice.call(this.keys);
            var o2 = [];
            return this._forEachCell(t2, e2, r3, n2, this._queryCell, o2, {}, i2), o2;
          }, ni2.prototype._queryCell = function(t2, e2, r3, n2, i2, s2, a2, o2) {
            var l2 = this.cells[i2];
            if (l2 !== null)
              for (var u2 = this.keys, c2 = this.bboxes, h2 = 0; h2 < l2.length; h2++) {
                var p2 = l2[h2];
                if (a2[p2] === void 0) {
                  var d2 = 4 * p2;
                  (o2 ? o2(c2[d2 + 0], c2[d2 + 1], c2[d2 + 2], c2[d2 + 3]) : t2 <= c2[d2 + 2] && e2 <= c2[d2 + 3] && r3 >= c2[d2 + 0] && n2 >= c2[d2 + 1]) ? (a2[p2] = true, s2.push(u2[p2])) : a2[p2] = false;
                }
              }
          }, ni2.prototype._forEachCell = function(t2, e2, r3, n2, i2, s2, a2, o2) {
            for (var l2 = this._convertToCellCoord(t2), u2 = this._convertToCellCoord(e2), c2 = this._convertToCellCoord(r3), h2 = this._convertToCellCoord(n2), p2 = l2; p2 <= c2; p2++)
              for (var d2 = u2; d2 <= h2; d2++) {
                var f2 = this.d * d2 + p2;
                if ((!o2 || o2(this._convertFromCellCoord(p2), this._convertFromCellCoord(d2), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(d2 + 1))) && i2.call(this, t2, e2, r3, n2, f2, s2, a2, o2))
                  return;
              }
          }, ni2.prototype._convertFromCellCoord = function(t2) {
            return (t2 - this.padding) / this.scale;
          }, ni2.prototype._convertToCellCoord = function(t2) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t2 * this.scale) + this.padding));
          }, ni2.prototype.toArrayBuffer = function() {
            if (this.arrayBuffer)
              return this.arrayBuffer;
            for (var t2 = this.cells, e2 = 3 + this.cells.length + 1 + 1, r3 = 0, n2 = 0; n2 < this.cells.length; n2++)
              r3 += this.cells[n2].length;
            var i2 = new Int32Array(e2 + r3 + this.keys.length + this.bboxes.length);
            i2[0] = this.extent, i2[1] = this.n, i2[2] = this.padding;
            for (var s2 = e2, a2 = 0; a2 < t2.length; a2++) {
              var o2 = t2[a2];
              i2[3 + a2] = s2, i2.set(o2, s2), s2 += o2.length;
            }
            return i2[3 + t2.length] = s2, i2.set(this.keys, s2), i2[3 + t2.length + 1] = s2 += this.keys.length, i2.set(this.bboxes, s2), s2 += this.bboxes.length, i2.buffer;
          };
          const { ImageData: ii2, ImageBitmap: si } = a, ai2 = {};
          function oi2(t2, e2, r3 = {}) {
            Object.defineProperty(e2, "_classRegistryKey", { value: t2, writeable: false }), ai2[t2] = { klass: e2, omit: r3.omit || [], shallow: r3.shallow || [] };
          }
          oi2("Object", Object), ri.serialize = function(t2, e2) {
            const r3 = t2.toArrayBuffer();
            return e2 && e2.push(r3), { buffer: r3 };
          }, ri.deserialize = function(t2) {
            return new ri(t2.buffer);
          }, oi2("Grid", ri), oi2("Color", ce2), oi2("Error", Error), oi2("ResolvedImage", fe2), oi2("StylePropertyFunction", fn2), oi2("StyleExpression", ln2, { omit: ["_evaluator"] }), oi2("ZoomDependentExpression", pn2), oi2("ZoomConstantExpression", hn2), oi2("CompoundExpression", Me2, { omit: ["_evaluate"] });
          for (const t2 in qr2)
            qr2[t2]._classRegistryKey || oi2(`Expression_${t2}`, qr2[t2]);
          function li2(t2) {
            return t2 && typeof ArrayBuffer != "undefined" && (t2 instanceof ArrayBuffer || t2.constructor && t2.constructor.name === "ArrayBuffer");
          }
          function ui(t2) {
            return si && t2 instanceof si;
          }
          function ci2(t2, e2) {
            if (t2 == null || typeof t2 == "boolean" || typeof t2 == "number" || typeof t2 == "string" || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp)
              return t2;
            if (li2(t2) || ui(t2))
              return e2 && e2.push(t2), t2;
            if (ArrayBuffer.isView(t2)) {
              const r3 = t2;
              return e2 && e2.push(r3.buffer), r3;
            }
            if (t2 instanceof ii2)
              return e2 && e2.push(t2.data.buffer), t2;
            if (Array.isArray(t2)) {
              const r3 = [];
              for (const n2 of t2)
                r3.push(ci2(n2, e2));
              return r3;
            }
            if (typeof t2 == "object") {
              const r3 = t2.constructor, n2 = r3._classRegistryKey;
              if (!n2)
                throw new Error("can't serialize object of unregistered class");
              const i2 = r3.serialize ? r3.serialize(t2, e2) : {};
              if (!r3.serialize) {
                for (const r4 in t2) {
                  if (!t2.hasOwnProperty(r4))
                    continue;
                  if (ai2[n2].omit.indexOf(r4) >= 0)
                    continue;
                  const s2 = t2[r4];
                  i2[r4] = ai2[n2].shallow.indexOf(r4) >= 0 ? s2 : ci2(s2, e2);
                }
                t2 instanceof Error && (i2.message = t2.message);
              }
              if (i2.$name)
                throw new Error("$name property is reserved for worker serialization logic.");
              return n2 !== "Object" && (i2.$name = n2), i2;
            }
            throw new Error("can't serialize object of type " + typeof t2);
          }
          function hi(t2) {
            if (t2 == null || typeof t2 == "boolean" || typeof t2 == "number" || typeof t2 == "string" || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || li2(t2) || ui(t2) || ArrayBuffer.isView(t2) || t2 instanceof ii2)
              return t2;
            if (Array.isArray(t2))
              return t2.map(hi);
            if (typeof t2 == "object") {
              const e2 = t2.$name || "Object", { klass: r3 } = ai2[e2];
              if (!r3)
                throw new Error(`can't deserialize unregistered class ${e2}`);
              if (r3.deserialize)
                return r3.deserialize(t2);
              const n2 = Object.create(r3.prototype);
              for (const r4 of Object.keys(t2)) {
                if (r4 === "$name")
                  continue;
                const i2 = t2[r4];
                n2[r4] = ai2[e2].shallow.indexOf(r4) >= 0 ? i2 : hi(i2);
              }
              return n2;
            }
            throw new Error("can't deserialize object of type " + typeof t2);
          }
          class pi {
            constructor() {
              this.first = true;
            }
            update(t2, e2) {
              const r3 = Math.floor(t2);
              return this.first ? (this.first = false, this.lastIntegerZoom = r3, this.lastIntegerZoomTime = 0, this.lastZoom = t2, this.lastFloorZoom = r3, true) : (this.lastFloorZoom > r3 ? (this.lastIntegerZoom = r3 + 1, this.lastIntegerZoomTime = e2) : this.lastFloorZoom < r3 && (this.lastIntegerZoom = r3, this.lastIntegerZoomTime = e2), t2 !== this.lastZoom && (this.lastZoom = t2, this.lastFloorZoom = r3, true));
            }
          }
          const di = (t2) => t2 >= 1536 && t2 <= 1791, fi = (t2) => t2 >= 1872 && t2 <= 1919, yi2 = (t2) => t2 >= 2208 && t2 <= 2303, mi = (t2) => t2 >= 11904 && t2 <= 12031, gi = (t2) => t2 >= 12032 && t2 <= 12255, xi2 = (t2) => t2 >= 12272 && t2 <= 12287, vi2 = (t2) => t2 >= 12288 && t2 <= 12351, bi2 = (t2) => t2 >= 12352 && t2 <= 12447, wi2 = (t2) => t2 >= 12448 && t2 <= 12543, _i = (t2) => t2 >= 12544 && t2 <= 12591, ki2 = (t2) => t2 >= 12704 && t2 <= 12735, Ai2 = (t2) => t2 >= 12736 && t2 <= 12783, Si2 = (t2) => t2 >= 12784 && t2 <= 12799, Ii2 = (t2) => t2 >= 12800 && t2 <= 13055, zi2 = (t2) => t2 >= 13056 && t2 <= 13311, Ti2 = (t2) => t2 >= 13312 && t2 <= 19903, Mi2 = (t2) => t2 >= 19968 && t2 <= 40959, Ei2 = (t2) => t2 >= 40960 && t2 <= 42127, Bi2 = (t2) => t2 >= 42128 && t2 <= 42191, Ci2 = (t2) => t2 >= 44032 && t2 <= 55215, Pi2 = (t2) => t2 >= 63744 && t2 <= 64255, Di2 = (t2) => t2 >= 64336 && t2 <= 65023, Vi2 = (t2) => t2 >= 65040 && t2 <= 65055, Li2 = (t2) => t2 >= 65072 && t2 <= 65103, Fi2 = (t2) => t2 >= 65104 && t2 <= 65135, Ri = (t2) => t2 >= 65136 && t2 <= 65279, Ui2 = (t2) => t2 >= 65280 && t2 <= 65519;
          function $i2(t2) {
            for (const e2 of t2)
              if (Ni2(e2.charCodeAt(0)))
                return true;
            return false;
          }
          function Oi2(t2) {
            for (const e2 of t2)
              if (!qi2(e2.charCodeAt(0)))
                return false;
            return true;
          }
          function qi2(t2) {
            return !(di(t2) || fi(t2) || yi2(t2) || Di2(t2) || Ri(t2));
          }
          function Ni2(t2) {
            return !(t2 !== 746 && t2 !== 747 && (t2 < 4352 || !(ki2(t2) || _i(t2) || Li2(t2) && !(t2 >= 65097 && t2 <= 65103) || Pi2(t2) || zi2(t2) || mi(t2) || Ai2(t2) || !(!vi2(t2) || t2 >= 12296 && t2 <= 12305 || t2 >= 12308 && t2 <= 12319 || t2 === 12336) || Ti2(t2) || Mi2(t2) || Ii2(t2) || ((t3) => t3 >= 12592 && t3 <= 12687)(t2) || ((t3) => t3 >= 43360 && t3 <= 43391)(t2) || ((t3) => t3 >= 55216 && t3 <= 55295)(t2) || ((t3) => t3 >= 4352 && t3 <= 4607)(t2) || Ci2(t2) || bi2(t2) || xi2(t2) || ((t3) => t3 >= 12688 && t3 <= 12703)(t2) || gi(t2) || Si2(t2) || wi2(t2) && t2 !== 12540 || !(!Ui2(t2) || t2 === 65288 || t2 === 65289 || t2 === 65293 || t2 >= 65306 && t2 <= 65310 || t2 === 65339 || t2 === 65341 || t2 === 65343 || t2 >= 65371 && t2 <= 65503 || t2 === 65507 || t2 >= 65512 && t2 <= 65519) || !(!Fi2(t2) || t2 >= 65112 && t2 <= 65118 || t2 >= 65123 && t2 <= 65126) || ((t3) => t3 >= 5120 && t3 <= 5759)(t2) || ((t3) => t3 >= 6320 && t3 <= 6399)(t2) || Vi2(t2) || ((t3) => t3 >= 19904 && t3 <= 19967)(t2) || Ei2(t2) || Bi2(t2))));
          }
          function ji2(t2) {
            return !(Ni2(t2) || function(t3) {
              return !!(((t4) => t4 >= 128 && t4 <= 255)(t3) && (t3 === 167 || t3 === 169 || t3 === 174 || t3 === 177 || t3 === 188 || t3 === 189 || t3 === 190 || t3 === 215 || t3 === 247) || ((t4) => t4 >= 8192 && t4 <= 8303)(t3) && (t3 === 8214 || t3 === 8224 || t3 === 8225 || t3 === 8240 || t3 === 8241 || t3 === 8251 || t3 === 8252 || t3 === 8258 || t3 === 8263 || t3 === 8264 || t3 === 8265 || t3 === 8273) || ((t4) => t4 >= 8448 && t4 <= 8527)(t3) || ((t4) => t4 >= 8528 && t4 <= 8591)(t3) || ((t4) => t4 >= 8960 && t4 <= 9215)(t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9e3 || t3 === 9003 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || t3 === 9167 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || ((t4) => t4 >= 9216 && t4 <= 9279)(t3) && t3 !== 9251 || ((t4) => t4 >= 9280 && t4 <= 9311)(t3) || ((t4) => t4 >= 9312 && t4 <= 9471)(t3) || ((t4) => t4 >= 9632 && t4 <= 9727)(t3) || ((t4) => t4 >= 9728 && t4 <= 9983)(t3) && !(t3 >= 9754 && t3 <= 9759) || ((t4) => t4 >= 11008 && t4 <= 11263)(t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || vi2(t3) || wi2(t3) || ((t4) => t4 >= 57344 && t4 <= 63743)(t3) || Li2(t3) || Fi2(t3) || Ui2(t3) || t3 === 8734 || t3 === 8756 || t3 === 8757 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || t3 === 65532 || t3 === 65533);
            }(t2));
          }
          function Gi2(t2) {
            return t2 >= 1424 && t2 <= 2303 || Di2(t2) || Ri(t2);
          }
          function Zi2(t2, e2) {
            return !(!e2 && Gi2(t2) || t2 >= 2304 && t2 <= 3583 || t2 >= 3840 && t2 <= 4255 || ((t3) => t3 >= 6016 && t3 <= 6143)(t2));
          }
          function Xi2(t2) {
            for (const e2 of t2)
              if (Gi2(e2.charCodeAt(0)))
                return true;
            return false;
          }
          const Ki2 = "deferred", Hi2 = "loading", Yi2 = "loaded";
          let Ji2 = null, Wi2 = "unavailable", Qi2 = null;
          const ts2 = function(t2) {
            t2 && typeof t2 == "string" && t2.indexOf("NetworkError") > -1 && (Wi2 = "error"), Ji2 && Ji2(t2);
          };
          function es2() {
            rs2.fire(new Vt2("pluginStateChange", { pluginStatus: Wi2, pluginURL: Qi2 }));
          }
          const rs2 = new Ft2(), ns2 = function() {
            return Wi2;
          }, is2 = function() {
            if (Wi2 !== Ki2 || !Qi2)
              throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
            Wi2 = Hi2, es2(), Qi2 && St2({ url: Qi2 }, (t2) => {
              t2 ? ts2(t2) : (Wi2 = Yi2, es2());
            });
          }, ss2 = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => Wi2 === Yi2 || ss2.applyArabicShaping != null, isLoading: () => Wi2 === Hi2, setState(t2) {
            Wi2 = t2.pluginStatus, Qi2 = t2.pluginURL;
          }, isParsed: () => ss2.applyArabicShaping != null && ss2.processBidirectionalText != null && ss2.processStyledBidirectionalText != null, getPluginURL: () => Qi2 };
          class as2 {
            constructor(t2, e2) {
              this.zoom = t2, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.zoomHistory = e2.zoomHistory, this.transition = e2.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new pi(), this.transition = {});
            }
            isSupportedScript(t2) {
              return function(t3, e2) {
                for (const r3 of t3)
                  if (!Zi2(r3.charCodeAt(0), e2))
                    return false;
                return true;
              }(t2, ss2.isLoaded());
            }
            crossFadingFactor() {
              return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
            }
            getCrossfadeParameters() {
              const t2 = this.zoom, e2 = t2 - Math.floor(t2), r3 = this.crossFadingFactor();
              return t2 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e2 + (1 - e2) * r3 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r3) * e2 };
            }
          }
          class os2 {
            constructor(t2, e2) {
              this.property = t2, this.value = e2, this.expression = function(t3, e3) {
                if (Qr2(t3))
                  return new fn2(t3, e3);
                if (un(t3)) {
                  const r3 = dn2(t3, e3);
                  if (r3.result === "error")
                    throw new Error(r3.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
                  return r3.value;
                }
                {
                  let r3 = t3;
                  return typeof t3 == "string" && e3.type === "color" && (r3 = ce2.parse(t3)), { kind: "constant", evaluate: () => r3 };
                }
              }(e2 === void 0 ? t2.specification.default : e2, t2.specification);
            }
            isDataDriven() {
              return this.expression.kind === "source" || this.expression.kind === "composite";
            }
            possiblyEvaluate(t2, e2, r3) {
              return this.property.possiblyEvaluate(this, t2, e2, r3);
            }
          }
          class ls2 {
            constructor(t2) {
              this.property = t2, this.value = new os2(t2, void 0);
            }
            transitioned(t2, e2) {
              return new cs2(this.property, this.value, e2, v({}, t2.transition, this.transition), t2.now);
            }
            untransitioned() {
              return new cs2(this.property, this.value, null, {}, 0);
            }
          }
          class us2 {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues);
            }
            getValue(t2) {
              return M2(this._values[t2].value.value);
            }
            setValue(t2, e2) {
              this._values.hasOwnProperty(t2) || (this._values[t2] = new ls2(this._values[t2].property)), this._values[t2].value = new os2(this._values[t2].property, e2 === null ? void 0 : M2(e2));
            }
            getTransition(t2) {
              return M2(this._values[t2].transition);
            }
            setTransition(t2, e2) {
              this._values.hasOwnProperty(t2) || (this._values[t2] = new ls2(this._values[t2].property)), this._values[t2].transition = M2(e2) || void 0;
            }
            serialize() {
              const t2 = {};
              for (const e2 of Object.keys(this._values)) {
                const r3 = this.getValue(e2);
                r3 !== void 0 && (t2[e2] = r3);
                const n2 = this.getTransition(e2);
                n2 !== void 0 && (t2[`${e2}-transition`] = n2);
              }
              return t2;
            }
            transitioned(t2, e2) {
              const r3 = new hs2(this._properties);
              for (const n2 of Object.keys(this._values))
                r3._values[n2] = this._values[n2].transitioned(t2, e2._values[n2]);
              return r3;
            }
            untransitioned() {
              const t2 = new hs2(this._properties);
              for (const e2 of Object.keys(this._values))
                t2._values[e2] = this._values[e2].untransitioned();
              return t2;
            }
          }
          class cs2 {
            constructor(t2, e2, r3, n2, i2) {
              const s2 = n2.delay || 0, a2 = n2.duration || 0;
              i2 = i2 || 0, this.property = t2, this.value = e2, this.begin = i2 + s2, this.end = this.begin + a2, t2.specification.transition && (n2.delay || n2.duration) && (this.prior = r3);
            }
            possiblyEvaluate(t2, e2, r3) {
              const n2 = t2.now || 0, i2 = this.value.possiblyEvaluate(t2, e2, r3), s2 = this.prior;
              if (s2) {
                if (n2 > this.end)
                  return this.prior = null, i2;
                if (this.value.isDataDriven())
                  return this.prior = null, i2;
                if (n2 < this.begin)
                  return s2.possiblyEvaluate(t2, e2, r3);
                {
                  const a2 = (n2 - this.begin) / (this.end - this.begin);
                  return this.property.interpolate(s2.possiblyEvaluate(t2, e2, r3), i2, p(a2));
                }
              }
              return i2;
            }
          }
          class hs2 {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
            }
            possiblyEvaluate(t2, e2, r3) {
              const n2 = new fs2(this._properties);
              for (const i2 of Object.keys(this._values))
                n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r3);
              return n2;
            }
            hasTransition() {
              for (const t2 of Object.keys(this._values))
                if (this._values[t2].prior)
                  return true;
              return false;
            }
          }
          class ps2 {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultPropertyValues);
            }
            getValue(t2) {
              return M2(this._values[t2].value);
            }
            setValue(t2, e2) {
              this._values[t2] = new os2(this._values[t2].property, e2 === null ? void 0 : M2(e2));
            }
            serialize() {
              const t2 = {};
              for (const e2 of Object.keys(this._values)) {
                const r3 = this.getValue(e2);
                r3 !== void 0 && (t2[e2] = r3);
              }
              return t2;
            }
            possiblyEvaluate(t2, e2, r3) {
              const n2 = new fs2(this._properties);
              for (const i2 of Object.keys(this._values))
                n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r3);
              return n2;
            }
          }
          class ds2 {
            constructor(t2, e2, r3) {
              this.property = t2, this.value = e2, this.parameters = r3;
            }
            isConstant() {
              return this.value.kind === "constant";
            }
            constantOr(t2) {
              return this.value.kind === "constant" ? this.value.value : t2;
            }
            evaluate(t2, e2, r3, n2) {
              return this.property.evaluate(this.value, this.parameters, t2, e2, r3, n2);
            }
          }
          class fs2 {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
            }
            get(t2) {
              return this._values[t2];
            }
          }
          class ys2 {
            constructor(t2) {
              this.specification = t2;
            }
            possiblyEvaluate(t2, e2) {
              return t2.expression.evaluate(e2);
            }
            interpolate(t2, e2, r3) {
              const n2 = nr2[this.specification.type];
              return n2 ? n2(t2, e2, r3) : t2;
            }
          }
          class ms2 {
            constructor(t2, e2) {
              this.specification = t2, this.overrides = e2;
            }
            possiblyEvaluate(t2, e2, r3, n2) {
              return new ds2(this, t2.expression.kind === "constant" || t2.expression.kind === "camera" ? { kind: "constant", value: t2.expression.evaluate(e2, null, {}, r3, n2) } : t2.expression, e2);
            }
            interpolate(t2, e2, r3) {
              if (t2.value.kind !== "constant" || e2.value.kind !== "constant")
                return t2;
              if (t2.value.value === void 0 || e2.value.value === void 0)
                return new ds2(this, { kind: "constant", value: void 0 }, t2.parameters);
              const n2 = nr2[this.specification.type];
              return n2 ? new ds2(this, { kind: "constant", value: n2(t2.value.value, e2.value.value, r3) }, t2.parameters) : t2;
            }
            evaluate(t2, e2, r3, n2, i2, s2) {
              return t2.kind === "constant" ? t2.value : t2.evaluate(e2, r3, n2, i2, s2);
            }
          }
          class gs2 extends ms2 {
            possiblyEvaluate(t2, e2, r3, n2) {
              if (t2.value === void 0)
                return new ds2(this, { kind: "constant", value: void 0 }, e2);
              if (t2.expression.kind === "constant") {
                const i2 = t2.expression.evaluate(e2, null, {}, r3, n2), s2 = t2.property.specification.type === "resolvedImage" && typeof i2 != "string" ? i2.name : i2, a2 = this._calculate(s2, s2, s2, e2);
                return new ds2(this, { kind: "constant", value: a2 }, e2);
              }
              if (t2.expression.kind === "camera") {
                const r4 = this._calculate(t2.expression.evaluate({ zoom: e2.zoom - 1 }), t2.expression.evaluate({ zoom: e2.zoom }), t2.expression.evaluate({ zoom: e2.zoom + 1 }), e2);
                return new ds2(this, { kind: "constant", value: r4 }, e2);
              }
              return new ds2(this, t2.expression, e2);
            }
            evaluate(t2, e2, r3, n2, i2, s2) {
              if (t2.kind === "source") {
                const a2 = t2.evaluate(e2, r3, n2, i2, s2);
                return this._calculate(a2, a2, a2, e2);
              }
              return t2.kind === "composite" ? this._calculate(t2.evaluate({ zoom: Math.floor(e2.zoom) - 1 }, r3, n2), t2.evaluate({ zoom: Math.floor(e2.zoom) }, r3, n2), t2.evaluate({ zoom: Math.floor(e2.zoom) + 1 }, r3, n2), e2) : t2.value;
            }
            _calculate(t2, e2, r3, n2) {
              return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2, other: r3 } : { from: r3, to: e2, other: t2 };
            }
            interpolate(t2) {
              return t2;
            }
          }
          class xs2 {
            constructor(t2) {
              this.specification = t2;
            }
            possiblyEvaluate(t2, e2, r3, n2) {
              if (t2.value !== void 0) {
                if (t2.expression.kind === "constant") {
                  const i2 = t2.expression.evaluate(e2, null, {}, r3, n2);
                  return this._calculate(i2, i2, i2, e2);
                }
                return this._calculate(t2.expression.evaluate(new as2(Math.floor(e2.zoom - 1), e2)), t2.expression.evaluate(new as2(Math.floor(e2.zoom), e2)), t2.expression.evaluate(new as2(Math.floor(e2.zoom + 1), e2)), e2);
              }
            }
            _calculate(t2, e2, r3, n2) {
              return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2 } : { from: r3, to: e2 };
            }
            interpolate(t2) {
              return t2;
            }
          }
          class vs2 {
            constructor(t2) {
              this.specification = t2;
            }
            possiblyEvaluate(t2, e2, r3, n2) {
              return !!t2.expression.evaluate(e2, null, {}, r3, n2);
            }
            interpolate() {
              return false;
            }
          }
          class bs2 {
            constructor(t2) {
              this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
              for (const e2 in t2) {
                const r3 = t2[e2];
                r3.specification.overridable && this.overridableProperties.push(e2);
                const n2 = this.defaultPropertyValues[e2] = new os2(r3, void 0), i2 = this.defaultTransitionablePropertyValues[e2] = new ls2(r3);
                this.defaultTransitioningPropertyValues[e2] = i2.untransitioned(), this.defaultPossiblyEvaluatedValues[e2] = n2.possiblyEvaluate({});
              }
            }
          }
          function ws(t2, e2) {
            return 256 * (t2 = y(Math.floor(t2), 0, 255)) + y(Math.floor(e2), 0, 255);
          }
          oi2("DataDrivenProperty", ms2), oi2("DataConstantProperty", ys2), oi2("CrossFadedDataDrivenProperty", gs2), oi2("CrossFadedProperty", xs2), oi2("ColorRampProperty", vs2);
          const _s2 = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
          class ks {
            constructor(t2, e2) {
              this._structArray = t2, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
            }
          }
          class As {
            constructor() {
              this.isTransferred = false, this.capacity = -1, this.resize(0);
            }
            static serialize(t2, e2) {
              return t2._trim(), e2 && (t2.isTransferred = true, e2.push(t2.arrayBuffer)), { length: t2.length, arrayBuffer: t2.arrayBuffer };
            }
            static deserialize(t2) {
              const e2 = Object.create(this.prototype);
              return e2.arrayBuffer = t2.arrayBuffer, e2.length = t2.length, e2.capacity = t2.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
            }
            _trim() {
              this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
            }
            clear() {
              this.length = 0;
            }
            resize(t2) {
              this.reserve(t2), this.length = t2;
            }
            reserve(t2) {
              if (t2 > this.capacity) {
                this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                const e2 = this.uint8;
                this._refreshViews(), e2 && this.uint8.set(e2);
              }
            }
            _refreshViews() {
              throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
            }
          }
          function Ss(t2, e2 = 1) {
            let r3 = 0, n2 = 0;
            return { members: t2.map((t3) => {
              const i2 = _s2[t3.type].BYTES_PER_ELEMENT, s2 = r3 = Is2(r3, Math.max(e2, i2)), a2 = t3.components || 1;
              return n2 = Math.max(n2, i2), r3 += i2 * a2, { name: t3.name, type: t3.type, components: a2, offset: s2 };
            }), size: Is2(r3, Math.max(n2, e2)), alignment: e2 };
          }
          function Is2(t2, e2) {
            return Math.ceil(t2 / e2) * e2;
          }
          class zs extends As {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2) {
              const r3 = this.length;
              return this.resize(r3 + 1), this.emplace(r3, t2, e2);
            }
            emplace(t2, e2, r3) {
              const n2 = 2 * t2;
              return this.int16[n2 + 0] = e2, this.int16[n2 + 1] = r3, t2;
            }
          }
          zs.prototype.bytesPerElement = 4, oi2("StructArrayLayout2i4", zs);
          class Ts2 extends As {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r3, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e2, r3, n2);
            }
            emplace(t2, e2, r3, n2, i2) {
              const s2 = 4 * t2;
              return this.int16[s2 + 0] = e2, this.int16[s2 + 1] = r3, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, t2;
            }
          }
          Ts2.prototype.bytesPerElement = 8, oi2("StructArrayLayout4i8", Ts2);
          class Ms2 extends As {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r3, n2, i2, s2, a2) {
              const o2 = this.length;
              return this.resize(o2 + 1), this.emplace(o2, t2, e2, r3, n2, i2, s2, a2);
            }
            emplace(t2, e2, r3, n2, i2, s2, a2, o2) {
              const l2 = 6 * t2, u2 = 12 * t2, c2 = 3 * t2;
              return this.int16[l2 + 0] = e2, this.int16[l2 + 1] = r3, this.uint8[u2 + 4] = n2, this.uint8[u2 + 5] = i2, this.uint8[u2 + 6] = s2, this.uint8[u2 + 7] = a2, this.float32[c2 + 2] = o2, t2;
            }
          }
          Ms2.prototype.bytesPerElement = 12, oi2("StructArrayLayout2i4ub1f12", Ms2);
          class Es2 extends As {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2) {
              const r3 = this.length;
              return this.resize(r3 + 1), this.emplace(r3, t2, e2);
            }
            emplace(t2, e2, r3) {
              const n2 = 2 * t2;
              return this.float32[n2 + 0] = e2, this.float32[n2 + 1] = r3, t2;
            }
          }
          Es2.prototype.bytesPerElement = 8, oi2("StructArrayLayout2f8", Es2);
          class Bs extends As {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2) {
              const c2 = this.length;
              return this.resize(c2 + 1), this.emplace(c2, t2, e2, r3, n2, i2, s2, a2, o2, l2, u2);
            }
            emplace(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2) {
              const h2 = 10 * t2;
              return this.uint16[h2 + 0] = e2, this.uint16[h2 + 1] = r3, this.uint16[h2 + 2] = n2, this.uint16[h2 + 3] = i2, this.uint16[h2 + 4] = s2, this.uint16[h2 + 5] = a2, this.uint16[h2 + 6] = o2, this.uint16[h2 + 7] = l2, this.uint16[h2 + 8] = u2, this.uint16[h2 + 9] = c2, t2;
            }
          }
          Bs.prototype.bytesPerElement = 20, oi2("StructArrayLayout10ui20", Bs);
          class Cs2 extends As {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r3, n2, i2, s2, a2, o2) {
              const l2 = this.length;
              return this.resize(l2 + 1), this.emplace(l2, t2, e2, r3, n2, i2, s2, a2, o2);
            }
            emplace(t2, e2, r3, n2, i2, s2, a2, o2, l2) {
              const u2 = 8 * t2;
              return this.uint16[u2 + 0] = e2, this.uint16[u2 + 1] = r3, this.uint16[u2 + 2] = n2, this.uint16[u2 + 3] = i2, this.uint16[u2 + 4] = s2, this.uint16[u2 + 5] = a2, this.uint16[u2 + 6] = o2, this.uint16[u2 + 7] = l2, t2;
            }
          }
          Cs2.prototype.bytesPerElement = 16, oi2("StructArrayLayout8ui16", Cs2);
          class Ps extends As {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2) {
              const p2 = this.length;
              return this.resize(p2 + 1), this.emplace(p2, t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2);
            }
            emplace(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
              const d2 = 12 * t2;
              return this.int16[d2 + 0] = e2, this.int16[d2 + 1] = r3, this.int16[d2 + 2] = n2, this.int16[d2 + 3] = i2, this.uint16[d2 + 4] = s2, this.uint16[d2 + 5] = a2, this.uint16[d2 + 6] = o2, this.uint16[d2 + 7] = l2, this.int16[d2 + 8] = u2, this.int16[d2 + 9] = c2, this.int16[d2 + 10] = h2, this.int16[d2 + 11] = p2, t2;
            }
          }
          Ps.prototype.bytesPerElement = 24, oi2("StructArrayLayout4i4ui4i24", Ps);
          class Ds extends As {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r3) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e2, r3);
            }
            emplace(t2, e2, r3, n2) {
              const i2 = 3 * t2;
              return this.float32[i2 + 0] = e2, this.float32[i2 + 1] = r3, this.float32[i2 + 2] = n2, t2;
            }
          }
          Ds.prototype.bytesPerElement = 12, oi2("StructArrayLayout3f12", Ds);
          class Vs extends As {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e2 = this.length;
              return this.resize(e2 + 1), this.emplace(e2, t2);
            }
            emplace(t2, e2) {
              return this.uint32[1 * t2 + 0] = e2, t2;
            }
          }
          Vs.prototype.bytesPerElement = 4, oi2("StructArrayLayout1ul4", Vs);
          class Ls2 extends As {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2) {
              const c2 = this.length;
              return this.resize(c2 + 1), this.emplace(c2, t2, e2, r3, n2, i2, s2, a2, o2, l2, u2);
            }
            emplace(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2) {
              const h2 = 16 * t2, p2 = 8 * t2;
              return this.int16[h2 + 0] = e2, this.int16[h2 + 1] = r3, this.float32[p2 + 1] = n2, this.float32[p2 + 2] = i2, this.float32[p2 + 3] = s2, this.float32[p2 + 4] = a2, this.int16[h2 + 10] = o2, this.uint32[p2 + 6] = l2, this.uint16[h2 + 14] = u2, this.uint16[h2 + 15] = c2, t2;
            }
          }
          Ls2.prototype.bytesPerElement = 32, oi2("StructArrayLayout2i4f1i1ul2ui32", Ls2);
          class Fs extends As {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r3, n2, i2, s2) {
              const a2 = this.length;
              return this.resize(a2 + 1), this.emplace(a2, t2, e2, r3, n2, i2, s2);
            }
            emplace(t2, e2, r3, n2, i2, s2, a2) {
              const o2 = 6 * t2;
              return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r3, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
            }
          }
          Fs.prototype.bytesPerElement = 12, oi2("StructArrayLayout2i2i2i12", Fs);
          class Rs2 extends As {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r3, n2, i2) {
              const s2 = this.length;
              return this.resize(s2 + 1), this.emplace(s2, t2, e2, r3, n2, i2);
            }
            emplace(t2, e2, r3, n2, i2, s2) {
              const a2 = 4 * t2, o2 = 8 * t2;
              return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r3, this.float32[a2 + 2] = n2, this.int16[o2 + 6] = i2, this.int16[o2 + 7] = s2, t2;
            }
          }
          Rs2.prototype.bytesPerElement = 16, oi2("StructArrayLayout2f1f2i16", Rs2);
          class Us extends As {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r3, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e2, r3, n2);
            }
            emplace(t2, e2, r3, n2, i2) {
              const s2 = 12 * t2, a2 = 3 * t2;
              return this.uint8[s2 + 0] = e2, this.uint8[s2 + 1] = r3, this.float32[a2 + 1] = n2, this.float32[a2 + 2] = i2, t2;
            }
          }
          Us.prototype.bytesPerElement = 12, oi2("StructArrayLayout2ub2f12", Us);
          class $s2 extends As {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r3) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e2, r3);
            }
            emplace(t2, e2, r3, n2) {
              const i2 = 3 * t2;
              return this.uint16[i2 + 0] = e2, this.uint16[i2 + 1] = r3, this.uint16[i2 + 2] = n2, t2;
            }
          }
          $s2.prototype.bytesPerElement = 6, oi2("StructArrayLayout3ui6", $s2);
          class Os2 extends As {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, y2, m2, g2) {
              const x3 = this.length;
              return this.resize(x3 + 1), this.emplace(x3, t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, y2, m2, g2);
            }
            emplace(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, y2, m2, g2, x3) {
              const v2 = 13 * t2, b2 = 26 * t2, w3 = 52 * t2;
              return this.float32[v2 + 0] = e2, this.float32[v2 + 1] = r3, this.uint16[b2 + 4] = n2, this.uint16[b2 + 5] = i2, this.uint32[v2 + 3] = s2, this.uint32[v2 + 4] = a2, this.uint32[v2 + 5] = o2, this.uint16[b2 + 12] = l2, this.uint16[b2 + 13] = u2, this.uint16[b2 + 14] = c2, this.float32[v2 + 8] = h2, this.float32[v2 + 9] = p2, this.uint8[w3 + 40] = d2, this.uint8[w3 + 41] = f2, this.uint8[w3 + 42] = y2, this.uint32[v2 + 11] = m2, this.int16[b2 + 24] = g2, this.uint8[w3 + 50] = x3, t2;
            }
          }
          Os2.prototype.bytesPerElement = 52, oi2("StructArrayLayout2f2ui3ul3ui2f3ub1ul1i1ub52", Os2);
          class qs2 extends As {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, y2, m2, g2, x3, v2, b2, w3, _2, k3, A2, S2, I3) {
              const z2 = this.length;
              return this.resize(z2 + 1), this.emplace(z2, t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, y2, m2, g2, x3, v2, b2, w3, _2, k3, A2, S2, I3);
            }
            emplace(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, y2, m2, g2, x3, v2, b2, w3, _2, k3, A2, S2, I3, z2) {
              const T2 = 17 * t2, M3 = 34 * t2;
              return this.float32[T2 + 0] = e2, this.float32[T2 + 1] = r3, this.int16[M3 + 4] = n2, this.int16[M3 + 5] = i2, this.int16[M3 + 6] = s2, this.int16[M3 + 7] = a2, this.int16[M3 + 8] = o2, this.int16[M3 + 9] = l2, this.uint16[M3 + 10] = u2, this.uint16[M3 + 11] = c2, this.uint16[M3 + 12] = h2, this.uint16[M3 + 13] = p2, this.uint16[M3 + 14] = d2, this.uint16[M3 + 15] = f2, this.uint16[M3 + 16] = y2, this.uint16[M3 + 17] = m2, this.uint16[M3 + 18] = g2, this.uint16[M3 + 19] = x3, this.uint16[M3 + 20] = v2, this.uint16[M3 + 21] = b2, this.uint16[M3 + 22] = w3, this.uint16[M3 + 23] = _2, this.uint16[M3 + 24] = k3, this.uint32[T2 + 13] = A2, this.float32[T2 + 14] = S2, this.float32[T2 + 15] = I3, this.float32[T2 + 16] = z2, t2;
            }
          }
          qs2.prototype.bytesPerElement = 68, oi2("StructArrayLayout2f6i15ui1ul3f68", qs2);
          class Ns2 extends As {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e2 = this.length;
              return this.resize(e2 + 1), this.emplace(e2, t2);
            }
            emplace(t2, e2) {
              return this.float32[1 * t2 + 0] = e2, t2;
            }
          }
          Ns2.prototype.bytesPerElement = 4, oi2("StructArrayLayout1f4", Ns2);
          class js extends As {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r3) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e2, r3);
            }
            emplace(t2, e2, r3, n2) {
              const i2 = 3 * t2;
              return this.int16[i2 + 0] = e2, this.int16[i2 + 1] = r3, this.int16[i2 + 2] = n2, t2;
            }
          }
          js.prototype.bytesPerElement = 6, oi2("StructArrayLayout3i6", js);
          class Gs extends As {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r3, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e2, r3, n2);
            }
            emplace(t2, e2, r3, n2, i2) {
              const s2 = 6 * t2;
              return this.uint32[3 * t2 + 0] = e2, this.uint16[s2 + 2] = r3, this.uint16[s2 + 3] = n2, this.uint16[s2 + 4] = i2, t2;
            }
          }
          Gs.prototype.bytesPerElement = 12, oi2("StructArrayLayout1ul3ui12", Gs);
          class Zs2 extends As {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2) {
              const r3 = this.length;
              return this.resize(r3 + 1), this.emplace(r3, t2, e2);
            }
            emplace(t2, e2, r3) {
              const n2 = 2 * t2;
              return this.uint16[n2 + 0] = e2, this.uint16[n2 + 1] = r3, t2;
            }
          }
          Zs2.prototype.bytesPerElement = 4, oi2("StructArrayLayout2ui4", Zs2);
          class Xs2 extends As {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e2 = this.length;
              return this.resize(e2 + 1), this.emplace(e2, t2);
            }
            emplace(t2, e2) {
              return this.uint16[1 * t2 + 0] = e2, t2;
            }
          }
          Xs2.prototype.bytesPerElement = 2, oi2("StructArrayLayout1ui2", Xs2);
          class Ks2 extends As {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r3, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e2, r3, n2);
            }
            emplace(t2, e2, r3, n2, i2) {
              const s2 = 4 * t2;
              return this.float32[s2 + 0] = e2, this.float32[s2 + 1] = r3, this.float32[s2 + 2] = n2, this.float32[s2 + 3] = i2, t2;
            }
          }
          Ks2.prototype.bytesPerElement = 16, oi2("StructArrayLayout4f16", Ks2);
          class Hs2 extends ks {
            get anchorPointX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get anchorPointY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get x1() {
              return this._structArray.float32[this._pos4 + 1];
            }
            get y1() {
              return this._structArray.float32[this._pos4 + 2];
            }
            get x2() {
              return this._structArray.float32[this._pos4 + 3];
            }
            get y2() {
              return this._structArray.float32[this._pos4 + 4];
            }
            get padding() {
              return this._structArray.int16[this._pos2 + 10];
            }
            get featureIndex() {
              return this._structArray.uint32[this._pos4 + 6];
            }
            get sourceLayerIndex() {
              return this._structArray.uint16[this._pos2 + 14];
            }
            get bucketIndex() {
              return this._structArray.uint16[this._pos2 + 15];
            }
            get anchorPoint() {
              return new i(this.anchorPointX, this.anchorPointY);
            }
          }
          Hs2.prototype.size = 32;
          class Ys2 extends Ls2 {
            get(t2) {
              return new Hs2(this, t2);
            }
          }
          oi2("CollisionBoxArray", Ys2);
          class Js2 extends ks {
            get anchorX() {
              return this._structArray.float32[this._pos4 + 0];
            }
            get anchorY() {
              return this._structArray.float32[this._pos4 + 1];
            }
            get glyphStartIndex() {
              return this._structArray.uint16[this._pos2 + 4];
            }
            get numGlyphs() {
              return this._structArray.uint16[this._pos2 + 5];
            }
            get vertexStartIndex() {
              return this._structArray.uint32[this._pos4 + 3];
            }
            get lineStartIndex() {
              return this._structArray.uint32[this._pos4 + 4];
            }
            get lineLength() {
              return this._structArray.uint32[this._pos4 + 5];
            }
            get segment() {
              return this._structArray.uint16[this._pos2 + 12];
            }
            get lowerSize() {
              return this._structArray.uint16[this._pos2 + 13];
            }
            get upperSize() {
              return this._structArray.uint16[this._pos2 + 14];
            }
            get lineOffsetX() {
              return this._structArray.float32[this._pos4 + 8];
            }
            get lineOffsetY() {
              return this._structArray.float32[this._pos4 + 9];
            }
            get writingMode() {
              return this._structArray.uint8[this._pos1 + 40];
            }
            get placedOrientation() {
              return this._structArray.uint8[this._pos1 + 41];
            }
            set placedOrientation(t2) {
              this._structArray.uint8[this._pos1 + 41] = t2;
            }
            get hidden() {
              return this._structArray.uint8[this._pos1 + 42];
            }
            set hidden(t2) {
              this._structArray.uint8[this._pos1 + 42] = t2;
            }
            get crossTileID() {
              return this._structArray.uint32[this._pos4 + 11];
            }
            set crossTileID(t2) {
              this._structArray.uint32[this._pos4 + 11] = t2;
            }
            get associatedIconIndex() {
              return this._structArray.int16[this._pos2 + 24];
            }
            get flipState() {
              return this._structArray.uint8[this._pos1 + 50];
            }
            set flipState(t2) {
              this._structArray.uint8[this._pos1 + 50] = t2;
            }
          }
          Js2.prototype.size = 52;
          class Ws extends Os2 {
            get(t2) {
              return new Js2(this, t2);
            }
          }
          oi2("PlacedSymbolArray", Ws);
          class Qs2 extends ks {
            get anchorX() {
              return this._structArray.float32[this._pos4 + 0];
            }
            get anchorY() {
              return this._structArray.float32[this._pos4 + 1];
            }
            get rightJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 4];
            }
            get centerJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 5];
            }
            get leftJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 6];
            }
            get verticalPlacedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 7];
            }
            get placedIconSymbolIndex() {
              return this._structArray.int16[this._pos2 + 8];
            }
            get verticalPlacedIconSymbolIndex() {
              return this._structArray.int16[this._pos2 + 9];
            }
            get key() {
              return this._structArray.uint16[this._pos2 + 10];
            }
            get textBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 11];
            }
            get textBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 12];
            }
            get verticalTextBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 13];
            }
            get verticalTextBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 14];
            }
            get iconBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 15];
            }
            get iconBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 16];
            }
            get verticalIconBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 17];
            }
            get verticalIconBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 18];
            }
            get featureIndex() {
              return this._structArray.uint16[this._pos2 + 19];
            }
            get numHorizontalGlyphVertices() {
              return this._structArray.uint16[this._pos2 + 20];
            }
            get numVerticalGlyphVertices() {
              return this._structArray.uint16[this._pos2 + 21];
            }
            get numIconVertices() {
              return this._structArray.uint16[this._pos2 + 22];
            }
            get numVerticalIconVertices() {
              return this._structArray.uint16[this._pos2 + 23];
            }
            get useRuntimeCollisionCircles() {
              return this._structArray.uint16[this._pos2 + 24];
            }
            get crossTileID() {
              return this._structArray.uint32[this._pos4 + 13];
            }
            set crossTileID(t2) {
              this._structArray.uint32[this._pos4 + 13] = t2;
            }
            get textOffset0() {
              return this._structArray.float32[this._pos4 + 14];
            }
            get textOffset1() {
              return this._structArray.float32[this._pos4 + 15];
            }
            get collisionCircleDiameter() {
              return this._structArray.float32[this._pos4 + 16];
            }
          }
          Qs2.prototype.size = 68;
          class ta2 extends qs2 {
            get(t2) {
              return new Qs2(this, t2);
            }
          }
          oi2("SymbolInstanceArray", ta2);
          class ea2 extends Ns2 {
            getoffsetX(t2) {
              return this.float32[1 * t2 + 0];
            }
          }
          oi2("GlyphOffsetArray", ea2);
          class ra2 extends js {
            getx(t2) {
              return this.int16[3 * t2 + 0];
            }
            gety(t2) {
              return this.int16[3 * t2 + 1];
            }
            gettileUnitDistanceFromAnchor(t2) {
              return this.int16[3 * t2 + 2];
            }
          }
          oi2("SymbolLineVertexArray", ra2);
          class na2 extends ks {
            get featureIndex() {
              return this._structArray.uint32[this._pos4 + 0];
            }
            get sourceLayerIndex() {
              return this._structArray.uint16[this._pos2 + 2];
            }
            get bucketIndex() {
              return this._structArray.uint16[this._pos2 + 3];
            }
            get layoutVertexArrayOffset() {
              return this._structArray.uint16[this._pos2 + 4];
            }
          }
          na2.prototype.size = 12;
          class ia2 extends Gs {
            get(t2) {
              return new na2(this, t2);
            }
          }
          oi2("FeatureIndexArray", ia2);
          class sa2 extends ks {
            get a_centroid_pos0() {
              return this._structArray.uint16[this._pos2 + 0];
            }
            get a_centroid_pos1() {
              return this._structArray.uint16[this._pos2 + 1];
            }
          }
          sa2.prototype.size = 4;
          class aa2 extends Zs2 {
            get(t2) {
              return new sa2(this, t2);
            }
          }
          oi2("FillExtrusionCentroidArray", aa2);
          const oa2 = Ss([{ name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }]), la2 = Ss([{ name: "a_dash_to", components: 4, type: "Uint16" }, { name: "a_dash_from", components: 4, type: "Uint16" }]);
          var ua2 = le2(function(t2) {
            t2.exports = function(t3, e2) {
              var r3, n2, i2, s2, a2, o2, l2, u2;
              for (n2 = t3.length - (r3 = 3 & t3.length), i2 = e2, a2 = 3432918353, o2 = 461845907, u2 = 0; u2 < n2; )
                l2 = 255 & t3.charCodeAt(u2) | (255 & t3.charCodeAt(++u2)) << 8 | (255 & t3.charCodeAt(++u2)) << 16 | (255 & t3.charCodeAt(++u2)) << 24, ++u2, i2 = 27492 + (65535 & (s2 = 5 * (65535 & (i2 = (i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s2 >>> 16) & 65535) << 16);
              switch (l2 = 0, r3) {
                case 3:
                  l2 ^= (255 & t3.charCodeAt(u2 + 2)) << 16;
                case 2:
                  l2 ^= (255 & t3.charCodeAt(u2 + 1)) << 8;
                case 1:
                  i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & t3.charCodeAt(u2))) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295;
              }
              return i2 ^= t3.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
            };
          }), ca2 = le2(function(t2) {
            t2.exports = function(t3, e2) {
              for (var r3, n2 = t3.length, i2 = e2 ^ n2, s2 = 0; n2 >= 4; )
                r3 = 1540483477 * (65535 & (r3 = 255 & t3.charCodeAt(s2) | (255 & t3.charCodeAt(++s2)) << 8 | (255 & t3.charCodeAt(++s2)) << 16 | (255 & t3.charCodeAt(++s2)) << 24)) + ((1540483477 * (r3 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r3 = 1540483477 * (65535 & (r3 ^= r3 >>> 24)) + ((1540483477 * (r3 >>> 16) & 65535) << 16)), n2 -= 4, ++s2;
              switch (n2) {
                case 3:
                  i2 ^= (255 & t3.charCodeAt(s2 + 2)) << 16;
                case 2:
                  i2 ^= (255 & t3.charCodeAt(s2 + 1)) << 8;
                case 1:
                  i2 = 1540483477 * (65535 & (i2 ^= 255 & t3.charCodeAt(s2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
              }
              return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
            };
          }), ha2 = ua2, pa2 = ca2;
          ha2.murmur3 = ua2, ha2.murmur2 = pa2;
          class da2 {
            constructor() {
              this.ids = [], this.positions = [], this.indexed = false;
            }
            add(t2, e2, r3, n2) {
              this.ids.push(fa2(t2)), this.positions.push(e2, r3, n2);
            }
            getPositions(t2) {
              const e2 = fa2(t2);
              let r3 = 0, n2 = this.ids.length - 1;
              for (; r3 < n2; ) {
                const t3 = r3 + n2 >> 1;
                this.ids[t3] >= e2 ? n2 = t3 : r3 = t3 + 1;
              }
              const i2 = [];
              for (; this.ids[r3] === e2; )
                i2.push({ index: this.positions[3 * r3], start: this.positions[3 * r3 + 1], end: this.positions[3 * r3 + 2] }), r3++;
              return i2;
            }
            static serialize(t2, e2) {
              const r3 = new Float64Array(t2.ids), n2 = new Uint32Array(t2.positions);
              return ya2(r3, n2, 0, r3.length - 1), e2 && e2.push(r3.buffer, n2.buffer), { ids: r3, positions: n2 };
            }
            static deserialize(t2) {
              const e2 = new da2();
              return e2.ids = t2.ids, e2.positions = t2.positions, e2.indexed = true, e2;
            }
          }
          function fa2(t2) {
            const e2 = +t2;
            return !isNaN(e2) && e2 <= o ? e2 : ha2(String(t2));
          }
          function ya2(t2, e2, r3, n2) {
            for (; r3 < n2; ) {
              const i2 = t2[r3 + n2 >> 1];
              let s2 = r3 - 1, a2 = n2 + 1;
              for (; ; ) {
                do {
                  s2++;
                } while (t2[s2] < i2);
                do {
                  a2--;
                } while (t2[a2] > i2);
                if (s2 >= a2)
                  break;
                ma2(t2, s2, a2), ma2(e2, 3 * s2, 3 * a2), ma2(e2, 3 * s2 + 1, 3 * a2 + 1), ma2(e2, 3 * s2 + 2, 3 * a2 + 2);
              }
              a2 - r3 < n2 - a2 ? (ya2(t2, e2, r3, a2), r3 = a2 + 1) : (ya2(t2, e2, a2 + 1, n2), n2 = a2);
            }
          }
          function ma2(t2, e2, r3) {
            const n2 = t2[e2];
            t2[e2] = t2[r3], t2[r3] = n2;
          }
          oi2("FeaturePositionMap", da2);
          class ga2 {
            constructor(t2, e2) {
              this.gl = t2.gl, this.location = e2;
            }
          }
          class xa2 extends ga2 {
            constructor(t2, e2) {
              super(t2, e2), this.current = 0;
            }
            set(t2) {
              this.current !== t2 && (this.current = t2, this.gl.uniform1f(this.location, t2));
            }
          }
          class va extends ga2 {
            constructor(t2, e2) {
              super(t2, e2), this.current = [0, 0, 0, 0];
            }
            set(t2) {
              t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] && t2[3] === this.current[3] || (this.current = t2, this.gl.uniform4f(this.location, t2[0], t2[1], t2[2], t2[3]));
            }
          }
          class ba2 extends ga2 {
            constructor(t2, e2) {
              super(t2, e2), this.current = ce2.transparent;
            }
            set(t2) {
              t2.r === this.current.r && t2.g === this.current.g && t2.b === this.current.b && t2.a === this.current.a || (this.current = t2, this.gl.uniform4f(this.location, t2.r, t2.g, t2.b, t2.a));
            }
          }
          const wa2 = new Float32Array(16), _a2 = new Float32Array(9);
          function ka2(t2) {
            return [ws(255 * t2.r, 255 * t2.g), ws(255 * t2.b, 255 * t2.a)];
          }
          class Aa2 {
            constructor(t2, e2, r3) {
              this.value = t2, this.uniformNames = e2.map((t3) => `u_${t3}`), this.type = r3;
            }
            setUniform(t2, e2, r3) {
              t2.set(r3.constantOr(this.value));
            }
            getBinding(t2, e2, r3) {
              return this.type === "color" ? new ba2(t2, e2) : new xa2(t2, e2);
            }
          }
          class Sa2 {
            constructor(t2, e2) {
              this.uniformNames = e2.map((t3) => `u_${t3}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
            }
            setConstantPatternPositions(t2, e2) {
              this.pixelRatioFrom = e2.pixelRatio, this.pixelRatioTo = t2.pixelRatio, this.patternFrom = e2.tl.concat(e2.br), this.patternTo = t2.tl.concat(t2.br);
            }
            setUniform(t2, e2, r3, n2) {
              const i2 = n2 === "u_pattern_to" || n2 === "u_dash_to" ? this.patternTo : n2 === "u_pattern_from" || n2 === "u_dash_from" ? this.patternFrom : n2 === "u_pixel_ratio_to" ? this.pixelRatioTo : n2 === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
              i2 && t2.set(i2);
            }
            getBinding(t2, e2, r3) {
              return r3 === "u_pattern_from" || r3 === "u_pattern_to" || r3 === "u_dash_from" || r3 === "u_dash_to" ? new va(t2, e2) : new xa2(t2, e2);
            }
          }
          class Ia2 {
            constructor(t2, e2, r3, n2) {
              this.expression = t2, this.type = r3, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: r3 === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new n2();
            }
            populatePaintArray(t2, e2, r3, n2, i2) {
              const s2 = this.paintVertexArray.length, a2 = this.expression.evaluate(new as2(0), e2, {}, n2, [], i2);
              this.paintVertexArray.resize(t2), this._setPaintValue(s2, t2, a2);
            }
            updatePaintArray(t2, e2, r3, n2) {
              const i2 = this.expression.evaluate({ zoom: 0 }, r3, n2);
              this._setPaintValue(t2, e2, i2);
            }
            _setPaintValue(t2, e2, r3) {
              if (this.type === "color") {
                const n2 = ka2(r3);
                for (let r4 = t2; r4 < e2; r4++)
                  this.paintVertexArray.emplace(r4, n2[0], n2[1]);
              } else {
                for (let n2 = t2; n2 < e2; n2++)
                  this.paintVertexArray.emplace(n2, r3);
                this.maxValue = Math.max(this.maxValue, Math.abs(r3));
              }
            }
            upload(t2) {
              this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
              this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
          }
          class za2 {
            constructor(t2, e2, r3, n2, i2, s2) {
              this.expression = t2, this.uniformNames = e2.map((t3) => `u_${t3}_t`), this.type = r3, this.useIntegerZoom = n2, this.zoom = i2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: r3 === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new s2();
            }
            populatePaintArray(t2, e2, r3, n2, i2) {
              const s2 = this.expression.evaluate(new as2(this.zoom), e2, {}, n2, [], i2), a2 = this.expression.evaluate(new as2(this.zoom + 1), e2, {}, n2, [], i2), o2 = this.paintVertexArray.length;
              this.paintVertexArray.resize(t2), this._setPaintValue(o2, t2, s2, a2);
            }
            updatePaintArray(t2, e2, r3, n2) {
              const i2 = this.expression.evaluate({ zoom: this.zoom }, r3, n2), s2 = this.expression.evaluate({ zoom: this.zoom + 1 }, r3, n2);
              this._setPaintValue(t2, e2, i2, s2);
            }
            _setPaintValue(t2, e2, r3, n2) {
              if (this.type === "color") {
                const i2 = ka2(r3), s2 = ka2(n2);
                for (let r4 = t2; r4 < e2; r4++)
                  this.paintVertexArray.emplace(r4, i2[0], i2[1], s2[0], s2[1]);
              } else {
                for (let i2 = t2; i2 < e2; i2++)
                  this.paintVertexArray.emplace(i2, r3, n2);
                this.maxValue = Math.max(this.maxValue, Math.abs(r3), Math.abs(n2));
              }
            }
            upload(t2) {
              this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
              this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
            setUniform(t2, e2) {
              const r3 = this.useIntegerZoom ? Math.floor(e2.zoom) : e2.zoom, n2 = y(this.expression.interpolationFactor(r3, this.zoom, this.zoom + 1), 0, 1);
              t2.set(n2);
            }
            getBinding(t2, e2, r3) {
              return new xa2(t2, e2);
            }
          }
          class Ta2 {
            constructor(t2, e2, r3, n2, i2, s2, a2) {
              this.expression = t2, this.type = r3, this.useIntegerZoom = n2, this.zoom = i2, this.layerId = a2, this.paintVertexAttributes = (r3 === "array" ? la2 : oa2).members;
              for (let t3 = 0; t3 < e2.length; ++t3)
                ;
              this.zoomInPaintVertexArray = new s2(), this.zoomOutPaintVertexArray = new s2();
            }
            populatePaintArray(t2, e2, r3) {
              const n2 = this.zoomInPaintVertexArray.length;
              this.zoomInPaintVertexArray.resize(t2), this.zoomOutPaintVertexArray.resize(t2), this._setPaintValues(n2, t2, e2.patterns && e2.patterns[this.layerId], r3);
            }
            updatePaintArray(t2, e2, r3, n2, i2) {
              this._setPaintValues(t2, e2, r3.patterns && r3.patterns[this.layerId], i2);
            }
            _setPaintValues(t2, e2, r3, n2) {
              if (!n2 || !r3)
                return;
              const { min: i2, mid: s2, max: a2 } = r3, o2 = n2[i2], l2 = n2[s2], u2 = n2[a2];
              if (o2 && l2 && u2)
                for (let r4 = t2; r4 < e2; r4++)
                  this._setPaintValue(this.zoomInPaintVertexArray, r4, l2, o2), this._setPaintValue(this.zoomOutPaintVertexArray, r4, l2, u2);
            }
            _setPaintValue(t2, e2, r3, n2) {
              t2.emplace(e2, r3.tl[0], r3.tl[1], r3.br[0], r3.br[1], n2.tl[0], n2.tl[1], n2.br[0], n2.br[1], r3.pixelRatio, n2.pixelRatio);
            }
            upload(t2) {
              this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t2.createVertexBuffer(this.zoomInPaintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t2.createVertexBuffer(this.zoomOutPaintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
              this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
            }
          }
          class Ma2 {
            constructor(t2, e2, r3 = () => true) {
              this.binders = {}, this._buffers = [];
              const n2 = [];
              for (const i2 in t2.paint._values) {
                if (!r3(i2))
                  continue;
                const s2 = t2.paint.get(i2);
                if (!(s2 instanceof ds2 && Hr2(s2.property.specification)))
                  continue;
                const a2 = Ca2(i2, t2.type), o2 = s2.value, l2 = s2.property.specification.type, u2 = s2.property.useIntegerZoom, c2 = s2.property.specification["property-type"], h2 = c2 === "cross-faded" || c2 === "cross-faded-data-driven", p2 = String(i2) === "line-dasharray" && t2.layout.get("line-cap").value.kind !== "constant";
                if (o2.kind !== "constant" || p2)
                  if (o2.kind === "source" || p2 || h2) {
                    const r4 = Va2(i2, l2, "source");
                    this.binders[i2] = h2 ? new Ta2(o2, a2, l2, u2, e2, r4, t2.id) : new Ia2(o2, a2, l2, r4), n2.push(`/a_${i2}`);
                  } else {
                    const t3 = Va2(i2, l2, "composite");
                    this.binders[i2] = new za2(o2, a2, l2, u2, e2, t3), n2.push(`/z_${i2}`);
                  }
                else
                  this.binders[i2] = h2 ? new Sa2(o2.value, a2) : new Aa2(o2.value, a2, l2), n2.push(`/u_${i2}`);
              }
              this.cacheKey = n2.sort().join("");
            }
            getMaxValue(t2) {
              const e2 = this.binders[t2];
              return e2 instanceof Ia2 || e2 instanceof za2 ? e2.maxValue : 0;
            }
            populatePaintArrays(t2, e2, r3, n2, i2) {
              for (const s2 in this.binders) {
                const a2 = this.binders[s2];
                (a2 instanceof Ia2 || a2 instanceof za2 || a2 instanceof Ta2) && a2.populatePaintArray(t2, e2, r3, n2, i2);
              }
            }
            setConstantPatternPositions(t2, e2) {
              for (const r3 in this.binders) {
                const n2 = this.binders[r3];
                n2 instanceof Sa2 && n2.setConstantPatternPositions(t2, e2);
              }
            }
            updatePaintArrays(t2, e2, r3, n2, i2) {
              let s2 = false;
              for (const a2 in t2) {
                const o2 = e2.getPositions(a2);
                for (const e3 of o2) {
                  const o3 = r3.feature(e3.index);
                  for (const r4 in this.binders) {
                    const l2 = this.binders[r4];
                    if ((l2 instanceof Ia2 || l2 instanceof za2 || l2 instanceof Ta2) && l2.expression.isStateDependent === true) {
                      const u2 = n2.paint.get(r4);
                      l2.expression = u2.value, l2.updatePaintArray(e3.start, e3.end, o3, t2[a2], i2), s2 = true;
                    }
                  }
                }
              }
              return s2;
            }
            defines() {
              const t2 = [];
              for (const e2 in this.binders) {
                const r3 = this.binders[e2];
                (r3 instanceof Aa2 || r3 instanceof Sa2) && t2.push(...r3.uniformNames.map((t3) => `#define HAS_UNIFORM_${t3}`));
              }
              return t2;
            }
            getBinderAttributes() {
              const t2 = [];
              for (const e2 in this.binders) {
                const r3 = this.binders[e2];
                if (r3 instanceof Ia2 || r3 instanceof za2 || r3 instanceof Ta2)
                  for (let e3 = 0; e3 < r3.paintVertexAttributes.length; e3++)
                    t2.push(r3.paintVertexAttributes[e3].name);
              }
              return t2;
            }
            getBinderUniforms() {
              const t2 = [];
              for (const e2 in this.binders) {
                const r3 = this.binders[e2];
                if (r3 instanceof Aa2 || r3 instanceof Sa2 || r3 instanceof za2)
                  for (const e3 of r3.uniformNames)
                    t2.push(e3);
              }
              return t2;
            }
            getPaintVertexBuffers() {
              return this._buffers;
            }
            getUniforms(t2, e2) {
              const r3 = [];
              for (const n2 in this.binders) {
                const i2 = this.binders[n2];
                if (i2 instanceof Aa2 || i2 instanceof Sa2 || i2 instanceof za2) {
                  for (const s2 of i2.uniformNames)
                    if (e2[s2]) {
                      const a2 = i2.getBinding(t2, e2[s2], s2);
                      r3.push({ name: s2, property: n2, binding: a2 });
                    }
                }
              }
              return r3;
            }
            setUniforms(t2, e2, r3, n2) {
              for (const { name: t3, property: i2, binding: s2 } of e2)
                this.binders[i2].setUniform(s2, n2, r3.get(i2), t3);
            }
            updatePaintBuffers(t2) {
              this._buffers = [];
              for (const e2 in this.binders) {
                const r3 = this.binders[e2];
                if (t2 && r3 instanceof Ta2) {
                  const e3 = t2.fromScale === 2 ? r3.zoomInPaintVertexBuffer : r3.zoomOutPaintVertexBuffer;
                  e3 && this._buffers.push(e3);
                } else
                  (r3 instanceof Ia2 || r3 instanceof za2) && r3.paintVertexBuffer && this._buffers.push(r3.paintVertexBuffer);
              }
            }
            upload(t2) {
              for (const e2 in this.binders) {
                const r3 = this.binders[e2];
                (r3 instanceof Ia2 || r3 instanceof za2 || r3 instanceof Ta2) && r3.upload(t2);
              }
              this.updatePaintBuffers();
            }
            destroy() {
              for (const t2 in this.binders) {
                const e2 = this.binders[t2];
                (e2 instanceof Ia2 || e2 instanceof za2 || e2 instanceof Ta2) && e2.destroy();
              }
            }
          }
          class Ea2 {
            constructor(t2, e2, r3 = () => true) {
              this.programConfigurations = {};
              for (const n2 of t2)
                this.programConfigurations[n2.id] = new Ma2(n2, e2, r3);
              this.needsUpload = false, this._featureMap = new da2(), this._bufferOffset = 0;
            }
            populatePaintArrays(t2, e2, r3, n2, i2, s2) {
              for (const r4 in this.programConfigurations)
                this.programConfigurations[r4].populatePaintArrays(t2, e2, n2, i2, s2);
              e2.id !== void 0 && this._featureMap.add(e2.id, r3, this._bufferOffset, t2), this._bufferOffset = t2, this.needsUpload = true;
            }
            updatePaintArrays(t2, e2, r3, n2) {
              for (const i2 of r3)
                this.needsUpload = this.programConfigurations[i2.id].updatePaintArrays(t2, this._featureMap, e2, i2, n2) || this.needsUpload;
            }
            get(t2) {
              return this.programConfigurations[t2];
            }
            upload(t2) {
              if (this.needsUpload) {
                for (const e2 in this.programConfigurations)
                  this.programConfigurations[e2].upload(t2);
                this.needsUpload = false;
              }
            }
            destroy() {
              for (const t2 in this.programConfigurations)
                this.programConfigurations[t2].destroy();
            }
          }
          const Ba2 = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "line-dasharray": ["dash_to", "dash_from"] };
          function Ca2(t2, e2) {
            return Ba2[t2] || [t2.replace(`${e2}-`, "").replace(/-/g, "_")];
          }
          const Pa2 = { "line-pattern": { source: Bs, composite: Bs }, "fill-pattern": { source: Bs, composite: Bs }, "fill-extrusion-pattern": { source: Bs, composite: Bs }, "line-dasharray": { source: Cs2, composite: Cs2 } }, Da2 = { color: { source: Es2, composite: Ks2 }, number: { source: Ns2, composite: Es2 } };
          function Va2(t2, e2, r3) {
            const n2 = Pa2[t2];
            return n2 && n2[r3] || Da2[e2][r3];
          }
          oi2("ConstantBinder", Aa2), oi2("CrossFadedConstantBinder", Sa2), oi2("SourceExpressionBinder", Ia2), oi2("CrossFadedCompositeBinder", Ta2), oi2("CompositeExpressionBinder", za2), oi2("ProgramConfiguration", Ma2, { omit: ["_buffers"] }), oi2("ProgramConfigurationSet", Ea2);
          const La2 = "-transition";
          class Fa2 extends Ft2 {
            constructor(t2, e2) {
              if (super(), this.id = t2.id, this.type = t2.type, this._featureFilter = { filter: () => true, needGeometry: false }, t2.type !== "custom" && (this.metadata = (t2 = t2).metadata, this.minzoom = t2.minzoom, this.maxzoom = t2.maxzoom, t2.type !== "background" && t2.type !== "sky" && (this.source = t2.source, this.sourceLayer = t2["source-layer"], this.filter = t2.filter), e2.layout && (this._unevaluatedLayout = new ps2(e2.layout)), e2.paint)) {
                this._transitionablePaint = new us2(e2.paint);
                for (const e3 in t2.paint)
                  this.setPaintProperty(e3, t2.paint[e3], { validate: false });
                for (const e3 in t2.layout)
                  this.setLayoutProperty(e3, t2.layout[e3], { validate: false });
                this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new fs2(e2.paint);
              }
            }
            getCrossfadeParameters() {
              return this._crossfadeParameters;
            }
            getLayoutProperty(t2) {
              return t2 === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t2);
            }
            setLayoutProperty(t2, e2, r3 = {}) {
              e2 != null && this._validate(ti2, `layers.${this.id}.layout.${t2}`, t2, e2, r3) || (t2 !== "visibility" ? this._unevaluatedLayout.setValue(t2, e2) : this.visibility = e2);
            }
            getPaintProperty(t2) {
              return I2(t2, La2) ? this._transitionablePaint.getTransition(t2.slice(0, -La2.length)) : this._transitionablePaint.getValue(t2);
            }
            setPaintProperty(t2, e2, r3 = {}) {
              if (e2 != null && this._validate(Qn2, `layers.${this.id}.paint.${t2}`, t2, e2, r3))
                return false;
              if (I2(t2, La2))
                return this._transitionablePaint.setTransition(t2.slice(0, -La2.length), e2 || void 0), false;
              {
                const r4 = this._transitionablePaint._values[t2], n2 = r4.property.specification["property-type"] === "cross-faded-data-driven", i2 = r4.value.isDataDriven(), s2 = r4.value;
                this._transitionablePaint.setValue(t2, e2), this._handleSpecialPaintPropertyUpdate(t2);
                const a2 = this._transitionablePaint._values[t2].value;
                return a2.isDataDriven() || i2 || n2 || this._handleOverridablePaintPropertyUpdate(t2, s2, a2);
              }
            }
            _handleSpecialPaintPropertyUpdate(t2) {
            }
            getProgramIds() {
              return null;
            }
            getProgramConfiguration(t2) {
              return null;
            }
            _handleOverridablePaintPropertyUpdate(t2, e2, r3) {
              return false;
            }
            isHidden(t2) {
              return !!(this.minzoom && t2 < this.minzoom) || !!(this.maxzoom && t2 >= this.maxzoom) || this.visibility === "none";
            }
            updateTransitions(t2) {
              this._transitioningPaint = this._transitionablePaint.transitioned(t2, this._transitioningPaint);
            }
            hasTransition() {
              return this._transitioningPaint.hasTransition();
            }
            recalculate(t2, e2) {
              t2.getCrossfadeParameters && (this._crossfadeParameters = t2.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t2, void 0, e2)), this.paint = this._transitioningPaint.possiblyEvaluate(t2, void 0, e2);
            }
            serialize() {
              const t2 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
              return this.visibility && (t2.layout = t2.layout || {}, t2.layout.visibility = this.visibility), T(t2, (t3, e2) => !(t3 === void 0 || e2 === "layout" && !Object.keys(t3).length || e2 === "paint" && !Object.keys(t3).length));
            }
            _validate(t2, e2, r3, n2, i2 = {}) {
              return (!i2 || i2.validate !== false) && ei2(this, t2.call(Yn2, { key: e2, layerType: this.type, objectKey: r3, value: n2, styleSpec: Rt, style: { glyphs: true, sprite: true } }));
            }
            is3D() {
              return false;
            }
            isSky() {
              return false;
            }
            isTileClipped() {
              return false;
            }
            hasOffscreenPass() {
              return false;
            }
            resize() {
            }
            isStateDependent() {
              for (const t2 in this.paint._values) {
                const e2 = this.paint.get(t2);
                if (e2 instanceof ds2 && Hr2(e2.property.specification) && (e2.value.kind === "source" || e2.value.kind === "composite") && e2.value.isStateDependent)
                  return true;
              }
              return false;
            }
          }
          const Ra2 = Ss([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Ua2 } = Ra2;
          class $a2 {
            constructor(t2 = []) {
              this.segments = t2;
            }
            prepareSegment(t2, e2, r3, n2) {
              let i2 = this.segments[this.segments.length - 1];
              return t2 > $a2.MAX_VERTEX_ARRAY_LENGTH && B(`Max vertices per segment is ${$a2.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t2}`), (!i2 || i2.vertexLength + t2 > $a2.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2) && (i2 = { vertexOffset: e2.length, primitiveOffset: r3.length, vertexLength: 0, primitiveLength: 0 }, n2 !== void 0 && (i2.sortKey = n2), this.segments.push(i2)), i2;
            }
            get() {
              return this.segments;
            }
            destroy() {
              for (const t2 of this.segments)
                for (const e2 in t2.vaos)
                  t2.vaos[e2].destroy();
            }
            static simpleSegment(t2, e2, r3, n2) {
              return new $a2([{ vertexOffset: t2, primitiveOffset: e2, vertexLength: r3, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
            }
          }
          $a2.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, oi2("SegmentVector", $a2);
          var Oa2 = 8192;
          const qa2 = Math.pow(2, 14) - 1, Na2 = -qa2 - 1;
          function ja2(t2) {
            const e2 = Oa2 / t2.extent, r3 = t2.loadGeometry();
            for (let t3 = 0; t3 < r3.length; t3++) {
              const n2 = r3[t3];
              for (let t4 = 0; t4 < n2.length; t4++) {
                const r4 = n2[t4], i2 = Math.round(r4.x * e2), s2 = Math.round(r4.y * e2);
                r4.x = y(i2, Na2, qa2), r4.y = y(s2, Na2, qa2), (i2 < r4.x || i2 > r4.x + 1 || s2 < r4.y || s2 > r4.y + 1) && B("Geometry exceeds allowed extent, reduce your vector tile buffer size");
              }
            }
            return r3;
          }
          function Ga2(t2, e2) {
            return { type: t2.type, id: t2.id, properties: t2.properties, geometry: e2 ? ja2(t2) : [] };
          }
          function Za2(t2, e2, r3, n2, i2) {
            t2.emplaceBack(2 * e2 + (n2 + 1) / 2, 2 * r3 + (i2 + 1) / 2);
          }
          class Xa2 {
            constructor(t2) {
              this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new zs(), this.indexArray = new $s2(), this.segments = new $a2(), this.programConfigurations = new Ea2(t2.layers, t2.zoom), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
            }
            populate(t2, e2, r3) {
              const n2 = this.layers[0], i2 = [];
              let s2 = null;
              n2.type === "circle" && (s2 = n2.layout.get("circle-sort-key"));
              for (const { feature: e3, id: n3, index: a2, sourceLayerIndex: o2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, l2 = Ga2(e3, t3);
                if (!this.layers[0]._featureFilter.filter(new as2(this.zoom), l2, r3))
                  continue;
                const u2 = s2 ? s2.evaluate(l2, {}, r3) : void 0, c2 = { id: n3, properties: e3.properties, type: e3.type, sourceLayerIndex: o2, index: a2, geometry: t3 ? l2.geometry : ja2(e3), patterns: {}, sortKey: u2 };
                i2.push(c2);
              }
              s2 && i2.sort((t3, e3) => t3.sortKey - e3.sortKey);
              for (const n3 of i2) {
                const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3, o2 = t2[s3].feature;
                this.addFeature(n3, i3, s3, r3), e2.featureIndex.insert(o2, i3, s3, a2, this.index);
              }
            }
            update(t2, e2, r3) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r3);
            }
            isEmpty() {
              return this.layoutVertexArray.length === 0;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Ua2), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            addFeature(t2, e2, r3, n2) {
              for (const r4 of e2)
                for (const e3 of r4) {
                  const r5 = e3.x, n3 = e3.y;
                  if (r5 < 0 || r5 >= Oa2 || n3 < 0 || n3 >= Oa2)
                    continue;
                  const i2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t2.sortKey), s2 = i2.vertexLength;
                  Za2(this.layoutVertexArray, r5, n3, -1, -1), Za2(this.layoutVertexArray, r5, n3, 1, -1), Za2(this.layoutVertexArray, r5, n3, 1, 1), Za2(this.layoutVertexArray, r5, n3, -1, 1), this.indexArray.emplaceBack(s2, s2 + 1, s2 + 2), this.indexArray.emplaceBack(s2, s2 + 3, s2 + 2), i2.vertexLength += 4, i2.primitiveLength += 2;
                }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r3, {}, n2);
            }
          }
          function Ka2(t2, e2) {
            for (let r3 = 0; r3 < t2.length; r3++)
              if (no2(e2, t2[r3]))
                return true;
            for (let r3 = 0; r3 < e2.length; r3++)
              if (no2(t2, e2[r3]))
                return true;
            return !!Wa2(t2, e2);
          }
          function Ha2(t2, e2, r3) {
            return !!no2(t2, e2) || !!to2(e2, t2, r3);
          }
          function Ya2(t2, e2) {
            if (t2.length === 1)
              return ro2(e2, t2[0]);
            for (let r3 = 0; r3 < e2.length; r3++) {
              const n2 = e2[r3];
              for (let e3 = 0; e3 < n2.length; e3++)
                if (no2(t2, n2[e3]))
                  return true;
            }
            for (let r3 = 0; r3 < t2.length; r3++)
              if (ro2(e2, t2[r3]))
                return true;
            for (let r3 = 0; r3 < e2.length; r3++)
              if (Wa2(t2, e2[r3]))
                return true;
            return false;
          }
          function Ja2(t2, e2, r3) {
            if (t2.length > 1) {
              if (Wa2(t2, e2))
                return true;
              for (let n2 = 0; n2 < e2.length; n2++)
                if (to2(e2[n2], t2, r3))
                  return true;
            }
            for (let n2 = 0; n2 < t2.length; n2++)
              if (to2(t2[n2], e2, r3))
                return true;
            return false;
          }
          function Wa2(t2, e2) {
            if (t2.length === 0 || e2.length === 0)
              return false;
            for (let r3 = 0; r3 < t2.length - 1; r3++) {
              const n2 = t2[r3], i2 = t2[r3 + 1];
              for (let t3 = 0; t3 < e2.length - 1; t3++)
                if (Qa2(n2, i2, e2[t3], e2[t3 + 1]))
                  return true;
            }
            return false;
          }
          function Qa2(t2, e2, r3, n2) {
            return C(t2, r3, n2) !== C(e2, r3, n2) && C(t2, e2, r3) !== C(t2, e2, n2);
          }
          function to2(t2, e2, r3) {
            const n2 = r3 * r3;
            if (e2.length === 1)
              return t2.distSqr(e2[0]) < n2;
            for (let r4 = 1; r4 < e2.length; r4++)
              if (eo2(t2, e2[r4 - 1], e2[r4]) < n2)
                return true;
            return false;
          }
          function eo2(t2, e2, r3) {
            const n2 = e2.distSqr(r3);
            if (n2 === 0)
              return t2.distSqr(e2);
            const i2 = ((t2.x - e2.x) * (r3.x - e2.x) + (t2.y - e2.y) * (r3.y - e2.y)) / n2;
            return t2.distSqr(i2 < 0 ? e2 : i2 > 1 ? r3 : r3.sub(e2)._mult(i2)._add(e2));
          }
          function ro2(t2, e2) {
            let r3, n2, i2, s2 = false;
            for (let a2 = 0; a2 < t2.length; a2++) {
              r3 = t2[a2];
              for (let t3 = 0, a3 = r3.length - 1; t3 < r3.length; a3 = t3++)
                n2 = r3[t3], i2 = r3[a3], n2.y > e2.y != i2.y > e2.y && e2.x < (i2.x - n2.x) * (e2.y - n2.y) / (i2.y - n2.y) + n2.x && (s2 = !s2);
            }
            return s2;
          }
          function no2(t2, e2) {
            let r3 = false;
            for (let n2 = 0, i2 = t2.length - 1; n2 < t2.length; i2 = n2++) {
              const s2 = t2[n2], a2 = t2[i2];
              s2.y > e2.y != a2.y > e2.y && e2.x < (a2.x - s2.x) * (e2.y - s2.y) / (a2.y - s2.y) + s2.x && (r3 = !r3);
            }
            return r3;
          }
          function io2(t2, e2, r3, n2, s2) {
            for (const i2 of t2)
              if (e2 <= i2.x && r3 <= i2.y && n2 >= i2.x && s2 >= i2.y)
                return true;
            const a2 = [new i(e2, r3), new i(e2, s2), new i(n2, s2), new i(n2, r3)];
            if (t2.length > 2) {
              for (const e3 of a2)
                if (no2(t2, e3))
                  return true;
            }
            for (let e3 = 0; e3 < t2.length - 1; e3++)
              if (so2(t2[e3], t2[e3 + 1], a2))
                return true;
            return false;
          }
          function so2(t2, e2, r3) {
            const n2 = r3[0], i2 = r3[2];
            if (t2.x < n2.x && e2.x < n2.x || t2.x > i2.x && e2.x > i2.x || t2.y < n2.y && e2.y < n2.y || t2.y > i2.y && e2.y > i2.y)
              return false;
            const s2 = C(t2, e2, r3[0]);
            return s2 !== C(t2, e2, r3[1]) || s2 !== C(t2, e2, r3[2]) || s2 !== C(t2, e2, r3[3]);
          }
          function ao2(t2, e2, r3) {
            const n2 = e2.paint.get(t2).value;
            return n2.kind === "constant" ? n2.value : r3.programConfigurations.get(e2.id).getMaxValue(t2);
          }
          function oo2(t2) {
            return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
          }
          function lo2(t2, e2, r3, n2, s2) {
            if (!e2[0] && !e2[1])
              return t2;
            const a2 = i.convert(e2)._mult(s2);
            r3 === "viewport" && a2._rotate(-n2);
            const o2 = [];
            for (let e3 = 0; e3 < t2.length; e3++)
              o2.push(t2[e3].sub(a2));
            return o2;
          }
          function uo(t2, e2, r3, n2) {
            const s2 = i.convert(t2)._mult(n2);
            return e2 === "viewport" && s2._rotate(-r3), s2;
          }
          oi2("CircleBucket", Xa2, { omit: ["layers"] });
          const co = new bs2({ "circle-sort-key": new ms2(Rt.layout_circle["circle-sort-key"]) });
          var ho = { paint: new bs2({ "circle-radius": new ms2(Rt.paint_circle["circle-radius"]), "circle-color": new ms2(Rt.paint_circle["circle-color"]), "circle-blur": new ms2(Rt.paint_circle["circle-blur"]), "circle-opacity": new ms2(Rt.paint_circle["circle-opacity"]), "circle-translate": new ys2(Rt.paint_circle["circle-translate"]), "circle-translate-anchor": new ys2(Rt.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new ys2(Rt.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new ys2(Rt.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new ms2(Rt.paint_circle["circle-stroke-width"]), "circle-stroke-color": new ms2(Rt.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new ms2(Rt.paint_circle["circle-stroke-opacity"]) }), layout: co }, po2 = typeof Float32Array != "undefined" ? Float32Array : Array;
          function fo() {
            var t2 = new po2(9);
            return po2 != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[0] = 1, t2[4] = 1, t2[8] = 1, t2;
          }
          function yo2(t2) {
            return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
          }
          function mo2(t2, e2, r3) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], d2 = e2[10], f2 = e2[11], y2 = e2[12], m2 = e2[13], g2 = e2[14], x3 = e2[15], v2 = r3[0], b2 = r3[1], w3 = r3[2], _2 = r3[3];
            return t2[0] = v2 * n2 + b2 * o2 + w3 * h2 + _2 * y2, t2[1] = v2 * i2 + b2 * l2 + w3 * p2 + _2 * m2, t2[2] = v2 * s2 + b2 * u2 + w3 * d2 + _2 * g2, t2[3] = v2 * a2 + b2 * c2 + w3 * f2 + _2 * x3, t2[4] = (v2 = r3[4]) * n2 + (b2 = r3[5]) * o2 + (w3 = r3[6]) * h2 + (_2 = r3[7]) * y2, t2[5] = v2 * i2 + b2 * l2 + w3 * p2 + _2 * m2, t2[6] = v2 * s2 + b2 * u2 + w3 * d2 + _2 * g2, t2[7] = v2 * a2 + b2 * c2 + w3 * f2 + _2 * x3, t2[8] = (v2 = r3[8]) * n2 + (b2 = r3[9]) * o2 + (w3 = r3[10]) * h2 + (_2 = r3[11]) * y2, t2[9] = v2 * i2 + b2 * l2 + w3 * p2 + _2 * m2, t2[10] = v2 * s2 + b2 * u2 + w3 * d2 + _2 * g2, t2[11] = v2 * a2 + b2 * c2 + w3 * f2 + _2 * x3, t2[12] = (v2 = r3[12]) * n2 + (b2 = r3[13]) * o2 + (w3 = r3[14]) * h2 + (_2 = r3[15]) * y2, t2[13] = v2 * i2 + b2 * l2 + w3 * p2 + _2 * m2, t2[14] = v2 * s2 + b2 * u2 + w3 * d2 + _2 * g2, t2[15] = v2 * a2 + b2 * c2 + w3 * f2 + _2 * x3, t2;
          }
          Math.hypot || (Math.hypot = function() {
            for (var t2 = 0, e2 = arguments.length; e2--; )
              t2 += arguments[e2] * arguments[e2];
            return Math.sqrt(t2);
          });
          var go2 = mo2;
          function xo2() {
            var t2 = new po2(3);
            return po2 != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2;
          }
          function vo2(t2) {
            return Math.hypot(t2[0], t2[1], t2[2]);
          }
          function bo2(t2, e2, r3) {
            var n2 = new po2(3);
            return n2[0] = t2, n2[1] = e2, n2[2] = r3, n2;
          }
          function wo2(t2, e2, r3) {
            return t2[0] = e2[0] - r3[0], t2[1] = e2[1] - r3[1], t2[2] = e2[2] - r3[2], t2;
          }
          function _o2(t2, e2, r3) {
            return t2[0] = e2[0] * r3[0], t2[1] = e2[1] * r3[1], t2[2] = e2[2] * r3[2], t2;
          }
          function ko2(t2, e2, r3, n2) {
            return t2[0] = e2[0] + r3[0] * n2, t2[1] = e2[1] + r3[1] * n2, t2[2] = e2[2] + r3[2] * n2, t2;
          }
          function Ao2(t2, e2) {
            var r3 = e2[0], n2 = e2[1], i2 = e2[2], s2 = r3 * r3 + n2 * n2 + i2 * i2;
            return s2 > 0 && (s2 = 1 / Math.sqrt(s2)), t2[0] = e2[0] * s2, t2[1] = e2[1] * s2, t2[2] = e2[2] * s2, t2;
          }
          function So2(t2, e2, r3) {
            var n2 = r3[0], i2 = r3[1], s2 = r3[2], a2 = e2[0], o2 = e2[1], l2 = e2[2], u2 = i2 * l2 - s2 * o2, c2 = s2 * a2 - n2 * l2, h2 = n2 * o2 - i2 * a2, p2 = i2 * h2 - s2 * c2, d2 = s2 * u2 - n2 * h2, f2 = n2 * c2 - i2 * u2, y2 = 2 * r3[3];
            return c2 *= y2, h2 *= y2, d2 *= 2, f2 *= 2, t2[0] = a2 + (u2 *= y2) + (p2 *= 2), t2[1] = o2 + c2 + d2, t2[2] = l2 + h2 + f2, t2;
          }
          var Io2, zo2 = wo2, To2 = _o2, Mo2 = vo2;
          function Eo2(t2, e2, r3) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3];
            return t2[0] = r3[0] * n2 + r3[4] * i2 + r3[8] * s2 + r3[12] * a2, t2[1] = r3[1] * n2 + r3[5] * i2 + r3[9] * s2 + r3[13] * a2, t2[2] = r3[2] * n2 + r3[6] * i2 + r3[10] * s2 + r3[14] * a2, t2[3] = r3[3] * n2 + r3[7] * i2 + r3[11] * s2 + r3[15] * a2, t2;
          }
          function Bo2() {
            var t2 = new po2(4);
            return po2 != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2[3] = 1, t2;
          }
          function Co2(t2) {
            return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2;
          }
          function Po2(t2, e2, r3) {
            r3 *= 0.5;
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = Math.sin(r3), l2 = Math.cos(r3);
            return t2[0] = n2 * l2 + a2 * o2, t2[1] = i2 * l2 + s2 * o2, t2[2] = s2 * l2 - i2 * o2, t2[3] = a2 * l2 - n2 * o2, t2;
          }
          function Do2(t2, e2, r3) {
            const n2 = Eo2([], [t2.x, t2.y, e2, 1], r3);
            return new i(n2[0] / n2[3], n2[1] / n2[3]);
          }
          xo2(), Io2 = new po2(4), po2 != Float32Array && (Io2[0] = 0, Io2[1] = 0, Io2[2] = 0, Io2[3] = 0), xo2(), bo2(1, 0, 0), bo2(0, 1, 0), Bo2(), Bo2(), fo();
          const Vo2 = bo2(0, 0, 0), Lo2 = bo2(0, 0, 1);
          function Fo2(t2, e2) {
            const r3 = xo2();
            return Vo2[2] = e2, t2.intersectsPlane(Vo2, Lo2, r3), new i(r3[0], r3[1]);
          }
          class Ro2 extends Xa2 {
          }
          function Uo2(t2, { width: e2, height: r3 }, n2, i2) {
            if (i2) {
              if (i2 instanceof Uint8ClampedArray)
                i2 = new Uint8Array(i2.buffer);
              else if (i2.length !== e2 * r3 * n2)
                throw new RangeError("mismatched image size");
            } else
              i2 = new Uint8Array(e2 * r3 * n2);
            return t2.width = e2, t2.height = r3, t2.data = i2, t2;
          }
          function $o2(t2, { width: e2, height: r3 }, n2) {
            if (e2 === t2.width && r3 === t2.height)
              return;
            const i2 = Uo2({}, { width: e2, height: r3 }, n2);
            Oo2(t2, i2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, e2), height: Math.min(t2.height, r3) }, n2), t2.width = e2, t2.height = r3, t2.data = i2.data;
          }
          function Oo2(t2, e2, r3, n2, i2, s2) {
            if (i2.width === 0 || i2.height === 0)
              return e2;
            if (i2.width > t2.width || i2.height > t2.height || r3.x > t2.width - i2.width || r3.y > t2.height - i2.height)
              throw new RangeError("out of range source coordinates for image copy");
            if (i2.width > e2.width || i2.height > e2.height || n2.x > e2.width - i2.width || n2.y > e2.height - i2.height)
              throw new RangeError("out of range destination coordinates for image copy");
            const a2 = t2.data, o2 = e2.data;
            for (let l2 = 0; l2 < i2.height; l2++) {
              const u2 = ((r3.y + l2) * t2.width + r3.x) * s2, c2 = ((n2.y + l2) * e2.width + n2.x) * s2;
              for (let t3 = 0; t3 < i2.width * s2; t3++)
                o2[c2 + t3] = a2[u2 + t3];
            }
            return e2;
          }
          oi2("HeatmapBucket", Ro2, { omit: ["layers"] });
          class qo2 {
            constructor(t2, e2) {
              Uo2(this, t2, 1, e2);
            }
            resize(t2) {
              $o2(this, t2, 1);
            }
            clone() {
              return new qo2({ width: this.width, height: this.height }, new Uint8Array(this.data));
            }
            static copy(t2, e2, r3, n2, i2) {
              Oo2(t2, e2, r3, n2, i2, 1);
            }
          }
          class No2 {
            constructor(t2, e2) {
              Uo2(this, t2, 4, e2);
            }
            resize(t2) {
              $o2(this, t2, 4);
            }
            replace(t2, e2) {
              e2 ? this.data.set(t2) : this.data = t2 instanceof Uint8ClampedArray ? new Uint8Array(t2.buffer) : t2;
            }
            clone() {
              return new No2({ width: this.width, height: this.height }, new Uint8Array(this.data));
            }
            static copy(t2, e2, r3, n2, i2) {
              Oo2(t2, e2, r3, n2, i2, 4);
            }
          }
          oi2("AlphaImage", qo2), oi2("RGBAImage", No2);
          var jo2 = { paint: new bs2({ "heatmap-radius": new ms2(Rt.paint_heatmap["heatmap-radius"]), "heatmap-weight": new ms2(Rt.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new ys2(Rt.paint_heatmap["heatmap-intensity"]), "heatmap-color": new vs2(Rt.paint_heatmap["heatmap-color"]), "heatmap-opacity": new ys2(Rt.paint_heatmap["heatmap-opacity"]) }) };
          function Go2(t2) {
            const e2 = {}, r3 = t2.resolution || 256, n2 = t2.clips ? t2.clips.length : 1, i2 = t2.image || new No2({ width: r3, height: n2 }), s2 = (r4, n3, s3) => {
              e2[t2.evaluationKey] = s3;
              const a2 = t2.expression.evaluate(e2);
              i2.data[r4 + n3 + 0] = Math.floor(255 * a2.r / a2.a), i2.data[r4 + n3 + 1] = Math.floor(255 * a2.g / a2.a), i2.data[r4 + n3 + 2] = Math.floor(255 * a2.b / a2.a), i2.data[r4 + n3 + 3] = Math.floor(255 * a2.a);
            };
            if (t2.clips)
              for (let e3 = 0, i3 = 0; e3 < n2; ++e3, i3 += 4 * r3)
                for (let n3 = 0, a2 = 0; n3 < r3; n3++, a2 += 4) {
                  const o2 = n3 / (r3 - 1), { start: l2, end: u2 } = t2.clips[e3];
                  s2(i3, a2, l2 * (1 - o2) + u2 * o2);
                }
            else
              for (let t3 = 0, e3 = 0; t3 < r3; t3++, e3 += 4)
                s2(0, e3, t3 / (r3 - 1));
            return i2;
          }
          var Zo2 = { paint: new bs2({ "hillshade-illumination-direction": new ys2(Rt.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new ys2(Rt.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new ys2(Rt.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new ys2(Rt.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new ys2(Rt.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new ys2(Rt.paint_hillshade["hillshade-accent-color"]) }) };
          const Xo2 = Ss([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Ko2 } = Xo2;
          var Ho2 = Jo2, Yo2 = Jo2;
          function Jo2(t2, e2, r3) {
            r3 = r3 || 2;
            var n2, i2, s2, a2, o2, l2, u2, c2 = e2 && e2.length, h2 = c2 ? e2[0] * r3 : t2.length, p2 = Wo2(t2, 0, h2, r3, true), d2 = [];
            if (!p2 || p2.next === p2.prev)
              return d2;
            if (c2 && (p2 = function(t3, e3, r4, n3) {
              var i3, s3, a3, o3 = [];
              for (i3 = 0, s3 = e3.length; i3 < s3; i3++)
                (a3 = Wo2(t3, e3[i3] * n3, i3 < s3 - 1 ? e3[i3 + 1] * n3 : t3.length, n3, false)) === a3.next && (a3.steiner = true), o3.push(ul2(a3));
              for (o3.sort(sl2), i3 = 0; i3 < o3.length; i3++)
                al2(o3[i3], r4), r4 = Qo2(r4, r4.next);
              return r4;
            }(t2, e2, p2, r3)), t2.length > 80 * r3) {
              n2 = s2 = t2[0], i2 = a2 = t2[1];
              for (var f2 = r3; f2 < h2; f2 += r3)
                (o2 = t2[f2]) < n2 && (n2 = o2), (l2 = t2[f2 + 1]) < i2 && (i2 = l2), o2 > s2 && (s2 = o2), l2 > a2 && (a2 = l2);
              u2 = (u2 = Math.max(s2 - n2, a2 - i2)) !== 0 ? 1 / u2 : 0;
            }
            return tl2(p2, d2, r3, n2, i2, u2), d2;
          }
          function Wo2(t2, e2, r3, n2, i2) {
            var s2, a2;
            if (i2 === _l2(t2, e2, r3, n2) > 0)
              for (s2 = e2; s2 < r3; s2 += n2)
                a2 = vl2(s2, t2[s2], t2[s2 + 1], a2);
            else
              for (s2 = r3 - n2; s2 >= e2; s2 -= n2)
                a2 = vl2(s2, t2[s2], t2[s2 + 1], a2);
            return a2 && dl2(a2, a2.next) && (bl2(a2), a2 = a2.next), a2;
          }
          function Qo2(t2, e2) {
            if (!t2)
              return t2;
            e2 || (e2 = t2);
            var r3, n2 = t2;
            do {
              if (r3 = false, n2.steiner || !dl2(n2, n2.next) && pl2(n2.prev, n2, n2.next) !== 0)
                n2 = n2.next;
              else {
                if (bl2(n2), (n2 = e2 = n2.prev) === n2.next)
                  break;
                r3 = true;
              }
            } while (r3 || n2 !== e2);
            return e2;
          }
          function tl2(t2, e2, r3, n2, i2, s2, a2) {
            if (t2) {
              !a2 && s2 && function(t3, e3, r4, n3) {
                var i3 = t3;
                do {
                  i3.z === null && (i3.z = ll2(i3.x, i3.y, e3, r4, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
                } while (i3 !== t3);
                i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
                  var e4, r5, n4, i4, s3, a3, o3, l3, u3 = 1;
                  do {
                    for (r5 = t4, t4 = null, s3 = null, a3 = 0; r5; ) {
                      for (a3++, n4 = r5, o3 = 0, e4 = 0; e4 < u3 && (o3++, n4 = n4.nextZ); e4++)
                        ;
                      for (l3 = u3; o3 > 0 || l3 > 0 && n4; )
                        o3 !== 0 && (l3 === 0 || !n4 || r5.z <= n4.z) ? (i4 = r5, r5 = r5.nextZ, o3--) : (i4 = n4, n4 = n4.nextZ, l3--), s3 ? s3.nextZ = i4 : t4 = i4, i4.prevZ = s3, s3 = i4;
                      r5 = n4;
                    }
                    s3.nextZ = null, u3 *= 2;
                  } while (a3 > 1);
                }(i3);
              }(t2, n2, i2, s2);
              for (var o2, l2, u2 = t2; t2.prev !== t2.next; )
                if (o2 = t2.prev, l2 = t2.next, s2 ? rl2(t2, n2, i2, s2) : el2(t2))
                  e2.push(o2.i / r3), e2.push(t2.i / r3), e2.push(l2.i / r3), bl2(t2), t2 = l2.next, u2 = l2.next;
                else if ((t2 = l2) === u2) {
                  a2 ? a2 === 1 ? tl2(t2 = nl2(Qo2(t2), e2, r3), e2, r3, n2, i2, s2, 2) : a2 === 2 && il2(t2, e2, r3, n2, i2, s2) : tl2(Qo2(t2), e2, r3, n2, i2, s2, 1);
                  break;
                }
            }
          }
          function el2(t2) {
            var e2 = t2.prev, r3 = t2, n2 = t2.next;
            if (pl2(e2, r3, n2) >= 0)
              return false;
            for (var i2 = t2.next.next; i2 !== t2.prev; ) {
              if (cl2(e2.x, e2.y, r3.x, r3.y, n2.x, n2.y, i2.x, i2.y) && pl2(i2.prev, i2, i2.next) >= 0)
                return false;
              i2 = i2.next;
            }
            return true;
          }
          function rl2(t2, e2, r3, n2) {
            var i2 = t2.prev, s2 = t2, a2 = t2.next;
            if (pl2(i2, s2, a2) >= 0)
              return false;
            for (var o2 = i2.x > s2.x ? i2.x > a2.x ? i2.x : a2.x : s2.x > a2.x ? s2.x : a2.x, l2 = i2.y > s2.y ? i2.y > a2.y ? i2.y : a2.y : s2.y > a2.y ? s2.y : a2.y, u2 = ll2(i2.x < s2.x ? i2.x < a2.x ? i2.x : a2.x : s2.x < a2.x ? s2.x : a2.x, i2.y < s2.y ? i2.y < a2.y ? i2.y : a2.y : s2.y < a2.y ? s2.y : a2.y, e2, r3, n2), c2 = ll2(o2, l2, e2, r3, n2), h2 = t2.prevZ, p2 = t2.nextZ; h2 && h2.z >= u2 && p2 && p2.z <= c2; ) {
              if (h2 !== t2.prev && h2 !== t2.next && cl2(i2.x, i2.y, s2.x, s2.y, a2.x, a2.y, h2.x, h2.y) && pl2(h2.prev, h2, h2.next) >= 0)
                return false;
              if (h2 = h2.prevZ, p2 !== t2.prev && p2 !== t2.next && cl2(i2.x, i2.y, s2.x, s2.y, a2.x, a2.y, p2.x, p2.y) && pl2(p2.prev, p2, p2.next) >= 0)
                return false;
              p2 = p2.nextZ;
            }
            for (; h2 && h2.z >= u2; ) {
              if (h2 !== t2.prev && h2 !== t2.next && cl2(i2.x, i2.y, s2.x, s2.y, a2.x, a2.y, h2.x, h2.y) && pl2(h2.prev, h2, h2.next) >= 0)
                return false;
              h2 = h2.prevZ;
            }
            for (; p2 && p2.z <= c2; ) {
              if (p2 !== t2.prev && p2 !== t2.next && cl2(i2.x, i2.y, s2.x, s2.y, a2.x, a2.y, p2.x, p2.y) && pl2(p2.prev, p2, p2.next) >= 0)
                return false;
              p2 = p2.nextZ;
            }
            return true;
          }
          function nl2(t2, e2, r3) {
            var n2 = t2;
            do {
              var i2 = n2.prev, s2 = n2.next.next;
              !dl2(i2, s2) && fl2(i2, n2, n2.next, s2) && gl2(i2, s2) && gl2(s2, i2) && (e2.push(i2.i / r3), e2.push(n2.i / r3), e2.push(s2.i / r3), bl2(n2), bl2(n2.next), n2 = t2 = s2), n2 = n2.next;
            } while (n2 !== t2);
            return Qo2(n2);
          }
          function il2(t2, e2, r3, n2, i2, s2) {
            var a2 = t2;
            do {
              for (var o2 = a2.next.next; o2 !== a2.prev; ) {
                if (a2.i !== o2.i && hl2(a2, o2)) {
                  var l2 = xl(a2, o2);
                  return a2 = Qo2(a2, a2.next), l2 = Qo2(l2, l2.next), tl2(a2, e2, r3, n2, i2, s2), void tl2(l2, e2, r3, n2, i2, s2);
                }
                o2 = o2.next;
              }
              a2 = a2.next;
            } while (a2 !== t2);
          }
          function sl2(t2, e2) {
            return t2.x - e2.x;
          }
          function al2(t2, e2) {
            if (e2 = function(t3, e3) {
              var r4, n2 = e3, i2 = t3.x, s2 = t3.y, a2 = -1 / 0;
              do {
                if (s2 <= n2.y && s2 >= n2.next.y && n2.next.y !== n2.y) {
                  var o2 = n2.x + (s2 - n2.y) * (n2.next.x - n2.x) / (n2.next.y - n2.y);
                  if (o2 <= i2 && o2 > a2) {
                    if (a2 = o2, o2 === i2) {
                      if (s2 === n2.y)
                        return n2;
                      if (s2 === n2.next.y)
                        return n2.next;
                    }
                    r4 = n2.x < n2.next.x ? n2 : n2.next;
                  }
                }
                n2 = n2.next;
              } while (n2 !== e3);
              if (!r4)
                return null;
              if (i2 === a2)
                return r4;
              var l2, u2 = r4, c2 = r4.x, h2 = r4.y, p2 = 1 / 0;
              n2 = r4;
              do {
                i2 >= n2.x && n2.x >= c2 && i2 !== n2.x && cl2(s2 < h2 ? i2 : a2, s2, c2, h2, s2 < h2 ? a2 : i2, s2, n2.x, n2.y) && (l2 = Math.abs(s2 - n2.y) / (i2 - n2.x), gl2(n2, t3) && (l2 < p2 || l2 === p2 && (n2.x > r4.x || n2.x === r4.x && ol2(r4, n2))) && (r4 = n2, p2 = l2)), n2 = n2.next;
              } while (n2 !== u2);
              return r4;
            }(t2, e2)) {
              var r3 = xl(e2, t2);
              Qo2(e2, e2.next), Qo2(r3, r3.next);
            }
          }
          function ol2(t2, e2) {
            return pl2(t2.prev, t2, e2.prev) < 0 && pl2(e2.next, t2, t2.next) < 0;
          }
          function ll2(t2, e2, r3, n2, i2) {
            return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = 32767 * (t2 - r3) * i2) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = 32767 * (e2 - n2) * i2) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
          }
          function ul2(t2) {
            var e2 = t2, r3 = t2;
            do {
              (e2.x < r3.x || e2.x === r3.x && e2.y < r3.y) && (r3 = e2), e2 = e2.next;
            } while (e2 !== t2);
            return r3;
          }
          function cl2(t2, e2, r3, n2, i2, s2, a2, o2) {
            return (i2 - a2) * (e2 - o2) - (t2 - a2) * (s2 - o2) >= 0 && (t2 - a2) * (n2 - o2) - (r3 - a2) * (e2 - o2) >= 0 && (r3 - a2) * (s2 - o2) - (i2 - a2) * (n2 - o2) >= 0;
          }
          function hl2(t2, e2) {
            return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
              var r3 = t3;
              do {
                if (r3.i !== t3.i && r3.next.i !== t3.i && r3.i !== e3.i && r3.next.i !== e3.i && fl2(r3, r3.next, t3, e3))
                  return true;
                r3 = r3.next;
              } while (r3 !== t3);
              return false;
            }(t2, e2) && (gl2(t2, e2) && gl2(e2, t2) && function(t3, e3) {
              var r3 = t3, n2 = false, i2 = (t3.x + e3.x) / 2, s2 = (t3.y + e3.y) / 2;
              do {
                r3.y > s2 != r3.next.y > s2 && r3.next.y !== r3.y && i2 < (r3.next.x - r3.x) * (s2 - r3.y) / (r3.next.y - r3.y) + r3.x && (n2 = !n2), r3 = r3.next;
              } while (r3 !== t3);
              return n2;
            }(t2, e2) && (pl2(t2.prev, t2, e2.prev) || pl2(t2, e2.prev, e2)) || dl2(t2, e2) && pl2(t2.prev, t2, t2.next) > 0 && pl2(e2.prev, e2, e2.next) > 0);
          }
          function pl2(t2, e2, r3) {
            return (e2.y - t2.y) * (r3.x - e2.x) - (e2.x - t2.x) * (r3.y - e2.y);
          }
          function dl2(t2, e2) {
            return t2.x === e2.x && t2.y === e2.y;
          }
          function fl2(t2, e2, r3, n2) {
            var i2 = ml2(pl2(t2, e2, r3)), s2 = ml2(pl2(t2, e2, n2)), a2 = ml2(pl2(r3, n2, t2)), o2 = ml2(pl2(r3, n2, e2));
            return i2 !== s2 && a2 !== o2 || !(i2 !== 0 || !yl(t2, r3, e2)) || !(s2 !== 0 || !yl(t2, n2, e2)) || !(a2 !== 0 || !yl(r3, t2, n2)) || !(o2 !== 0 || !yl(r3, e2, n2));
          }
          function yl(t2, e2, r3) {
            return e2.x <= Math.max(t2.x, r3.x) && e2.x >= Math.min(t2.x, r3.x) && e2.y <= Math.max(t2.y, r3.y) && e2.y >= Math.min(t2.y, r3.y);
          }
          function ml2(t2) {
            return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
          }
          function gl2(t2, e2) {
            return pl2(t2.prev, t2, t2.next) < 0 ? pl2(t2, e2, t2.next) >= 0 && pl2(t2, t2.prev, e2) >= 0 : pl2(t2, e2, t2.prev) < 0 || pl2(t2, t2.next, e2) < 0;
          }
          function xl(t2, e2) {
            var r3 = new wl2(t2.i, t2.x, t2.y), n2 = new wl2(e2.i, e2.x, e2.y), i2 = t2.next, s2 = e2.prev;
            return t2.next = e2, e2.prev = t2, r3.next = i2, i2.prev = r3, n2.next = r3, r3.prev = n2, s2.next = n2, n2.prev = s2, n2;
          }
          function vl2(t2, e2, r3, n2) {
            var i2 = new wl2(t2, e2, r3);
            return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
          }
          function bl2(t2) {
            t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
          }
          function wl2(t2, e2, r3) {
            this.i = t2, this.x = e2, this.y = r3, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
          }
          function _l2(t2, e2, r3, n2) {
            for (var i2 = 0, s2 = e2, a2 = r3 - n2; s2 < r3; s2 += n2)
              i2 += (t2[a2] - t2[s2]) * (t2[s2 + 1] + t2[a2 + 1]), a2 = s2;
            return i2;
          }
          function kl2(t2, e2, r3, n2, i2) {
            Al2(t2, e2, r3 || 0, n2 || t2.length - 1, i2 || Il2);
          }
          function Al2(t2, e2, r3, n2, i2) {
            for (; n2 > r3; ) {
              if (n2 - r3 > 600) {
                var s2 = n2 - r3 + 1, a2 = e2 - r3 + 1, o2 = Math.log(s2), l2 = 0.5 * Math.exp(2 * o2 / 3), u2 = 0.5 * Math.sqrt(o2 * l2 * (s2 - l2) / s2) * (a2 - s2 / 2 < 0 ? -1 : 1);
                Al2(t2, e2, Math.max(r3, Math.floor(e2 - a2 * l2 / s2 + u2)), Math.min(n2, Math.floor(e2 + (s2 - a2) * l2 / s2 + u2)), i2);
              }
              var c2 = t2[e2], h2 = r3, p2 = n2;
              for (Sl2(t2, r3, e2), i2(t2[n2], c2) > 0 && Sl2(t2, r3, n2); h2 < p2; ) {
                for (Sl2(t2, h2, p2), h2++, p2--; i2(t2[h2], c2) < 0; )
                  h2++;
                for (; i2(t2[p2], c2) > 0; )
                  p2--;
              }
              i2(t2[r3], c2) === 0 ? Sl2(t2, r3, p2) : Sl2(t2, ++p2, n2), p2 <= e2 && (r3 = p2 + 1), e2 <= p2 && (n2 = p2 - 1);
            }
          }
          function Sl2(t2, e2, r3) {
            var n2 = t2[e2];
            t2[e2] = t2[r3], t2[r3] = n2;
          }
          function Il2(t2, e2) {
            return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
          }
          function zl2(t2, e2) {
            const r3 = t2.length;
            if (r3 <= 1)
              return [t2];
            const n2 = [];
            let i2, s2;
            for (let e3 = 0; e3 < r3; e3++) {
              const r4 = P(t2[e3]);
              r4 !== 0 && (t2[e3].area = Math.abs(r4), s2 === void 0 && (s2 = r4 < 0), s2 === r4 < 0 ? (i2 && n2.push(i2), i2 = [t2[e3]]) : i2.push(t2[e3]));
            }
            if (i2 && n2.push(i2), e2 > 1)
              for (let t3 = 0; t3 < n2.length; t3++)
                n2[t3].length <= e2 || (kl2(n2[t3], e2, 1, n2[t3].length - 1, Tl2), n2[t3] = n2[t3].slice(0, e2));
            return n2;
          }
          function Tl2(t2, e2) {
            return e2.area - t2.area;
          }
          function Ml2(t2, e2, r3) {
            const n2 = r3.patternDependencies;
            let i2 = false;
            for (const r4 of e2) {
              const e3 = r4.paint.get(`${t2}-pattern`);
              e3.isConstant() || (i2 = true);
              const s2 = e3.constantOr(null);
              s2 && (i2 = true, n2[s2.to] = true, n2[s2.from] = true);
            }
            return i2;
          }
          function El2(t2, e2, r3, n2, i2) {
            const s2 = i2.patternDependencies;
            for (const a2 of e2) {
              const e3 = a2.paint.get(`${t2}-pattern`).value;
              if (e3.kind !== "constant") {
                let t3 = e3.evaluate({ zoom: n2 - 1 }, r3, {}, i2.availableImages), o2 = e3.evaluate({ zoom: n2 }, r3, {}, i2.availableImages), l2 = e3.evaluate({ zoom: n2 + 1 }, r3, {}, i2.availableImages);
                t3 = t3 && t3.name ? t3.name : t3, o2 = o2 && o2.name ? o2.name : o2, l2 = l2 && l2.name ? l2.name : l2, s2[t3] = true, s2[o2] = true, s2[l2] = true, r3.patterns[a2.id] = { min: t3, mid: o2, max: l2 };
              }
            }
            return r3;
          }
          Jo2.deviation = function(t2, e2, r3, n2) {
            var i2 = e2 && e2.length, s2 = Math.abs(_l2(t2, 0, i2 ? e2[0] * r3 : t2.length, r3));
            if (i2)
              for (var a2 = 0, o2 = e2.length; a2 < o2; a2++)
                s2 -= Math.abs(_l2(t2, e2[a2] * r3, a2 < o2 - 1 ? e2[a2 + 1] * r3 : t2.length, r3));
            var l2 = 0;
            for (a2 = 0; a2 < n2.length; a2 += 3) {
              var u2 = n2[a2] * r3, c2 = n2[a2 + 1] * r3, h2 = n2[a2 + 2] * r3;
              l2 += Math.abs((t2[u2] - t2[h2]) * (t2[c2 + 1] - t2[u2 + 1]) - (t2[u2] - t2[c2]) * (t2[h2 + 1] - t2[u2 + 1]));
            }
            return s2 === 0 && l2 === 0 ? 0 : Math.abs((l2 - s2) / s2);
          }, Jo2.flatten = function(t2) {
            for (var e2 = t2[0][0].length, r3 = { vertices: [], holes: [], dimensions: e2 }, n2 = 0, i2 = 0; i2 < t2.length; i2++) {
              for (var s2 = 0; s2 < t2[i2].length; s2++)
                for (var a2 = 0; a2 < e2; a2++)
                  r3.vertices.push(t2[i2][s2][a2]);
              i2 > 0 && r3.holes.push(n2 += t2[i2 - 1].length);
            }
            return r3;
          }, Ho2.default = Yo2;
          class Bl2 {
            constructor(t2) {
              this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new zs(), this.indexArray = new $s2(), this.indexArray2 = new Zs2(), this.programConfigurations = new Ea2(t2.layers, t2.zoom), this.segments = new $a2(), this.segments2 = new $a2(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
            }
            populate(t2, e2, r3) {
              this.hasPattern = Ml2("fill", this.layers, e2);
              const n2 = this.layers[0].layout.get("fill-sort-key"), i2 = [];
              for (const { feature: s2, id: a2, index: o2, sourceLayerIndex: l2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, u2 = Ga2(s2, t3);
                if (!this.layers[0]._featureFilter.filter(new as2(this.zoom), u2, r3))
                  continue;
                const c2 = n2 ? n2.evaluate(u2, {}, r3, e2.availableImages) : void 0, h2 = { id: a2, properties: s2.properties, type: s2.type, sourceLayerIndex: l2, index: o2, geometry: t3 ? u2.geometry : ja2(s2), patterns: {}, sortKey: c2 };
                i2.push(h2);
              }
              n2 && i2.sort((t3, e3) => t3.sortKey - e3.sortKey);
              for (const n3 of i2) {
                const { geometry: i3, index: s2, sourceLayerIndex: a2 } = n3;
                if (this.hasPattern) {
                  const t3 = El2("fill", this.layers, n3, this.zoom, e2);
                  this.patternFeatures.push(t3);
                } else
                  this.addFeature(n3, i3, s2, r3, {});
                e2.featureIndex.insert(t2[s2].feature, i3, s2, a2, this.index);
              }
            }
            update(t2, e2, r3) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r3);
            }
            addFeatures(t2, e2, r3) {
              for (const t3 of this.patternFeatures)
                this.addFeature(t3, t3.geometry, t3.index, e2, r3);
            }
            isEmpty() {
              return this.layoutVertexArray.length === 0;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Ko2), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.indexBuffer2 = t2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
            }
            addFeature(t2, e2, r3, n2, i2) {
              for (const t3 of zl2(e2, 500)) {
                let e3 = 0;
                for (const r5 of t3)
                  e3 += r5.length;
                const r4 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray), n3 = r4.vertexLength, i3 = [], s2 = [];
                for (const e4 of t3) {
                  if (e4.length === 0)
                    continue;
                  e4 !== t3[0] && s2.push(i3.length / 2);
                  const r5 = this.segments2.prepareSegment(e4.length, this.layoutVertexArray, this.indexArray2), n4 = r5.vertexLength;
                  this.layoutVertexArray.emplaceBack(e4[0].x, e4[0].y), this.indexArray2.emplaceBack(n4 + e4.length - 1, n4), i3.push(e4[0].x), i3.push(e4[0].y);
                  for (let t4 = 1; t4 < e4.length; t4++)
                    this.layoutVertexArray.emplaceBack(e4[t4].x, e4[t4].y), this.indexArray2.emplaceBack(n4 + t4 - 1, n4 + t4), i3.push(e4[t4].x), i3.push(e4[t4].y);
                  r5.vertexLength += e4.length, r5.primitiveLength += e4.length;
                }
                const a2 = Ho2(i3, s2);
                for (let t4 = 0; t4 < a2.length; t4 += 3)
                  this.indexArray.emplaceBack(n3 + a2[t4], n3 + a2[t4 + 1], n3 + a2[t4 + 2]);
                r4.vertexLength += e3, r4.primitiveLength += a2.length / 3;
              }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r3, i2, n2);
            }
          }
          oi2("FillBucket", Bl2, { omit: ["layers", "patternFeatures"] });
          const Cl2 = new bs2({ "fill-sort-key": new ms2(Rt.layout_fill["fill-sort-key"]) });
          var Pl2 = { paint: new bs2({ "fill-antialias": new ys2(Rt.paint_fill["fill-antialias"]), "fill-opacity": new ms2(Rt.paint_fill["fill-opacity"]), "fill-color": new ms2(Rt.paint_fill["fill-color"]), "fill-outline-color": new ms2(Rt.paint_fill["fill-outline-color"]), "fill-translate": new ys2(Rt.paint_fill["fill-translate"]), "fill-translate-anchor": new ys2(Rt.paint_fill["fill-translate-anchor"]), "fill-pattern": new gs2(Rt.paint_fill["fill-pattern"]) }), layout: Cl2 };
          const Dl2 = Ss([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), Vl2 = Ss([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), { members: Ll2 } = Dl2;
          var Fl2 = Rl2;
          function Rl2(t2, e2, r3, n2, i2) {
            this.properties = {}, this.extent = r3, this.type = 0, this._pbf = t2, this._geometry = -1, this._keys = n2, this._values = i2, t2.readFields(Ul2, this, e2);
          }
          function Ul2(t2, e2, r3) {
            t2 == 1 ? e2.id = r3.readVarint() : t2 == 2 ? function(t3, e3) {
              for (var r4 = t3.readVarint() + t3.pos; t3.pos < r4; ) {
                var n2 = e3._keys[t3.readVarint()], i2 = e3._values[t3.readVarint()];
                e3.properties[n2] = i2;
              }
            }(r3, e2) : t2 == 3 ? e2.type = r3.readVarint() : t2 == 4 && (e2._geometry = r3.pos);
          }
          function $l2(t2) {
            for (var e2, r3, n2 = 0, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
              n2 += ((r3 = t2[a2]).x - (e2 = t2[i2]).x) * (e2.y + r3.y);
            return n2;
          }
          Rl2.types = ["Unknown", "Point", "LineString", "Polygon"], Rl2.prototype.loadGeometry = function() {
            var t2 = this._pbf;
            t2.pos = this._geometry;
            for (var e2, r3 = t2.readVarint() + t2.pos, n2 = 1, s2 = 0, a2 = 0, o2 = 0, l2 = []; t2.pos < r3; ) {
              if (s2 <= 0) {
                var u2 = t2.readVarint();
                n2 = 7 & u2, s2 = u2 >> 3;
              }
              if (s2--, n2 === 1 || n2 === 2)
                a2 += t2.readSVarint(), o2 += t2.readSVarint(), n2 === 1 && (e2 && l2.push(e2), e2 = []), e2.push(new i(a2, o2));
              else {
                if (n2 !== 7)
                  throw new Error("unknown command " + n2);
                e2 && e2.push(e2[0].clone());
              }
            }
            return e2 && l2.push(e2), l2;
          }, Rl2.prototype.bbox = function() {
            var t2 = this._pbf;
            t2.pos = this._geometry;
            for (var e2 = t2.readVarint() + t2.pos, r3 = 1, n2 = 0, i2 = 0, s2 = 0, a2 = 1 / 0, o2 = -1 / 0, l2 = 1 / 0, u2 = -1 / 0; t2.pos < e2; ) {
              if (n2 <= 0) {
                var c2 = t2.readVarint();
                r3 = 7 & c2, n2 = c2 >> 3;
              }
              if (n2--, r3 === 1 || r3 === 2)
                (i2 += t2.readSVarint()) < a2 && (a2 = i2), i2 > o2 && (o2 = i2), (s2 += t2.readSVarint()) < l2 && (l2 = s2), s2 > u2 && (u2 = s2);
              else if (r3 !== 7)
                throw new Error("unknown command " + r3);
            }
            return [a2, l2, o2, u2];
          }, Rl2.prototype.toGeoJSON = function(t2, e2, r3) {
            var n2, i2, s2 = this.extent * Math.pow(2, r3), a2 = this.extent * t2, o2 = this.extent * e2, l2 = this.loadGeometry(), u2 = Rl2.types[this.type];
            function c2(t3) {
              for (var e3 = 0; e3 < t3.length; e3++) {
                var r4 = t3[e3];
                t3[e3] = [360 * (r4.x + a2) / s2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r4.y + o2) / s2) * Math.PI / 180)) - 90];
              }
            }
            switch (this.type) {
              case 1:
                var h2 = [];
                for (n2 = 0; n2 < l2.length; n2++)
                  h2[n2] = l2[n2][0];
                c2(l2 = h2);
                break;
              case 2:
                for (n2 = 0; n2 < l2.length; n2++)
                  c2(l2[n2]);
                break;
              case 3:
                for (l2 = function(t3) {
                  var e3 = t3.length;
                  if (e3 <= 1)
                    return [t3];
                  for (var r4, n3, i3 = [], s3 = 0; s3 < e3; s3++) {
                    var a3 = $l2(t3[s3]);
                    a3 !== 0 && (n3 === void 0 && (n3 = a3 < 0), n3 === a3 < 0 ? (r4 && i3.push(r4), r4 = [t3[s3]]) : r4.push(t3[s3]));
                  }
                  return r4 && i3.push(r4), i3;
                }(l2), n2 = 0; n2 < l2.length; n2++)
                  for (i2 = 0; i2 < l2[n2].length; i2++)
                    c2(l2[n2][i2]);
            }
            l2.length === 1 ? l2 = l2[0] : u2 = "Multi" + u2;
            var p2 = { type: "Feature", geometry: { type: u2, coordinates: l2 }, properties: this.properties };
            return "id" in this && (p2.id = this.id), p2;
          };
          var Ol2 = ql2;
          function ql2(t2, e2) {
            this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t2, this._keys = [], this._values = [], this._features = [], t2.readFields(Nl2, this, e2), this.length = this._features.length;
          }
          function Nl2(t2, e2, r3) {
            t2 === 15 ? e2.version = r3.readVarint() : t2 === 1 ? e2.name = r3.readString() : t2 === 5 ? e2.extent = r3.readVarint() : t2 === 2 ? e2._features.push(r3.pos) : t2 === 3 ? e2._keys.push(r3.readString()) : t2 === 4 && e2._values.push(function(t3) {
              for (var e3 = null, r4 = t3.readVarint() + t3.pos; t3.pos < r4; ) {
                var n2 = t3.readVarint() >> 3;
                e3 = n2 === 1 ? t3.readString() : n2 === 2 ? t3.readFloat() : n2 === 3 ? t3.readDouble() : n2 === 4 ? t3.readVarint64() : n2 === 5 ? t3.readVarint() : n2 === 6 ? t3.readSVarint() : n2 === 7 ? t3.readBoolean() : null;
              }
              return e3;
            }(r3));
          }
          function jl2(t2, e2, r3) {
            if (t2 === 3) {
              var n2 = new Ol2(r3, r3.readVarint() + r3.pos);
              n2.length && (e2[n2.name] = n2);
            }
          }
          ql2.prototype.feature = function(t2) {
            if (t2 < 0 || t2 >= this._features.length)
              throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t2];
            var e2 = this._pbf.readVarint() + this._pbf.pos;
            return new Fl2(this._pbf, e2, this.extent, this._keys, this._values);
          };
          var Gl2 = { VectorTile: function(t2, e2) {
            this.layers = t2.readFields(jl2, {}, e2);
          }, VectorTileFeature: Fl2, VectorTileLayer: Ol2 };
          const Zl2 = Gl2.VectorTileFeature.types, Xl2 = Math.pow(2, 13);
          function Kl2(t2, e2, r3, n2, i2, s2, a2, o2) {
            t2.emplaceBack((e2 << 1) + a2, (r3 << 1) + s2, (Math.floor(n2 * Xl2) << 1) + i2, Math.round(o2));
          }
          class Hl2 {
            constructor() {
              this.acc = new i(0, 0), this.polyCount = [];
            }
            startRing(t2) {
              this.currentPolyCount = { edges: 0, top: 0 }, this.polyCount.push(this.currentPolyCount), this.min || (this.min = new i(t2.x, t2.y), this.max = new i(t2.x, t2.y));
            }
            append(t2, e2) {
              this.currentPolyCount.edges++, this.acc._add(t2);
              let r3 = !!this.borders;
              const n2 = this.min, i2 = this.max;
              t2.x < n2.x ? (n2.x = t2.x, r3 = true) : t2.x > i2.x && (i2.x = t2.x, r3 = true), t2.y < n2.y ? (n2.y = t2.y, r3 = true) : t2.y > i2.y && (i2.y = t2.y, r3 = true), ((t2.x === 0 || t2.x === Oa2) && t2.x === e2.x) != ((t2.y === 0 || t2.y === Oa2) && t2.y === e2.y) && this.processBorderOverlap(t2, e2), r3 && this.checkBorderIntersection(t2, e2);
            }
            checkBorderIntersection(t2, e2) {
              e2.x < 0 != t2.x < 0 && this.addBorderIntersection(0, rr2(e2.y, t2.y, (0 - e2.x) / (t2.x - e2.x))), e2.x > Oa2 != t2.x > Oa2 && this.addBorderIntersection(1, rr2(e2.y, t2.y, (Oa2 - e2.x) / (t2.x - e2.x))), e2.y < 0 != t2.y < 0 && this.addBorderIntersection(2, rr2(e2.x, t2.x, (0 - e2.y) / (t2.y - e2.y))), e2.y > Oa2 != t2.y > Oa2 && this.addBorderIntersection(3, rr2(e2.x, t2.x, (Oa2 - e2.y) / (t2.y - e2.y)));
            }
            addBorderIntersection(t2, e2) {
              this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
              const r3 = this.borders[t2];
              e2 < r3[0] && (r3[0] = e2), e2 > r3[1] && (r3[1] = e2);
            }
            processBorderOverlap(t2, e2) {
              if (t2.x === e2.x) {
                if (t2.y === e2.y)
                  return;
                const r3 = t2.x === 0 ? 0 : 1;
                this.addBorderIntersection(r3, e2.y), this.addBorderIntersection(r3, t2.y);
              } else {
                const r3 = t2.y === 0 ? 2 : 3;
                this.addBorderIntersection(r3, e2.x), this.addBorderIntersection(r3, t2.x);
              }
            }
            centroid() {
              const t2 = this.polyCount.reduce((t3, e2) => t3 + e2.edges, 0);
              return t2 !== 0 ? this.acc.div(t2)._round() : new i(0, 0);
            }
            span() {
              return new i(this.max.x - this.min.x, this.max.y - this.min.y);
            }
            intersectsCount() {
              return this.borders.reduce((t2, e2) => t2 + +(e2[0] !== Number.MAX_VALUE), 0);
            }
          }
          class Yl2 {
            constructor(t2) {
              this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new Ts2(), this.centroidVertexArray = new aa2(), this.indexArray = new $s2(), this.programConfigurations = new Ea2(t2.layers, t2.zoom), this.segments = new $a2(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.enableTerrain = t2.enableTerrain;
            }
            populate(t2, e2, r3) {
              this.features = [], this.hasPattern = Ml2("fill-extrusion", this.layers, e2), this.featuresOnBorder = [], this.borders = [[], [], [], []], this.borderDone = [false, false, false, false], this.tileToMeter = function(t3) {
                const e3 = Math.exp(Math.PI * (1 - t3.y / (1 << t3.z) * 2));
                return 80150034 * e3 / (e3 * e3 + 1) / Oa2 / (1 << t3.z);
              }(r3);
              for (const { feature: n2, id: i2, index: s2, sourceLayerIndex: a2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, o2 = Ga2(n2, t3);
                if (!this.layers[0]._featureFilter.filter(new as2(this.zoom), o2, r3))
                  continue;
                const l2 = { id: i2, sourceLayerIndex: a2, index: s2, geometry: t3 ? o2.geometry : ja2(n2), properties: n2.properties, type: n2.type, patterns: {} }, u2 = this.layoutVertexArray.length;
                this.hasPattern ? this.features.push(El2("fill-extrusion", this.layers, l2, this.zoom, e2)) : this.addFeature(l2, l2.geometry, s2, r3, {}), e2.featureIndex.insert(n2, l2.geometry, s2, a2, this.index, u2);
              }
              this.sortBorders();
            }
            addFeatures(t2, e2, r3) {
              for (const t3 of this.features) {
                const { geometry: n2 } = t3;
                this.addFeature(t3, n2, t3.index, e2, r3);
              }
              this.sortBorders();
            }
            update(t2, e2, r3) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r3);
            }
            isEmpty() {
              return this.layoutVertexArray.length === 0;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Ll2), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            uploadCentroid(t2) {
              this.centroidVertexArray.length !== 0 && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = t2.createVertexBuffer(this.centroidVertexArray, Vl2.members, true), this.needsCentroidUpdate = false);
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            addFeature(t2, e2, r3, n2, i2) {
              const s2 = this.enableTerrain ? new Hl2() : null;
              for (const r4 of zl2(e2, 500)) {
                let e3 = 0, n3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
                if (r4.length === 0 || (a2 = r4[0]).every((t3) => t3.x <= 0) || a2.every((t3) => t3.x >= Oa2) || a2.every((t3) => t3.y <= 0) || a2.every((t3) => t3.y >= Oa2))
                  continue;
                for (let t3 = 0; t3 < r4.length; t3++) {
                  const i4 = r4[t3];
                  if (i4.length === 0)
                    continue;
                  e3 += i4.length;
                  let a3 = 0;
                  s2 && s2.startRing(i4[0]);
                  for (let t4 = 0; t4 < i4.length; t4++) {
                    const e4 = i4[t4];
                    if (t4 >= 1) {
                      const r5 = i4[t4 - 1];
                      if (!Jl2(e4, r5)) {
                        s2 && s2.append(e4, r5), n3.vertexLength + 4 > $a2.MAX_VERTEX_ARRAY_LENGTH && (n3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                        const t5 = e4.sub(r5)._perp(), i5 = t5.x / (Math.abs(t5.x) + Math.abs(t5.y)), o3 = t5.y > 0 ? 1 : 0, l3 = r5.dist(e4);
                        a3 + l3 > 32768 && (a3 = 0), Kl2(this.layoutVertexArray, e4.x, e4.y, i5, o3, 0, 0, a3), Kl2(this.layoutVertexArray, e4.x, e4.y, i5, o3, 0, 1, a3), a3 += l3, Kl2(this.layoutVertexArray, r5.x, r5.y, i5, o3, 0, 0, a3), Kl2(this.layoutVertexArray, r5.x, r5.y, i5, o3, 0, 1, a3);
                        const u3 = n3.vertexLength;
                        this.indexArray.emplaceBack(u3, u3 + 2, u3 + 1), this.indexArray.emplaceBack(u3 + 1, u3 + 2, u3 + 3), n3.vertexLength += 4, n3.primitiveLength += 2;
                      }
                    }
                  }
                }
                if (n3.vertexLength + e3 > $a2.MAX_VERTEX_ARRAY_LENGTH && (n3 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray)), Zl2[t2.type] !== "Polygon")
                  continue;
                const i3 = [], o2 = [], l2 = n3.vertexLength;
                for (let t3 = 0; t3 < r4.length; t3++) {
                  const e4 = r4[t3];
                  if (e4.length !== 0) {
                    e4 !== r4[0] && o2.push(i3.length / 2);
                    for (let t4 = 0; t4 < e4.length; t4++) {
                      const r5 = e4[t4];
                      Kl2(this.layoutVertexArray, r5.x, r5.y, 0, 0, 1, 1, 0), i3.push(r5.x), i3.push(r5.y), s2 && s2.currentPolyCount.top++;
                    }
                  }
                }
                const u2 = Ho2(i3, o2);
                for (let t3 = 0; t3 < u2.length; t3 += 3)
                  this.indexArray.emplaceBack(l2 + u2[t3], l2 + u2[t3 + 2], l2 + u2[t3 + 1]);
                n3.primitiveLength += u2.length / 3, n3.vertexLength += e3;
              }
              var a2;
              if (s2 && s2.polyCount.length > 0) {
                if (s2.borders) {
                  s2.vertexArrayOffset = this.centroidVertexArray.length;
                  const t3 = s2.borders, e3 = this.featuresOnBorder.push(s2) - 1;
                  for (let r4 = 0; r4 < 4; r4++)
                    t3[r4][0] !== Number.MAX_VALUE && this.borders[r4].push(e3);
                }
                this.encodeCentroid(s2.borders ? void 0 : s2.centroid(), s2);
              }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r3, i2, n2);
            }
            sortBorders() {
              for (let t2 = 0; t2 < 4; t2++)
                this.borders[t2].sort((e2, r3) => this.featuresOnBorder[e2].borders[t2][0] - this.featuresOnBorder[r3].borders[t2][0]);
            }
            encodeCentroid(t2, e2, r3 = true) {
              let n2, i2;
              if (t2)
                if (t2.y !== 0) {
                  const r4 = e2.span()._mult(this.tileToMeter);
                  n2 = (Math.max(t2.x, 1) << 3) + Math.min(7, Math.round(r4.x / 10)), i2 = (Math.max(t2.y, 1) << 3) + Math.min(7, Math.round(r4.y / 10));
                } else
                  n2 = Math.ceil(7 * (t2.x + 450)), i2 = 0;
              else
                n2 = 0, i2 = +r3;
              let s2 = r3 ? this.centroidVertexArray.length : e2.vertexArrayOffset;
              for (const t3 of e2.polyCount) {
                r3 && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * t3.edges + t3.top);
                for (let e3 = 0; e3 < 2 * t3.edges; e3++)
                  this.centroidVertexArray.emplace(s2++, 0, i2), this.centroidVertexArray.emplace(s2++, n2, i2);
                for (let e3 = 0; e3 < t3.top; e3++)
                  this.centroidVertexArray.emplace(s2++, n2, i2);
              }
            }
          }
          function Jl2(t2, e2) {
            return t2.x === e2.x && (t2.x < 0 || t2.x > Oa2) || t2.y === e2.y && (t2.y < 0 || t2.y > Oa2);
          }
          oi2("FillExtrusionBucket", Yl2, { omit: ["layers", "features"] }), oi2("PartMetadata", Hl2);
          var Wl2 = { paint: new bs2({ "fill-extrusion-opacity": new ys2(Rt["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new ms2(Rt["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new ys2(Rt["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new ys2(Rt["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new gs2(Rt["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new ms2(Rt["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new ms2(Rt["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new ys2(Rt["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }) };
          function Ql2(t2, e2) {
            return t2.x * e2.x + t2.y * e2.y;
          }
          function tu2(t2, e2) {
            if (t2.length === 1) {
              let r3 = 0;
              const n2 = e2[r3++];
              let i2;
              for (; !i2 || n2.equals(i2); )
                if (i2 = e2[r3++], !i2)
                  return 1 / 0;
              for (; r3 < e2.length; r3++) {
                const s2 = e2[r3], a2 = t2[0], o2 = i2.sub(n2), l2 = s2.sub(n2), u2 = a2.sub(n2), c2 = Ql2(o2, o2), h2 = Ql2(o2, l2), p2 = Ql2(l2, l2), d2 = Ql2(u2, o2), f2 = Ql2(u2, l2), y2 = c2 * p2 - h2 * h2, m2 = (p2 * d2 - h2 * f2) / y2, g2 = (c2 * f2 - h2 * d2) / y2, x3 = n2.z * (1 - m2 - g2) + i2.z * m2 + s2.z * g2;
                if (isFinite(x3))
                  return x3;
              }
              return 1 / 0;
            }
            {
              let t3 = 1 / 0;
              for (const r3 of e2)
                t3 = Math.min(t3, r3.z);
              return t3;
            }
          }
          function eu2(t2) {
            const e2 = new i(t2[0], t2[1]);
            return e2.z = t2[2], e2;
          }
          function ru2(t2, e2, r3, n2, i2, s2, a2, o2) {
            const l2 = a2 * i2.getElevationAt(t2, e2, true, true), u2 = s2[0] !== 0, c2 = u2 ? s2[1] === 0 ? a2 * (s2[0] / 7 - 450) : a2 * function(t3, e3, r4) {
              const n3 = Math.floor(e3[0] / 8), i3 = Math.floor(e3[1] / 8), s3 = 10 * (e3[0] - 8 * n3), a3 = 10 * (e3[1] - 8 * i3), o3 = t3.getElevationAt(n3, i3, true, true), l3 = t3.getMeterToDEM(r4), u3 = Math.floor(0.5 * (s3 * l3 - 1)), c3 = Math.floor(0.5 * (a3 * l3 - 1)), h2 = t3.tileCoordToPixel(n3, i3), p2 = 2 * u3 + 1, d2 = 2 * c3 + 1, f2 = function(t4, e4, r5, n4, i4) {
                return [t4.getElevationAtPixel(e4, r5, true), t4.getElevationAtPixel(e4 + i4, r5, true), t4.getElevationAtPixel(e4, r5 + i4, true), t4.getElevationAtPixel(e4 + n4, r5 + i4, true)];
              }(t3, h2.x - u3, h2.y - c3, p2, d2), y2 = Math.abs(f2[0] - f2[1]), m2 = Math.abs(f2[2] - f2[3]), g2 = Math.abs(f2[0] - f2[2]) + Math.abs(f2[1] - f2[3]), x3 = Math.min(0.25, 0.5 * l3 * (y2 + m2) / p2), v2 = Math.min(0.25, 0.5 * l3 * g2 / d2);
              return o3 + Math.max(x3 * s3, v2 * a3);
            }(i2, s2, o2) : l2;
            return { base: l2 + (r3 === 0) ? -1 : r3, top: u2 ? Math.max(c2 + n2, l2 + r3 + 2) : l2 + n2 };
          }
          const nu2 = Ss([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), { members: iu2 } = nu2, su2 = Ss([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: au2 } = su2, ou2 = Gl2.VectorTileFeature.types, lu2 = Math.cos(Math.PI / 180 * 37.5);
          class uu2 {
            constructor(t2) {
              this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t3) => {
                this.gradients[t3.id] = {};
              }), this.layoutVertexArray = new Ms2(), this.layoutVertexArray2 = new Es2(), this.indexArray = new $s2(), this.programConfigurations = new Ea2(t2.layers, t2.zoom), this.segments = new $a2(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
            }
            populate(t2, e2, r3) {
              this.hasPattern = Ml2("line", this.layers, e2);
              const n2 = this.layers[0].layout.get("line-sort-key"), i2 = [];
              for (const { feature: e3, id: s3, index: a3, sourceLayerIndex: o3 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, l2 = Ga2(e3, t3);
                if (!this.layers[0]._featureFilter.filter(new as2(this.zoom), l2, r3))
                  continue;
                const u2 = n2 ? n2.evaluate(l2, {}, r3) : void 0, c2 = { id: s3, properties: e3.properties, type: e3.type, sourceLayerIndex: o3, index: a3, geometry: t3 ? l2.geometry : ja2(e3), patterns: {}, sortKey: u2 };
                i2.push(c2);
              }
              n2 && i2.sort((t3, e3) => t3.sortKey - e3.sortKey);
              const { lineAtlas: s2, featureIndex: a2 } = e2, o2 = this.addConstantDashes(s2);
              for (const n3 of i2) {
                const { geometry: i3, index: l2, sourceLayerIndex: u2 } = n3;
                if (o2 && this.addFeatureDashes(n3, s2), this.hasPattern) {
                  const t3 = El2("line", this.layers, n3, this.zoom, e2);
                  this.patternFeatures.push(t3);
                } else
                  this.addFeature(n3, i3, l2, r3, s2.positions);
                a2.insert(t2[l2].feature, i3, l2, u2, this.index);
              }
            }
            addConstantDashes(t2) {
              let e2 = false;
              for (const r3 of this.layers) {
                const n2 = r3.paint.get("line-dasharray").value, i2 = r3.layout.get("line-cap").value;
                if (n2.kind !== "constant" || i2.kind !== "constant")
                  e2 = true;
                else {
                  const e3 = i2.value, r4 = n2.value;
                  if (!r4)
                    continue;
                  t2.addDash(r4.from, e3), t2.addDash(r4.to, e3), r4.other && t2.addDash(r4.other, e3);
                }
              }
              return e2;
            }
            addFeatureDashes(t2, e2) {
              const r3 = this.zoom;
              for (const n2 of this.layers) {
                const i2 = n2.paint.get("line-dasharray").value, s2 = n2.layout.get("line-cap").value;
                if (i2.kind === "constant" && s2.kind === "constant")
                  continue;
                let a2, o2, l2, u2, c2, h2;
                if (i2.kind === "constant") {
                  const t3 = i2.value;
                  if (!t3)
                    continue;
                  a2 = t3.other || t3.to, o2 = t3.to, l2 = t3.from;
                } else
                  a2 = i2.evaluate({ zoom: r3 - 1 }, t2), o2 = i2.evaluate({ zoom: r3 }, t2), l2 = i2.evaluate({ zoom: r3 + 1 }, t2);
                s2.kind === "constant" ? u2 = c2 = h2 = s2.value : (u2 = s2.evaluate({ zoom: r3 - 1 }, t2), c2 = s2.evaluate({ zoom: r3 }, t2), h2 = s2.evaluate({ zoom: r3 + 1 }, t2)), e2.addDash(a2, u2), e2.addDash(o2, c2), e2.addDash(l2, h2);
                const p2 = e2.getKey(a2, u2), d2 = e2.getKey(o2, c2), f2 = e2.getKey(l2, h2);
                t2.patterns[n2.id] = { min: p2, mid: d2, max: f2 };
              }
            }
            update(t2, e2, r3) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r3);
            }
            addFeatures(t2, e2, r3) {
              for (const t3 of this.patternFeatures)
                this.addFeature(t3, t3.geometry, t3.index, e2, r3);
            }
            isEmpty() {
              return this.layoutVertexArray.length === 0;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t2.createVertexBuffer(this.layoutVertexArray2, au2)), this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, iu2), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            lineFeatureClips(t2) {
              if (t2.properties && t2.properties.hasOwnProperty("mapbox_clip_start") && t2.properties.hasOwnProperty("mapbox_clip_end"))
                return { start: +t2.properties.mapbox_clip_start, end: +t2.properties.mapbox_clip_end };
            }
            addFeature(t2, e2, r3, n2, i2) {
              const s2 = this.layers[0].layout, a2 = s2.get("line-join").evaluate(t2, {}), o2 = s2.get("line-cap").evaluate(t2, {}), l2 = s2.get("line-miter-limit"), u2 = s2.get("line-round-limit");
              this.lineClips = this.lineFeatureClips(t2);
              for (const r4 of e2)
                this.addLine(r4, t2, a2, o2, l2, u2);
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r3, i2, n2);
            }
            addLine(t2, e2, r3, n2, i2, s2) {
              if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {
                this.lineClipsArray.push(this.lineClips);
                for (let e3 = 0; e3 < t2.length - 1; e3++)
                  this.totalDistance += t2[e3].dist(t2[e3 + 1]);
                this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
              }
              const a2 = ou2[e2.type] === "Polygon";
              let o2 = t2.length;
              for (; o2 >= 2 && t2[o2 - 1].equals(t2[o2 - 2]); )
                o2--;
              let l2 = 0;
              for (; l2 < o2 - 1 && t2[l2].equals(t2[l2 + 1]); )
                l2++;
              if (o2 < (a2 ? 3 : 2))
                return;
              r3 === "bevel" && (i2 = 1.05);
              const u2 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, c2 = this.segments.prepareSegment(10 * o2, this.layoutVertexArray, this.indexArray);
              let h2, p2, d2, f2, y2;
              this.e1 = this.e2 = -1, a2 && (h2 = t2[o2 - 2], y2 = t2[l2].sub(h2)._unit()._perp());
              for (let e3 = l2; e3 < o2; e3++) {
                if (d2 = e3 === o2 - 1 ? a2 ? t2[l2 + 1] : void 0 : t2[e3 + 1], d2 && t2[e3].equals(d2))
                  continue;
                y2 && (f2 = y2), h2 && (p2 = h2), h2 = t2[e3], y2 = d2 ? d2.sub(h2)._unit()._perp() : f2, f2 = f2 || y2;
                let m2 = f2.add(y2);
                m2.x === 0 && m2.y === 0 || m2._unit();
                const g2 = f2.x * y2.x + f2.y * y2.y, x3 = m2.x * y2.x + m2.y * y2.y, v2 = x3 !== 0 ? 1 / x3 : 1 / 0, b2 = 2 * Math.sqrt(2 - 2 * x3), w3 = x3 < lu2 && p2 && d2, _2 = f2.x * y2.y - f2.y * y2.x > 0;
                if (w3 && e3 > l2) {
                  const t3 = h2.dist(p2);
                  if (t3 > 2 * u2) {
                    const e4 = h2.sub(h2.sub(p2)._mult(u2 / t3)._round());
                    this.updateDistance(p2, e4), this.addCurrentVertex(e4, f2, 0, 0, c2), p2 = e4;
                  }
                }
                const k3 = p2 && d2;
                let A2 = k3 ? r3 : a2 ? "butt" : n2;
                if (k3 && A2 === "round" && (v2 < s2 ? A2 = "miter" : v2 <= 2 && (A2 = "fakeround")), A2 === "miter" && v2 > i2 && (A2 = "bevel"), A2 === "bevel" && (v2 > 2 && (A2 = "flipbevel"), v2 < i2 && (A2 = "miter")), p2 && this.updateDistance(p2, h2), A2 === "miter")
                  m2._mult(v2), this.addCurrentVertex(h2, m2, 0, 0, c2);
                else if (A2 === "flipbevel") {
                  if (v2 > 100)
                    m2 = y2.mult(-1);
                  else {
                    const t3 = v2 * f2.add(y2).mag() / f2.sub(y2).mag();
                    m2._perp()._mult(t3 * (_2 ? -1 : 1));
                  }
                  this.addCurrentVertex(h2, m2, 0, 0, c2), this.addCurrentVertex(h2, m2.mult(-1), 0, 0, c2);
                } else if (A2 === "bevel" || A2 === "fakeround") {
                  const t3 = -Math.sqrt(v2 * v2 - 1), e4 = _2 ? t3 : 0, r4 = _2 ? 0 : t3;
                  if (p2 && this.addCurrentVertex(h2, f2, e4, r4, c2), A2 === "fakeround") {
                    const t4 = Math.round(180 * b2 / Math.PI / 20);
                    for (let e5 = 1; e5 < t4; e5++) {
                      let r5 = e5 / t4;
                      if (r5 !== 0.5) {
                        const t5 = r5 - 0.5;
                        r5 += r5 * t5 * (r5 - 1) * ((1.0904 + g2 * (g2 * (3.55645 - 1.43519 * g2) - 3.2452)) * t5 * t5 + (0.848013 + g2 * (0.215638 * g2 - 1.06021)));
                      }
                      const n3 = y2.sub(f2)._mult(r5)._add(f2)._unit()._mult(_2 ? -1 : 1);
                      this.addHalfVertex(h2, n3.x, n3.y, false, _2, 0, c2);
                    }
                  }
                  d2 && this.addCurrentVertex(h2, y2, -e4, -r4, c2);
                } else if (A2 === "butt")
                  this.addCurrentVertex(h2, m2, 0, 0, c2);
                else if (A2 === "square") {
                  const t3 = p2 ? 1 : -1;
                  p2 || this.addCurrentVertex(h2, m2, t3, t3, c2), this.addCurrentVertex(h2, m2, 0, 0, c2), p2 && this.addCurrentVertex(h2, m2, t3, t3, c2);
                } else
                  A2 === "round" && (p2 && (this.addCurrentVertex(h2, f2, 0, 0, c2), this.addCurrentVertex(h2, f2, 1, 1, c2, true)), d2 && (this.addCurrentVertex(h2, y2, -1, -1, c2, true), this.addCurrentVertex(h2, y2, 0, 0, c2)));
                if (w3 && e3 < o2 - 1) {
                  const t3 = h2.dist(d2);
                  if (t3 > 2 * u2) {
                    const e4 = h2.add(d2.sub(h2)._mult(u2 / t3)._round());
                    this.updateDistance(h2, e4), this.addCurrentVertex(e4, y2, 0, 0, c2), h2 = e4;
                  }
                }
              }
            }
            addCurrentVertex(t2, e2, r3, n2, i2, s2 = false) {
              const a2 = e2.y * n2 - e2.x, o2 = -e2.y - e2.x * n2;
              this.addHalfVertex(t2, e2.x + e2.y * r3, e2.y - e2.x * r3, s2, false, r3, i2), this.addHalfVertex(t2, a2, o2, s2, true, -n2, i2);
            }
            addHalfVertex({ x: t2, y: e2 }, r3, n2, i2, s2, a2, o2) {
              this.layoutVertexArray.emplaceBack((t2 << 1) + (i2 ? 1 : 0), (e2 << 1) + (s2 ? 1 : 0), Math.round(63 * r3) + 128, Math.round(63 * n2) + 128, 1 + (a2 === 0 ? 0 : a2 < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length);
              const l2 = o2.vertexLength++;
              this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l2), o2.primitiveLength++), s2 ? this.e2 = l2 : this.e1 = l2;
            }
            updateScaledDistance() {
              if (this.lineClips) {
                const t2 = this.totalDistance / (this.lineClips.end - this.lineClips.start);
                this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t2 * this.lineClips.start + this.distance;
              } else
                this.lineSoFar = this.distance;
            }
            updateDistance(t2, e2) {
              this.distance += t2.dist(e2), this.updateScaledDistance();
            }
          }
          oi2("LineBucket", uu2, { omit: ["layers", "patternFeatures"] });
          const cu2 = new bs2({ "line-cap": new ms2(Rt.layout_line["line-cap"]), "line-join": new ms2(Rt.layout_line["line-join"]), "line-miter-limit": new ys2(Rt.layout_line["line-miter-limit"]), "line-round-limit": new ys2(Rt.layout_line["line-round-limit"]), "line-sort-key": new ms2(Rt.layout_line["line-sort-key"]) });
          var hu2 = { paint: new bs2({ "line-opacity": new ms2(Rt.paint_line["line-opacity"]), "line-color": new ms2(Rt.paint_line["line-color"]), "line-translate": new ys2(Rt.paint_line["line-translate"]), "line-translate-anchor": new ys2(Rt.paint_line["line-translate-anchor"]), "line-width": new ms2(Rt.paint_line["line-width"]), "line-gap-width": new ms2(Rt.paint_line["line-gap-width"]), "line-offset": new ms2(Rt.paint_line["line-offset"]), "line-blur": new ms2(Rt.paint_line["line-blur"]), "line-dasharray": new gs2(Rt.paint_line["line-dasharray"]), "line-pattern": new gs2(Rt.paint_line["line-pattern"]), "line-gradient": new vs2(Rt.paint_line["line-gradient"]) }), layout: cu2 };
          const pu2 = new class extends ms2 {
            possiblyEvaluate(t2, e2) {
              return e2 = new as2(Math.floor(e2.zoom), { now: e2.now, fadeDuration: e2.fadeDuration, zoomHistory: e2.zoomHistory, transition: e2.transition }), super.possiblyEvaluate(t2, e2);
            }
            evaluate(t2, e2, r3, n2) {
              return e2 = v({}, e2, { zoom: Math.floor(e2.zoom) }), super.evaluate(t2, e2, r3, n2);
            }
          }(hu2.paint.properties["line-width"].specification);
          function du2(t2, e2) {
            return e2 > 0 ? e2 + 2 * t2 : t2;
          }
          pu2.useIntegerZoom = true;
          const fu2 = Ss([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), yu2 = Ss([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
          Ss([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
          const mu2 = Ss([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]), gu2 = Ss([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }]);
          Ss([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
          const xu2 = Ss([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), vu = Ss([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
          Ss([{ name: "triangle", components: 3, type: "Uint16" }]), Ss([{ type: "Float32", name: "anchorX" }, { type: "Float32", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), Ss([{ type: "Float32", name: "anchorX" }, { type: "Float32", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), Ss([{ type: "Float32", name: "offsetX" }]), Ss([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
          var bu = 24;
          const wu = 128;
          function _u2(t2, e2) {
            const { expression: r3 } = e2;
            if (r3.kind === "constant")
              return { kind: "constant", layoutSize: r3.evaluate(new as2(t2 + 1)) };
            if (r3.kind === "source")
              return { kind: "source" };
            {
              const { zoomStops: e3, interpolationType: n2 } = r3;
              let i2 = 0;
              for (; i2 < e3.length && e3[i2] <= t2; )
                i2++;
              i2 = Math.max(0, i2 - 1);
              let s2 = i2;
              for (; s2 < e3.length && e3[s2] < t2 + 1; )
                s2++;
              s2 = Math.min(e3.length - 1, s2);
              const a2 = e3[i2], o2 = e3[s2];
              return r3.kind === "composite" ? { kind: "composite", minZoom: a2, maxZoom: o2, interpolationType: n2 } : { kind: "camera", minZoom: a2, maxZoom: o2, minSize: r3.evaluate(new as2(a2)), maxSize: r3.evaluate(new as2(o2)), interpolationType: n2 };
            }
          }
          function ku(t2, { uSize: e2, uSizeT: r3 }, { lowerSize: n2, upperSize: i2 }) {
            return t2.kind === "source" ? n2 / wu : t2.kind === "composite" ? rr2(n2 / wu, i2 / wu, r3) : e2;
          }
          function Au(t2, e2) {
            let r3 = 0, n2 = 0;
            if (t2.kind === "constant")
              n2 = t2.layoutSize;
            else if (t2.kind !== "source") {
              const { interpolationType: i2, minZoom: s2, maxZoom: a2 } = t2, o2 = i2 ? y(wr2.interpolationFactor(i2, e2, s2, a2), 0, 1) : 0;
              t2.kind === "camera" ? n2 = rr2(t2.minSize, t2.maxSize, o2) : r3 = o2;
            }
            return { uSizeT: r3, uSize: n2 };
          }
          var Su = Object.freeze({ __proto__: null, getSizeData: _u2, evaluateSizeForFeature: ku, evaluateSizeForZoom: Au, SIZE_PACK_FACTOR: wu });
          function Iu(t2, e2, r3) {
            return t2.sections.forEach((t3) => {
              t3.text = function(t4, e3, r4) {
                const n2 = e3.layout.get("text-transform").evaluate(r4, {});
                return n2 === "uppercase" ? t4 = t4.toLocaleUpperCase() : n2 === "lowercase" && (t4 = t4.toLocaleLowerCase()), ss2.applyArabicShaping && (t4 = ss2.applyArabicShaping(t4)), t4;
              }(t3.text, e2, r3);
            }), t2;
          }
          const zu2 = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" };
          function Tu(t2) {
            return t2 === "\uFE36" || t2 === "\uFE48" || t2 === "\uFE38" || t2 === "\uFE44" || t2 === "\uFE42" || t2 === "\uFE3E" || t2 === "\uFE3C" || t2 === "\uFE3A" || t2 === "\uFE18" || t2 === "\uFE40" || t2 === "\uFE10" || t2 === "\uFE13" || t2 === "\uFE14" || t2 === "\uFF40" || t2 === "\uFFE3" || t2 === "\uFE11" || t2 === "\uFE12";
          }
          function Mu(t2) {
            return t2 === "\uFE35" || t2 === "\uFE47" || t2 === "\uFE37" || t2 === "\uFE43" || t2 === "\uFE41" || t2 === "\uFE3D" || t2 === "\uFE3B" || t2 === "\uFE39" || t2 === "\uFE17" || t2 === "\uFE3F";
          }
          var Eu2 = function(t2, e2, r3, n2, i2) {
            var s2, a2, o2 = 8 * i2 - n2 - 1, l2 = (1 << o2) - 1, u2 = l2 >> 1, c2 = -7, h2 = r3 ? i2 - 1 : 0, p2 = r3 ? -1 : 1, d2 = t2[e2 + h2];
            for (h2 += p2, s2 = d2 & (1 << -c2) - 1, d2 >>= -c2, c2 += o2; c2 > 0; s2 = 256 * s2 + t2[e2 + h2], h2 += p2, c2 -= 8)
              ;
            for (a2 = s2 & (1 << -c2) - 1, s2 >>= -c2, c2 += n2; c2 > 0; a2 = 256 * a2 + t2[e2 + h2], h2 += p2, c2 -= 8)
              ;
            if (s2 === 0)
              s2 = 1 - u2;
            else {
              if (s2 === l2)
                return a2 ? NaN : 1 / 0 * (d2 ? -1 : 1);
              a2 += Math.pow(2, n2), s2 -= u2;
            }
            return (d2 ? -1 : 1) * a2 * Math.pow(2, s2 - n2);
          }, Bu = function(t2, e2, r3, n2, i2, s2) {
            var a2, o2, l2, u2 = 8 * s2 - i2 - 1, c2 = (1 << u2) - 1, h2 = c2 >> 1, p2 = i2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d2 = n2 ? 0 : s2 - 1, f2 = n2 ? 1 : -1, y2 = e2 < 0 || e2 === 0 && 1 / e2 < 0 ? 1 : 0;
            for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (o2 = isNaN(e2) ? 1 : 0, a2 = c2) : (a2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (l2 = Math.pow(2, -a2)) < 1 && (a2--, l2 *= 2), (e2 += a2 + h2 >= 1 ? p2 / l2 : p2 * Math.pow(2, 1 - h2)) * l2 >= 2 && (a2++, l2 /= 2), a2 + h2 >= c2 ? (o2 = 0, a2 = c2) : a2 + h2 >= 1 ? (o2 = (e2 * l2 - 1) * Math.pow(2, i2), a2 += h2) : (o2 = e2 * Math.pow(2, h2 - 1) * Math.pow(2, i2), a2 = 0)); i2 >= 8; t2[r3 + d2] = 255 & o2, d2 += f2, o2 /= 256, i2 -= 8)
              ;
            for (a2 = a2 << i2 | o2, u2 += i2; u2 > 0; t2[r3 + d2] = 255 & a2, d2 += f2, a2 /= 256, u2 -= 8)
              ;
            t2[r3 + d2 - f2] |= 128 * y2;
          }, Cu = Pu;
          function Pu(t2) {
            this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t2) ? t2 : new Uint8Array(t2 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          Pu.Varint = 0, Pu.Fixed64 = 1, Pu.Bytes = 2, Pu.Fixed32 = 5;
          var Du = 4294967296, Vu2 = 1 / Du, Lu = typeof TextDecoder == "undefined" ? null : new TextDecoder("utf8");
          function Fu(t2) {
            return t2.type === Pu.Bytes ? t2.readVarint() + t2.pos : t2.pos + 1;
          }
          function Ru(t2, e2, r3) {
            return r3 ? 4294967296 * e2 + (t2 >>> 0) : 4294967296 * (e2 >>> 0) + (t2 >>> 0);
          }
          function Uu(t2, e2, r3) {
            var n2 = e2 <= 16383 ? 1 : e2 <= 2097151 ? 2 : e2 <= 268435455 ? 3 : Math.floor(Math.log(e2) / (7 * Math.LN2));
            r3.realloc(n2);
            for (var i2 = r3.pos - 1; i2 >= t2; i2--)
              r3.buf[i2 + n2] = r3.buf[i2];
          }
          function $u2(t2, e2) {
            for (var r3 = 0; r3 < t2.length; r3++)
              e2.writeVarint(t2[r3]);
          }
          function Ou(t2, e2) {
            for (var r3 = 0; r3 < t2.length; r3++)
              e2.writeSVarint(t2[r3]);
          }
          function qu2(t2, e2) {
            for (var r3 = 0; r3 < t2.length; r3++)
              e2.writeFloat(t2[r3]);
          }
          function Nu(t2, e2) {
            for (var r3 = 0; r3 < t2.length; r3++)
              e2.writeDouble(t2[r3]);
          }
          function ju2(t2, e2) {
            for (var r3 = 0; r3 < t2.length; r3++)
              e2.writeBoolean(t2[r3]);
          }
          function Gu2(t2, e2) {
            for (var r3 = 0; r3 < t2.length; r3++)
              e2.writeFixed32(t2[r3]);
          }
          function Zu2(t2, e2) {
            for (var r3 = 0; r3 < t2.length; r3++)
              e2.writeSFixed32(t2[r3]);
          }
          function Xu2(t2, e2) {
            for (var r3 = 0; r3 < t2.length; r3++)
              e2.writeFixed64(t2[r3]);
          }
          function Ku2(t2, e2) {
            for (var r3 = 0; r3 < t2.length; r3++)
              e2.writeSFixed64(t2[r3]);
          }
          function Hu2(t2, e2) {
            return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + 16777216 * t2[e2 + 3];
          }
          function Yu2(t2, e2, r3) {
            t2[r3] = e2, t2[r3 + 1] = e2 >>> 8, t2[r3 + 2] = e2 >>> 16, t2[r3 + 3] = e2 >>> 24;
          }
          function Ju2(t2, e2) {
            return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + (t2[e2 + 3] << 24);
          }
          function Wu2(t2, e2, r3) {
            e2.glyphs = [], t2 === 1 && r3.readMessage(Qu2, e2);
          }
          function Qu2(t2, e2, r3) {
            if (t2 === 3) {
              const { id: t3, bitmap: n2, width: i2, height: s2, left: a2, top: o2, advance: l2 } = r3.readMessage(tc2, {});
              e2.glyphs.push({ id: t3, bitmap: new qo2({ width: i2 + 6, height: s2 + 6 }, n2), metrics: { width: i2, height: s2, left: a2, top: o2, advance: l2 } });
            } else
              t2 === 4 ? e2.ascender = r3.readSVarint() : t2 === 5 && (e2.descender = r3.readSVarint());
          }
          function tc2(t2, e2, r3) {
            t2 === 1 ? e2.id = r3.readVarint() : t2 === 2 ? e2.bitmap = r3.readBytes() : t2 === 3 ? e2.width = r3.readVarint() : t2 === 4 ? e2.height = r3.readVarint() : t2 === 5 ? e2.left = r3.readSVarint() : t2 === 6 ? e2.top = r3.readSVarint() : t2 === 7 && (e2.advance = r3.readVarint());
          }
          function ec2(t2) {
            let e2 = 0, r3 = 0;
            for (const n3 of t2)
              e2 += n3.w * n3.h, r3 = Math.max(r3, n3.w);
            t2.sort((t3, e3) => e3.h - t3.h);
            const n2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r3), h: 1 / 0 }];
            let i2 = 0, s2 = 0;
            for (const e3 of t2)
              for (let t3 = n2.length - 1; t3 >= 0; t3--) {
                const r4 = n2[t3];
                if (!(e3.w > r4.w || e3.h > r4.h)) {
                  if (e3.x = r4.x, e3.y = r4.y, s2 = Math.max(s2, e3.y + e3.h), i2 = Math.max(i2, e3.x + e3.w), e3.w === r4.w && e3.h === r4.h) {
                    const e4 = n2.pop();
                    t3 < n2.length && (n2[t3] = e4);
                  } else
                    e3.h === r4.h ? (r4.x += e3.w, r4.w -= e3.w) : e3.w === r4.w ? (r4.y += e3.h, r4.h -= e3.h) : (n2.push({ x: r4.x + e3.w, y: r4.y, w: r4.w - e3.w, h: e3.h }), r4.y += e3.h, r4.h -= e3.h);
                  break;
                }
              }
            return { w: i2, h: s2, fill: e2 / (i2 * s2) || 0 };
          }
          Pu.prototype = { destroy: function() {
            this.buf = null;
          }, readFields: function(t2, e2, r3) {
            for (r3 = r3 || this.length; this.pos < r3; ) {
              var n2 = this.readVarint(), i2 = n2 >> 3, s2 = this.pos;
              this.type = 7 & n2, t2(i2, e2, this), this.pos === s2 && this.skip(n2);
            }
            return e2;
          }, readMessage: function(t2, e2) {
            return this.readFields(t2, e2, this.readVarint() + this.pos);
          }, readFixed32: function() {
            var t2 = Hu2(this.buf, this.pos);
            return this.pos += 4, t2;
          }, readSFixed32: function() {
            var t2 = Ju2(this.buf, this.pos);
            return this.pos += 4, t2;
          }, readFixed64: function() {
            var t2 = Hu2(this.buf, this.pos) + Hu2(this.buf, this.pos + 4) * Du;
            return this.pos += 8, t2;
          }, readSFixed64: function() {
            var t2 = Hu2(this.buf, this.pos) + Ju2(this.buf, this.pos + 4) * Du;
            return this.pos += 8, t2;
          }, readFloat: function() {
            var t2 = Eu2(this.buf, this.pos, true, 23, 4);
            return this.pos += 4, t2;
          }, readDouble: function() {
            var t2 = Eu2(this.buf, this.pos, true, 52, 8);
            return this.pos += 8, t2;
          }, readVarint: function(t2) {
            var e2, r3, n2 = this.buf;
            return e2 = 127 & (r3 = n2[this.pos++]), r3 < 128 ? e2 : (e2 |= (127 & (r3 = n2[this.pos++])) << 7, r3 < 128 ? e2 : (e2 |= (127 & (r3 = n2[this.pos++])) << 14, r3 < 128 ? e2 : (e2 |= (127 & (r3 = n2[this.pos++])) << 21, r3 < 128 ? e2 : function(t3, e3, r4) {
              var n3, i2, s2 = r4.buf;
              if (n3 = (112 & (i2 = s2[r4.pos++])) >> 4, i2 < 128)
                return Ru(t3, n3, e3);
              if (n3 |= (127 & (i2 = s2[r4.pos++])) << 3, i2 < 128)
                return Ru(t3, n3, e3);
              if (n3 |= (127 & (i2 = s2[r4.pos++])) << 10, i2 < 128)
                return Ru(t3, n3, e3);
              if (n3 |= (127 & (i2 = s2[r4.pos++])) << 17, i2 < 128)
                return Ru(t3, n3, e3);
              if (n3 |= (127 & (i2 = s2[r4.pos++])) << 24, i2 < 128)
                return Ru(t3, n3, e3);
              if (n3 |= (1 & (i2 = s2[r4.pos++])) << 31, i2 < 128)
                return Ru(t3, n3, e3);
              throw new Error("Expected varint not more than 10 bytes");
            }(e2 |= (15 & (r3 = n2[this.pos])) << 28, t2, this))));
          }, readVarint64: function() {
            return this.readVarint(true);
          }, readSVarint: function() {
            var t2 = this.readVarint();
            return t2 % 2 == 1 ? (t2 + 1) / -2 : t2 / 2;
          }, readBoolean: function() {
            return Boolean(this.readVarint());
          }, readString: function() {
            var t2 = this.readVarint() + this.pos, e2 = this.pos;
            return this.pos = t2, t2 - e2 >= 12 && Lu ? function(t3, e3, r3) {
              return Lu.decode(t3.subarray(e3, r3));
            }(this.buf, e2, t2) : function(t3, e3, r3) {
              for (var n2 = "", i2 = e3; i2 < r3; ) {
                var s2, a2, o2, l2 = t3[i2], u2 = null, c2 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
                if (i2 + c2 > r3)
                  break;
                c2 === 1 ? l2 < 128 && (u2 = l2) : c2 === 2 ? (192 & (s2 = t3[i2 + 1])) == 128 && (u2 = (31 & l2) << 6 | 63 & s2) <= 127 && (u2 = null) : c2 === 3 ? (a2 = t3[i2 + 2], (192 & (s2 = t3[i2 + 1])) == 128 && (192 & a2) == 128 && ((u2 = (15 & l2) << 12 | (63 & s2) << 6 | 63 & a2) <= 2047 || u2 >= 55296 && u2 <= 57343) && (u2 = null)) : c2 === 4 && (a2 = t3[i2 + 2], o2 = t3[i2 + 3], (192 & (s2 = t3[i2 + 1])) == 128 && (192 & a2) == 128 && (192 & o2) == 128 && ((u2 = (15 & l2) << 18 | (63 & s2) << 12 | (63 & a2) << 6 | 63 & o2) <= 65535 || u2 >= 1114112) && (u2 = null)), u2 === null ? (u2 = 65533, c2 = 1) : u2 > 65535 && (u2 -= 65536, n2 += String.fromCharCode(u2 >>> 10 & 1023 | 55296), u2 = 56320 | 1023 & u2), n2 += String.fromCharCode(u2), i2 += c2;
              }
              return n2;
            }(this.buf, e2, t2);
          }, readBytes: function() {
            var t2 = this.readVarint() + this.pos, e2 = this.buf.subarray(this.pos, t2);
            return this.pos = t2, e2;
          }, readPackedVarint: function(t2, e2) {
            if (this.type !== Pu.Bytes)
              return t2.push(this.readVarint(e2));
            var r3 = Fu(this);
            for (t2 = t2 || []; this.pos < r3; )
              t2.push(this.readVarint(e2));
            return t2;
          }, readPackedSVarint: function(t2) {
            if (this.type !== Pu.Bytes)
              return t2.push(this.readSVarint());
            var e2 = Fu(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readSVarint());
            return t2;
          }, readPackedBoolean: function(t2) {
            if (this.type !== Pu.Bytes)
              return t2.push(this.readBoolean());
            var e2 = Fu(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readBoolean());
            return t2;
          }, readPackedFloat: function(t2) {
            if (this.type !== Pu.Bytes)
              return t2.push(this.readFloat());
            var e2 = Fu(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readFloat());
            return t2;
          }, readPackedDouble: function(t2) {
            if (this.type !== Pu.Bytes)
              return t2.push(this.readDouble());
            var e2 = Fu(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readDouble());
            return t2;
          }, readPackedFixed32: function(t2) {
            if (this.type !== Pu.Bytes)
              return t2.push(this.readFixed32());
            var e2 = Fu(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readFixed32());
            return t2;
          }, readPackedSFixed32: function(t2) {
            if (this.type !== Pu.Bytes)
              return t2.push(this.readSFixed32());
            var e2 = Fu(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readSFixed32());
            return t2;
          }, readPackedFixed64: function(t2) {
            if (this.type !== Pu.Bytes)
              return t2.push(this.readFixed64());
            var e2 = Fu(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readFixed64());
            return t2;
          }, readPackedSFixed64: function(t2) {
            if (this.type !== Pu.Bytes)
              return t2.push(this.readSFixed64());
            var e2 = Fu(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readSFixed64());
            return t2;
          }, skip: function(t2) {
            var e2 = 7 & t2;
            if (e2 === Pu.Varint)
              for (; this.buf[this.pos++] > 127; )
                ;
            else if (e2 === Pu.Bytes)
              this.pos = this.readVarint() + this.pos;
            else if (e2 === Pu.Fixed32)
              this.pos += 4;
            else {
              if (e2 !== Pu.Fixed64)
                throw new Error("Unimplemented type: " + e2);
              this.pos += 8;
            }
          }, writeTag: function(t2, e2) {
            this.writeVarint(t2 << 3 | e2);
          }, realloc: function(t2) {
            for (var e2 = this.length || 16; e2 < this.pos + t2; )
              e2 *= 2;
            if (e2 !== this.length) {
              var r3 = new Uint8Array(e2);
              r3.set(this.buf), this.buf = r3, this.length = e2;
            }
          }, finish: function() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }, writeFixed32: function(t2) {
            this.realloc(4), Yu2(this.buf, t2, this.pos), this.pos += 4;
          }, writeSFixed32: function(t2) {
            this.realloc(4), Yu2(this.buf, t2, this.pos), this.pos += 4;
          }, writeFixed64: function(t2) {
            this.realloc(8), Yu2(this.buf, -1 & t2, this.pos), Yu2(this.buf, Math.floor(t2 * Vu2), this.pos + 4), this.pos += 8;
          }, writeSFixed64: function(t2) {
            this.realloc(8), Yu2(this.buf, -1 & t2, this.pos), Yu2(this.buf, Math.floor(t2 * Vu2), this.pos + 4), this.pos += 8;
          }, writeVarint: function(t2) {
            (t2 = +t2 || 0) > 268435455 || t2 < 0 ? function(t3, e2) {
              var r3, n2;
              if (t3 >= 0 ? (r3 = t3 % 4294967296 | 0, n2 = t3 / 4294967296 | 0) : (n2 = ~(-t3 / 4294967296), 4294967295 ^ (r3 = ~(-t3 % 4294967296)) ? r3 = r3 + 1 | 0 : (r3 = 0, n2 = n2 + 1 | 0)), t3 >= 18446744073709552e3 || t3 < -18446744073709552e3)
                throw new Error("Given varint doesn't fit into 10 bytes");
              e2.realloc(10), function(t4, e3, r4) {
                r4.buf[r4.pos++] = 127 & t4 | 128, t4 >>>= 7, r4.buf[r4.pos++] = 127 & t4 | 128, t4 >>>= 7, r4.buf[r4.pos++] = 127 & t4 | 128, t4 >>>= 7, r4.buf[r4.pos++] = 127 & t4 | 128, r4.buf[r4.pos] = 127 & (t4 >>>= 7);
              }(r3, 0, e2), function(t4, e3) {
                var r4 = (7 & t4) << 4;
                e3.buf[e3.pos++] |= r4 | ((t4 >>>= 3) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4)))));
              }(n2, e2);
            }(t2, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t2 | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = t2 >>> 7 & 127))));
          }, writeSVarint: function(t2) {
            this.writeVarint(t2 < 0 ? 2 * -t2 - 1 : 2 * t2);
          }, writeBoolean: function(t2) {
            this.writeVarint(Boolean(t2));
          }, writeString: function(t2) {
            t2 = String(t2), this.realloc(4 * t2.length), this.pos++;
            var e2 = this.pos;
            this.pos = function(t3, e3, r4) {
              for (var n2, i2, s2 = 0; s2 < e3.length; s2++) {
                if ((n2 = e3.charCodeAt(s2)) > 55295 && n2 < 57344) {
                  if (!i2) {
                    n2 > 56319 || s2 + 1 === e3.length ? (t3[r4++] = 239, t3[r4++] = 191, t3[r4++] = 189) : i2 = n2;
                    continue;
                  }
                  if (n2 < 56320) {
                    t3[r4++] = 239, t3[r4++] = 191, t3[r4++] = 189, i2 = n2;
                    continue;
                  }
                  n2 = i2 - 55296 << 10 | n2 - 56320 | 65536, i2 = null;
                } else
                  i2 && (t3[r4++] = 239, t3[r4++] = 191, t3[r4++] = 189, i2 = null);
                n2 < 128 ? t3[r4++] = n2 : (n2 < 2048 ? t3[r4++] = n2 >> 6 | 192 : (n2 < 65536 ? t3[r4++] = n2 >> 12 | 224 : (t3[r4++] = n2 >> 18 | 240, t3[r4++] = n2 >> 12 & 63 | 128), t3[r4++] = n2 >> 6 & 63 | 128), t3[r4++] = 63 & n2 | 128);
              }
              return r4;
            }(this.buf, t2, this.pos);
            var r3 = this.pos - e2;
            r3 >= 128 && Uu(e2, r3, this), this.pos = e2 - 1, this.writeVarint(r3), this.pos += r3;
          }, writeFloat: function(t2) {
            this.realloc(4), Bu(this.buf, t2, this.pos, true, 23, 4), this.pos += 4;
          }, writeDouble: function(t2) {
            this.realloc(8), Bu(this.buf, t2, this.pos, true, 52, 8), this.pos += 8;
          }, writeBytes: function(t2) {
            var e2 = t2.length;
            this.writeVarint(e2), this.realloc(e2);
            for (var r3 = 0; r3 < e2; r3++)
              this.buf[this.pos++] = t2[r3];
          }, writeRawMessage: function(t2, e2) {
            this.pos++;
            var r3 = this.pos;
            t2(e2, this);
            var n2 = this.pos - r3;
            n2 >= 128 && Uu(r3, n2, this), this.pos = r3 - 1, this.writeVarint(n2), this.pos += n2;
          }, writeMessage: function(t2, e2, r3) {
            this.writeTag(t2, Pu.Bytes), this.writeRawMessage(e2, r3);
          }, writePackedVarint: function(t2, e2) {
            e2.length && this.writeMessage(t2, $u2, e2);
          }, writePackedSVarint: function(t2, e2) {
            e2.length && this.writeMessage(t2, Ou, e2);
          }, writePackedBoolean: function(t2, e2) {
            e2.length && this.writeMessage(t2, ju2, e2);
          }, writePackedFloat: function(t2, e2) {
            e2.length && this.writeMessage(t2, qu2, e2);
          }, writePackedDouble: function(t2, e2) {
            e2.length && this.writeMessage(t2, Nu, e2);
          }, writePackedFixed32: function(t2, e2) {
            e2.length && this.writeMessage(t2, Gu2, e2);
          }, writePackedSFixed32: function(t2, e2) {
            e2.length && this.writeMessage(t2, Zu2, e2);
          }, writePackedFixed64: function(t2, e2) {
            e2.length && this.writeMessage(t2, Xu2, e2);
          }, writePackedSFixed64: function(t2, e2) {
            e2.length && this.writeMessage(t2, Ku2, e2);
          }, writeBytesField: function(t2, e2) {
            this.writeTag(t2, Pu.Bytes), this.writeBytes(e2);
          }, writeFixed32Field: function(t2, e2) {
            this.writeTag(t2, Pu.Fixed32), this.writeFixed32(e2);
          }, writeSFixed32Field: function(t2, e2) {
            this.writeTag(t2, Pu.Fixed32), this.writeSFixed32(e2);
          }, writeFixed64Field: function(t2, e2) {
            this.writeTag(t2, Pu.Fixed64), this.writeFixed64(e2);
          }, writeSFixed64Field: function(t2, e2) {
            this.writeTag(t2, Pu.Fixed64), this.writeSFixed64(e2);
          }, writeVarintField: function(t2, e2) {
            this.writeTag(t2, Pu.Varint), this.writeVarint(e2);
          }, writeSVarintField: function(t2, e2) {
            this.writeTag(t2, Pu.Varint), this.writeSVarint(e2);
          }, writeStringField: function(t2, e2) {
            this.writeTag(t2, Pu.Bytes), this.writeString(e2);
          }, writeFloatField: function(t2, e2) {
            this.writeTag(t2, Pu.Fixed32), this.writeFloat(e2);
          }, writeDoubleField: function(t2, e2) {
            this.writeTag(t2, Pu.Fixed64), this.writeDouble(e2);
          }, writeBooleanField: function(t2, e2) {
            this.writeVarintField(t2, Boolean(e2));
          } };
          class rc2 {
            constructor(t2, { pixelRatio: e2, version: r3, stretchX: n2, stretchY: i2, content: s2 }) {
              this.paddedRect = t2, this.pixelRatio = e2, this.stretchX = n2, this.stretchY = i2, this.content = s2, this.version = r3;
            }
            get tl() {
              return [this.paddedRect.x + 1, this.paddedRect.y + 1];
            }
            get br() {
              return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
            }
            get displaySize() {
              return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
            }
          }
          class nc {
            constructor(t2, e2) {
              const r3 = {}, n2 = {};
              this.haveRenderCallbacks = [];
              const i2 = [];
              this.addImages(t2, r3, i2), this.addImages(e2, n2, i2);
              const { w: s2, h: a2 } = ec2(i2), o2 = new No2({ width: s2 || 1, height: a2 || 1 });
              for (const e3 in t2) {
                const n3 = t2[e3], i3 = r3[e3].paddedRect;
                No2.copy(n3.data, o2, { x: 0, y: 0 }, { x: i3.x + 1, y: i3.y + 1 }, n3.data);
              }
              for (const t3 in e2) {
                const r4 = e2[t3], i3 = n2[t3].paddedRect, s3 = i3.x + 1, a3 = i3.y + 1, l2 = r4.data.width, u2 = r4.data.height;
                No2.copy(r4.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 }, r4.data), No2.copy(r4.data, o2, { x: 0, y: u2 - 1 }, { x: s3, y: a3 - 1 }, { width: l2, height: 1 }), No2.copy(r4.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 + u2 }, { width: l2, height: 1 }), No2.copy(r4.data, o2, { x: l2 - 1, y: 0 }, { x: s3 - 1, y: a3 }, { width: 1, height: u2 }), No2.copy(r4.data, o2, { x: 0, y: 0 }, { x: s3 + l2, y: a3 }, { width: 1, height: u2 });
              }
              this.image = o2, this.iconPositions = r3, this.patternPositions = n2;
            }
            addImages(t2, e2, r3) {
              for (const n2 in t2) {
                const i2 = t2[n2], s2 = { x: 0, y: 0, w: i2.data.width + 2, h: i2.data.height + 2 };
                r3.push(s2), e2[n2] = new rc2(s2, i2), i2.hasRenderCallback && this.haveRenderCallbacks.push(n2);
              }
            }
            patchUpdatedImages(t2, e2) {
              t2.dispatchRenderCallbacks(this.haveRenderCallbacks);
              for (const r3 in t2.updatedImages)
                this.patchUpdatedImage(this.iconPositions[r3], t2.getImage(r3), e2), this.patchUpdatedImage(this.patternPositions[r3], t2.getImage(r3), e2);
            }
            patchUpdatedImage(t2, e2, r3) {
              if (!t2 || !e2)
                return;
              if (t2.version === e2.version)
                return;
              t2.version = e2.version;
              const [n2, i2] = t2.tl;
              r3.update(e2.data, void 0, { x: n2, y: i2 });
            }
          }
          oi2("ImagePosition", rc2), oi2("ImageAtlas", nc);
          const ic = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
          class sc {
            constructor() {
              this.scale = 1, this.fontStack = "", this.imageName = null;
            }
            static forText(t2, e2) {
              const r3 = new sc();
              return r3.scale = t2 || 1, r3.fontStack = e2, r3;
            }
            static forImage(t2) {
              const e2 = new sc();
              return e2.imageName = t2, e2;
            }
          }
          class ac2 {
            constructor() {
              this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
            }
            static fromFeature(t2, e2) {
              const r3 = new ac2();
              for (let n2 = 0; n2 < t2.sections.length; n2++) {
                const i2 = t2.sections[n2];
                i2.image ? r3.addImageSection(i2) : r3.addTextSection(i2, e2);
              }
              return r3;
            }
            length() {
              return this.text.length;
            }
            getSection(t2) {
              return this.sections[this.sectionIndex[t2]];
            }
            getSections() {
              return this.sections;
            }
            getSectionIndex(t2) {
              return this.sectionIndex[t2];
            }
            getCharCode(t2) {
              return this.text.charCodeAt(t2);
            }
            verticalizePunctuation(t2) {
              this.text = function(t3, e2) {
                let r3 = "";
                for (let n2 = 0; n2 < t3.length; n2++) {
                  const i2 = t3.charCodeAt(n2 + 1) || null, s2 = t3.charCodeAt(n2 - 1) || null;
                  r3 += !e2 && (i2 && ji2(i2) && !zu2[t3[n2 + 1]] || s2 && ji2(s2) && !zu2[t3[n2 - 1]]) || !zu2[t3[n2]] ? t3[n2] : zu2[t3[n2]];
                }
                return r3;
              }(this.text, t2);
            }
            trim() {
              let t2 = 0;
              for (let e3 = 0; e3 < this.text.length && lc2[this.text.charCodeAt(e3)]; e3++)
                t2++;
              let e2 = this.text.length;
              for (let r3 = this.text.length - 1; r3 >= 0 && r3 >= t2 && lc2[this.text.charCodeAt(r3)]; r3--)
                e2--;
              this.text = this.text.substring(t2, e2), this.sectionIndex = this.sectionIndex.slice(t2, e2);
            }
            substring(t2, e2) {
              const r3 = new ac2();
              return r3.text = this.text.substring(t2, e2), r3.sectionIndex = this.sectionIndex.slice(t2, e2), r3.sections = this.sections, r3;
            }
            toString() {
              return this.text;
            }
            getMaxScale() {
              return this.sectionIndex.reduce((t2, e2) => Math.max(t2, this.sections[e2].scale), 0);
            }
            addTextSection(t2, e2) {
              this.text += t2.text, this.sections.push(sc.forText(t2.scale, t2.fontStack || e2));
              const r3 = this.sections.length - 1;
              for (let e3 = 0; e3 < t2.text.length; ++e3)
                this.sectionIndex.push(r3);
            }
            addImageSection(t2) {
              const e2 = t2.image ? t2.image.name : "";
              if (e2.length === 0)
                return void B("Can't add FormattedSection with an empty image.");
              const r3 = this.getNextImageSectionCharCode();
              r3 ? (this.text += String.fromCharCode(r3), this.sections.push(sc.forImage(e2)), this.sectionIndex.push(this.sections.length - 1)) : B("Reached maximum number of images 6401");
            }
            getNextImageSectionCharCode() {
              return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
            }
          }
          function oc(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, y2) {
            const m2 = ac2.fromFeature(t2, i2);
            let g2;
            h2 === ic.vertical && m2.verticalizePunctuation(p2);
            const { processBidirectionalText: x3, processStyledBidirectionalText: v2 } = ss2;
            if (x3 && m2.sections.length === 1) {
              g2 = [];
              const t3 = x3(m2.toString(), yc2(m2, u2, s2, e2, n2, d2, f2));
              for (const e3 of t3) {
                const t4 = new ac2();
                t4.text = e3, t4.sections = m2.sections;
                for (let r4 = 0; r4 < e3.length; r4++)
                  t4.sectionIndex.push(0);
                g2.push(t4);
              }
            } else if (v2) {
              g2 = [];
              const t3 = v2(m2.text, m2.sectionIndex, yc2(m2, u2, s2, e2, n2, d2, f2));
              for (const e3 of t3) {
                const t4 = new ac2();
                t4.text = e3[0], t4.sectionIndex = e3[1], t4.sections = m2.sections, g2.push(t4);
              }
            } else
              g2 = function(t3, e3) {
                const r4 = [], n3 = t3.text;
                let i3 = 0;
                for (const n4 of e3)
                  r4.push(t3.substring(i3, n4)), i3 = n4;
                return i3 < n3.length && r4.push(t3.substring(i3, n3.length)), r4;
              }(m2, yc2(m2, u2, s2, e2, n2, d2, f2));
            const b2 = [], w3 = { positionedLines: b2, text: m2.toString(), top: c2[1], bottom: c2[1], left: c2[0], right: c2[0], writingMode: h2, iconsInText: false, verticalizable: false, hasBaseline: false };
            return function(t3, e3, r4, n3, i3, s3, a3, o3, l3, u3, c3, h3) {
              let p3 = 0, d3 = 0, f3 = 0;
              const y3 = o3 === "right" ? 1 : o3 === "left" ? 0 : 0.5;
              let m3 = false;
              for (const t4 of i3) {
                const r5 = t4.getSections();
                for (const t5 of r5) {
                  if (t5.imageName)
                    continue;
                  const r6 = e3[t5.fontStack];
                  if (r6 && (m3 = r6.ascender !== void 0 && r6.descender !== void 0, !m3))
                    break;
                }
                if (!m3)
                  break;
              }
              let g3 = 0;
              for (const a4 of i3) {
                a4.trim();
                const i4 = a4.getMaxScale(), o4 = (i4 - 1) * bu, v4 = { positionedGlyphs: [], lineOffset: 0 };
                t3.positionedLines[g3] = v4;
                const b4 = v4.positionedGlyphs;
                let w5 = 0;
                if (!a4.length()) {
                  d3 += s3, ++g3;
                  continue;
                }
                let _2 = 0, k3 = 0;
                for (let s4 = 0; s4 < a4.length(); s4++) {
                  const o5 = a4.getSection(s4), f4 = a4.getSectionIndex(s4), y4 = a4.getCharCode(s4);
                  let g4 = o5.scale, v5 = null, A3 = null, S2 = null, I3 = bu, z2 = 0;
                  const T2 = !(l3 === ic.horizontal || !c3 && !Ni2(y4) || c3 && (lc2[y4] || (x4 = y4, di(x4) || fi(x4) || yi2(x4) || Di2(x4) || Ri(x4))));
                  if (o5.imageName) {
                    const e4 = n3[o5.imageName];
                    if (!e4)
                      continue;
                    S2 = o5.imageName, t3.iconsInText = t3.iconsInText || true, A3 = e4.paddedRect;
                    const r5 = e4.displaySize;
                    g4 = g4 * bu / h3, v5 = { width: r5[0], height: r5[1], left: 1, top: -3, advance: T2 ? r5[1] : r5[0], localGlyph: false }, z2 = m3 ? -v5.height * g4 : i4 * bu - 17 - r5[1] * g4, I3 = v5.advance;
                    const s5 = (T2 ? r5[0] : r5[1]) * g4 - bu * i4;
                    s5 > 0 && s5 > w5 && (w5 = s5);
                  } else {
                    const t4 = r4[o5.fontStack];
                    if (!t4)
                      continue;
                    t4[y4] && (A3 = t4[y4]);
                    const n4 = e3[o5.fontStack];
                    if (!n4)
                      continue;
                    const s5 = n4.glyphs[y4];
                    if (!s5)
                      continue;
                    if (v5 = s5.metrics, I3 = y4 !== 8203 ? bu : 0, m3) {
                      const t5 = n4.ascender !== void 0 ? Math.abs(n4.ascender) : 0, e4 = n4.descender !== void 0 ? Math.abs(n4.descender) : 0, r5 = (t5 + e4) * g4;
                      _2 < r5 && (_2 = r5, k3 = (t5 - e4) / 2 * g4), z2 = -t5 * g4;
                    } else
                      z2 = (i4 - g4) * bu - 17;
                  }
                  T2 ? (t3.verticalizable = true, b4.push({ glyph: y4, imageName: S2, x: p3, y: d3 + z2, vertical: T2, scale: g4, localGlyph: v5.localGlyph, fontStack: o5.fontStack, sectionIndex: f4, metrics: v5, rect: A3 }), p3 += I3 * g4 + u3) : (b4.push({ glyph: y4, imageName: S2, x: p3, y: d3 + z2, vertical: T2, scale: g4, localGlyph: v5.localGlyph, fontStack: o5.fontStack, sectionIndex: f4, metrics: v5, rect: A3 }), p3 += v5.advance * g4 + u3);
                }
                b4.length !== 0 && (f3 = Math.max(p3 - u3, f3), m3 ? gc2(b4, y3, w5, k3, s3 * i4 / 2) : gc2(b4, y3, w5, 0, s3 / 2)), p3 = 0;
                const A2 = s3 * i4 + w5;
                v4.lineOffset = Math.max(w5, o4), d3 += A2, ++g3;
              }
              var x4;
              const v3 = d3, { horizontalAlign: b3, verticalAlign: w4 } = mc2(a3);
              (function(t4, e4, r5, n4, i4, s4) {
                const a4 = (e4 - r5) * i4, o4 = -s4 * n4;
                for (const e5 of t4)
                  for (const t5 of e5.positionedGlyphs)
                    t5.x += a4, t5.y += o4;
              })(t3.positionedLines, y3, b3, w4, f3, v3), t3.top += -w4 * v3, t3.bottom = t3.top + v3, t3.left += -b3 * f3, t3.right = t3.left + f3, t3.hasBaseline = m3;
            }(w3, e2, r3, n2, g2, a2, o2, l2, h2, u2, p2, y2), !function(t3) {
              for (const e3 of t3)
                if (e3.positionedGlyphs.length !== 0)
                  return false;
              return true;
            }(b2) && w3;
          }
          const lc2 = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, uc2 = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
          function cc2(t2, e2, r3, n2, i2, s2) {
            if (e2.imageName) {
              const t3 = n2[e2.imageName];
              return t3 ? t3.displaySize[0] * e2.scale * bu / s2 + i2 : 0;
            }
            {
              const n3 = r3[e2.fontStack], s3 = n3 && n3.glyphs[t2];
              return s3 ? s3.metrics.advance * e2.scale + i2 : 0;
            }
          }
          function hc2(t2, e2, r3, n2) {
            const i2 = Math.pow(t2 - e2, 2);
            return n2 ? t2 < e2 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r3) * r3;
          }
          function pc2(t2, e2, r3) {
            let n2 = 0;
            return t2 === 10 && (n2 -= 1e4), r3 && (n2 += 150), t2 !== 40 && t2 !== 65288 || (n2 += 50), e2 !== 41 && e2 !== 65289 || (n2 += 50), n2;
          }
          function dc2(t2, e2, r3, n2, i2, s2) {
            let a2 = null, o2 = hc2(e2, r3, i2, s2);
            for (const t3 of n2) {
              const n3 = hc2(e2 - t3.x, r3, i2, s2) + t3.badness;
              n3 <= o2 && (a2 = t3, o2 = n3);
            }
            return { index: t2, x: e2, priorBreak: a2, badness: o2 };
          }
          function fc2(t2) {
            return t2 ? fc2(t2.priorBreak).concat(t2.index) : [];
          }
          function yc2(t2, e2, r3, n2, i2, s2, a2) {
            if (s2 !== "point")
              return [];
            if (!t2)
              return [];
            const o2 = [], l2 = function(t3, e3, r4, n3, i3, s3) {
              let a3 = 0;
              for (let r5 = 0; r5 < t3.length(); r5++) {
                const o3 = t3.getSection(r5);
                a3 += cc2(t3.getCharCode(r5), o3, n3, i3, e3, s3);
              }
              return a3 / Math.max(1, Math.ceil(a3 / r4));
            }(t2, e2, r3, n2, i2, a2), u2 = t2.text.indexOf("\u200B") >= 0;
            let c2 = 0;
            for (let r4 = 0; r4 < t2.length(); r4++) {
              const s3 = t2.getSection(r4), p2 = t2.getCharCode(r4);
              if (lc2[p2] || (c2 += cc2(p2, s3, n2, i2, e2, a2)), r4 < t2.length() - 1) {
                const e3 = !((h2 = p2) < 11904 || !(ki2(h2) || _i(h2) || Li2(h2) || Pi2(h2) || zi2(h2) || mi(h2) || Ai2(h2) || vi2(h2) || Ti2(h2) || Mi2(h2) || Ii2(h2) || Ui2(h2) || bi2(h2) || xi2(h2) || gi(h2) || Si2(h2) || wi2(h2) || Vi2(h2) || Bi2(h2) || Ei2(h2)));
                (uc2[p2] || e3 || s3.imageName) && o2.push(dc2(r4 + 1, c2, l2, o2, pc2(p2, t2.getCharCode(r4 + 1), e3 && u2), false));
              }
            }
            var h2;
            return fc2(dc2(t2.length(), c2, l2, o2, 0, true));
          }
          function mc2(t2) {
            let e2 = 0.5, r3 = 0.5;
            switch (t2) {
              case "right":
              case "top-right":
              case "bottom-right":
                e2 = 1;
                break;
              case "left":
              case "top-left":
              case "bottom-left":
                e2 = 0;
            }
            switch (t2) {
              case "bottom":
              case "bottom-right":
              case "bottom-left":
                r3 = 1;
                break;
              case "top":
              case "top-right":
              case "top-left":
                r3 = 0;
            }
            return { horizontalAlign: e2, verticalAlign: r3 };
          }
          function gc2(t2, e2, r3, n2, i2) {
            if (!(e2 || r3 || n2 || i2))
              return;
            const s2 = t2.length - 1, a2 = t2[s2], o2 = (a2.x + a2.metrics.advance * a2.scale) * e2;
            for (let e3 = 0; e3 <= s2; e3++)
              t2[e3].x -= o2, t2[e3].y += r3 + n2 + i2;
          }
          function xc2(t2, e2, r3) {
            const { horizontalAlign: n2, verticalAlign: i2 } = mc2(r3), s2 = e2[0] - t2.displaySize[0] * n2, a2 = e2[1] - t2.displaySize[1] * i2;
            return { image: t2, top: a2, bottom: a2 + t2.displaySize[1], left: s2, right: s2 + t2.displaySize[0] };
          }
          function vc2(t2, e2, r3, n2, i2, s2) {
            const a2 = t2.image;
            let o2;
            if (a2.content) {
              const t3 = a2.content, e3 = a2.pixelRatio || 1;
              o2 = [t3[0] / e3, t3[1] / e3, a2.displaySize[0] - t3[2] / e3, a2.displaySize[1] - t3[3] / e3];
            }
            const l2 = e2.left * s2, u2 = e2.right * s2;
            let c2, h2, p2, d2;
            r3 === "width" || r3 === "both" ? (d2 = i2[0] + l2 - n2[3], h2 = i2[0] + u2 + n2[1]) : (d2 = i2[0] + (l2 + u2 - a2.displaySize[0]) / 2, h2 = d2 + a2.displaySize[0]);
            const f2 = e2.top * s2, y2 = e2.bottom * s2;
            return r3 === "height" || r3 === "both" ? (c2 = i2[1] + f2 - n2[0], p2 = i2[1] + y2 + n2[2]) : (c2 = i2[1] + (f2 + y2 - a2.displaySize[1]) / 2, p2 = c2 + a2.displaySize[1]), { image: a2, top: c2, right: h2, bottom: p2, left: d2, collisionPadding: o2 };
          }
          class bc2 extends i {
            constructor(t2, e2, r3, n2) {
              super(t2, e2), this.angle = r3, n2 !== void 0 && (this.segment = n2);
            }
            clone() {
              return new bc2(this.x, this.y, this.angle, this.segment);
            }
          }
          function wc(t2, e2, r3, n2, i2) {
            if (e2.segment === void 0)
              return true;
            let s2 = e2, a2 = e2.segment + 1, o2 = 0;
            for (; o2 > -r3 / 2; ) {
              if (a2--, a2 < 0)
                return false;
              o2 -= t2[a2].dist(s2), s2 = t2[a2];
            }
            o2 += t2[a2].dist(t2[a2 + 1]), a2++;
            const l2 = [];
            let u2 = 0;
            for (; o2 < r3 / 2; ) {
              const e3 = t2[a2], r4 = t2[a2 + 1];
              if (!r4)
                return false;
              let s3 = t2[a2 - 1].angleTo(e3) - e3.angleTo(r4);
              for (s3 = Math.abs((s3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l2.push({ distance: o2, angleDelta: s3 }), u2 += s3; o2 - l2[0].distance > n2; )
                u2 -= l2.shift().angleDelta;
              if (u2 > i2)
                return false;
              a2++, o2 += e3.dist(r4);
            }
            return true;
          }
          function _c2(t2) {
            let e2 = 0;
            for (let r3 = 0; r3 < t2.length - 1; r3++)
              e2 += t2[r3].dist(t2[r3 + 1]);
            return e2;
          }
          function kc2(t2, e2, r3) {
            return t2 ? 0.6 * e2 * r3 : 0;
          }
          function Ac(t2, e2) {
            return Math.max(t2 ? t2.right - t2.left : 0, e2 ? e2.right - e2.left : 0);
          }
          function Sc(t2, e2, r3, n2, i2, s2) {
            const a2 = kc2(r3, i2, s2), o2 = Ac(r3, n2) * s2;
            let l2 = 0;
            const u2 = _c2(t2) / 2;
            for (let r4 = 0; r4 < t2.length - 1; r4++) {
              const n3 = t2[r4], i3 = t2[r4 + 1], s3 = n3.dist(i3);
              if (l2 + s3 > u2) {
                const c2 = (u2 - l2) / s3, h2 = rr2(n3.x, i3.x, c2), p2 = rr2(n3.y, i3.y, c2), d2 = new bc2(h2, p2, i3.angleTo(n3), r4);
                return !a2 || wc(t2, d2, o2, a2, e2) ? d2 : void 0;
              }
              l2 += s3;
            }
          }
          function Ic(t2, e2, r3, n2, i2, s2, a2, o2, l2) {
            const u2 = kc2(n2, s2, a2), c2 = Ac(n2, i2), h2 = c2 * a2, p2 = t2[0].x === 0 || t2[0].x === l2 || t2[0].y === 0 || t2[0].y === l2;
            return e2 - h2 < e2 / 4 && (e2 = h2 + e2 / 4), zc2(t2, p2 ? e2 / 2 * o2 % e2 : (c2 / 2 + 2 * s2) * a2 * o2 % e2, e2, u2, r3, h2, p2, false, l2);
          }
          function zc2(t2, e2, r3, n2, i2, s2, a2, o2, l2) {
            const u2 = s2 / 2, c2 = _c2(t2);
            let h2 = 0, p2 = e2 - r3, d2 = [];
            for (let e3 = 0; e3 < t2.length - 1; e3++) {
              const a3 = t2[e3], o3 = t2[e3 + 1], f2 = a3.dist(o3), y2 = o3.angleTo(a3);
              for (; p2 + r3 < h2 + f2; ) {
                p2 += r3;
                const m2 = (p2 - h2) / f2, g2 = rr2(a3.x, o3.x, m2), x3 = rr2(a3.y, o3.y, m2);
                if (g2 >= 0 && g2 < l2 && x3 >= 0 && x3 < l2 && p2 - u2 >= 0 && p2 + u2 <= c2) {
                  const r4 = new bc2(g2, x3, y2, e3);
                  r4._round(), n2 && !wc(t2, r4, s2, n2, i2) || d2.push(r4);
                }
              }
              h2 += f2;
            }
            return o2 || d2.length || a2 || (d2 = zc2(t2, h2 / 2, r3, n2, i2, s2, a2, true, l2)), d2;
          }
          function Tc2(t2, e2, r3, n2, s2) {
            const a2 = [];
            for (let o2 = 0; o2 < t2.length; o2++) {
              const l2 = t2[o2];
              let u2;
              for (let t3 = 0; t3 < l2.length - 1; t3++) {
                let o3 = l2[t3], c2 = l2[t3 + 1];
                o3.x < e2 && c2.x < e2 || (o3.x < e2 ? o3 = new i(e2, o3.y + (e2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round() : c2.x < e2 && (c2 = new i(e2, o3.y + (e2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round()), o3.y < r3 && c2.y < r3 || (o3.y < r3 ? o3 = new i(o3.x + (r3 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), r3)._round() : c2.y < r3 && (c2 = new i(o3.x + (r3 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), r3)._round()), o3.x >= n2 && c2.x >= n2 || (o3.x >= n2 ? o3 = new i(n2, o3.y + (n2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round() : c2.x >= n2 && (c2 = new i(n2, o3.y + (n2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round()), o3.y >= s2 && c2.y >= s2 || (o3.y >= s2 ? o3 = new i(o3.x + (s2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), s2)._round() : c2.y >= s2 && (c2 = new i(o3.x + (s2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), s2)._round()), u2 && o3.equals(u2[u2.length - 1]) || (u2 = [o3], a2.push(u2)), u2.push(c2)))));
              }
            }
            return a2;
          }
          oi2("Anchor", bc2);
          var Mc = Cc, Ec2 = Cc, Bc2 = 1e20;
          function Cc(t2, e2, r3, n2, i2, s2) {
            this.fontSize = t2 || 24, this.buffer = e2 === void 0 ? 3 : e2, this.cutoff = n2 || 0.25, this.fontFamily = i2 || "sans-serif", this.fontWeight = s2 || "normal", this.radius = r3 || 8;
            var a2 = this.size = this.fontSize + 2 * this.buffer, o2 = a2 + 2 * this.buffer;
            this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = a2, this.ctx = this.canvas.getContext("2d"), this.ctx.font = this.fontWeight + " " + this.fontSize + "px " + this.fontFamily, this.ctx.textAlign = "left", this.ctx.fillStyle = "black", this.gridOuter = new Float64Array(o2 * o2), this.gridInner = new Float64Array(o2 * o2), this.f = new Float64Array(o2), this.z = new Float64Array(o2 + 1), this.v = new Uint16Array(o2), this.useMetrics = this.ctx.measureText("A").actualBoundingBoxLeft !== void 0, this.middle = Math.round(a2 / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1));
          }
          function Pc(t2, e2, r3, n2, i2, s2) {
            for (var a2 = 0; a2 < e2; a2++)
              Dc(t2, a2, e2, r3, n2, i2, s2);
            for (var o2 = 0; o2 < r3; o2++)
              Dc(t2, o2 * e2, 1, e2, n2, i2, s2);
          }
          function Dc(t2, e2, r3, n2, i2, s2, a2) {
            var o2, l2, u2, c2;
            for (s2[0] = 0, a2[0] = -Bc2, a2[1] = Bc2, o2 = 0; o2 < n2; o2++)
              i2[o2] = t2[e2 + o2 * r3];
            for (o2 = 1, l2 = 0, u2 = 0; o2 < n2; o2++) {
              do {
                u2 = (i2[o2] - i2[c2 = s2[l2]] + o2 * o2 - c2 * c2) / (o2 - c2) / 2;
              } while (u2 <= a2[l2] && --l2 > -1);
              s2[++l2] = o2, a2[l2] = u2, a2[l2 + 1] = Bc2;
            }
            for (o2 = 0, l2 = 0; o2 < n2; o2++) {
              for (; a2[l2 + 1] < o2; )
                l2++;
              t2[e2 + o2 * r3] = i2[c2 = s2[l2]] + (o2 - c2) * (o2 - c2);
            }
          }
          Cc.prototype._draw = function(t2, e2) {
            var r3, n2, i2, s2, a2, o2, l2, u2, c2, h2 = this.ctx.measureText(t2), p2 = h2.width, d2 = 2 * this.buffer;
            e2 && this.useMetrics ? (a2 = Math.floor(h2.actualBoundingBoxAscent), u2 = this.buffer + Math.ceil(h2.actualBoundingBoxAscent), o2 = this.buffer, l2 = this.buffer, r3 = (n2 = Math.min(this.size, Math.ceil(h2.actualBoundingBoxRight - h2.actualBoundingBoxLeft))) + d2, i2 = (s2 = Math.min(this.size - o2, Math.ceil(h2.actualBoundingBoxAscent + h2.actualBoundingBoxDescent))) + d2, this.ctx.textBaseline = "alphabetic") : (r3 = n2 = this.size, i2 = s2 = this.size, a2 = 19 * this.fontSize / 24, o2 = l2 = 0, u2 = this.middle, this.ctx.textBaseline = "middle"), n2 && s2 && (this.ctx.clearRect(l2, o2, n2, s2), this.ctx.fillText(t2, this.buffer, u2), c2 = this.ctx.getImageData(l2, o2, n2, s2));
            var f2 = new Uint8ClampedArray(r3 * i2);
            return function(t3, e3, r4, n3, i3, s3, a3) {
              s3.fill(Bc2, 0, e3 * r4), a3.fill(0, 0, e3 * r4);
              for (var o3 = (e3 - n3) / 2, l3 = 0; l3 < i3; l3++)
                for (var u3 = 0; u3 < n3; u3++) {
                  var c3 = (l3 + o3) * e3 + u3 + o3, h3 = t3.data[4 * (l3 * n3 + u3) + 3] / 255;
                  if (h3 === 1)
                    s3[c3] = 0, a3[c3] = Bc2;
                  else if (h3 === 0)
                    s3[c3] = Bc2, a3[c3] = 0;
                  else {
                    var p3 = Math.max(0, 0.5 - h3), d3 = Math.max(0, h3 - 0.5);
                    s3[c3] = p3 * p3, a3[c3] = d3 * d3;
                  }
                }
            }(c2, r3, i2, n2, s2, this.gridOuter, this.gridInner), Pc(this.gridOuter, r3, i2, this.f, this.v, this.z), Pc(this.gridInner, r3, i2, this.f, this.v, this.z), function(t3, e3, r4, n3, i3, s3, a3) {
              for (var o3 = 0; o3 < e3 * r4; o3++) {
                var l3 = Math.sqrt(n3[o3]) - Math.sqrt(i3[o3]);
                t3[o3] = Math.round(255 - 255 * (l3 / s3 + a3));
              }
            }(f2, r3, i2, this.gridOuter, this.gridInner, this.radius, this.cutoff), { data: f2, metrics: { width: n2, height: s2, sdfWidth: r3, sdfHeight: i2, top: a2, left: 0, advance: p2 } };
          }, Cc.prototype.draw = function(t2) {
            return this._draw(t2, false).data;
          }, Cc.prototype.drawWithMetrics = function(t2) {
            return this._draw(t2, true);
          }, Mc.default = Ec2;
          const Vc2 = { none: 0, ideographs: 1, all: 2 };
          class Lc {
            constructor(t2, e2, r3) {
              this.requestManager = t2, this.localGlyphMode = e2, this.localFontFamily = r3, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
            }
            setURL(t2) {
              this.url = t2;
            }
            getGlyphs(t2, e2) {
              const r3 = [];
              for (const e3 in t2)
                for (const n2 of t2[e3])
                  r3.push({ stack: e3, id: n2 });
              g(r3, ({ stack: t3, id: e3 }, r4) => {
                let n2 = this.entries[t3];
                n2 || (n2 = this.entries[t3] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
                let i2 = n2.glyphs[e3];
                if (i2 !== void 0)
                  return void r4(null, { stack: t3, id: e3, glyph: i2 });
                if (i2 = this._tinySDF(n2, t3, e3), i2)
                  return n2.glyphs[e3] = i2, void r4(null, { stack: t3, id: e3, glyph: i2 });
                const s2 = Math.floor(e3 / 256);
                if (256 * s2 > 65535)
                  return void r4(new Error("glyphs > 65535 not supported"));
                if (n2.ranges[s2])
                  return void r4(null, { stack: t3, id: e3, glyph: i2 });
                let a2 = n2.requests[s2];
                a2 || (a2 = n2.requests[s2] = [], Lc.loadGlyphRange(t3, s2, this.url, this.requestManager, (t4, e4) => {
                  if (e4) {
                    n2.ascender = e4.ascender, n2.descender = e4.descender;
                    for (const t5 in e4.glyphs)
                      this._doesCharSupportLocalGlyph(+t5) || (n2.glyphs[+t5] = e4.glyphs[+t5]);
                    n2.ranges[s2] = true;
                  }
                  for (const r5 of a2)
                    r5(t4, e4);
                  delete n2.requests[s2];
                })), a2.push((n3, i3) => {
                  n3 ? r4(n3) : i3 && r4(null, { stack: t3, id: e3, glyph: i3.glyphs[e3] || null });
                });
              }, (t3, r4) => {
                if (t3)
                  e2(t3);
                else if (r4) {
                  const t4 = {};
                  for (const { stack: e3, id: n2, glyph: i2 } of r4)
                    t4[e3] === void 0 && (t4[e3] = {}), t4[e3].glyphs === void 0 && (t4[e3].glyphs = {}), t4[e3].glyphs[n2] = i2 && { id: i2.id, bitmap: i2.bitmap.clone(), metrics: i2.metrics }, t4[e3].ascender = this.entries[e3].ascender, t4[e3].descender = this.entries[e3].descender;
                  e2(null, t4);
                }
              });
            }
            _doesCharSupportLocalGlyph(t2) {
              return this.localGlyphMode !== Vc2.none && (this.localGlyphMode === Vc2.all ? !!this.localFontFamily : !!this.localFontFamily && (Mi2(t2) || Ci2(t2) || bi2(t2) || wi2(t2)) || vi2(t2));
            }
            _tinySDF(t2, e2, r3) {
              const n2 = this.localFontFamily;
              if (!n2)
                return;
              if (!this._doesCharSupportLocalGlyph(r3))
                return;
              let i2 = t2.tinySDF;
              if (!i2) {
                let r4 = "400";
                /bold/i.test(e2) ? r4 = "900" : /medium/i.test(e2) ? r4 = "500" : /light/i.test(e2) && (r4 = "200"), i2 = t2.tinySDF = new Lc.TinySDF(48, 6, 16, 0.25, n2, r4);
              }
              if (this.localGlyphs[i2.fontWeight][r3])
                return this.localGlyphs[i2.fontWeight][r3];
              const { data: s2, metrics: a2 } = i2.drawWithMetrics(String.fromCharCode(r3)), { sdfWidth: o2, sdfHeight: l2, width: u2, height: c2, left: h2, top: p2, advance: d2 } = a2;
              return this.localGlyphs[i2.fontWeight][r3] = { id: r3, bitmap: new qo2({ width: o2, height: l2 }, s2), metrics: { width: u2 / 2, height: c2 / 2, left: h2 / 2, top: p2 / 2 - 27, advance: d2 / 2, localGlyph: true } };
            }
          }
          function Fc(t2, e2, r3, n2) {
            const s2 = [], a2 = t2.image, o2 = a2.pixelRatio, l2 = a2.paddedRect.w - 2, u2 = a2.paddedRect.h - 2, c2 = t2.right - t2.left, h2 = t2.bottom - t2.top, p2 = a2.stretchX || [[0, l2]], d2 = a2.stretchY || [[0, u2]], f2 = (t3, e3) => t3 + e3[1] - e3[0], y2 = p2.reduce(f2, 0), m2 = d2.reduce(f2, 0), g2 = l2 - y2, x3 = u2 - m2;
            let v2 = 0, b2 = y2, w3 = 0, _2 = m2, k3 = 0, A2 = g2, S2 = 0, I3 = x3;
            if (a2.content && n2) {
              const t3 = a2.content;
              v2 = Rc(p2, 0, t3[0]), w3 = Rc(d2, 0, t3[1]), b2 = Rc(p2, t3[0], t3[2]), _2 = Rc(d2, t3[1], t3[3]), k3 = t3[0] - v2, S2 = t3[1] - w3, A2 = t3[2] - t3[0] - b2, I3 = t3[3] - t3[1] - _2;
            }
            const z2 = (n3, s3, l3, u3) => {
              const p3 = $c2(n3.stretch - v2, b2, c2, t2.left), d3 = Oc(n3.fixed - k3, A2, n3.stretch, y2), f3 = $c2(s3.stretch - w3, _2, h2, t2.top), g3 = Oc(s3.fixed - S2, I3, s3.stretch, m2), x4 = $c2(l3.stretch - v2, b2, c2, t2.left), z3 = Oc(l3.fixed - k3, A2, l3.stretch, y2), T2 = $c2(u3.stretch - w3, _2, h2, t2.top), M3 = Oc(u3.fixed - S2, I3, u3.stretch, m2), E2 = new i(p3, f3), B2 = new i(x4, f3), C2 = new i(x4, T2), P2 = new i(p3, T2), D2 = new i(d3 / o2, g3 / o2), V2 = new i(z3 / o2, M3 / o2), L3 = e2 * Math.PI / 180;
              if (L3) {
                const t3 = Math.sin(L3), e3 = Math.cos(L3), r4 = [e3, -t3, t3, e3];
                E2._matMult(r4), B2._matMult(r4), P2._matMult(r4), C2._matMult(r4);
              }
              const F3 = n3.stretch + n3.fixed, R2 = s3.stretch + s3.fixed;
              return { tl: E2, tr: B2, bl: P2, br: C2, tex: { x: a2.paddedRect.x + 1 + F3, y: a2.paddedRect.y + 1 + R2, w: l3.stretch + l3.fixed - F3, h: u3.stretch + u3.fixed - R2 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: D2, pixelOffsetBR: V2, minFontScaleX: A2 / o2 / c2, minFontScaleY: I3 / o2 / h2, isSDF: r3 };
            };
            if (n2 && (a2.stretchX || a2.stretchY)) {
              const t3 = Uc2(p2, g2, y2), e3 = Uc2(d2, x3, m2);
              for (let r4 = 0; r4 < t3.length - 1; r4++) {
                const n3 = t3[r4], i2 = t3[r4 + 1];
                for (let t4 = 0; t4 < e3.length - 1; t4++)
                  s2.push(z2(n3, e3[t4], i2, e3[t4 + 1]));
              }
            } else
              s2.push(z2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l2 + 1 }, { fixed: 0, stretch: u2 + 1 }));
            return s2;
          }
          function Rc(t2, e2, r3) {
            let n2 = 0;
            for (const i2 of t2)
              n2 += Math.max(e2, Math.min(r3, i2[1])) - Math.max(e2, Math.min(r3, i2[0]));
            return n2;
          }
          function Uc2(t2, e2, r3) {
            const n2 = [{ fixed: -1, stretch: 0 }];
            for (const [e3, r4] of t2) {
              const t3 = n2[n2.length - 1];
              n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch }), n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch + (r4 - e3) });
            }
            return n2.push({ fixed: e2 + 1, stretch: r3 }), n2;
          }
          function $c2(t2, e2, r3, n2) {
            return t2 / e2 * r3 + n2;
          }
          function Oc(t2, e2, r3, n2) {
            return t2 - e2 * r3 / n2;
          }
          function qc2(t2, e2, r3, n2) {
            const i2 = e2 + t2.positionedLines[n2].lineOffset;
            return n2 === 0 ? r3 + i2 / 2 : r3 + (i2 + (e2 + t2.positionedLines[n2 - 1].lineOffset)) / 2;
          }
          Lc.loadGlyphRange = function(t2, e2, r3, n2, i2) {
            const s2 = 256 * e2, a2 = s2 + 255, o2 = n2.transformRequest(n2.normalizeGlyphsURL(r3).replace("{fontstack}", t2).replace("{range}", `${s2}-${a2}`), wt2.Glyphs);
            St2(o2, (t3, e3) => {
              if (t3)
                i2(t3);
              else if (e3) {
                const t4 = {}, r4 = function(t5) {
                  return new Cu(t5).readFields(Wu2, {});
                }(e3);
                for (const e4 of r4.glyphs)
                  t4[e4.id] = e4;
                i2(null, { glyphs: t4, ascender: r4.ascender, descender: r4.descender });
              }
            });
          }, Lc.TinySDF = Mc;
          class Nc {
            constructor(t2 = [], e2 = jc2) {
              if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0)
                for (let t3 = (this.length >> 1) - 1; t3 >= 0; t3--)
                  this._down(t3);
            }
            push(t2) {
              this.data.push(t2), this.length++, this._up(this.length - 1);
            }
            pop() {
              if (this.length === 0)
                return;
              const t2 = this.data[0], e2 = this.data.pop();
              return this.length--, this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
            }
            peek() {
              return this.data[0];
            }
            _up(t2) {
              const { data: e2, compare: r3 } = this, n2 = e2[t2];
              for (; t2 > 0; ) {
                const i2 = t2 - 1 >> 1, s2 = e2[i2];
                if (r3(n2, s2) >= 0)
                  break;
                e2[t2] = s2, t2 = i2;
              }
              e2[t2] = n2;
            }
            _down(t2) {
              const { data: e2, compare: r3 } = this, n2 = this.length >> 1, i2 = e2[t2];
              for (; t2 < n2; ) {
                let n3 = 1 + (t2 << 1), s2 = e2[n3];
                const a2 = n3 + 1;
                if (a2 < this.length && r3(e2[a2], s2) < 0 && (n3 = a2, s2 = e2[a2]), r3(s2, i2) >= 0)
                  break;
                e2[t2] = s2, t2 = n3;
              }
              e2[t2] = i2;
            }
          }
          function jc2(t2, e2) {
            return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
          }
          function Gc2(t2, e2 = 1, r3 = false) {
            let n2 = 1 / 0, s2 = 1 / 0, a2 = -1 / 0, o2 = -1 / 0;
            const l2 = t2[0];
            for (let t3 = 0; t3 < l2.length; t3++) {
              const e3 = l2[t3];
              (!t3 || e3.x < n2) && (n2 = e3.x), (!t3 || e3.y < s2) && (s2 = e3.y), (!t3 || e3.x > a2) && (a2 = e3.x), (!t3 || e3.y > o2) && (o2 = e3.y);
            }
            const u2 = Math.min(a2 - n2, o2 - s2);
            let c2 = u2 / 2;
            const h2 = new Nc([], Zc2);
            if (u2 === 0)
              return new i(n2, s2);
            for (let e3 = n2; e3 < a2; e3 += u2)
              for (let r4 = s2; r4 < o2; r4 += u2)
                h2.push(new Xc2(e3 + c2, r4 + c2, c2, t2));
            let p2 = function(t3) {
              let e3 = 0, r4 = 0, n3 = 0;
              const i2 = t3[0];
              for (let t4 = 0, s3 = i2.length, a3 = s3 - 1; t4 < s3; a3 = t4++) {
                const s4 = i2[t4], o3 = i2[a3], l3 = s4.x * o3.y - o3.x * s4.y;
                r4 += (s4.x + o3.x) * l3, n3 += (s4.y + o3.y) * l3, e3 += 3 * l3;
              }
              return new Xc2(r4 / e3, n3 / e3, 0, t3);
            }(t2), d2 = h2.length;
            for (; h2.length; ) {
              const n3 = h2.pop();
              (n3.d > p2.d || !p2.d) && (p2 = n3, r3 && console.log("found best %d after %d probes", Math.round(1e4 * n3.d) / 1e4, d2)), n3.max - p2.d <= e2 || (c2 = n3.h / 2, h2.push(new Xc2(n3.p.x - c2, n3.p.y - c2, c2, t2)), h2.push(new Xc2(n3.p.x + c2, n3.p.y - c2, c2, t2)), h2.push(new Xc2(n3.p.x - c2, n3.p.y + c2, c2, t2)), h2.push(new Xc2(n3.p.x + c2, n3.p.y + c2, c2, t2)), d2 += 4);
            }
            return r3 && (console.log(`num probes: ${d2}`), console.log(`best distance: ${p2.d}`)), p2.p;
          }
          function Zc2(t2, e2) {
            return e2.max - t2.max;
          }
          function Xc2(t2, e2, r3, n2) {
            this.p = new i(t2, e2), this.h = r3, this.d = function(t3, e3) {
              let r4 = false, n3 = 1 / 0;
              for (let i2 = 0; i2 < e3.length; i2++) {
                const s2 = e3[i2];
                for (let e4 = 0, i3 = s2.length, a2 = i3 - 1; e4 < i3; a2 = e4++) {
                  const i4 = s2[e4], o2 = s2[a2];
                  i4.y > t3.y != o2.y > t3.y && t3.x < (o2.x - i4.x) * (t3.y - i4.y) / (o2.y - i4.y) + i4.x && (r4 = !r4), n3 = Math.min(n3, eo2(t3, i4, o2));
                }
              }
              return (r4 ? 1 : -1) * Math.sqrt(n3);
            }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
          }
          const Kc2 = Number.POSITIVE_INFINITY, Hc2 = Math.sqrt(2);
          function Yc2(t2, e2) {
            return e2[1] !== Kc2 ? function(t3, e3, r3) {
              let n2 = 0, i2 = 0;
              switch (e3 = Math.abs(e3), r3 = Math.abs(r3), t3) {
                case "top-right":
                case "top-left":
                case "top":
                  i2 = r3 - 7;
                  break;
                case "bottom-right":
                case "bottom-left":
                case "bottom":
                  i2 = 7 - r3;
              }
              switch (t3) {
                case "top-right":
                case "bottom-right":
                case "right":
                  n2 = -e3;
                  break;
                case "top-left":
                case "bottom-left":
                case "left":
                  n2 = e3;
              }
              return [n2, i2];
            }(t2, e2[0], e2[1]) : function(t3, e3) {
              let r3 = 0, n2 = 0;
              e3 < 0 && (e3 = 0);
              const i2 = e3 / Hc2;
              switch (t3) {
                case "top-right":
                case "top-left":
                  n2 = i2 - 7;
                  break;
                case "bottom-right":
                case "bottom-left":
                  n2 = 7 - i2;
                  break;
                case "bottom":
                  n2 = 7 - e3;
                  break;
                case "top":
                  n2 = e3 - 7;
              }
              switch (t3) {
                case "top-right":
                case "bottom-right":
                  r3 = -i2;
                  break;
                case "top-left":
                case "bottom-left":
                  r3 = i2;
                  break;
                case "left":
                  r3 = e3;
                  break;
                case "right":
                  r3 = -e3;
              }
              return [r3, n2];
            }(t2, e2[0]);
          }
          function Jc2(t2, e2, r3, n2, i2, s2, a2, o2) {
            t2.createArrays(), t2.tilePixelRatio = Oa2 / (512 * t2.overscaling), t2.compareText = {}, t2.iconsNeedLinear = false;
            const l2 = t2.layers[0].layout, u2 = t2.layers[0]._unevaluatedLayout._values, c2 = {};
            if (t2.textSizeData.kind === "composite") {
              const { minZoom: e3, maxZoom: r4 } = t2.textSizeData;
              c2.compositeTextSizes = [u2["text-size"].possiblyEvaluate(new as2(e3), a2), u2["text-size"].possiblyEvaluate(new as2(r4), a2)];
            }
            if (t2.iconSizeData.kind === "composite") {
              const { minZoom: e3, maxZoom: r4 } = t2.iconSizeData;
              c2.compositeIconSizes = [u2["icon-size"].possiblyEvaluate(new as2(e3), a2), u2["icon-size"].possiblyEvaluate(new as2(r4), a2)];
            }
            c2.layoutTextSize = u2["text-size"].possiblyEvaluate(new as2(o2 + 1), a2), c2.layoutIconSize = u2["icon-size"].possiblyEvaluate(new as2(o2 + 1), a2), c2.textMaxSize = u2["text-size"].possiblyEvaluate(new as2(18), a2);
            const h2 = l2.get("text-rotation-alignment") === "map" && l2.get("symbol-placement") !== "point", p2 = l2.get("text-size");
            for (const s3 of t2.features) {
              const o3 = l2.get("text-font").evaluate(s3, {}, a2).join(","), u3 = p2.evaluate(s3, {}, a2), d2 = c2.layoutTextSize.evaluate(s3, {}, a2), f2 = (c2.layoutIconSize.evaluate(s3, {}, a2), { horizontal: {}, vertical: void 0 }), y2 = s3.text;
              let m2, g2 = [0, 0];
              if (y2) {
                const n3 = y2.toString(), c3 = l2.get("text-letter-spacing").evaluate(s3, {}, a2) * bu, p3 = l2.get("text-line-height").evaluate(s3, {}, a2) * bu, m3 = Oi2(n3) ? c3 : 0, x4 = l2.get("text-anchor").evaluate(s3, {}, a2), v3 = l2.get("text-variable-anchor");
                if (!v3) {
                  const t3 = l2.get("text-radial-offset").evaluate(s3, {}, a2);
                  g2 = t3 ? Yc2(x4, [t3 * bu, Kc2]) : l2.get("text-offset").evaluate(s3, {}, a2).map((t4) => t4 * bu);
                }
                let b2 = h2 ? "center" : l2.get("text-justify").evaluate(s3, {}, a2);
                const w3 = l2.get("symbol-placement"), _2 = w3 === "point", k3 = w3 === "point" ? l2.get("text-max-width").evaluate(s3, {}, a2) * bu : 0, A2 = (s4) => {
                  t2.allowVerticalPlacement && $i2(n3) && (f2.vertical = oc(y2, e2, r3, i2, o3, k3, p3, x4, s4, m3, g2, ic.vertical, true, w3, d2, u3));
                };
                if (!h2 && v3) {
                  const t3 = b2 === "auto" ? v3.map((t4) => Wc2(t4)) : [b2];
                  let n4 = false;
                  for (let s4 = 0; s4 < t3.length; s4++) {
                    const a3 = t3[s4];
                    if (!f2.horizontal[a3])
                      if (n4)
                        f2.horizontal[a3] = f2.horizontal[0];
                      else {
                        const t4 = oc(y2, e2, r3, i2, o3, k3, p3, "center", a3, m3, g2, ic.horizontal, false, w3, d2, u3);
                        t4 && (f2.horizontal[a3] = t4, n4 = t4.positionedLines.length === 1);
                      }
                  }
                  A2("left");
                } else {
                  if (b2 === "auto" && (b2 = Wc2(x4)), _2 || l2.get("text-writing-mode").indexOf("horizontal") >= 0 || !$i2(n3)) {
                    const t3 = oc(y2, e2, r3, i2, o3, k3, p3, x4, b2, m3, g2, ic.horizontal, false, w3, d2, u3);
                    t3 && (f2.horizontal[b2] = t3);
                  }
                  A2(w3 === "point" ? "left" : b2);
                }
              }
              let x3 = false;
              if (s3.icon && s3.icon.name) {
                const e3 = n2[s3.icon.name];
                e3 && (m2 = xc2(i2[s3.icon.name], l2.get("icon-offset").evaluate(s3, {}, a2), l2.get("icon-anchor").evaluate(s3, {}, a2)), x3 = e3.sdf, t2.sdfIcons === void 0 ? t2.sdfIcons = e3.sdf : t2.sdfIcons !== e3.sdf && B("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (e3.pixelRatio !== t2.pixelRatio || l2.get("icon-rotate").constantOr(1) !== 0) && (t2.iconsNeedLinear = true));
              }
              const v2 = rh2(f2.horizontal) || f2.vertical;
              t2.iconsInText || (t2.iconsInText = !!v2 && v2.iconsInText), (v2 || m2) && Qc2(t2, s3, f2, m2, n2, c2, d2, 0, g2, x3, a2);
            }
            s2 && t2.generateCollisionDebugBuffers(o2, t2.collisionBoxArray);
          }
          function Wc2(t2) {
            switch (t2) {
              case "right":
              case "top-right":
              case "bottom-right":
                return "right";
              case "left":
              case "top-left":
              case "bottom-left":
                return "left";
            }
            return "center";
          }
          function Qc2(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, h2) {
            let p2 = s2.textMaxSize.evaluate(e2, {}, h2);
            p2 === void 0 && (p2 = a2);
            const d2 = t2.layers[0].layout, f2 = d2.get("icon-offset").evaluate(e2, {}, h2), y2 = rh2(r3.horizontal) || r3.vertical, m2 = a2 / 24, g2 = t2.tilePixelRatio * p2 / 24, x3 = t2.tilePixelRatio * d2.get("symbol-spacing"), v2 = d2.get("text-padding") * t2.tilePixelRatio, b2 = d2.get("icon-padding") * t2.tilePixelRatio, w3 = c(d2.get("text-max-angle")), _2 = d2.get("text-rotation-alignment") === "map" && d2.get("symbol-placement") !== "point", k3 = d2.get("icon-rotation-alignment") === "map" && d2.get("symbol-placement") !== "point", A2 = d2.get("symbol-placement"), S2 = x3 / 2, I3 = d2.get("icon-text-fit");
            let z2;
            n2 && I3 !== "none" && (t2.allowVerticalPlacement && r3.vertical && (z2 = vc2(n2, r3.vertical, I3, d2.get("icon-text-fit-padding"), f2, m2)), y2 && (n2 = vc2(n2, y2, I3, d2.get("icon-text-fit-padding"), f2, m2)));
            const T2 = (o3, c2) => {
              c2.x < 0 || c2.x >= Oa2 || c2.y < 0 || c2.y >= Oa2 || function(t3, e3, r4, n3, i3, s3, a3, o4, l3, u3, c3, h3, p3, d3, f3, y3, m3, g3, x4, v3, b3, w4, _3, k4) {
                const A3 = t3.addToLineVertexArray(e3, r4);
                let S3, I4, z3, T3, M3, E2, C2, P2 = 0, D2 = 0, V2 = 0, L3 = 0, F3 = -1, R2 = -1;
                const U3 = {};
                let $3 = ha2(""), O2 = 0, q2 = 0;
                if (o4._unevaluatedLayout.getValue("text-radial-offset") === void 0 ? [O2, q2] = o4.layout.get("text-offset").evaluate(v3, {}, _3).map((t4) => t4 * bu) : (O2 = o4.layout.get("text-radial-offset").evaluate(v3, {}, _3) * bu, q2 = Kc2), t3.allowVerticalPlacement && n3.vertical) {
                  const t4 = n3.vertical;
                  if (d3)
                    E2 = ih2(t4), a3 && (C2 = ih2(a3));
                  else {
                    const r5 = o4.layout.get("text-rotate").evaluate(v3, {}, _3) + 90;
                    z3 = nh2(l3, e3, u3, c3, h3, t4, p3, r5, f3), a3 && (T3 = nh2(l3, e3, u3, c3, h3, a3, m3, r5));
                  }
                }
                if (i3) {
                  const r5 = o4.layout.get("icon-rotate").evaluate(v3, {}, _3), n4 = o4.layout.get("icon-text-fit") !== "none", s4 = Fc(i3, r5, w4, n4), p4 = a3 ? Fc(a3, r5, w4, n4) : void 0;
                  I4 = nh2(l3, e3, u3, c3, h3, i3, m3, r5), P2 = 4 * s4.length;
                  const d4 = t3.iconSizeData;
                  let f4 = null;
                  d4.kind === "source" ? (f4 = [wu * o4.layout.get("icon-size").evaluate(v3, {}, _3)], f4[0] > th2 && B(`${t3.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : d4.kind === "composite" && (f4 = [wu * b3.compositeIconSizes[0].evaluate(v3, {}, _3), wu * b3.compositeIconSizes[1].evaluate(v3, {}, _3)], (f4[0] > th2 || f4[1] > th2) && B(`${t3.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), t3.addSymbols(t3.icon, s4, f4, x4, g3, v3, false, e3, A3.lineStartIndex, A3.lineLength, -1, _3), F3 = t3.icon.placedSymbolArray.length - 1, p4 && (D2 = 4 * p4.length, t3.addSymbols(t3.icon, p4, f4, x4, g3, v3, ic.vertical, e3, A3.lineStartIndex, A3.lineLength, -1, _3), R2 = t3.icon.placedSymbolArray.length - 1);
                }
                for (const r5 in n3.horizontal) {
                  const i4 = n3.horizontal[r5];
                  S3 || ($3 = ha2(i4.text), d3 ? M3 = ih2(i4) : S3 = nh2(l3, e3, u3, c3, h3, i4, p3, o4.layout.get("text-rotate").evaluate(v3, {}, _3), f3));
                  const a4 = i4.positionedLines.length === 1;
                  if (V2 += eh2(t3, e3, i4, s3, o4, d3, v3, f3, A3, n3.vertical ? ic.horizontal : ic.horizontalOnly, a4 ? Object.keys(n3.horizontal) : [r5], U3, F3, b3, _3), a4)
                    break;
                }
                n3.vertical && (L3 += eh2(t3, e3, n3.vertical, s3, o4, d3, v3, f3, A3, ic.vertical, ["vertical"], U3, R2, b3, _3));
                let N2 = -1;
                const j3 = (t4, e4) => t4 ? Math.max(t4, e4) : e4;
                N2 = j3(M3, N2), N2 = j3(E2, N2), N2 = j3(C2, N2);
                const G3 = N2 > -1 ? 1 : 0;
                G3 && (N2 *= k4 / bu), t3.glyphOffsetArray.length >= dh2.MAX_GLYPHS && B("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), v3.sortKey !== void 0 && t3.addToSortKeyRanges(t3.symbolInstances.length, v3.sortKey), t3.symbolInstances.emplaceBack(e3.x, e3.y, U3.right >= 0 ? U3.right : -1, U3.center >= 0 ? U3.center : -1, U3.left >= 0 ? U3.left : -1, U3.vertical >= 0 ? U3.vertical : -1, F3, R2, $3, S3 !== void 0 ? S3 : t3.collisionBoxArray.length, S3 !== void 0 ? S3 + 1 : t3.collisionBoxArray.length, z3 !== void 0 ? z3 : t3.collisionBoxArray.length, z3 !== void 0 ? z3 + 1 : t3.collisionBoxArray.length, I4 !== void 0 ? I4 : t3.collisionBoxArray.length, I4 !== void 0 ? I4 + 1 : t3.collisionBoxArray.length, T3 || t3.collisionBoxArray.length, T3 ? T3 + 1 : t3.collisionBoxArray.length, u3, V2, L3, P2, D2, G3, 0, O2, q2, N2);
              }(t2, c2, o3, r3, n2, i2, z2, t2.layers[0], t2.collisionBoxArray, e2.index, e2.sourceLayerIndex, t2.index, v2, _2, l2, 0, b2, k3, f2, e2, s2, u2, h2, a2);
            };
            if (A2 === "line")
              for (const i3 of Tc2(e2.geometry, 0, 0, Oa2, Oa2)) {
                const e3 = Ic(i3, x3, w3, r3.vertical || y2, n2, 24, g2, t2.overscaling, Oa2);
                for (const r4 of e3) {
                  const e4 = y2;
                  e4 && sh2(t2, e4.text, S2, r4) || T2(i3, r4);
                }
              }
            else if (A2 === "line-center") {
              for (const t3 of e2.geometry)
                if (t3.length > 1) {
                  const e3 = Sc(t3, w3, r3.vertical || y2, n2, 24, g2);
                  e3 && T2(t3, e3);
                }
            } else if (e2.type === "Polygon")
              for (const t3 of zl2(e2.geometry, 0)) {
                const e3 = Gc2(t3, 16);
                T2(t3[0], new bc2(e3.x, e3.y, 0));
              }
            else if (e2.type === "LineString")
              for (const t3 of e2.geometry)
                T2(t3, new bc2(t3[0].x, t3[0].y, 0));
            else if (e2.type === "Point")
              for (const t3 of e2.geometry)
                for (const e3 of t3)
                  T2([e3], new bc2(e3.x, e3.y, 0));
          }
          const th2 = 32640;
          function eh2(t2, e2, r3, n2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, y2) {
            const m2 = function(t3, e3, r4, n3, s3, a3, o3, l3) {
              const u3 = [];
              if (e3.positionedLines.length === 0)
                return u3;
              const c3 = n3.layout.get("text-rotate").evaluate(a3, {}) * Math.PI / 180, h3 = function(t4) {
                const e4 = t4[0], r5 = t4[1], n4 = e4 * r5;
                return n4 > 0 ? [e4, -r5] : n4 < 0 ? [-e4, r5] : e4 === 0 ? [r5, e4] : [r5, -e4];
              }(r4);
              let p3 = Math.abs(e3.top - e3.bottom);
              for (const t4 of e3.positionedLines)
                p3 -= t4.lineOffset;
              const d3 = e3.positionedLines.length, f3 = p3 / d3;
              let y3 = e3.top - r4[1];
              for (let t4 = 0; t4 < d3; ++t4) {
                const n4 = e3.positionedLines[t4];
                y3 = qc2(e3, f3, y3, t4);
                for (const t5 of n4.positionedGlyphs) {
                  if (!t5.rect)
                    continue;
                  const n5 = t5.rect || {};
                  let a4 = 4, p4 = true, d4 = 1, f4 = 0;
                  const m3 = (s3 || l3) && t5.vertical, g3 = t5.metrics.advance * t5.scale / 2, x4 = t5.metrics, v2 = t5.rect;
                  if (v2 === null)
                    continue;
                  if (l3 && e3.verticalizable && (f4 = t5.imageName ? g3 - t5.metrics.width * t5.scale / 2 : 0), t5.imageName) {
                    const e4 = o3[t5.imageName];
                    if (!e4)
                      continue;
                    p4 = e4.sdf, d4 = e4.pixelRatio, a4 = 1 / d4;
                  }
                  const b2 = s3 ? [t5.x + g3, t5.y] : [0, 0];
                  let w3 = [0, 0], _2 = [0, 0], k3 = false;
                  s3 || (m3 ? (_2 = [t5.x + g3 + h3[0], t5.y + h3[1] - f4], k3 = true) : w3 = [t5.x + g3 + r4[0], t5.y + r4[1] - f4]);
                  const A2 = v2.w * t5.scale / (d4 * (t5.localGlyph ? 2 : 1)), S2 = v2.h * t5.scale / (d4 * (t5.localGlyph ? 2 : 1));
                  let I3, z2, T2, M3;
                  if (m3) {
                    const e4 = t5.y - y3, r5 = new i(-g3, g3 - e4), n6 = -Math.PI / 2, s4 = new i(..._2);
                    I3 = new i(-g3 + w3[0], w3[1]), I3._rotateAround(n6, r5)._add(s4), I3.x += -e4 + g3, I3.y -= (x4.left - a4) * t5.scale;
                    const o4 = t5.imageName ? x4.advance * t5.scale : bu * t5.scale, l4 = String.fromCharCode(t5.glyph);
                    Tu(l4) ? I3.x += (1 - a4) * t5.scale : Mu(l4) ? I3.x += o4 - x4.height * t5.scale + (-a4 - 1) * t5.scale : I3.x += t5.imageName || x4.width + 2 * a4 === v2.w && x4.height + 2 * a4 === v2.h ? (o4 - S2) / 2 : (o4 - (x4.height + 2 * a4) * t5.scale) / 2, z2 = new i(I3.x, I3.y - A2), T2 = new i(I3.x + S2, I3.y), M3 = new i(I3.x + S2, I3.y - A2);
                  } else {
                    const e4 = (x4.left - a4) * t5.scale - g3 + w3[0], r5 = (-x4.top - a4) * t5.scale + w3[1], n6 = e4 + A2, s4 = r5 + S2;
                    I3 = new i(e4, r5), z2 = new i(n6, r5), T2 = new i(e4, s4), M3 = new i(n6, s4);
                  }
                  if (c3) {
                    let t6;
                    t6 = s3 ? new i(0, 0) : k3 ? new i(h3[0], h3[1]) : new i(r4[0], r4[1]), I3._rotateAround(c3, t6), z2._rotateAround(c3, t6), T2._rotateAround(c3, t6), M3._rotateAround(c3, t6);
                  }
                  const E2 = new i(0, 0), B2 = new i(0, 0);
                  u3.push({ tl: I3, tr: z2, bl: T2, br: M3, tex: n5, writingMode: e3.writingMode, glyphOffset: b2, sectionIndex: t5.sectionIndex, isSDF: p4, pixelOffsetTL: E2, pixelOffsetBR: B2, minFontScaleX: 0, minFontScaleY: 0 });
                }
              }
              return u3;
            }(0, r3, l2, s2, a2, o2, n2, t2.allowVerticalPlacement), g2 = t2.textSizeData;
            let x3 = null;
            g2.kind === "source" ? (x3 = [wu * s2.layout.get("text-size").evaluate(o2, {}, y2)], x3[0] > th2 && B(`${t2.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : g2.kind === "composite" && (x3 = [wu * f2.compositeTextSizes[0].evaluate(o2, {}, y2), wu * f2.compositeTextSizes[1].evaluate(o2, {}, y2)], (x3[0] > th2 || x3[1] > th2) && B(`${t2.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), t2.addSymbols(t2.text, m2, x3, l2, a2, o2, c2, e2, u2.lineStartIndex, u2.lineLength, d2, y2);
            for (const e3 of h2)
              p2[e3] = t2.text.placedSymbolArray.length - 1;
            return 4 * m2.length;
          }
          function rh2(t2) {
            for (const e2 in t2)
              return t2[e2];
            return null;
          }
          function nh2(t2, e2, r3, n2, s2, a2, o2, l2, u2) {
            let h2 = a2.top, p2 = a2.bottom, d2 = a2.left, f2 = a2.right;
            const y2 = a2.collisionPadding;
            if (y2 && (d2 -= y2[0], h2 -= y2[1], f2 += y2[2], p2 += y2[3]), l2) {
              const t3 = new i(d2, h2), e3 = new i(f2, h2), r4 = new i(d2, p2), n3 = new i(f2, p2), s3 = c(l2);
              let a3 = new i(0, 0);
              u2 && (a3 = new i(u2[0], u2[1])), t3._rotateAround(s3, a3), e3._rotateAround(s3, a3), r4._rotateAround(s3, a3), n3._rotateAround(s3, a3), d2 = Math.min(t3.x, e3.x, r4.x, n3.x), f2 = Math.max(t3.x, e3.x, r4.x, n3.x), h2 = Math.min(t3.y, e3.y, r4.y, n3.y), p2 = Math.max(t3.y, e3.y, r4.y, n3.y);
            }
            return t2.emplaceBack(e2.x, e2.y, d2, h2, f2, p2, o2, r3, n2, s2), t2.length - 1;
          }
          function ih2(t2) {
            t2.collisionPadding && (t2.top -= t2.collisionPadding[1], t2.bottom += t2.collisionPadding[3]);
            const e2 = t2.bottom - t2.top;
            return e2 > 0 ? Math.max(10, e2) : null;
          }
          function sh2(t2, e2, r3, n2) {
            const i2 = t2.compareText;
            if (e2 in i2) {
              const t3 = i2[e2];
              for (let e3 = t3.length - 1; e3 >= 0; e3--)
                if (n2.dist(t3[e3]) < r3)
                  return true;
            } else
              i2[e2] = [];
            return i2[e2].push(n2), false;
          }
          const ah2 = Gl2.VectorTileFeature.types, oh2 = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
          function lh2(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
            const d2 = o2 ? Math.min(th2, Math.round(o2[0])) : 0, f2 = o2 ? Math.min(th2, Math.round(o2[1])) : 0;
            t2.emplaceBack(e2, r3, Math.round(32 * n2), Math.round(32 * i2), s2, a2, (d2 << 1) + (l2 ? 1 : 0), f2, 16 * u2, 16 * c2, 256 * h2, 256 * p2);
          }
          function uh2(t2, e2, r3) {
            t2.emplaceBack(e2.x, e2.y, r3), t2.emplaceBack(e2.x, e2.y, r3), t2.emplaceBack(e2.x, e2.y, r3), t2.emplaceBack(e2.x, e2.y, r3);
          }
          function ch2(t2) {
            for (const e2 of t2.sections)
              if (Xi2(e2.text))
                return true;
            return false;
          }
          class hh2 {
            constructor(t2) {
              this.layoutVertexArray = new Ps(), this.indexArray = new $s2(), this.programConfigurations = t2, this.segments = new $a2(), this.dynamicLayoutVertexArray = new Ds(), this.opacityVertexArray = new Vs(), this.placedSymbolArray = new Ws();
            }
            isEmpty() {
              return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
            }
            upload(t2, e2, r3, n2) {
              this.isEmpty() || (r3 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, fu2.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, yu2.members, true), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, oh2, true), this.opacityVertexBuffer.itemSize = 1), (r3 || n2) && this.programConfigurations.upload(t2));
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
            }
          }
          oi2("SymbolBuffers", hh2);
          class ph2 {
            constructor(t2, e2, r3) {
              this.layoutVertexArray = new t2(), this.layoutAttributes = e2, this.indexArray = new r3(), this.segments = new $a2(), this.collisionVertexArray = new Us(), this.collisionVertexArrayExt = new Ds();
            }
            upload(t2) {
              this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, mu2.members, true), this.collisionVertexBufferExt = t2.createVertexBuffer(this.collisionVertexArrayExt, gu2.members, true);
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
            }
          }
          oi2("CollisionBuffers", ph2);
          class dh2 {
            constructor(t2) {
              this.collisionBoxArray = t2.collisionBoxArray, this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.pixelRatio = t2.pixelRatio, this.sourceLayerIndex = t2.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = yo2([]), this.placementViewportMatrix = yo2([]);
              const e2 = this.layers[0]._unevaluatedLayout._values;
              this.textSizeData = _u2(this.zoom, e2["text-size"]), this.iconSizeData = _u2(this.zoom, e2["icon-size"]);
              const r3 = this.layers[0].layout, n2 = r3.get("symbol-sort-key"), i2 = r3.get("symbol-z-order");
              this.canOverlap = r3.get("text-allow-overlap") || r3.get("icon-allow-overlap") || r3.get("text-ignore-placement") || r3.get("icon-ignore-placement"), this.sortFeaturesByKey = i2 !== "viewport-y" && n2.constantOr(1) !== void 0, this.sortFeaturesByY = (i2 === "viewport-y" || i2 === "auto" && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r3.get("text-writing-mode").map((t3) => ic[t3]), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.sourceID = t2.sourceID;
            }
            createArrays() {
              this.text = new hh2(new Ea2(this.layers, this.zoom, (t2) => /^text/.test(t2))), this.icon = new hh2(new Ea2(this.layers, this.zoom, (t2) => /^icon/.test(t2))), this.glyphOffsetArray = new ea2(), this.lineVertexArray = new ra2(), this.symbolInstances = new ta2();
            }
            calculateGlyphDependencies(t2, e2, r3, n2, i2) {
              for (let r4 = 0; r4 < t2.length; r4++)
                if (e2[t2.charCodeAt(r4)] = true, n2 && i2) {
                  const n3 = zu2[t2.charAt(r4)];
                  n3 && (e2[n3.charCodeAt(0)] = true);
                }
            }
            populate(t2, e2, r3) {
              const n2 = this.layers[0], i2 = n2.layout, s2 = i2.get("text-font"), a2 = i2.get("text-field"), o2 = i2.get("icon-image"), l2 = (a2.value.kind !== "constant" || a2.value.value instanceof de2 && !a2.value.value.isEmpty() || a2.value.value.toString().length > 0) && (s2.value.kind !== "constant" || s2.value.value.length > 0), u2 = o2.value.kind !== "constant" || !!o2.value.value || Object.keys(o2.parameters).length > 0, c2 = i2.get("symbol-sort-key");
              if (this.features = [], !l2 && !u2)
                return;
              const h2 = e2.iconDependencies, p2 = e2.glyphDependencies, d2 = e2.availableImages, f2 = new as2(this.zoom);
              for (const { feature: e3, id: a3, index: o3, sourceLayerIndex: y2 } of t2) {
                const t3 = n2._featureFilter.needGeometry, m2 = Ga2(e3, t3);
                if (!n2._featureFilter.filter(f2, m2, r3))
                  continue;
                let g2, x3;
                if (t3 || (m2.geometry = ja2(e3)), l2) {
                  const t4 = n2.getValueAndResolveTokens("text-field", m2, r3, d2), e4 = de2.factory(t4);
                  ch2(e4) && (this.hasRTLText = true), (!this.hasRTLText || ns2() === "unavailable" || this.hasRTLText && ss2.isParsed()) && (g2 = Iu(e4, n2, m2));
                }
                if (u2) {
                  const t4 = n2.getValueAndResolveTokens("icon-image", m2, r3, d2);
                  x3 = t4 instanceof fe2 ? t4 : fe2.fromString(t4);
                }
                if (!g2 && !x3)
                  continue;
                const v2 = this.sortFeaturesByKey ? c2.evaluate(m2, {}, r3) : void 0;
                if (this.features.push({ id: a3, text: g2, icon: x3, index: o3, sourceLayerIndex: y2, geometry: m2.geometry, properties: e3.properties, type: ah2[e3.type], sortKey: v2 }), x3 && (h2[x3.name] = true), g2) {
                  const t4 = s2.evaluate(m2, {}, r3).join(","), e4 = i2.get("text-rotation-alignment") === "map" && i2.get("symbol-placement") !== "point";
                  this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(ic.vertical) >= 0;
                  for (const r4 of g2.sections)
                    if (r4.image)
                      h2[r4.image.name] = true;
                    else {
                      const n3 = $i2(g2.toString()), i3 = r4.fontStack || t4, s3 = p2[i3] = p2[i3] || {};
                      this.calculateGlyphDependencies(r4.text, s3, e4, this.allowVerticalPlacement, n3);
                    }
                }
              }
              i2.get("symbol-placement") === "line" && (this.features = function(t3) {
                const e3 = {}, r4 = {}, n3 = [];
                let i3 = 0;
                function s3(e4) {
                  n3.push(t3[e4]), i3++;
                }
                function a3(t4, e4, i4) {
                  const s4 = r4[t4];
                  return delete r4[t4], r4[e4] = s4, n3[s4].geometry[0].pop(), n3[s4].geometry[0] = n3[s4].geometry[0].concat(i4[0]), s4;
                }
                function o3(t4, r5, i4) {
                  const s4 = e3[r5];
                  return delete e3[r5], e3[t4] = s4, n3[s4].geometry[0].shift(), n3[s4].geometry[0] = i4[0].concat(n3[s4].geometry[0]), s4;
                }
                function l3(t4, e4, r5) {
                  const n4 = r5 ? e4[0][e4[0].length - 1] : e4[0][0];
                  return `${t4}:${n4.x}:${n4.y}`;
                }
                for (let u3 = 0; u3 < t3.length; u3++) {
                  const c3 = t3[u3], h3 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
                  if (!p3) {
                    s3(u3);
                    continue;
                  }
                  const d3 = l3(p3, h3), f3 = l3(p3, h3, true);
                  if (d3 in r4 && f3 in e3 && r4[d3] !== e3[f3]) {
                    const t4 = o3(d3, f3, h3), i4 = a3(d3, f3, n3[t4].geometry);
                    delete e3[d3], delete r4[f3], r4[l3(p3, n3[i4].geometry, true)] = i4, n3[t4].geometry = null;
                  } else
                    d3 in r4 ? a3(d3, f3, h3) : f3 in e3 ? o3(d3, f3, h3) : (s3(u3), e3[d3] = i3 - 1, r4[f3] = i3 - 1);
                }
                return n3.filter((t4) => t4.geometry);
              }(this.features)), this.sortFeaturesByKey && this.features.sort((t3, e3) => t3.sortKey - e3.sortKey);
            }
            update(t2, e2, r3) {
              this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t2, e2, this.layers, r3), this.icon.programConfigurations.updatePaintArrays(t2, e2, this.layers, r3));
            }
            isEmpty() {
              return this.symbolInstances.length === 0 && !this.hasRTLText;
            }
            uploadPending() {
              return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
            }
            upload(t2) {
              !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
            }
            destroyDebugData() {
              this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
            }
            destroy() {
              this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
            }
            addToLineVertexArray(t2, e2) {
              const r3 = this.lineVertexArray.length;
              if (t2.segment !== void 0) {
                let r4 = t2.dist(e2[t2.segment + 1]), n2 = t2.dist(e2[t2.segment]);
                const i2 = {};
                for (let n3 = t2.segment + 1; n3 < e2.length; n3++)
                  i2[n3] = { x: e2[n3].x, y: e2[n3].y, tileUnitDistanceFromAnchor: r4 }, n3 < e2.length - 1 && (r4 += e2[n3 + 1].dist(e2[n3]));
                for (let r5 = t2.segment || 0; r5 >= 0; r5--)
                  i2[r5] = { x: e2[r5].x, y: e2[r5].y, tileUnitDistanceFromAnchor: n2 }, r5 > 0 && (n2 += e2[r5 - 1].dist(e2[r5]));
                for (let t3 = 0; t3 < e2.length; t3++) {
                  const e3 = i2[t3];
                  this.lineVertexArray.emplaceBack(e3.x, e3.y, e3.tileUnitDistanceFromAnchor);
                }
              }
              return { lineStartIndex: r3, lineLength: this.lineVertexArray.length - r3 };
            }
            addSymbols(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2) {
              const p2 = t2.indexArray, d2 = t2.layoutVertexArray, f2 = t2.segments.prepareSegment(4 * e2.length, d2, p2, this.canOverlap ? s2.sortKey : void 0), y2 = this.glyphOffsetArray.length, m2 = f2.vertexLength, g2 = this.allowVerticalPlacement && a2 === ic.vertical ? Math.PI / 2 : 0, x3 = s2.text && s2.text.sections;
              for (let n3 = 0; n3 < e2.length; n3++) {
                const { tl: i3, tr: a3, bl: l3, br: u3, tex: c3, pixelOffsetTL: y3, pixelOffsetBR: m3, minFontScaleX: v2, minFontScaleY: b2, glyphOffset: w3, isSDF: _2, sectionIndex: k3 } = e2[n3], A2 = f2.vertexLength, S2 = w3[1];
                lh2(d2, o2.x, o2.y, i3.x, S2 + i3.y, c3.x, c3.y, r3, _2, y3.x, y3.y, v2, b2), lh2(d2, o2.x, o2.y, a3.x, S2 + a3.y, c3.x + c3.w, c3.y, r3, _2, m3.x, y3.y, v2, b2), lh2(d2, o2.x, o2.y, l3.x, S2 + l3.y, c3.x, c3.y + c3.h, r3, _2, y3.x, m3.y, v2, b2), lh2(d2, o2.x, o2.y, u3.x, S2 + u3.y, c3.x + c3.w, c3.y + c3.h, r3, _2, m3.x, m3.y, v2, b2), uh2(t2.dynamicLayoutVertexArray, o2, g2), p2.emplaceBack(A2, A2 + 1, A2 + 2), p2.emplaceBack(A2 + 1, A2 + 2, A2 + 3), f2.vertexLength += 4, f2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w3[0]), n3 !== e2.length - 1 && k3 === e2[n3 + 1].sectionIndex || t2.programConfigurations.populatePaintArrays(d2.length, s2, s2.index, {}, h2, x3 && x3[k3]);
              }
              t2.placedSymbolArray.emplaceBack(o2.x, o2.y, y2, this.glyphOffsetArray.length - y2, m2, l2, u2, o2.segment, r3 ? r3[0] : 0, r3 ? r3[1] : 0, n2[0], n2[1], a2, 0, false, 0, c2, 0);
            }
            _commitLayoutVertex(t2, e2, r3, n2, i2) {
              t2.emplaceBack(e2.x, e2.y, r3, n2, Math.round(i2.x), Math.round(i2.y));
            }
            _addCollisionDebugVertices(t2, e2, r3, n2, s2) {
              const a2 = r3.segments.prepareSegment(4, r3.layoutVertexArray, r3.indexArray), o2 = a2.vertexLength, l2 = s2.anchorX, u2 = s2.anchorY;
              for (let t3 = 0; t3 < 4; t3++)
                r3.collisionVertexArray.emplaceBack(0, 0, 0, 0);
              r3.collisionVertexArrayExt.emplaceBack(e2, -t2.padding, -t2.padding), r3.collisionVertexArrayExt.emplaceBack(e2, t2.padding, -t2.padding), r3.collisionVertexArrayExt.emplaceBack(e2, t2.padding, t2.padding), r3.collisionVertexArrayExt.emplaceBack(e2, -t2.padding, t2.padding), this._commitLayoutVertex(r3.layoutVertexArray, n2, l2, u2, new i(t2.x1, t2.y1)), this._commitLayoutVertex(r3.layoutVertexArray, n2, l2, u2, new i(t2.x2, t2.y1)), this._commitLayoutVertex(r3.layoutVertexArray, n2, l2, u2, new i(t2.x2, t2.y2)), this._commitLayoutVertex(r3.layoutVertexArray, n2, l2, u2, new i(t2.x1, t2.y2)), a2.vertexLength += 4;
              const c2 = r3.indexArray;
              c2.emplaceBack(o2, o2 + 1), c2.emplaceBack(o2 + 1, o2 + 2), c2.emplaceBack(o2 + 2, o2 + 3), c2.emplaceBack(o2 + 3, o2), a2.primitiveLength += 4;
            }
            _addTextDebugCollisionBoxes(t2, e2, r3, n2, i2, s2) {
              for (let a2 = n2; a2 < i2; a2++) {
                const n3 = r3.get(a2), i3 = this.getSymbolInstanceTextSize(t2, s2, e2, a2);
                this._addCollisionDebugVertices(n3, i3, this.textCollisionBox, n3.anchorPoint, s2);
              }
            }
            _addIconDebugCollisionBoxes(t2, e2, r3, n2, i2, s2) {
              for (let a2 = n2; a2 < i2; a2++) {
                const n3 = r3.get(a2), i3 = this.getSymbolInstanceIconSize(t2, e2, a2);
                this._addCollisionDebugVertices(n3, i3, this.iconCollisionBox, n3.anchorPoint, s2);
              }
            }
            generateCollisionDebugBuffers(t2, e2) {
              this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new ph2(Fs, xu2.members, Zs2), this.iconCollisionBox = new ph2(Fs, xu2.members, Zs2);
              const r3 = Au(this.iconSizeData, t2), n2 = Au(this.textSizeData, t2);
              for (let i2 = 0; i2 < this.symbolInstances.length; i2++) {
                const s2 = this.symbolInstances.get(i2);
                this._addTextDebugCollisionBoxes(n2, t2, e2, s2.textBoxStartIndex, s2.textBoxEndIndex, s2), this._addTextDebugCollisionBoxes(n2, t2, e2, s2.verticalTextBoxStartIndex, s2.verticalTextBoxEndIndex, s2), this._addIconDebugCollisionBoxes(r3, t2, e2, s2.iconBoxStartIndex, s2.iconBoxEndIndex, s2), this._addIconDebugCollisionBoxes(r3, t2, e2, s2.verticalIconBoxStartIndex, s2.verticalIconBoxEndIndex, s2);
              }
            }
            getSymbolInstanceTextSize(t2, e2, r3, n2) {
              const i2 = this.text.placedSymbolArray.get(e2.rightJustifiedTextSymbolIndex >= 0 ? e2.rightJustifiedTextSymbolIndex : e2.centerJustifiedTextSymbolIndex >= 0 ? e2.centerJustifiedTextSymbolIndex : e2.leftJustifiedTextSymbolIndex >= 0 ? e2.leftJustifiedTextSymbolIndex : e2.verticalPlacedTextSymbolIndex >= 0 ? e2.verticalPlacedTextSymbolIndex : n2), s2 = ku(this.textSizeData, t2, i2) / bu;
              return this.tilePixelRatio * s2;
            }
            getSymbolInstanceIconSize(t2, e2, r3) {
              const n2 = this.icon.placedSymbolArray.get(r3), i2 = ku(this.iconSizeData, t2, n2);
              return this.tilePixelRatio * i2;
            }
            _commitDebugCollisionVertexUpdate(t2, e2, r3) {
              t2.emplaceBack(e2, -r3, -r3), t2.emplaceBack(e2, r3, -r3), t2.emplaceBack(e2, r3, r3), t2.emplaceBack(e2, -r3, r3);
            }
            _updateTextDebugCollisionBoxes(t2, e2, r3, n2, i2, s2) {
              for (let a2 = n2; a2 < i2; a2++) {
                const n3 = r3.get(a2), i3 = this.getSymbolInstanceTextSize(t2, s2, e2, a2);
                this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i3, n3.padding);
              }
            }
            _updateIconDebugCollisionBoxes(t2, e2, r3, n2, i2) {
              for (let s2 = n2; s2 < i2; s2++) {
                const n3 = r3.get(s2), i3 = this.getSymbolInstanceIconSize(t2, e2, s2);
                this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i3, n3.padding);
              }
            }
            updateCollisionDebugBuffers(t2, e2) {
              if (!this.hasDebugData())
                return;
              this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
              const r3 = Au(this.iconSizeData, t2), n2 = Au(this.textSizeData, t2);
              for (let i2 = 0; i2 < this.symbolInstances.length; i2++) {
                const s2 = this.symbolInstances.get(i2);
                this._updateTextDebugCollisionBoxes(n2, t2, e2, s2.textBoxStartIndex, s2.textBoxEndIndex, s2), this._updateTextDebugCollisionBoxes(n2, t2, e2, s2.verticalTextBoxStartIndex, s2.verticalTextBoxEndIndex, s2), this._updateIconDebugCollisionBoxes(r3, t2, e2, s2.iconBoxStartIndex, s2.iconBoxEndIndex), this._updateIconDebugCollisionBoxes(r3, t2, e2, s2.verticalIconBoxStartIndex, s2.verticalIconBoxEndIndex);
              }
              this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
            }
            _deserializeCollisionBoxesForSymbol(t2, e2, r3, n2, i2, s2, a2, o2, l2) {
              const u2 = {};
              for (let n3 = e2; n3 < r3; n3++) {
                const e3 = t2.get(n3);
                u2.textBox = { x1: e3.x1, y1: e3.y1, x2: e3.x2, y2: e3.y2, padding: e3.padding, anchorPointX: e3.anchorPointX, anchorPointY: e3.anchorPointY }, u2.textFeatureIndex = e3.featureIndex;
                break;
              }
              for (let e3 = n2; e3 < i2; e3++) {
                const r4 = t2.get(e3);
                u2.verticalTextBox = { x1: r4.x1, y1: r4.y1, x2: r4.x2, y2: r4.y2, padding: r4.padding, anchorPointX: r4.anchorPointX, anchorPointY: r4.anchorPointY }, u2.verticalTextFeatureIndex = r4.featureIndex;
                break;
              }
              for (let e3 = s2; e3 < a2; e3++) {
                const r4 = t2.get(e3);
                u2.iconBox = { x1: r4.x1, y1: r4.y1, x2: r4.x2, y2: r4.y2, padding: r4.padding, anchorPointX: r4.anchorPointX, anchorPointY: r4.anchorPointY }, u2.iconFeatureIndex = r4.featureIndex;
                break;
              }
              for (let e3 = o2; e3 < l2; e3++) {
                const r4 = t2.get(e3);
                u2.verticalIconBox = { x1: r4.x1, y1: r4.y1, x2: r4.x2, y2: r4.y2, padding: r4.padding, anchorPointX: r4.anchorPointX, anchorPointY: r4.anchorPointY }, u2.verticalIconFeatureIndex = r4.featureIndex;
                break;
              }
              return u2;
            }
            deserializeCollisionBoxes(t2) {
              this.collisionArrays = [];
              for (let e2 = 0; e2 < this.symbolInstances.length; e2++) {
                const r3 = this.symbolInstances.get(e2);
                this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r3.textBoxStartIndex, r3.textBoxEndIndex, r3.verticalTextBoxStartIndex, r3.verticalTextBoxEndIndex, r3.iconBoxStartIndex, r3.iconBoxEndIndex, r3.verticalIconBoxStartIndex, r3.verticalIconBoxEndIndex));
              }
            }
            hasTextData() {
              return this.text.segments.get().length > 0;
            }
            hasIconData() {
              return this.icon.segments.get().length > 0;
            }
            hasDebugData() {
              return this.textCollisionBox && this.iconCollisionBox;
            }
            hasTextCollisionBoxData() {
              return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
            }
            hasIconCollisionBoxData() {
              return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
            }
            addIndicesForPlacedSymbol(t2, e2) {
              const r3 = t2.placedSymbolArray.get(e2), n2 = r3.vertexStartIndex + 4 * r3.numGlyphs;
              for (let e3 = r3.vertexStartIndex; e3 < n2; e3 += 4)
                t2.indexArray.emplaceBack(e3, e3 + 1, e3 + 2), t2.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
            }
            getSortedSymbolIndexes(t2) {
              if (this.sortedAngle === t2 && this.symbolInstanceIndexes !== void 0)
                return this.symbolInstanceIndexes;
              const e2 = Math.sin(t2), r3 = Math.cos(t2), n2 = [], i2 = [], s2 = [];
              for (let t3 = 0; t3 < this.symbolInstances.length; ++t3) {
                s2.push(t3);
                const a2 = this.symbolInstances.get(t3);
                n2.push(0 | Math.round(e2 * a2.anchorX + r3 * a2.anchorY)), i2.push(a2.featureIndex);
              }
              return s2.sort((t3, e3) => n2[t3] - n2[e3] || i2[e3] - i2[t3]), s2;
            }
            addToSortKeyRanges(t2, e2) {
              const r3 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
              r3 && r3.sortKey === e2 ? r3.symbolInstanceEnd = t2 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t2, symbolInstanceEnd: t2 + 1 });
            }
            sortFeatures(t2) {
              if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
                for (const t3 of this.symbolInstanceIndexes) {
                  const e2 = this.symbolInstances.get(t3);
                  this.featureSortOrder.push(e2.featureIndex), [e2.rightJustifiedTextSymbolIndex, e2.centerJustifiedTextSymbolIndex, e2.leftJustifiedTextSymbolIndex].forEach((t4, e3, r3) => {
                    t4 >= 0 && r3.indexOf(t4) === e3 && this.addIndicesForPlacedSymbol(this.text, t4);
                  }), e2.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e2.verticalPlacedTextSymbolIndex), e2.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.placedIconSymbolIndex), e2.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.verticalPlacedIconSymbolIndex);
                }
                this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
              }
            }
          }
          oi2("SymbolBucket", dh2, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), dh2.MAX_GLYPHS = 65535, dh2.addDynamicAttributes = uh2;
          const fh2 = new bs2({ "symbol-placement": new ys2(Rt.layout_symbol["symbol-placement"]), "symbol-spacing": new ys2(Rt.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new ys2(Rt.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new ms2(Rt.layout_symbol["symbol-sort-key"]), "symbol-z-order": new ys2(Rt.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new ys2(Rt.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new ys2(Rt.layout_symbol["icon-ignore-placement"]), "icon-optional": new ys2(Rt.layout_symbol["icon-optional"]), "icon-rotation-alignment": new ys2(Rt.layout_symbol["icon-rotation-alignment"]), "icon-size": new ms2(Rt.layout_symbol["icon-size"]), "icon-text-fit": new ys2(Rt.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new ys2(Rt.layout_symbol["icon-text-fit-padding"]), "icon-image": new ms2(Rt.layout_symbol["icon-image"]), "icon-rotate": new ms2(Rt.layout_symbol["icon-rotate"]), "icon-padding": new ys2(Rt.layout_symbol["icon-padding"]), "icon-keep-upright": new ys2(Rt.layout_symbol["icon-keep-upright"]), "icon-offset": new ms2(Rt.layout_symbol["icon-offset"]), "icon-anchor": new ms2(Rt.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new ys2(Rt.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new ys2(Rt.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new ys2(Rt.layout_symbol["text-rotation-alignment"]), "text-field": new ms2(Rt.layout_symbol["text-field"]), "text-font": new ms2(Rt.layout_symbol["text-font"]), "text-size": new ms2(Rt.layout_symbol["text-size"]), "text-max-width": new ms2(Rt.layout_symbol["text-max-width"]), "text-line-height": new ms2(Rt.layout_symbol["text-line-height"]), "text-letter-spacing": new ms2(Rt.layout_symbol["text-letter-spacing"]), "text-justify": new ms2(Rt.layout_symbol["text-justify"]), "text-radial-offset": new ms2(Rt.layout_symbol["text-radial-offset"]), "text-variable-anchor": new ys2(Rt.layout_symbol["text-variable-anchor"]), "text-anchor": new ms2(Rt.layout_symbol["text-anchor"]), "text-max-angle": new ys2(Rt.layout_symbol["text-max-angle"]), "text-writing-mode": new ys2(Rt.layout_symbol["text-writing-mode"]), "text-rotate": new ms2(Rt.layout_symbol["text-rotate"]), "text-padding": new ys2(Rt.layout_symbol["text-padding"]), "text-keep-upright": new ys2(Rt.layout_symbol["text-keep-upright"]), "text-transform": new ms2(Rt.layout_symbol["text-transform"]), "text-offset": new ms2(Rt.layout_symbol["text-offset"]), "text-allow-overlap": new ys2(Rt.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new ys2(Rt.layout_symbol["text-ignore-placement"]), "text-optional": new ys2(Rt.layout_symbol["text-optional"]) });
          var yh2 = { paint: new bs2({ "icon-opacity": new ms2(Rt.paint_symbol["icon-opacity"]), "icon-color": new ms2(Rt.paint_symbol["icon-color"]), "icon-halo-color": new ms2(Rt.paint_symbol["icon-halo-color"]), "icon-halo-width": new ms2(Rt.paint_symbol["icon-halo-width"]), "icon-halo-blur": new ms2(Rt.paint_symbol["icon-halo-blur"]), "icon-translate": new ys2(Rt.paint_symbol["icon-translate"]), "icon-translate-anchor": new ys2(Rt.paint_symbol["icon-translate-anchor"]), "text-opacity": new ms2(Rt.paint_symbol["text-opacity"]), "text-color": new ms2(Rt.paint_symbol["text-color"], { runtimeType: Yt, getOverride: (t2) => t2.textColor, hasOverride: (t2) => !!t2.textColor }), "text-halo-color": new ms2(Rt.paint_symbol["text-halo-color"]), "text-halo-width": new ms2(Rt.paint_symbol["text-halo-width"]), "text-halo-blur": new ms2(Rt.paint_symbol["text-halo-blur"]), "text-translate": new ys2(Rt.paint_symbol["text-translate"]), "text-translate-anchor": new ys2(Rt.paint_symbol["text-translate-anchor"]) }), layout: fh2 };
          class mh2 {
            constructor(t2) {
              this.type = t2.property.overrides ? t2.property.overrides.runtimeType : Zt2, this.defaultValue = t2;
            }
            evaluate(t2) {
              if (t2.formattedSection) {
                const e2 = this.defaultValue.property.overrides;
                if (e2 && e2.hasOverride(t2.formattedSection))
                  return e2.getOverride(t2.formattedSection);
              }
              return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
            }
            eachChild(t2) {
              this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return null;
            }
          }
          oi2("FormatSectionOverride", mh2, { omit: ["defaultValue"] });
          class gh2 extends Fa2 {
            constructor(t2) {
              super(t2, yh2);
            }
            recalculate(t2, e2) {
              super.recalculate(t2, e2), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
              const r3 = this.layout.get("text-writing-mode");
              if (r3) {
                const t3 = [];
                for (const e3 of r3)
                  t3.indexOf(e3) < 0 && t3.push(e3);
                this.layout._values["text-writing-mode"] = t3;
              } else
                this.layout._values["text-writing-mode"] = this.layout.get("symbol-placement") === "point" ? ["horizontal"] : ["horizontal", "vertical"];
              this._setPaintOverrides();
            }
            getValueAndResolveTokens(t2, e2, r3, n2) {
              const i2 = this.layout.get(t2).evaluate(e2, {}, r3, n2), s2 = this._unevaluatedLayout._values[t2];
              return s2.isDataDriven() || un(s2.value) || !i2 ? i2 : function(t3, e3) {
                return e3.replace(/{([^{}]+)}/g, (e4, r4) => r4 in t3 ? String(t3[r4]) : "");
              }(e2.properties, i2);
            }
            createBucket(t2) {
              return new dh2(t2);
            }
            queryRadius() {
              return 0;
            }
            queryIntersectsFeature() {
              return false;
            }
            _setPaintOverrides() {
              for (const t2 of yh2.paint.overridableProperties) {
                if (!gh2.hasPaintOverride(this.layout, t2))
                  continue;
                const e2 = this.paint.get(t2), r3 = new mh2(e2), n2 = new ln2(r3, e2.property.specification);
                let i2 = null;
                i2 = e2.value.kind === "constant" || e2.value.kind === "source" ? new hn2("source", n2) : new pn2("composite", n2, e2.value.zoomStops, e2.value._interpolationType), this.paint._values[t2] = new ds2(e2.property, i2, e2.parameters);
              }
            }
            _handleOverridablePaintPropertyUpdate(t2, e2, r3) {
              return !(!this.layout || e2.isDataDriven() || r3.isDataDriven()) && gh2.hasPaintOverride(this.layout, t2);
            }
            static hasPaintOverride(t2, e2) {
              const r3 = t2.get("text-field"), n2 = yh2.paint.properties[e2];
              let i2 = false;
              const s2 = (t3) => {
                for (const e3 of t3)
                  if (n2.overrides && n2.overrides.hasOverride(e3))
                    return void (i2 = true);
              };
              if (r3.value.kind === "constant" && r3.value.value instanceof de2)
                s2(r3.value.value.sections);
              else if (r3.value.kind === "source") {
                const t3 = (e4) => {
                  i2 || (e4 instanceof ve2 && ge2(e4.value) === te2 ? s2(e4.value.sections) : e4 instanceof ke ? s2(e4.sections) : e4.eachChild(t3));
                }, e3 = r3.value;
                e3._styleExpression && t3(e3._styleExpression.expression);
              }
              return i2;
            }
            getProgramConfiguration(t2) {
              return new Ma2(this, t2);
            }
          }
          var xh2 = { paint: new bs2({ "background-color": new ys2(Rt.paint_background["background-color"]), "background-pattern": new xs2(Rt.paint_background["background-pattern"]), "background-opacity": new ys2(Rt.paint_background["background-opacity"]) }) }, vh2 = { paint: new bs2({ "raster-opacity": new ys2(Rt.paint_raster["raster-opacity"]), "raster-hue-rotate": new ys2(Rt.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new ys2(Rt.paint_raster["raster-brightness-min"]), "raster-brightness-max": new ys2(Rt.paint_raster["raster-brightness-max"]), "raster-saturation": new ys2(Rt.paint_raster["raster-saturation"]), "raster-contrast": new ys2(Rt.paint_raster["raster-contrast"]), "raster-resampling": new ys2(Rt.paint_raster["raster-resampling"]), "raster-fade-duration": new ys2(Rt.paint_raster["raster-fade-duration"]) }) };
          class bh2 extends Fa2 {
            constructor(t2) {
              super(t2, {}), this.implementation = t2;
            }
            is3D() {
              return this.implementation.renderingMode === "3d";
            }
            hasOffscreenPass() {
              return this.implementation.prerender !== void 0;
            }
            recalculate() {
            }
            updateTransitions() {
            }
            hasTransition() {
            }
            serialize() {
            }
            onAdd(t2) {
              this.implementation.onAdd && this.implementation.onAdd(t2, t2.painter.context.gl);
            }
            onRemove(t2) {
              this.implementation.onRemove && this.implementation.onRemove(t2, t2.painter.context.gl);
            }
          }
          var wh2 = { paint: new bs2({ "sky-type": new ys2(Rt.paint_sky["sky-type"]), "sky-atmosphere-sun": new ys2(Rt.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new ys2(Rt.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new ys2(Rt.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new ys2(Rt.paint_sky["sky-gradient-radius"]), "sky-gradient": new vs2(Rt.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new ys2(Rt.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new ys2(Rt.paint_sky["sky-atmosphere-color"]), "sky-opacity": new ys2(Rt.paint_sky["sky-opacity"]) }) };
          function _h2(t2, e2, r3) {
            const n2 = bo2(0, 0, 1), i2 = Co2(Bo2());
            return function(t3, e3, r4) {
              r4 *= 0.5;
              var n3 = e3[0], i3 = e3[1], s2 = e3[2], a2 = e3[3], o2 = Math.sin(r4), l2 = Math.cos(r4);
              t3[0] = n3 * l2 - s2 * o2, t3[1] = i3 * l2 + a2 * o2, t3[2] = s2 * l2 + n3 * o2, t3[3] = a2 * l2 - i3 * o2;
            }(i2, i2, r3 ? -c(t2) + Math.PI : c(t2)), Po2(i2, i2, -c(e2)), So2(n2, n2, i2), Ao2(n2, n2);
          }
          const kh2 = { circle: class extends Fa2 {
            constructor(t2) {
              super(t2, ho);
            }
            createBucket(t2) {
              return new Xa2(t2);
            }
            queryRadius(t2) {
              const e2 = t2;
              return ao2("circle-radius", this, e2) + ao2("circle-stroke-width", this, e2) + oo2(this.paint.get("circle-translate"));
            }
            queryIntersectsFeature(t2, e2, r3, n2, i2, s2, a2, o2) {
              const l2 = this.paint.get("circle-pitch-alignment") === "map";
              if (l2 && t2.queryGeometry.isAboveHorizon)
                return false;
              const u2 = uo(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), c2 = this.paint.get("circle-radius").evaluate(e2, r3) + this.paint.get("circle-stroke-width").evaluate(e2, r3), h2 = l2 ? c2 * t2.pixelToTileUnitsFactor : c2;
              for (const e3 of n2)
                for (const r4 of e3) {
                  const e4 = r4.add(u2), n3 = o2 && s2.elevation ? s2.elevation.exaggeration() * o2.getElevationAt(e4.x, e4.y, true) : 0, i3 = l2 ? e4 : Do2(e4, n3, a2), c3 = l2 ? t2.tilespaceRays.map((t3) => Fo2(t3, n3)) : t2.queryGeometry.screenGeometry;
                  let p2 = h2;
                  const d2 = Eo2([], [r4.x, r4.y, n3, 1], a2);
                  if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? p2 *= d2[3] / s2.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (p2 *= s2.cameraToCenterDistance / d2[3]), Ha2(c3, i3, p2))
                    return true;
                }
              return false;
            }
            getProgramIds() {
              return ["circle"];
            }
            getProgramConfiguration(t2) {
              return new Ma2(this, t2);
            }
          }, heatmap: class extends Fa2 {
            createBucket(t2) {
              return new Ro2(t2);
            }
            constructor(t2) {
              super(t2, jo2), this._updateColorRamp();
            }
            _handleSpecialPaintPropertyUpdate(t2) {
              t2 === "heatmap-color" && this._updateColorRamp();
            }
            _updateColorRamp() {
              this.colorRamp = Go2({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
            }
            resize() {
              this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
            }
            queryRadius() {
              return 0;
            }
            queryIntersectsFeature() {
              return false;
            }
            hasOffscreenPass() {
              return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
            }
            getProgramIds() {
              return ["heatmap", "heatmapTexture"];
            }
            getProgramConfiguration(t2) {
              return new Ma2(this, t2);
            }
          }, hillshade: class extends Fa2 {
            constructor(t2) {
              super(t2, Zo2);
            }
            hasOffscreenPass() {
              return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
            }
            getProgramIds() {
              return ["hillshade", "hillshadePrepare"];
            }
            getProgramConfiguration(t2) {
              return new Ma2(this, t2);
            }
          }, fill: class extends Fa2 {
            constructor(t2) {
              super(t2, Pl2);
            }
            getProgramIds() {
              const t2 = this.paint.get("fill-pattern"), e2 = t2 && t2.constantOr(1), r3 = [e2 ? "fillPattern" : "fill"];
              return this.paint.get("fill-antialias") && r3.push(e2 && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r3;
            }
            getProgramConfiguration(t2) {
              return new Ma2(this, t2);
            }
            recalculate(t2, e2) {
              super.recalculate(t2, e2);
              const r3 = this.paint._values["fill-outline-color"];
              r3.value.kind === "constant" && r3.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
            }
            createBucket(t2) {
              return new Bl2(t2);
            }
            queryRadius() {
              return oo2(this.paint.get("fill-translate"));
            }
            queryIntersectsFeature(t2, e2, r3, n2, i2, s2) {
              return !t2.queryGeometry.isAboveHorizon && Ya2(lo2(t2.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), n2);
            }
            isTileClipped() {
              return true;
            }
          }, "fill-extrusion": class extends Fa2 {
            constructor(t2) {
              super(t2, Wl2);
            }
            createBucket(t2) {
              return new Yl2(t2);
            }
            queryRadius() {
              return oo2(this.paint.get("fill-extrusion-translate"));
            }
            is3D() {
              return true;
            }
            getProgramIds() {
              return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
            }
            getProgramConfiguration(t2) {
              return new Ma2(this, t2);
            }
            queryIntersectsFeature(t2, e2, r3, n2, s2, a2, o2, l2, u2) {
              const c2 = uo(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a2.angle, t2.pixelToTileUnitsFactor), h2 = this.paint.get("fill-extrusion-height").evaluate(e2, r3), p2 = this.paint.get("fill-extrusion-base").evaluate(e2, r3), d2 = [0, 0], f2 = l2 && a2.elevation, y2 = a2.elevation ? a2.elevation.exaggeration() : 1;
              if (f2) {
                const e3 = t2.tile.getBucket(this).centroidVertexArray, r4 = u2 + 1;
                if (r4 < e3.length) {
                  const t3 = e3.get(r4);
                  d2[0] = t3.a_centroid_pos0, d2[1] = t3.a_centroid_pos1;
                }
              }
              if (d2[0] === 0 && d2[1] === 1)
                return false;
              const m2 = function(t3, e3, r4, n3, s3, a3, o3, l3, u3) {
                return a3 ? function(t4, e4, r5, n4, i2, s4, a4, o4, l4) {
                  const u4 = [], c3 = [], h3 = [0, 0, 0, 1];
                  for (const p3 of t4) {
                    const t5 = [], d3 = [];
                    for (const u5 of p3) {
                      const c4 = u5.x + n4.x, p4 = u5.y + n4.y, f3 = ru2(c4, p4, e4, r5, s4, a4, o4, l4);
                      h3[0] = c4, h3[1] = p4, h3[2] = f3.base, h3[3] = 1, Eo2(h3, h3, i2), h3[3] = Math.max(h3[3], 1e-5);
                      const y3 = eu2([h3[0] / h3[3], h3[1] / h3[3], h3[2] / h3[3]]);
                      h3[0] = c4, h3[1] = p4, h3[2] = f3.top, h3[3] = 1, Eo2(h3, h3, i2), h3[3] = Math.max(h3[3], 1e-5);
                      const m3 = eu2([h3[0] / h3[3], h3[1] / h3[3], h3[2] / h3[3]]);
                      t5.push(y3), d3.push(m3);
                    }
                    u4.push(t5), c3.push(d3);
                  }
                  return [u4, c3];
                }(t3, e3, r4, n3, s3, a3, o3, l3, u3) : function(t4, e4, r5, n4, s4) {
                  const a4 = [], o4 = [], l4 = s4[8] * e4, u4 = s4[9] * e4, c3 = s4[10] * e4, h3 = s4[11] * e4, p3 = s4[8] * r5, d3 = s4[9] * r5, f3 = s4[10] * r5, y3 = s4[11] * r5;
                  for (const e5 of t4) {
                    const t5 = [], r6 = [];
                    for (const a5 of e5) {
                      const e6 = a5.x + n4.x, o5 = a5.y + n4.y, m3 = s4[0] * e6 + s4[4] * o5 + s4[12], g3 = s4[1] * e6 + s4[5] * o5 + s4[13], x3 = s4[2] * e6 + s4[6] * o5 + s4[14], v2 = s4[3] * e6 + s4[7] * o5 + s4[15], b2 = m3 + l4, w3 = g3 + u4, _2 = x3 + c3, k3 = Math.max(v2 + h3, 1e-5), A2 = m3 + p3, S2 = g3 + d3, I3 = x3 + f3, z2 = Math.max(v2 + y3, 1e-5), T2 = new i(b2 / k3, w3 / k3);
                      T2.z = _2 / k3, t5.push(T2);
                      const M3 = new i(A2 / z2, S2 / z2);
                      M3.z = I3 / z2, r6.push(M3);
                    }
                    a4.push(t5), o4.push(r6);
                  }
                  return [a4, o4];
                }(t3, e3, r4, n3, s3);
              }(n2, p2, h2, c2, o2, f2 ? l2 : null, d2, y2, a2.center.lat), g2 = t2.queryGeometry;
              return function(t3, e3, r4) {
                let n3 = 1 / 0;
                Ya2(r4, e3) && (n3 = tu2(r4, e3[0]));
                for (let i2 = 0; i2 < e3.length; i2++) {
                  const s3 = e3[i2], a3 = t3[i2];
                  for (let t4 = 0; t4 < s3.length - 1; t4++) {
                    const e4 = s3[t4], i3 = [e4, s3[t4 + 1], a3[t4 + 1], a3[t4], e4];
                    Ka2(r4, i3) && (n3 = Math.min(n3, tu2(r4, i3)));
                  }
                }
                return n3 !== 1 / 0 && n3;
              }(m2[0], m2[1], g2.isPointQuery() ? g2.screenBounds : g2.screenGeometry);
            }
          }, line: class extends Fa2 {
            constructor(t2) {
              super(t2, hu2), this.gradientVersion = 0;
            }
            _handleSpecialPaintPropertyUpdate(t2) {
              if (t2 === "line-gradient") {
                const t3 = this._transitionablePaint._values["line-gradient"].value.expression;
                this.stepInterpolant = t3._styleExpression && t3._styleExpression.expression instanceof er2, this.gradientVersion = (this.gradientVersion + 1) % o;
              }
            }
            gradientExpression() {
              return this._transitionablePaint._values["line-gradient"].value.expression;
            }
            recalculate(t2, e2) {
              super.recalculate(t2, e2), this.paint._values["line-floorwidth"] = pu2.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t2);
            }
            createBucket(t2) {
              return new uu2(t2);
            }
            getProgramIds() {
              const t2 = this.paint.get("line-dasharray"), e2 = this.paint.get("line-pattern").constantOr(1), r3 = this.paint.get("line-gradient");
              return [e2 ? "linePattern" : t2 ? "lineSDF" : r3 ? "lineGradient" : "line"];
            }
            getProgramConfiguration(t2) {
              return new Ma2(this, t2);
            }
            queryRadius(t2) {
              const e2 = t2, r3 = du2(ao2("line-width", this, e2), ao2("line-gap-width", this, e2)), n2 = ao2("line-offset", this, e2);
              return r3 / 2 + Math.abs(n2) + oo2(this.paint.get("line-translate"));
            }
            queryIntersectsFeature(t2, e2, r3, n2, s2, a2) {
              if (t2.queryGeometry.isAboveHorizon)
                return false;
              const o2 = lo2(t2.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), a2.angle, t2.pixelToTileUnitsFactor), l2 = t2.pixelToTileUnitsFactor / 2 * du2(this.paint.get("line-width").evaluate(e2, r3), this.paint.get("line-gap-width").evaluate(e2, r3)), u2 = this.paint.get("line-offset").evaluate(e2, r3);
              return u2 && (n2 = function(t3, e3) {
                const r4 = [], n3 = new i(0, 0);
                for (let i2 = 0; i2 < t3.length; i2++) {
                  const s3 = t3[i2], a3 = [];
                  for (let t4 = 0; t4 < s3.length; t4++) {
                    const r5 = s3[t4 - 1], i3 = s3[t4], o3 = s3[t4 + 1], l3 = t4 === 0 ? n3 : i3.sub(r5)._unit()._perp(), u3 = t4 === s3.length - 1 ? n3 : o3.sub(i3)._unit()._perp(), c2 = l3._add(u3)._unit();
                    c2._mult(1 / (c2.x * u3.x + c2.y * u3.y)), a3.push(c2._mult(e3)._add(i3));
                  }
                  r4.push(a3);
                }
                return r4;
              }(n2, u2 * t2.pixelToTileUnitsFactor)), function(t3, e3, r4) {
                for (let n3 = 0; n3 < e3.length; n3++) {
                  const i2 = e3[n3];
                  if (t3.length >= 3) {
                    for (let e4 = 0; e4 < i2.length; e4++)
                      if (no2(t3, i2[e4]))
                        return true;
                  }
                  if (Ja2(t3, i2, r4))
                    return true;
                }
                return false;
              }(o2, n2, l2);
            }
            isTileClipped() {
              return true;
            }
          }, symbol: gh2, background: class extends Fa2 {
            constructor(t2) {
              super(t2, xh2);
            }
            getProgramIds() {
              return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
            }
          }, raster: class extends Fa2 {
            constructor(t2) {
              super(t2, vh2);
            }
            getProgramIds() {
              return ["raster"];
            }
          }, sky: class extends Fa2 {
            constructor(t2) {
              super(t2, wh2), this._updateColorRamp();
            }
            _handleSpecialPaintPropertyUpdate(t2) {
              t2 === "sky-gradient" ? this._updateColorRamp() : t2 !== "sky-atmosphere-sun" && t2 !== "sky-atmosphere-halo-color" && t2 !== "sky-atmosphere-color" && t2 !== "sky-atmosphere-sun-intensity" || (this._skyboxInvalidated = true);
            }
            _updateColorRamp() {
              this.colorRamp = Go2({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
            }
            needsSkyboxCapture(t2) {
              if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry)
                return true;
              if (!this.paint.get("sky-atmosphere-sun")) {
                const e2 = t2.style.light.properties.get("position");
                return this._lightPosition.azimuthal !== e2.azimuthal || this._lightPosition.polar !== e2.polar;
              }
            }
            getCenter(t2, e2) {
              const r3 = this.paint.get("sky-type");
              if (r3 === "atmosphere") {
                const r4 = this.paint.get("sky-atmosphere-sun"), n2 = !r4, i2 = t2.style.light, s2 = i2.properties.get("position");
                return n2 && i2.properties.get("anchor") === "viewport" && B("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n2 ? _h2(s2.azimuthal, 90 - s2.polar, e2) : _h2(r4[0], 90 - r4[1], e2);
              }
              if (r3 === "gradient") {
                const t3 = this.paint.get("sky-gradient-center");
                return _h2(t3[0], 90 - t3[1], e2);
              }
            }
            is3D() {
              return false;
            }
            isSky() {
              return true;
            }
            markSkyboxValid(t2) {
              this._skyboxInvalidated = false, this._lightPosition = t2.style.light.properties.get("position");
            }
            hasOffscreenPass() {
              return true;
            }
            getProgramIds() {
              const t2 = this.paint.get("sky-type");
              return t2 === "atmosphere" ? ["skyboxCapture", "skybox"] : t2 === "gradient" ? ["skyboxGradient"] : null;
            }
          } }, { HTMLImageElement: Ah2, HTMLCanvasElement: Sh2, HTMLVideoElement: Ih2, ImageData: zh, ImageBitmap: Th2 } = a;
          class Mh2 {
            constructor(t2, e2, r3, n2) {
              this.context = t2, this.format = r3, this.texture = t2.gl.createTexture(), this.update(e2, n2);
            }
            update(t2, e2, r3) {
              const { width: n2, height: i2 } = t2, s2 = !(this.size && this.size[0] === n2 && this.size[1] === i2 || r3), { context: a2 } = this, { gl: o2 } = a2;
              if (this.useMipmap = Boolean(e2 && e2.useMipmap), o2.bindTexture(o2.TEXTURE_2D, this.texture), a2.pixelStoreUnpackFlipY.set(false), a2.pixelStoreUnpack.set(1), a2.pixelStoreUnpackPremultiplyAlpha.set(this.format === o2.RGBA && (!e2 || e2.premultiply !== false)), s2)
                this.size = [n2, i2], t2 instanceof Ah2 || t2 instanceof Sh2 || t2 instanceof Ih2 || t2 instanceof zh || Th2 && t2 instanceof Th2 ? o2.texImage2D(o2.TEXTURE_2D, 0, this.format, this.format, o2.UNSIGNED_BYTE, t2) : o2.texImage2D(o2.TEXTURE_2D, 0, this.format, n2, i2, 0, this.format, o2.UNSIGNED_BYTE, t2.data);
              else {
                const { x: e3, y: s3 } = r3 || { x: 0, y: 0 };
                t2 instanceof Ah2 || t2 instanceof Sh2 || t2 instanceof Ih2 || t2 instanceof zh || Th2 && t2 instanceof Th2 ? o2.texSubImage2D(o2.TEXTURE_2D, 0, e3, s3, o2.RGBA, o2.UNSIGNED_BYTE, t2) : o2.texSubImage2D(o2.TEXTURE_2D, 0, e3, s3, n2, i2, o2.RGBA, o2.UNSIGNED_BYTE, t2.data);
              }
              this.useMipmap && this.isSizePowerOfTwo() && o2.generateMipmap(o2.TEXTURE_2D);
            }
            bind(t2, e2, r3) {
              const { context: n2 } = this, { gl: i2 } = n2;
              i2.bindTexture(i2.TEXTURE_2D, this.texture), r3 !== i2.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (r3 = i2.LINEAR), t2 !== this.filter && (i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MAG_FILTER, t2), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MIN_FILTER, r3 || t2), this.filter = t2), e2 !== this.wrap && (i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_S, e2), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_T, e2), this.wrap = e2);
            }
            isSizePowerOfTwo() {
              return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
            }
            destroy() {
              const { gl: t2 } = this.context;
              t2.deleteTexture(this.texture), this.texture = null;
            }
          }
          class Eh2 {
            constructor(t2, e2) {
              t2 && (e2 ? this.setSouthWest(t2).setNorthEast(e2) : t2.length === 4 ? this.setSouthWest([t2[0], t2[1]]).setNorthEast([t2[2], t2[3]]) : this.setSouthWest(t2[0]).setNorthEast(t2[1]));
            }
            setNorthEast(t2) {
              return this._ne = t2 instanceof Ch2 ? new Ch2(t2.lng, t2.lat) : Ch2.convert(t2), this;
            }
            setSouthWest(t2) {
              return this._sw = t2 instanceof Ch2 ? new Ch2(t2.lng, t2.lat) : Ch2.convert(t2), this;
            }
            extend(t2) {
              const e2 = this._sw, r3 = this._ne;
              let n2, i2;
              if (t2 instanceof Ch2)
                n2 = t2, i2 = t2;
              else {
                if (!(t2 instanceof Eh2))
                  return Array.isArray(t2) ? t2.length === 4 || t2.every(Array.isArray) ? this.extend(Eh2.convert(t2)) : this.extend(Ch2.convert(t2)) : this;
                if (n2 = t2._sw, i2 = t2._ne, !n2 || !i2)
                  return this;
              }
              return e2 || r3 ? (e2.lng = Math.min(n2.lng, e2.lng), e2.lat = Math.min(n2.lat, e2.lat), r3.lng = Math.max(i2.lng, r3.lng), r3.lat = Math.max(i2.lat, r3.lat)) : (this._sw = new Ch2(n2.lng, n2.lat), this._ne = new Ch2(i2.lng, i2.lat)), this;
            }
            getCenter() {
              return new Ch2((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
            }
            getSouthWest() {
              return this._sw;
            }
            getNorthEast() {
              return this._ne;
            }
            getNorthWest() {
              return new Ch2(this.getWest(), this.getNorth());
            }
            getSouthEast() {
              return new Ch2(this.getEast(), this.getSouth());
            }
            getWest() {
              return this._sw.lng;
            }
            getSouth() {
              return this._sw.lat;
            }
            getEast() {
              return this._ne.lng;
            }
            getNorth() {
              return this._ne.lat;
            }
            toArray() {
              return [this._sw.toArray(), this._ne.toArray()];
            }
            toString() {
              return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
            }
            isEmpty() {
              return !(this._sw && this._ne);
            }
            contains(t2) {
              const { lng: e2, lat: r3 } = Ch2.convert(t2);
              let n2 = this._sw.lng <= e2 && e2 <= this._ne.lng;
              return this._sw.lng > this._ne.lng && (n2 = this._sw.lng >= e2 && e2 >= this._ne.lng), this._sw.lat <= r3 && r3 <= this._ne.lat && n2;
            }
            static convert(t2) {
              return !t2 || t2 instanceof Eh2 ? t2 : new Eh2(t2);
            }
          }
          const Bh2 = 63710088e-1;
          class Ch2 {
            constructor(t2, e2) {
              if (isNaN(t2) || isNaN(e2))
                throw new Error(`Invalid LngLat object: (${t2}, ${e2})`);
              if (this.lng = +t2, this.lat = +e2, this.lat > 90 || this.lat < -90)
                throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
            }
            wrap() {
              return new Ch2(m(this.lng, -180, 180), this.lat);
            }
            toArray() {
              return [this.lng, this.lat];
            }
            toString() {
              return `LngLat(${this.lng}, ${this.lat})`;
            }
            distanceTo(t2) {
              const e2 = Math.PI / 180, r3 = this.lat * e2, n2 = t2.lat * e2, i2 = Math.sin(r3) * Math.sin(n2) + Math.cos(r3) * Math.cos(n2) * Math.cos((t2.lng - this.lng) * e2);
              return Bh2 * Math.acos(Math.min(i2, 1));
            }
            toBounds(t2 = 0) {
              const e2 = 360 * t2 / 40075017, r3 = e2 / Math.cos(Math.PI / 180 * this.lat);
              return new Eh2(new Ch2(this.lng - r3, this.lat - e2), new Ch2(this.lng + r3, this.lat + e2));
            }
            static convert(t2) {
              if (t2 instanceof Ch2)
                return t2;
              if (Array.isArray(t2) && (t2.length === 2 || t2.length === 3))
                return new Ch2(Number(t2[0]), Number(t2[1]));
              if (!Array.isArray(t2) && typeof t2 == "object" && t2 !== null)
                return new Ch2(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
              throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
            }
          }
          const Ph2 = 2 * Math.PI * Bh2;
          function Dh2(t2) {
            return Ph2 * Math.cos(t2 * Math.PI / 180);
          }
          function Vh2(t2) {
            return (180 + t2) / 360;
          }
          function Lh2(t2) {
            return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
          }
          function Fh2(t2, e2) {
            return t2 / Dh2(e2);
          }
          function Rh2(t2) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
          }
          function Uh2(t2, e2) {
            return t2 * Dh2(Rh2(e2));
          }
          class $h2 {
            constructor(t2, e2, r3 = 0) {
              this.x = +t2, this.y = +e2, this.z = +r3;
            }
            static fromLngLat(t2, e2 = 0) {
              const r3 = Ch2.convert(t2);
              return new $h2(Vh2(r3.lng), Lh2(r3.lat), Fh2(e2, r3.lat));
            }
            toLngLat() {
              return new Ch2(360 * this.x - 180, Rh2(this.y));
            }
            toAltitude() {
              return Uh2(this.z, this.y);
            }
            meterInMercatorCoordinateUnits() {
              return 1 / Ph2 * (t2 = Rh2(this.y), 1 / Math.cos(t2 * Math.PI / 180));
              var t2;
            }
          }
          class Oh2 {
            constructor(t2, e2) {
              this.width = t2, this.height = e2, this.nextRow = 0, this.image = new qo2({ width: t2, height: e2 }), this.positions = {}, this.uploaded = false;
            }
            getDash(t2, e2) {
              const r3 = this.getKey(t2, e2);
              return this.positions[r3];
            }
            trim() {
              const t2 = this.width, e2 = this.height = k2(this.nextRow);
              this.image.resize({ width: t2, height: e2 });
            }
            getKey(t2, e2) {
              return t2.join(",") + e2;
            }
            getDashRanges(t2, e2, r3) {
              const n2 = [];
              let i2 = t2.length % 2 == 1 ? -t2[t2.length - 1] * r3 : 0, s2 = t2[0] * r3, a2 = true;
              n2.push({ left: i2, right: s2, isDash: a2, zeroLength: t2[0] === 0 });
              let o2 = t2[0];
              for (let e3 = 1; e3 < t2.length; e3++) {
                a2 = !a2;
                const l2 = t2[e3];
                i2 = o2 * r3, o2 += l2, s2 = o2 * r3, n2.push({ left: i2, right: s2, isDash: a2, zeroLength: l2 === 0 });
              }
              return n2;
            }
            addRoundDash(t2, e2, r3) {
              const n2 = e2 / 2;
              for (let e3 = -r3; e3 <= r3; e3++) {
                const i2 = this.width * (this.nextRow + r3 + e3);
                let s2 = 0, a2 = t2[s2];
                for (let o2 = 0; o2 < this.width; o2++) {
                  o2 / a2.right > 1 && (a2 = t2[++s2]);
                  const l2 = Math.abs(o2 - a2.left), u2 = Math.abs(o2 - a2.right), c2 = Math.min(l2, u2);
                  let h2;
                  const p2 = e3 / r3 * (n2 + 1);
                  if (a2.isDash) {
                    const t3 = n2 - Math.abs(p2);
                    h2 = Math.sqrt(c2 * c2 + t3 * t3);
                  } else
                    h2 = n2 - Math.sqrt(c2 * c2 + p2 * p2);
                  this.image.data[i2 + o2] = Math.max(0, Math.min(255, h2 + 128));
                }
              }
            }
            addRegularDash(t2, e2) {
              for (let e3 = t2.length - 1; e3 >= 0; --e3) {
                const r4 = t2[e3], n3 = t2[e3 + 1];
                r4.zeroLength ? t2.splice(e3, 1) : n3 && n3.isDash === r4.isDash && (n3.left = r4.left, t2.splice(e3, 1));
              }
              const r3 = t2[0], n2 = t2[t2.length - 1];
              r3.isDash === n2.isDash && (r3.left = n2.left - this.width, n2.right = r3.right + this.width);
              const i2 = this.width * this.nextRow;
              let s2 = 0, a2 = t2[s2];
              for (let r4 = 0; r4 < this.width; r4++) {
                r4 / a2.right > 1 && (a2 = t2[++s2]);
                const n3 = Math.abs(r4 - a2.left), o2 = Math.abs(r4 - a2.right), l2 = Math.min(n3, o2);
                this.image.data[i2 + r4] = Math.max(0, Math.min(255, (a2.isDash ? l2 : -l2) + e2 + 128));
              }
            }
            addDash(t2, e2) {
              const r3 = this.getKey(t2, e2);
              if (this.positions[r3])
                return this.positions[r3];
              const n2 = e2 === "round", i2 = n2 ? 7 : 0, s2 = 2 * i2 + 1;
              if (this.nextRow + s2 > this.height)
                return B("LineAtlas out of space"), null;
              t2.length === 0 && t2.push(1);
              let a2 = 0;
              for (let e3 = 0; e3 < t2.length; e3++)
                t2[e3] < 0 && (B("Negative value is found in line dasharray, replacing values with 0"), t2[e3] = 0), a2 += t2[e3];
              if (a2 !== 0) {
                const r4 = this.width / a2, s3 = this.getDashRanges(t2, this.width, r4);
                n2 ? this.addRoundDash(s3, r4, i2) : this.addRegularDash(s3, e2 === "square" ? 0.5 * r4 : 0);
              }
              const o2 = this.nextRow + i2;
              this.nextRow += s2;
              const l2 = { tl: [o2, i2], br: [a2, 0] };
              return this.positions[r3] = l2, l2;
            }
          }
          oi2("LineAtlas", Oh2);
          class qh {
            constructor(t2) {
              this._callback = t2, this._triggered = false, typeof MessageChannel != "undefined" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
                this._triggered = false, this._callback();
              });
            }
            trigger() {
              this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
                this._triggered = false, this._callback();
              }, 0));
            }
            remove() {
              delete this._channel, this._callback = () => {
              };
            }
          }
          const Nh2 = a.performance;
          function jh(t2) {
            const e2 = t2 ? t2.url.toString() : void 0;
            return Nh2.getEntriesByName(e2);
          }
          class Gh {
            constructor() {
              this.tasks = {}, this.taskQueue = [], S(["process"], this), this.invoker = new qh(this.process), this.nextId = 0;
            }
            add(t2, e2) {
              const r3 = this.nextId++, n2 = function({ type: t3, isSymbolTile: e3, zoom: r4 }) {
                return r4 = r4 || 0, t3 === "message" ? 0 : t3 !== "maybePrepare" || e3 ? t3 !== "parseTile" || e3 ? t3 === "parseTile" && e3 ? 300 - r4 : t3 === "maybePrepare" && e3 ? 400 - r4 : 500 : 200 - r4 : 100 - r4;
              }(e2);
              if (n2 === 0) {
                D();
                try {
                  t2();
                } finally {
                }
                return { cancel: () => {
                } };
              }
              return this.tasks[r3] = { fn: t2, metadata: e2, priority: n2, id: r3 }, this.taskQueue.push(r3), this.invoker.trigger(), { cancel: () => {
                delete this.tasks[r3];
              } };
            }
            process() {
              D();
              try {
                if (this.taskQueue = this.taskQueue.filter((t3) => !!this.tasks[t3]), !this.taskQueue.length)
                  return;
                const t2 = this.pick();
                if (t2 === null)
                  return;
                const e2 = this.tasks[t2];
                if (delete this.tasks[t2], this.taskQueue.length && this.invoker.trigger(), !e2)
                  return;
                e2.fn();
              } finally {
              }
            }
            pick() {
              let t2 = null, e2 = 1 / 0;
              for (let r4 = 0; r4 < this.taskQueue.length; r4++) {
                const n2 = this.tasks[this.taskQueue[r4]];
                n2.priority < e2 && (e2 = n2.priority, t2 = r4);
              }
              if (t2 === null)
                return null;
              const r3 = this.taskQueue[t2];
              return this.taskQueue.splice(t2, 1), r3;
            }
            remove() {
              this.invoker.remove();
            }
          }
          function Zh2(t2, e2, r3) {
            var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r3);
            return [t2 * n2 - 2 * Math.PI * 6378137 / 2, e2 * n2 - 2 * Math.PI * 6378137 / 2];
          }
          class Xh {
            constructor(t2, e2, r3) {
              this.z = t2, this.x = e2, this.y = r3, this.key = Yh(0, t2, t2, e2, r3);
            }
            equals(t2) {
              return this.z === t2.z && this.x === t2.x && this.y === t2.y;
            }
            url(t2, e2) {
              const r3 = (i2 = this.y, s2 = this.z, a2 = Zh2(256 * (n2 = this.x), 256 * (i2 = Math.pow(2, s2) - i2 - 1), s2), o2 = Zh2(256 * (n2 + 1), 256 * (i2 + 1), s2), a2[0] + "," + a2[1] + "," + o2[0] + "," + o2[1]);
              var n2, i2, s2, a2, o2;
              const l2 = function(t3, e3, r4) {
                let n3, i3 = "";
                for (let s3 = t3; s3 > 0; s3--)
                  n3 = 1 << s3 - 1, i3 += (e3 & n3 ? 1 : 0) + (r4 & n3 ? 2 : 0);
                return i3;
              }(this.z, this.x, this.y);
              return t2[(this.x + this.y) % t2.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace("{z}", String(this.z)).replace("{x}", String(this.x)).replace("{y}", String(e2 === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", l2).replace("{bbox-epsg-3857}", r3);
            }
            getTilePoint(t2) {
              const e2 = Math.pow(2, this.z);
              return new i((t2.x * e2 - this.x) * Oa2, (t2.y * e2 - this.y) * Oa2);
            }
            getTileVec3(t2) {
              const e2 = Math.pow(2, this.z);
              return bo2((t2.x * e2 - this.x) * Oa2, (t2.y * e2 - this.y) * Oa2, Uh2(t2.z, t2.y));
            }
            toString() {
              return `${this.z}/${this.x}/${this.y}`;
            }
          }
          class Kh {
            constructor(t2, e2) {
              this.wrap = t2, this.canonical = e2, this.key = Yh(t2, e2.z, e2.z, e2.x, e2.y);
            }
          }
          class Hh {
            constructor(t2, e2, r3, n2, i2) {
              this.overscaledZ = t2, this.wrap = e2, this.canonical = new Xh(r3, +n2, +i2), this.key = e2 === 0 && t2 === r3 ? this.canonical.key : Yh(e2, t2, r3, n2, i2);
            }
            equals(t2) {
              return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
            }
            scaledTo(t2) {
              const e2 = this.canonical.z - t2;
              return t2 > this.canonical.z ? new Hh(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Hh(t2, this.wrap, t2, this.canonical.x >> e2, this.canonical.y >> e2);
            }
            calculateScaledKey(t2, e2 = true) {
              if (this.overscaledZ === t2 && e2)
                return this.key;
              if (t2 > this.canonical.z)
                return Yh(this.wrap * +e2, t2, this.canonical.z, this.canonical.x, this.canonical.y);
              {
                const r3 = this.canonical.z - t2;
                return Yh(this.wrap * +e2, t2, t2, this.canonical.x >> r3, this.canonical.y >> r3);
              }
            }
            isChildOf(t2) {
              if (t2.wrap !== this.wrap)
                return false;
              const e2 = this.canonical.z - t2.canonical.z;
              return t2.overscaledZ === 0 || t2.overscaledZ < this.overscaledZ && t2.canonical.x === this.canonical.x >> e2 && t2.canonical.y === this.canonical.y >> e2;
            }
            children(t2) {
              if (this.overscaledZ >= t2)
                return [new Hh(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
              const e2 = this.canonical.z + 1, r3 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
              return [new Hh(e2, this.wrap, e2, r3, n2), new Hh(e2, this.wrap, e2, r3 + 1, n2), new Hh(e2, this.wrap, e2, r3, n2 + 1), new Hh(e2, this.wrap, e2, r3 + 1, n2 + 1)];
            }
            isLessThan(t2) {
              return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
            }
            wrapped() {
              return new Hh(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            unwrapTo(t2) {
              return new Hh(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            overscaleFactor() {
              return Math.pow(2, this.overscaledZ - this.canonical.z);
            }
            toUnwrapped() {
              return new Kh(this.wrap, this.canonical);
            }
            toString() {
              return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
            }
            getTilePoint(t2) {
              return this.canonical.getTilePoint(new $h2(t2.x - this.wrap, t2.y));
            }
            getTileVec3(t2) {
              return this.canonical.getTileVec3(new $h2(t2.x - this.wrap, t2.y, t2.z));
            }
          }
          function Yh(t2, e2, r3, n2, i2) {
            const s2 = 1 << Math.min(r3, 22);
            let a2 = s2 * (i2 % s2) + n2 % s2;
            return t2 && r3 < 22 && (a2 += s2 * s2 * ((t2 < 0 ? -2 * t2 - 1 : 2 * t2) % (1 << 2 * (22 - r3)))), 16 * (32 * a2 + r3) + (e2 - r3);
          }
          oi2("CanonicalTileID", Xh), oi2("OverscaledTileID", Hh, { omit: ["projMatrix"] });
          class Jh2 {
            constructor(t2) {
              this._stringToNumber = {}, this._numberToString = [];
              for (let e2 = 0; e2 < t2.length; e2++) {
                const r3 = t2[e2];
                this._stringToNumber[r3] = e2, this._numberToString[e2] = r3;
              }
            }
            encode(t2) {
              return this._stringToNumber[t2];
            }
            decode(t2) {
              return this._numberToString[t2];
            }
          }
          class Wh2 {
            constructor(t2, e2, r3, n2, i2) {
              this.type = "Feature", this._vectorTileFeature = t2, t2._z = e2, t2._x = r3, t2._y = n2, this.properties = t2.properties, this.id = i2;
            }
            get geometry() {
              return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
            }
            set geometry(t2) {
              this._geometry = t2;
            }
            toJSON() {
              const t2 = { geometry: this.geometry };
              for (const e2 in this)
                e2 !== "_geometry" && e2 !== "_vectorTileFeature" && (t2[e2] = this[e2]);
              return t2;
            }
          }
          var Qh2 = Ss([{ name: "a_pos", type: "Int16", components: 2 }]);
          class tp2 {
            constructor(t2, e2, r3) {
              this.tileID = t2, this.uid = w2(), this.uses = 0, this.tileSize = e2, this.tileZoom = r3, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.expiredRequestCount = 0, this.state = "loading";
            }
            registerFadeDuration(t2) {
              const e2 = t2 + this.timeAdded;
              e2 < q.now() || this.fadeEndTime && e2 < this.fadeEndTime || (this.fadeEndTime = e2);
            }
            wasRequested() {
              return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
            }
            loadVectorData(t2, e2, r3) {
              if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t2) {
                t2.featureIndex && (this.latestFeatureIndex = t2.featureIndex, t2.rawTileData ? (this.latestRawTileData = t2.rawTileData, this.latestFeatureIndex.rawTileData = t2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t2.collisionBoxArray, this.buckets = function(t3, e3) {
                  const r4 = {};
                  if (!e3)
                    return r4;
                  for (const n2 of t3) {
                    const t4 = n2.layerIds.map((t5) => e3.getLayer(t5)).filter(Boolean);
                    if (t4.length !== 0) {
                      n2.layers = t4, n2.stateDependentLayerIds && (n2.stateDependentLayers = n2.stateDependentLayerIds.map((e4) => t4.filter((t5) => t5.id === e4)[0]));
                      for (const e4 of t4)
                        r4[e4.id] = n2;
                    }
                  }
                  return r4;
                }(t2.buckets, e2.style), this.hasSymbolBuckets = false;
                for (const t3 in this.buckets) {
                  const e3 = this.buckets[t3];
                  if (e3 instanceof dh2) {
                    if (this.hasSymbolBuckets = true, !r3)
                      break;
                    e3.justReloaded = true;
                  }
                }
                if (this.hasRTLText = false, this.hasSymbolBuckets)
                  for (const t3 in this.buckets) {
                    const e3 = this.buckets[t3];
                    if (e3 instanceof dh2 && e3.hasRTLText) {
                      this.hasRTLText = true, ss2.isLoading() || ss2.isLoaded() || ns2() !== "deferred" || is2();
                      break;
                    }
                  }
                this.queryPadding = 0;
                for (const t3 in this.buckets) {
                  const r4 = this.buckets[t3];
                  this.queryPadding = Math.max(this.queryPadding, e2.style.getLayer(t3).queryRadius(r4));
                }
                t2.imageAtlas && (this.imageAtlas = t2.imageAtlas), t2.glyphAtlasImage && (this.glyphAtlasImage = t2.glyphAtlasImage), t2.lineAtlas && (this.lineAtlas = t2.lineAtlas);
              } else
                this.collisionBoxArray = new Ys2();
            }
            unloadVectorData() {
              for (const t2 in this.buckets)
                this.buckets[t2].destroy();
              this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
            }
            getBucket(t2) {
              return this.buckets[t2.id];
            }
            upload(t2) {
              for (const e3 in this.buckets) {
                const r3 = this.buckets[e3];
                r3.uploadPending() && r3.upload(t2);
              }
              const e2 = t2.gl;
              this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new Mh2(t2, this.imageAtlas.image, e2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new Mh2(t2, this.glyphAtlasImage, e2.ALPHA), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new Mh2(t2, this.lineAtlas.image, e2.ALPHA), this.lineAtlas.uploaded = true);
            }
            prepare(t2) {
              this.imageAtlas && this.imageAtlas.patchUpdatedImages(t2, this.imageAtlasTexture);
            }
            queryRenderedFeatures(t2, e2, r3, n2, i2, s2, a2, o2) {
              return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ tileResult: n2, pixelPosMatrix: a2, transform: s2, params: i2 }, t2, e2, r3) : {};
            }
            querySourceFeatures(t2, e2) {
              const r3 = this.latestFeatureIndex;
              if (!r3 || !r3.rawTileData)
                return;
              const n2 = r3.loadVTLayers(), i2 = e2 ? e2.sourceLayer : "", s2 = n2._geojsonTileLayer || n2[i2];
              if (!s2)
                return;
              const a2 = An2(e2 && e2.filter), { z: o2, x: l2, y: u2 } = this.tileID.canonical, c2 = { z: o2, x: l2, y: u2 };
              for (let e3 = 0; e3 < s2.length; e3++) {
                const n3 = s2.feature(e3);
                if (a2.needGeometry) {
                  const t3 = Ga2(n3, true);
                  if (!a2.filter(new as2(this.tileID.overscaledZ), t3, this.tileID.canonical))
                    continue;
                } else if (!a2.filter(new as2(this.tileID.overscaledZ), n3))
                  continue;
                const h2 = r3.getId(n3, i2), p2 = new Wh2(n3, o2, l2, u2, h2);
                p2.tile = c2, t2.push(p2);
              }
            }
            hasData() {
              return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
            }
            patternsLoaded() {
              return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
            }
            setExpiryData(t2) {
              const e2 = this.expirationTime;
              if (t2.cacheControl) {
                const e3 = V(t2.cacheControl);
                e3["max-age"] && (this.expirationTime = Date.now() + 1e3 * e3["max-age"]);
              } else
                t2.expires && (this.expirationTime = new Date(t2.expires).getTime());
              if (this.expirationTime) {
                const t3 = Date.now();
                let r3 = false;
                if (this.expirationTime > t3)
                  r3 = false;
                else if (e2)
                  if (this.expirationTime < e2)
                    r3 = true;
                  else {
                    const n2 = this.expirationTime - e2;
                    n2 ? this.expirationTime = t3 + Math.max(n2, 3e4) : r3 = true;
                  }
                else
                  r3 = true;
                r3 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
              }
            }
            getExpiryTimeout() {
              if (this.expirationTime)
                return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
            }
            setFeatureState(t2, e2) {
              if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(t2).length === 0)
                return;
              const r3 = this.latestFeatureIndex.loadVTLayers();
              for (const n2 in this.buckets) {
                if (!e2.style.hasLayer(n2))
                  continue;
                const i2 = this.buckets[n2], s2 = i2.layers[0].sourceLayer || "_geojsonTileLayer", a2 = r3[s2], o2 = t2[s2];
                if (!a2 || !o2 || Object.keys(o2).length === 0)
                  continue;
                i2.update(o2, a2, this.imageAtlas && this.imageAtlas.patternPositions || {});
                const l2 = e2 && e2.style && e2.style.getLayer(n2);
                l2 && (this.queryPadding = Math.max(this.queryPadding, l2.queryRadius(i2)));
              }
            }
            holdingForFade() {
              return this.symbolFadeHoldUntil !== void 0;
            }
            symbolFadeFinished() {
              return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < q.now();
            }
            clearFadeHold() {
              this.symbolFadeHoldUntil = void 0;
            }
            setHoldDuration(t2) {
              this.symbolFadeHoldUntil = q.now() + t2;
            }
            setDependencies(t2, e2) {
              const r3 = {};
              for (const t3 of e2)
                r3[t3] = true;
              this.dependencies[t2] = r3;
            }
            hasDependency(t2, e2) {
              for (const r3 of t2) {
                const t3 = this.dependencies[r3];
                if (t3) {
                  for (const r4 of e2)
                    if (t3[r4])
                      return true;
                }
              }
              return false;
            }
            clearQueryDebugViz() {
            }
          }
          class ep2 {
            constructor() {
              this.state = {}, this.stateChanges = {}, this.deletedStates = {};
            }
            updateState(t2, e2, r3) {
              const n2 = String(e2);
              if (this.stateChanges[t2] = this.stateChanges[t2] || {}, this.stateChanges[t2][n2] = this.stateChanges[t2][n2] || {}, v(this.stateChanges[t2][n2], r3), this.deletedStates[t2] === null) {
                this.deletedStates[t2] = {};
                for (const e3 in this.state[t2])
                  e3 !== n2 && (this.deletedStates[t2][e3] = null);
              } else if (this.deletedStates[t2] && this.deletedStates[t2][n2] === null) {
                this.deletedStates[t2][n2] = {};
                for (const e3 in this.state[t2][n2])
                  r3[e3] || (this.deletedStates[t2][n2][e3] = null);
              } else
                for (const e3 in r3)
                  this.deletedStates[t2] && this.deletedStates[t2][n2] && this.deletedStates[t2][n2][e3] === null && delete this.deletedStates[t2][n2][e3];
            }
            removeFeatureState(t2, e2, r3) {
              if (this.deletedStates[t2] === null)
                return;
              const n2 = String(e2);
              if (this.deletedStates[t2] = this.deletedStates[t2] || {}, r3 && e2 !== void 0)
                this.deletedStates[t2][n2] !== null && (this.deletedStates[t2][n2] = this.deletedStates[t2][n2] || {}, this.deletedStates[t2][n2][r3] = null);
              else if (e2 !== void 0)
                if (this.stateChanges[t2] && this.stateChanges[t2][n2])
                  for (r3 in this.deletedStates[t2][n2] = {}, this.stateChanges[t2][n2])
                    this.deletedStates[t2][n2][r3] = null;
                else
                  this.deletedStates[t2][n2] = null;
              else
                this.deletedStates[t2] = null;
            }
            getState(t2, e2) {
              const r3 = String(e2), n2 = v({}, (this.state[t2] || {})[r3], (this.stateChanges[t2] || {})[r3]);
              if (this.deletedStates[t2] === null)
                return {};
              if (this.deletedStates[t2]) {
                const r4 = this.deletedStates[t2][e2];
                if (r4 === null)
                  return {};
                for (const t3 in r4)
                  delete n2[t3];
              }
              return n2;
            }
            initializeTileState(t2, e2) {
              t2.setFeatureState(this.state, e2);
            }
            coalesceChanges(t2, e2) {
              const r3 = {};
              for (const t3 in this.stateChanges) {
                this.state[t3] = this.state[t3] || {};
                const e3 = {};
                for (const r4 in this.stateChanges[t3])
                  this.state[t3][r4] || (this.state[t3][r4] = {}), v(this.state[t3][r4], this.stateChanges[t3][r4]), e3[r4] = this.state[t3][r4];
                r3[t3] = e3;
              }
              for (const t3 in this.deletedStates) {
                this.state[t3] = this.state[t3] || {};
                const e3 = {};
                if (this.deletedStates[t3] === null)
                  for (const r4 in this.state[t3])
                    e3[r4] = {}, this.state[t3][r4] = {};
                else
                  for (const r4 in this.deletedStates[t3]) {
                    if (this.deletedStates[t3][r4] === null)
                      this.state[t3][r4] = {};
                    else
                      for (const e4 of Object.keys(this.deletedStates[t3][r4]))
                        delete this.state[t3][r4][e4];
                    e3[r4] = this.state[t3][r4];
                  }
                r3[t3] = r3[t3] || {}, v(r3[t3], e3);
              }
              if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(r3).length !== 0)
                for (const n2 in t2)
                  t2[n2].setFeatureState(r3, e2);
            }
          }
          class rp2 {
            constructor(t2) {
              this.size = t2, this.minimums = [], this.maximums = [], this.leaves = [];
            }
            getElevation(t2, e2) {
              const r3 = this.toIdx(t2, e2);
              return { min: this.minimums[r3], max: this.maximums[r3] };
            }
            isLeaf(t2, e2) {
              return this.leaves[this.toIdx(t2, e2)];
            }
            toIdx(t2, e2) {
              return e2 * this.size + t2;
            }
          }
          function np2(t2, e2, r3, n2) {
            let i2 = 0, s2 = Number.MAX_VALUE;
            for (let a2 = 0; a2 < 3; a2++)
              if (Math.abs(n2[a2]) < 1e-15) {
                if (r3[a2] < t2[a2] || r3[a2] > e2[a2])
                  return null;
              } else {
                const o2 = 1 / n2[a2];
                let l2 = (t2[a2] - r3[a2]) * o2, u2 = (e2[a2] - r3[a2]) * o2;
                if (l2 > u2) {
                  const t3 = l2;
                  l2 = u2, u2 = t3;
                }
                if (l2 > i2 && (i2 = l2), u2 < s2 && (s2 = u2), i2 > s2)
                  return null;
              }
            return i2;
          }
          function ip2(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2) {
            const h2 = n2 - t2, p2 = i2 - e2, d2 = s2 - r3, f2 = a2 - t2, y2 = o2 - e2, m2 = l2 - r3, g2 = c2[1] * m2 - c2[2] * y2, x3 = c2[2] * f2 - c2[0] * m2, v2 = c2[0] * y2 - c2[1] * f2, b2 = h2 * g2 + p2 * x3 + d2 * v2;
            if (Math.abs(b2) < 1e-15)
              return null;
            const w3 = 1 / b2, _2 = u2[0] - t2, k3 = u2[1] - e2, A2 = u2[2] - r3, S2 = (_2 * g2 + k3 * x3 + A2 * v2) * w3;
            if (S2 < 0 || S2 > 1)
              return null;
            const I3 = k3 * d2 - A2 * p2, z2 = A2 * h2 - _2 * d2, T2 = _2 * p2 - k3 * h2, M3 = (c2[0] * I3 + c2[1] * z2 + c2[2] * T2) * w3;
            return M3 < 0 || S2 + M3 > 1 ? null : (f2 * I3 + y2 * z2 + m2 * T2) * w3;
          }
          function sp2(t2, e2, r3) {
            return (t2 - e2) / (r3 - e2);
          }
          function ap2(t2, e2, r3, n2, i2, s2, a2, o2, l2) {
            const u2 = 1 << r3, c2 = s2 - n2, h2 = a2 - i2, p2 = (t2 + 1) / u2 * c2 + n2, d2 = (e2 + 0) / u2 * h2 + i2, f2 = (e2 + 1) / u2 * h2 + i2;
            o2[0] = (t2 + 0) / u2 * c2 + n2, o2[1] = d2, l2[0] = p2, l2[1] = f2;
          }
          class op2 {
            constructor(t2) {
              if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t2, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem)
                return;
              const e2 = function(t3) {
                const e3 = Math.ceil(Math.log2(t3.dim / 8)), r4 = [];
                let n3 = Math.ceil(Math.pow(2, e3));
                const i2 = 1 / n3, s2 = (t4, e4, r5, n4, i3) => {
                  const s3 = n4 ? 1 : 0, a3 = (t4 + 1) * r5 - s3, o3 = e4 * r5, l2 = (e4 + 1) * r5 - s3;
                  i3[0] = t4 * r5, i3[1] = o3, i3[2] = a3, i3[3] = l2;
                };
                let a2 = new rp2(n3);
                const o2 = [];
                for (let e4 = 0; e4 < n3 * n3; e4++) {
                  s2(e4 % n3, Math.floor(e4 / n3), i2, false, o2);
                  const r5 = up2(o2[0], o2[1], t3), l2 = up2(o2[2], o2[1], t3), u2 = up2(o2[2], o2[3], t3), c2 = up2(o2[0], o2[3], t3);
                  a2.minimums.push(Math.min(r5, l2, u2, c2)), a2.maximums.push(Math.max(r5, l2, u2, c2)), a2.leaves.push(1);
                }
                for (r4.push(a2), n3 /= 2; n3 >= 1; n3 /= 2) {
                  const t4 = r4[r4.length - 1];
                  a2 = new rp2(n3);
                  for (let e4 = 0; e4 < n3 * n3; e4++) {
                    s2(e4 % n3, Math.floor(e4 / n3), 2, true, o2);
                    const r5 = t4.getElevation(o2[0], o2[1]), i3 = t4.getElevation(o2[2], o2[1]), l2 = t4.getElevation(o2[2], o2[3]), u2 = t4.getElevation(o2[0], o2[3]), c2 = t4.isLeaf(o2[0], o2[1]), h2 = t4.isLeaf(o2[2], o2[1]), p2 = t4.isLeaf(o2[2], o2[3]), d2 = t4.isLeaf(o2[0], o2[3]), f2 = Math.min(r5.min, i3.min, l2.min, u2.min), y2 = Math.max(r5.max, i3.max, l2.max, u2.max), m2 = c2 && h2 && p2 && d2;
                    a2.maximums.push(y2), a2.minimums.push(f2), a2.leaves.push(y2 - f2 <= 5 && m2 ? 1 : 0);
                  }
                  r4.push(a2);
                }
                return r4;
              }(this.dem), r3 = e2.length - 1, n2 = e2[r3];
              this._addNode(n2.minimums[0], n2.maximums[0], n2.leaves[0]), this._construct(e2, 0, 0, r3, 0);
            }
            raycastRoot(t2, e2, r3, n2, i2, s2, a2 = 1) {
              return np2([t2, e2, -100], [r3, n2, this.maximums[0] * a2], i2, s2);
            }
            raycast(t2, e2, r3, n2, i2, s2, a2 = 1) {
              if (!this.nodeCount)
                return null;
              const o2 = this.raycastRoot(t2, e2, r3, n2, i2, s2, a2);
              if (o2 == null)
                return null;
              const l2 = [], u2 = [], c2 = [], h2 = [], p2 = [{ idx: 0, t: o2, nodex: 0, nodey: 0, depth: 0 }];
              for (; p2.length > 0; ) {
                const { idx: o3, t: d2, nodex: f2, nodey: y2, depth: m2 } = p2.pop();
                if (this.leaves[o3]) {
                  ap2(f2, y2, m2, t2, e2, r3, n2, c2, h2);
                  const o4 = 1 << m2, l3 = (f2 + 0) / o4, u3 = (f2 + 1) / o4, p3 = (y2 + 0) / o4, g3 = (y2 + 1) / o4, x3 = up2(l3, p3, this.dem) * a2, v2 = up2(u3, p3, this.dem) * a2, b2 = up2(u3, g3, this.dem) * a2, w3 = up2(l3, g3, this.dem) * a2, _2 = ip2(c2[0], c2[1], x3, h2[0], c2[1], v2, h2[0], h2[1], b2, i2, s2), k3 = ip2(h2[0], h2[1], b2, c2[0], h2[1], w3, c2[0], c2[1], x3, i2, s2), A2 = Math.min(_2 !== null ? _2 : Number.MAX_VALUE, k3 !== null ? k3 : Number.MAX_VALUE);
                  if (A2 !== Number.MAX_VALUE)
                    return A2;
                  {
                    const t3 = ko2([], i2, s2, d2);
                    if (lp2(x3, v2, w3, b2, sp2(t3[0], c2[0], h2[0]), sp2(t3[1], c2[1], h2[1])) >= t3[2])
                      return d2;
                  }
                  continue;
                }
                let g2 = 0;
                for (let p3 = 0; p3 < this._siblingOffset.length; p3++) {
                  ap2((f2 << 1) + this._siblingOffset[p3][0], (y2 << 1) + this._siblingOffset[p3][1], m2 + 1, t2, e2, r3, n2, c2, h2), c2[2] = -100, h2[2] = this.maximums[this.childOffsets[o3] + p3] * a2;
                  const d3 = np2(c2, h2, i2, s2);
                  if (d3 != null) {
                    const t3 = d3;
                    l2[p3] = t3;
                    let e3 = false;
                    for (let r4 = 0; r4 < g2 && !e3; r4++)
                      t3 >= l2[u2[r4]] && (u2.splice(r4, 0, p3), e3 = true);
                    e3 || (u2[g2] = p3), g2++;
                  }
                }
                for (let t3 = 0; t3 < g2; t3++) {
                  const e3 = u2[t3];
                  p2.push({ idx: this.childOffsets[o3] + e3, t: l2[e3], nodex: (f2 << 1) + this._siblingOffset[e3][0], nodey: (y2 << 1) + this._siblingOffset[e3][1], depth: m2 + 1 });
                }
              }
              return null;
            }
            _addNode(t2, e2, r3) {
              return this.minimums.push(t2), this.maximums.push(e2), this.leaves.push(r3), this.childOffsets.push(0), this.nodeCount++;
            }
            _construct(t2, e2, r3, n2, i2) {
              if (t2[n2].isLeaf(e2, r3) === 1)
                return;
              this.childOffsets[i2] || (this.childOffsets[i2] = this.nodeCount);
              const s2 = n2 - 1, a2 = t2[s2];
              let o2, l2 = 0;
              for (let t3 = 0; t3 < this._siblingOffset.length; t3++) {
                const n3 = 2 * e2 + this._siblingOffset[t3][0], i3 = 2 * r3 + this._siblingOffset[t3][1], s3 = a2.getElevation(n3, i3), u2 = a2.isLeaf(n3, i3), c2 = this._addNode(s3.min, s3.max, u2);
                u2 && (l2 |= 1 << t3), o2 || (o2 = c2);
              }
              for (let n3 = 0; n3 < this._siblingOffset.length; n3++)
                l2 & 1 << n3 || this._construct(t2, 2 * e2 + this._siblingOffset[n3][0], 2 * r3 + this._siblingOffset[n3][1], s2, o2 + n3);
            }
          }
          function lp2(t2, e2, r3, n2, i2, s2) {
            return rr2(rr2(t2, r3, s2), rr2(e2, n2, s2), i2);
          }
          function up2(t2, e2, r3) {
            const n2 = r3.dim, i2 = y(t2 * n2 - 0.5, 0, n2 - 1), s2 = y(e2 * n2 - 0.5, 0, n2 - 1), a2 = Math.floor(i2), o2 = Math.floor(s2), l2 = Math.min(a2 + 1, n2 - 1), u2 = Math.min(o2 + 1, n2 - 1);
            return lp2(r3.get(a2, o2), r3.get(l2, o2), r3.get(a2, u2), r3.get(l2, u2), i2 - a2, s2 - o2);
          }
          const cp2 = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
          class hp2 {
            get tree() {
              return this._tree || this._buildQuadTree(), this._tree;
            }
            constructor(t2, e2, r3, n2 = false, i2 = false) {
              if (this.uid = t2, e2.height !== e2.width)
                throw new RangeError("DEM tiles must be square");
              if (r3 && r3 !== "mapbox" && r3 !== "terrarium")
                return B(`"${r3}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
              this.stride = e2.height;
              const s2 = this.dim = e2.height - 2;
              if (this.data = new Uint32Array(e2.data.buffer), this.encoding = r3 || "mapbox", this.borderReady = n2, !n2) {
                for (let t3 = 0; t3 < s2; t3++)
                  this.data[this._idx(-1, t3)] = this.data[this._idx(0, t3)], this.data[this._idx(s2, t3)] = this.data[this._idx(s2 - 1, t3)], this.data[this._idx(t3, -1)] = this.data[this._idx(t3, 0)], this.data[this._idx(t3, s2)] = this.data[this._idx(t3, s2 - 1)];
                this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(s2, -1)] = this.data[this._idx(s2 - 1, 0)], this.data[this._idx(-1, s2)] = this.data[this._idx(0, s2 - 1)], this.data[this._idx(s2, s2)] = this.data[this._idx(s2 - 1, s2 - 1)], i2 && this._buildQuadTree();
              }
            }
            _buildQuadTree() {
              this._tree = new op2(this);
            }
            get(t2, e2, r3 = false) {
              const n2 = new Uint8Array(this.data.buffer);
              r3 && (t2 = y(t2, -1, this.dim), e2 = y(e2, -1, this.dim));
              const i2 = 4 * this._idx(t2, e2);
              return (this.encoding === "terrarium" ? this._unpackTerrarium : this._unpackMapbox)(n2[i2], n2[i2 + 1], n2[i2 + 2]);
            }
            static getUnpackVector(t2) {
              return cp2[t2];
            }
            get unpackVector() {
              return cp2[this.encoding];
            }
            _idx(t2, e2) {
              if (t2 < -1 || t2 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1)
                throw new RangeError("out of range source coordinates for DEM data");
              return (e2 + 1) * this.stride + (t2 + 1);
            }
            _unpackMapbox(t2, e2, r3) {
              return (256 * t2 * 256 + 256 * e2 + r3) / 10 - 1e4;
            }
            _unpackTerrarium(t2, e2, r3) {
              return 256 * t2 + e2 + r3 / 256 - 32768;
            }
            static pack(t2, e2) {
              const r3 = [0, 0, 0, 0], n2 = hp2.getUnpackVector(e2);
              let i2 = Math.floor((t2 + n2[3]) / n2[2]);
              return r3[2] = i2 % 256, i2 = Math.floor(i2 / 256), r3[1] = i2 % 256, i2 = Math.floor(i2 / 256), r3[0] = i2, r3;
            }
            getPixels() {
              return new No2({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
            }
            backfillBorder(t2, e2, r3) {
              if (this.dim !== t2.dim)
                throw new Error("dem dimension mismatch");
              let n2 = e2 * this.dim, i2 = e2 * this.dim + this.dim, s2 = r3 * this.dim, a2 = r3 * this.dim + this.dim;
              switch (e2) {
                case -1:
                  n2 = i2 - 1;
                  break;
                case 1:
                  i2 = n2 + 1;
              }
              switch (r3) {
                case -1:
                  s2 = a2 - 1;
                  break;
                case 1:
                  a2 = s2 + 1;
              }
              const o2 = -e2 * this.dim, l2 = -r3 * this.dim;
              for (let e3 = s2; e3 < a2; e3++)
                for (let r4 = n2; r4 < i2; r4++)
                  this.data[this._idx(r4, e3)] = t2.data[this._idx(r4 + o2, e3 + l2)];
            }
            onDeserialize() {
              this._tree && (this._tree.dem = this);
            }
          }
          oi2("DEMData", hp2), oi2("DemMinMaxQuadTree", op2, { omit: ["dem"] });
          class pp2 {
            constructor(t2, e2) {
              this.max = t2, this.onRemove = e2, this.reset();
            }
            reset() {
              for (const t2 in this.data)
                for (const e2 of this.data[t2])
                  e2.timeout && clearTimeout(e2.timeout), this.onRemove(e2.value);
              return this.data = {}, this.order = [], this;
            }
            add(t2, e2, r3) {
              const n2 = t2.wrapped().key;
              this.data[n2] === void 0 && (this.data[n2] = []);
              const i2 = { value: e2, timeout: void 0 };
              if (r3 !== void 0 && (i2.timeout = setTimeout(() => {
                this.remove(t2, i2);
              }, r3)), this.data[n2].push(i2), this.order.push(n2), this.order.length > this.max) {
                const t3 = this._getAndRemoveByKey(this.order[0]);
                t3 && this.onRemove(t3);
              }
              return this;
            }
            has(t2) {
              return t2.wrapped().key in this.data;
            }
            getAndRemove(t2) {
              return this.has(t2) ? this._getAndRemoveByKey(t2.wrapped().key) : null;
            }
            _getAndRemoveByKey(t2) {
              const e2 = this.data[t2].shift();
              return e2.timeout && clearTimeout(e2.timeout), this.data[t2].length === 0 && delete this.data[t2], this.order.splice(this.order.indexOf(t2), 1), e2.value;
            }
            getByKey(t2) {
              const e2 = this.data[t2];
              return e2 ? e2[0].value : null;
            }
            get(t2) {
              return this.has(t2) ? this.data[t2.wrapped().key][0].value : null;
            }
            remove(t2, e2) {
              if (!this.has(t2))
                return this;
              const r3 = t2.wrapped().key, n2 = e2 === void 0 ? 0 : this.data[r3].indexOf(e2), i2 = this.data[r3][n2];
              return this.data[r3].splice(n2, 1), i2.timeout && clearTimeout(i2.timeout), this.data[r3].length === 0 && delete this.data[r3], this.onRemove(i2.value), this.order.splice(this.order.indexOf(r3), 1), this;
            }
            setMaxSize(t2) {
              for (this.max = t2; this.order.length > this.max; ) {
                const t3 = this._getAndRemoveByKey(this.order[0]);
                t3 && this.onRemove(t3);
              }
              return this;
            }
            filter(t2) {
              const e2 = [];
              for (const r3 in this.data)
                for (const n2 of this.data[r3])
                  t2(n2.value) || e2.push(n2);
              for (const t3 of e2)
                this.remove(t3.value.tileID, t3);
            }
          }
          class dp2 {
            constructor(t2, e2, r3) {
              this.func = t2, this.mask = e2, this.range = r3;
            }
          }
          dp2.ReadOnly = false, dp2.ReadWrite = true, dp2.disabled = new dp2(519, dp2.ReadOnly, [0, 1]);
          const fp2 = 7680;
          class yp2 {
            constructor(t2, e2, r3, n2, i2, s2) {
              this.test = t2, this.ref = e2, this.mask = r3, this.fail = n2, this.depthFail = i2, this.pass = s2;
            }
          }
          yp2.disabled = new yp2({ func: 519, mask: 0 }, 0, 0, fp2, fp2, fp2);
          class mp2 {
            constructor(t2, e2, r3) {
              this.blendFunction = t2, this.blendColor = e2, this.mask = r3;
            }
          }
          mp2.Replace = [1, 0], mp2.disabled = new mp2(mp2.Replace, ce2.transparent, [false, false, false, false]), mp2.unblended = new mp2(mp2.Replace, ce2.transparent, [true, true, true, true]), mp2.alphaBlended = new mp2([1, 771], ce2.transparent, [true, true, true, true]);
          const gp = 1029, xp2 = 2305;
          class vp2 {
            constructor(t2, e2, r3) {
              this.enable = t2, this.mode = e2, this.frontFace = r3;
            }
          }
          vp2.disabled = new vp2(false, gp, xp2), vp2.backCCW = new vp2(true, gp, xp2), vp2.backCW = new vp2(true, gp, 2304), vp2.frontCW = new vp2(true, 1028, 2304), vp2.frontCCW = new vp2(true, 1028, xp2);
          class bp2 extends Ft2 {
            constructor(t2, e2, r3) {
              super(), this.id = t2, this._onlySymbols = r3, e2.on("data", (t3) => {
                t3.dataType === "source" && t3.sourceDataType === "metadata" && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && t3.dataType === "source" && t3.sourceDataType === "content" && (this.reload(), this.transform && this.update(this.transform));
              }), e2.on("error", () => {
                this._sourceErrored = true;
              }), this._source = e2, this._tiles = {}, this._cache = new pp2(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new ep2();
            }
            onAdd(t2) {
              this.map = t2, this._maxTileCacheSize = t2 ? t2._maxTileCacheSize : null;
            }
            loaded() {
              if (this._sourceErrored)
                return true;
              if (!this._sourceLoaded)
                return false;
              if (!this._source.loaded())
                return false;
              for (const t2 in this._tiles) {
                const e2 = this._tiles[t2];
                if (e2.state !== "loaded" && e2.state !== "errored")
                  return false;
              }
              return true;
            }
            getSource() {
              return this._source;
            }
            pause() {
              this._paused = true;
            }
            resume() {
              if (!this._paused)
                return;
              const t2 = this._shouldReloadOnResume;
              this._paused = false, this._shouldReloadOnResume = false, t2 && this.reload(), this.transform && this.update(this.transform);
            }
            _loadTile(t2, e2) {
              return t2.isSymbolTile = this._onlySymbols, this._source.loadTile(t2, e2);
            }
            _unloadTile(t2) {
              if (this._source.unloadTile)
                return this._source.unloadTile(t2, () => {
                });
            }
            _abortTile(t2) {
              if (this._source.abortTile)
                return this._source.abortTile(t2, () => {
                });
            }
            serialize() {
              return this._source.serialize();
            }
            prepare(t2) {
              this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
              for (const e2 in this._tiles) {
                const r3 = this._tiles[e2];
                r3.upload(t2), r3.prepare(this.map.style.imageManager);
              }
            }
            getIds() {
              return x2(this._tiles).map((t2) => t2.tileID).sort(wp2).map((t2) => t2.key);
            }
            getRenderableIds(t2) {
              const e2 = [];
              for (const r3 in this._tiles)
                this._isIdRenderable(+r3, t2) && e2.push(this._tiles[r3]);
              return t2 ? e2.sort((t3, e3) => {
                const r3 = t3.tileID, n2 = e3.tileID, s2 = new i(r3.canonical.x, r3.canonical.y)._rotate(this.transform.angle), a2 = new i(n2.canonical.x, n2.canonical.y)._rotate(this.transform.angle);
                return r3.overscaledZ - n2.overscaledZ || a2.y - s2.y || a2.x - s2.x;
              }).map((t3) => t3.tileID.key) : e2.map((t3) => t3.tileID).sort(wp2).map((t3) => t3.key);
            }
            hasRenderableParent(t2) {
              const e2 = this.findLoadedParent(t2, 0);
              return !!e2 && this._isIdRenderable(e2.tileID.key);
            }
            _isIdRenderable(t2, e2) {
              return this._tiles[t2] && this._tiles[t2].hasData() && !this._coveredTiles[t2] && (e2 || !this._tiles[t2].holdingForFade());
            }
            reload() {
              if (this._paused)
                this._shouldReloadOnResume = true;
              else {
                this._cache.reset();
                for (const t2 in this._tiles)
                  this._tiles[t2].state !== "errored" && this._reloadTile(+t2, "reloading");
              }
            }
            _reloadTile(t2, e2) {
              const r3 = this._tiles[t2];
              r3 && (r3.state !== "loading" && (r3.state = e2), this._loadTile(r3, this._tileLoaded.bind(this, r3, t2, e2)));
            }
            _tileLoaded(t2, e2, r3, n2) {
              if (n2)
                return t2.state = "errored", void (n2.status !== 404 ? this._source.fire(new Lt(n2, { tile: t2 })) : this.update(this.transform));
              t2.timeAdded = q.now(), r3 === "expired" && (t2.refreshedUponExpiration = true), this._setTileReloadTimer(e2, t2), this.getSource().type === "raster-dem" && t2.dem && this._backfillDEM(t2), this._state.initializeTileState(t2, this.map ? this.map.painter : null), this._source.fire(new Vt2("data", { dataType: "source", tile: t2, coord: t2.tileID, sourceCacheId: this.id }));
            }
            _backfillDEM(t2) {
              const e2 = this.getRenderableIds();
              for (let n2 = 0; n2 < e2.length; n2++) {
                const i2 = e2[n2];
                if (t2.neighboringTiles && t2.neighboringTiles[i2]) {
                  const e3 = this.getTileByID(i2);
                  r3(t2, e3), r3(e3, t2);
                }
              }
              function r3(t3, e3) {
                if (!t3.dem || t3.dem.borderReady)
                  return;
                t3.needsHillshadePrepare = true, t3.needsDEMTextureUpload = true;
                let r4 = e3.tileID.canonical.x - t3.tileID.canonical.x;
                const n2 = e3.tileID.canonical.y - t3.tileID.canonical.y, i2 = Math.pow(2, t3.tileID.canonical.z), s2 = e3.tileID.key;
                r4 === 0 && n2 === 0 || Math.abs(n2) > 1 || (Math.abs(r4) > 1 && (Math.abs(r4 + i2) === 1 ? r4 += i2 : Math.abs(r4 - i2) === 1 && (r4 -= i2)), e3.dem && t3.dem && (t3.dem.backfillBorder(e3.dem, r4, n2), t3.neighboringTiles && t3.neighboringTiles[s2] && (t3.neighboringTiles[s2].backfilled = true)));
              }
            }
            getTile(t2) {
              return this.getTileByID(t2.key);
            }
            getTileByID(t2) {
              return this._tiles[t2];
            }
            _retainLoadedChildren(t2, e2, r3, n2) {
              for (const i2 in this._tiles) {
                let s2 = this._tiles[i2];
                if (n2[i2] || !s2.hasData() || s2.tileID.overscaledZ <= e2 || s2.tileID.overscaledZ > r3)
                  continue;
                let a2 = s2.tileID;
                for (; s2 && s2.tileID.overscaledZ > e2 + 1; ) {
                  const t3 = s2.tileID.scaledTo(s2.tileID.overscaledZ - 1);
                  s2 = this._tiles[t3.key], s2 && s2.hasData() && (a2 = t3);
                }
                let o2 = a2;
                for (; o2.overscaledZ > e2; )
                  if (o2 = o2.scaledTo(o2.overscaledZ - 1), t2[o2.key]) {
                    n2[a2.key] = a2;
                    break;
                  }
              }
            }
            findLoadedParent(t2, e2) {
              if (t2.key in this._loadedParentTiles) {
                const r3 = this._loadedParentTiles[t2.key];
                return r3 && r3.tileID.overscaledZ >= e2 ? r3 : null;
              }
              for (let r3 = t2.overscaledZ - 1; r3 >= e2; r3--) {
                const e3 = t2.scaledTo(r3), n2 = this._getLoadedTile(e3);
                if (n2)
                  return n2;
              }
            }
            _getLoadedTile(t2) {
              const e2 = this._tiles[t2.key];
              return e2 && e2.hasData() ? e2 : this._cache.getByKey(this._source.reparseOverscaled ? t2.wrapped().key : t2.canonical.key);
            }
            updateCacheSize(t2, e2) {
              e2 = e2 || this._source.tileSize;
              const r3 = Math.ceil(t2.width / e2) + 1, n2 = Math.ceil(t2.height / e2) + 1, i2 = Math.floor(r3 * n2 * 5), s2 = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, i2) : i2;
              this._cache.setMaxSize(s2);
            }
            handleWrapJump(t2) {
              const e2 = Math.round((t2 - (this._prevLng === void 0 ? t2 : this._prevLng)) / 360);
              if (this._prevLng = t2, e2) {
                const t3 = {};
                for (const r3 in this._tiles) {
                  const n2 = this._tiles[r3];
                  n2.tileID = n2.tileID.unwrapTo(n2.tileID.wrap + e2), t3[n2.tileID.key] = n2;
                }
                this._tiles = t3;
                for (const t4 in this._timers)
                  clearTimeout(this._timers[t4]), delete this._timers[t4];
                for (const t4 in this._tiles)
                  this._setTileReloadTimer(+t4, this._tiles[t4]);
              }
            }
            update(t2, e2, r3) {
              if (this.transform = t2, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage)
                return;
              if (this.usedForTerrain && !r3)
                return;
              let n2;
              this.updateCacheSize(t2, e2), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? n2 = t2.getVisibleUnwrappedCoordinates(this._source.tileID).map((t3) => new Hh(t3.canonical.z, t3.wrap, t3.canonical.z, t3.canonical.x, t3.canonical.y)) : (n2 = t2.coveringTiles({ tileSize: e2 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !r3, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain }), this._source.hasTile && (n2 = n2.filter((t3) => this._source.hasTile(t3)))) : n2 = [];
              const i2 = this._updateRetainedTiles(n2);
              if (_p2(this._source.type) && n2.length !== 0) {
                const t3 = {}, e3 = {}, r4 = Object.keys(i2);
                for (const n3 of r4) {
                  const r5 = i2[n3], s4 = this._tiles[n3];
                  if (!s4 || s4.fadeEndTime && s4.fadeEndTime <= q.now())
                    continue;
                  const a2 = this.findLoadedParent(r5, Math.max(r5.overscaledZ - bp2.maxOverzooming, this._source.minzoom));
                  a2 && (this._addTile(a2.tileID), t3[a2.tileID.key] = a2.tileID), e3[n3] = r5;
                }
                const s3 = n2[n2.length - 1].overscaledZ;
                for (const t4 in this._tiles) {
                  const r5 = this._tiles[t4];
                  if (i2[t4] || !r5.hasData())
                    continue;
                  let n3 = r5.tileID;
                  for (; n3.overscaledZ > s3; ) {
                    n3 = n3.scaledTo(n3.overscaledZ - 1);
                    const s4 = this._tiles[n3.key];
                    if (s4 && s4.hasData() && e3[n3.key]) {
                      i2[t4] = r5.tileID;
                      break;
                    }
                  }
                }
                for (const e4 in t3)
                  i2[e4] || (this._coveredTiles[e4] = true, i2[e4] = t3[e4]);
              }
              for (const t3 in i2)
                this._tiles[t3].clearFadeHold();
              const s2 = function(t3, e3) {
                const r4 = [];
                for (const n3 in t3)
                  n3 in e3 || r4.push(n3);
                return r4;
              }(this._tiles, i2);
              for (const t3 of s2) {
                const e3 = this._tiles[t3];
                e3.hasSymbolBuckets && !e3.holdingForFade() ? e3.setHoldDuration(this.map._fadeDuration) : e3.hasSymbolBuckets && !e3.symbolFadeFinished() || this._removeTile(+t3);
              }
              this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
            }
            releaseSymbolFadeTiles() {
              for (const t2 in this._tiles)
                this._tiles[t2].holdingForFade() && this._removeTile(+t2);
            }
            _updateRetainedTiles(t2) {
              const e2 = {};
              if (t2.length === 0)
                return e2;
              const r3 = {}, n2 = t2[t2.length - 1].overscaledZ, i2 = t2[0].overscaledZ, s2 = Math.max(i2 - bp2.maxOverzooming, this._source.minzoom), a2 = Math.max(i2 + bp2.maxUnderzooming, this._source.minzoom), o2 = {};
              for (const r4 of t2) {
                const t3 = this._addTile(r4);
                e2[r4.key] = r4, t3.hasData() || n2 < this._source.maxzoom && (o2[r4.key] = r4);
              }
              this._retainLoadedChildren(o2, n2, a2, e2);
              for (const n3 of t2) {
                let t3 = this._tiles[n3.key];
                if (t3.hasData())
                  continue;
                if (n3.canonical.z >= this._source.maxzoom) {
                  const t4 = n3.children(this._source.maxzoom)[0], r4 = this.getTile(t4);
                  if (r4 && r4.hasData()) {
                    e2[t4.key] = t4;
                    continue;
                  }
                } else {
                  const t4 = n3.children(this._source.maxzoom);
                  if (e2[t4[0].key] && e2[t4[1].key] && e2[t4[2].key] && e2[t4[3].key])
                    continue;
                }
                let i3 = t3.wasRequested();
                for (let a3 = n3.overscaledZ - 1; a3 >= s2; --a3) {
                  const s3 = n3.scaledTo(a3);
                  if (r3[s3.key])
                    break;
                  if (r3[s3.key] = true, t3 = this.getTile(s3), !t3 && i3 && (t3 = this._addTile(s3)), t3 && (e2[s3.key] = s3, i3 = t3.wasRequested(), t3.hasData()))
                    break;
                }
              }
              return e2;
            }
            _updateLoadedParentTileCache() {
              this._loadedParentTiles = {};
              for (const t2 in this._tiles) {
                const e2 = [];
                let r3, n2 = this._tiles[t2].tileID;
                for (; n2.overscaledZ > 0; ) {
                  if (n2.key in this._loadedParentTiles) {
                    r3 = this._loadedParentTiles[n2.key];
                    break;
                  }
                  e2.push(n2.key);
                  const t3 = n2.scaledTo(n2.overscaledZ - 1);
                  if (r3 = this._getLoadedTile(t3), r3)
                    break;
                  n2 = t3;
                }
                for (const t3 of e2)
                  this._loadedParentTiles[t3] = r3;
              }
            }
            _addTile(t2) {
              let e2 = this._tiles[t2.key];
              if (e2)
                return e2;
              e2 = this._cache.getAndRemove(t2), e2 && (this._setTileReloadTimer(t2.key, e2), e2.tileID = t2, this._state.initializeTileState(e2, this.map ? this.map.painter : null), this._cacheTimers[t2.key] && (clearTimeout(this._cacheTimers[t2.key]), delete this._cacheTimers[t2.key], this._setTileReloadTimer(t2.key, e2)));
              const r3 = Boolean(e2);
              return r3 || (e2 = new tp2(t2, this._source.tileSize * t2.overscaleFactor(), this.transform.tileZoom), this._loadTile(e2, this._tileLoaded.bind(this, e2, t2.key, e2.state))), e2 ? (e2.uses++, this._tiles[t2.key] = e2, r3 || this._source.fire(new Vt2("dataloading", { tile: e2, coord: e2.tileID, dataType: "source" })), e2) : null;
            }
            _setTileReloadTimer(t2, e2) {
              t2 in this._timers && (clearTimeout(this._timers[t2]), delete this._timers[t2]);
              const r3 = e2.getExpiryTimeout();
              r3 && (this._timers[t2] = setTimeout(() => {
                this._reloadTile(t2, "expired"), delete this._timers[t2];
              }, r3));
            }
            _removeTile(t2) {
              const e2 = this._tiles[t2];
              e2 && (e2.uses--, delete this._tiles[t2], this._timers[t2] && (clearTimeout(this._timers[t2]), delete this._timers[t2]), e2.uses > 0 || (e2.hasData() && e2.state !== "reloading" ? this._cache.add(e2.tileID, e2, e2.getExpiryTimeout()) : (e2.aborted = true, this._abortTile(e2), this._unloadTile(e2))));
            }
            clearTiles() {
              this._shouldReloadOnResume = false, this._paused = false;
              for (const t2 in this._tiles)
                this._removeTile(+t2);
              this._cache.reset();
            }
            tilesIn(t2, e2, r3) {
              const n2 = [], i2 = this.transform;
              if (!i2)
                return n2;
              for (const s2 in this._tiles) {
                const a2 = this._tiles[s2];
                if (r3 && a2.clearQueryDebugViz(), a2.holdingForFade())
                  continue;
                const o2 = t2.containsTile(a2, i2, e2);
                o2 && n2.push(o2);
              }
              return n2;
            }
            getVisibleCoordinates(t2) {
              const e2 = this.getRenderableIds(t2).map((t3) => this._tiles[t3].tileID);
              for (const t3 of e2)
                t3.projMatrix = this.transform.calculateProjMatrix(t3.toUnwrapped());
              return e2;
            }
            hasTransition() {
              if (this._source.hasTransition())
                return true;
              if (_p2(this._source.type))
                for (const t2 in this._tiles) {
                  const e2 = this._tiles[t2];
                  if (e2.fadeEndTime !== void 0 && e2.fadeEndTime >= q.now())
                    return true;
                }
              return false;
            }
            setFeatureState(t2, e2, r3) {
              this._state.updateState(t2 = t2 || "_geojsonTileLayer", e2, r3);
            }
            removeFeatureState(t2, e2, r3) {
              this._state.removeFeatureState(t2 = t2 || "_geojsonTileLayer", e2, r3);
            }
            getFeatureState(t2, e2) {
              return this._state.getState(t2 = t2 || "_geojsonTileLayer", e2);
            }
            setDependencies(t2, e2, r3) {
              const n2 = this._tiles[t2];
              n2 && n2.setDependencies(e2, r3);
            }
            reloadTilesForDependencies(t2, e2) {
              for (const r3 in this._tiles)
                this._tiles[r3].hasDependency(t2, e2) && this._reloadTile(+r3, "reloading");
              this._cache.filter((r3) => !r3.hasDependency(t2, e2));
            }
          }
          function wp2(t2, e2) {
            const r3 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0), n2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0);
            return t2.overscaledZ - e2.overscaledZ || n2 - r3 || e2.canonical.y - t2.canonical.y || e2.canonical.x - t2.canonical.x;
          }
          function _p2(t2) {
            return t2 === "raster" || t2 === "image" || t2 === "video";
          }
          bp2.maxOverzooming = 10, bp2.maxUnderzooming = 3;
          class kp2 {
            constructor(t2, e2, r3) {
              this._demTile = t2, this._dem = this._demTile.dem, this._scale = e2, this._offset = r3;
            }
            static create(t2, e2, r3) {
              const n2 = r3 || t2.findDEMTileFor(e2);
              if (!n2 || !n2.dem)
                return;
              const i2 = n2.dem, s2 = n2.tileID, a2 = 1 << e2.canonical.z - s2.canonical.z;
              return new kp2(n2, n2.tileSize / Oa2 / a2, [(e2.canonical.x / a2 - s2.canonical.x) * i2.dim, (e2.canonical.y / a2 - s2.canonical.y) * i2.dim]);
            }
            tileCoordToPixel(t2, e2) {
              const r3 = e2 * this._scale + this._offset[1], n2 = Math.floor(t2 * this._scale + this._offset[0]), s2 = Math.floor(r3);
              return new i(n2, s2);
            }
            getElevationAt(t2, e2, r3, n2) {
              const i2 = t2 * this._scale + this._offset[0], s2 = e2 * this._scale + this._offset[1], a2 = Math.floor(i2), o2 = Math.floor(s2), l2 = this._dem;
              return n2 = !!n2, r3 ? rr2(rr2(l2.get(a2, o2, n2), l2.get(a2, o2 + 1, n2), s2 - o2), rr2(l2.get(a2 + 1, o2, n2), l2.get(a2 + 1, o2 + 1, n2), s2 - o2), i2 - a2) : l2.get(a2, o2, n2);
            }
            getElevationAtPixel(t2, e2, r3) {
              return this._dem.get(t2, e2, !!r3);
            }
            getMeterToDEM(t2) {
              return (1 << this._demTile.tileID.canonical.z) * Fh2(1, t2) * this._dem.stride;
            }
          }
          class Ap2 {
            constructor(t2, e2) {
              this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new ri(Oa2, 16, 0), this.featureIndexArray = new ia2(), this.promoteId = e2;
            }
            insert(t2, e2, r3, n2, i2, s2 = 0) {
              const a2 = this.featureIndexArray.length;
              this.featureIndexArray.emplaceBack(r3, n2, i2, s2);
              const o2 = this.grid;
              for (let t3 = 0; t3 < e2.length; t3++) {
                const r4 = e2[t3], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                for (let t4 = 0; t4 < r4.length; t4++) {
                  const e3 = r4[t4];
                  n3[0] = Math.min(n3[0], e3.x), n3[1] = Math.min(n3[1], e3.y), n3[2] = Math.max(n3[2], e3.x), n3[3] = Math.max(n3[3], e3.y);
                }
                n3[0] < Oa2 && n3[1] < Oa2 && n3[2] >= 0 && n3[3] >= 0 && o2.insert(a2, n3[0], n3[1], n3[2], n3[3]);
              }
            }
            loadVTLayers() {
              return this.vtLayers || (this.vtLayers = new Gl2.VectorTile(new Cu(this.rawTileData)).layers, this.sourceLayerCoder = new Jh2(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
            }
            query(t2, e2, r3, n2) {
              this.loadVTLayers();
              const i2 = t2.params || {}, s2 = An2(i2.filter), a2 = t2.tileResult, o2 = t2.transform, l2 = a2.bufferedTilespaceBounds, u2 = this.grid.query(l2.min.x, l2.min.y, l2.max.x, l2.max.y, (t3, e3, r4, n3) => io2(a2.bufferedTilespaceGeometry, t3, e3, r4, n3));
              u2.sort(Ip2);
              let c2 = null;
              o2.elevation && u2.length > 0 && (c2 = kp2.create(o2.elevation, this.tileID));
              const h2 = {};
              let p2;
              for (let o3 = 0; o3 < u2.length; o3++) {
                const l3 = u2[o3];
                if (l3 === p2)
                  continue;
                p2 = l3;
                const d2 = this.featureIndexArray.get(l3);
                let f2 = null;
                this.loadMatchingFeature(h2, d2, s2, i2.layers, i2.availableImages, e2, r3, n2, (e3, r4, n3, i3 = 0) => (f2 || (f2 = ja2(e3)), r4.queryIntersectsFeature(a2, e3, n3, f2, this.z, t2.transform, t2.pixelPosMatrix, c2, i3)));
              }
              return h2;
            }
            loadMatchingFeature(t2, e2, r3, n2, i2, s2, a2, o2, l2) {
              const { featureIndex: u2, bucketIndex: c2, sourceLayerIndex: h2, layoutVertexArrayOffset: p2 } = e2, d2 = this.bucketLayerIDs[c2];
              if (n2 && !function(t3, e3) {
                for (let r4 = 0; r4 < t3.length; r4++)
                  if (e3.indexOf(t3[r4]) >= 0)
                    return true;
                return false;
              }(n2, d2))
                return;
              const f2 = this.sourceLayerCoder.decode(h2), y2 = this.vtLayers[f2].feature(u2);
              if (r3.needGeometry) {
                const t3 = Ga2(y2, true);
                if (!r3.filter(new as2(this.tileID.overscaledZ), t3, this.tileID.canonical))
                  return;
              } else if (!r3.filter(new as2(this.tileID.overscaledZ), y2))
                return;
              const m2 = this.getId(y2, f2);
              for (let e3 = 0; e3 < d2.length; e3++) {
                const r4 = d2[e3];
                if (n2 && n2.indexOf(r4) < 0)
                  continue;
                const c3 = s2[r4];
                if (!c3)
                  continue;
                let h3 = {};
                m2 !== void 0 && o2 && (h3 = o2.getState(c3.sourceLayer || "_geojsonTileLayer", m2));
                const f3 = v({}, a2[r4]);
                f3.paint = Sp2(f3.paint, c3.paint, y2, h3, i2), f3.layout = Sp2(f3.layout, c3.layout, y2, h3, i2);
                const g2 = !l2 || l2(y2, c3, h3, p2);
                if (!g2)
                  continue;
                const x3 = new Wh2(y2, this.z, this.x, this.y, m2);
                x3.layer = f3;
                let b2 = t2[r4];
                b2 === void 0 && (b2 = t2[r4] = []), b2.push({ featureIndex: u2, feature: x3, intersectionZ: g2 });
              }
            }
            lookupSymbolFeatures(t2, e2, r3, n2, i2, s2, a2, o2) {
              const l2 = {};
              this.loadVTLayers();
              const u2 = An2(i2);
              for (const i3 of t2)
                this.loadMatchingFeature(l2, { bucketIndex: r3, sourceLayerIndex: n2, featureIndex: i3, layoutVertexArrayOffset: 0 }, u2, s2, a2, o2, e2);
              return l2;
            }
            hasLayer(t2) {
              for (const e2 of this.bucketLayerIDs)
                for (const r3 of e2)
                  if (t2 === r3)
                    return true;
              return false;
            }
            getId(t2, e2) {
              let r3 = t2.id;
              return this.promoteId && (r3 = t2.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[e2]], typeof r3 == "boolean" && (r3 = Number(r3))), r3;
            }
          }
          function Sp2(t2, e2, r3, n2, i2) {
            return z(t2, (t3, s2) => {
              const a2 = e2 instanceof fs2 ? e2.get(s2) : null;
              return a2 && a2.evaluate ? a2.evaluate(r3, n2, i2) : a2;
            });
          }
          function Ip2(t2, e2) {
            return e2 - t2;
          }
          oi2("FeatureIndex", Ap2, { omit: ["rawTileData", "sourceLayerCoder"] });
          class zp2 {
            constructor(t2) {
              const e2 = {}, r3 = [];
              for (const n3 in t2) {
                const i3 = t2[n3], s3 = e2[n3] = {};
                for (const t3 in i3.glyphs) {
                  const e3 = i3.glyphs[+t3];
                  if (!e3 || e3.bitmap.width === 0 || e3.bitmap.height === 0)
                    continue;
                  const n4 = e3.metrics.localGlyph ? 2 : 1, a2 = { x: 0, y: 0, w: e3.bitmap.width + 2 * n4, h: e3.bitmap.height + 2 * n4 };
                  r3.push(a2), s3[t3] = a2;
                }
              }
              const { w: n2, h: i2 } = ec2(r3), s2 = new qo2({ width: n2 || 1, height: i2 || 1 });
              for (const r4 in t2) {
                const n3 = t2[r4];
                for (const t3 in n3.glyphs) {
                  const i3 = n3.glyphs[+t3];
                  if (!i3 || i3.bitmap.width === 0 || i3.bitmap.height === 0)
                    continue;
                  const a2 = e2[r4][t3], o2 = i3.metrics.localGlyph ? 2 : 1;
                  qo2.copy(i3.bitmap, s2, { x: 0, y: 0 }, { x: a2.x + o2, y: a2.y + o2 }, i3.bitmap);
                }
              }
              this.image = s2, this.positions = e2;
            }
          }
          oi2("GlyphAtlas", zp2);
          class Tp2 {
            constructor(t2) {
              this.tileID = new Hh(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.tileZoom = t2.tileZoom, this.uid = t2.uid, this.zoom = t2.zoom, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.collectResourceTiming, this.returnDependencies = !!t2.returnDependencies, this.promoteId = t2.promoteId, this.enableTerrain = !!t2.enableTerrain, this.isSymbolTile = t2.isSymbolTile;
            }
            parse(t2, e2, r3, n2, i2) {
              this.status = "parsing", this.data = t2, this.collisionBoxArray = new Ys2();
              const s2 = new Jh2(Object.keys(t2.layers).sort()), a2 = new Ap2(this.tileID, this.promoteId);
              a2.bucketLayerIDs = [];
              const o2 = {}, l2 = new Oh2(256, 256), u2 = { featureIndex: a2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, lineAtlas: l2, availableImages: r3 }, c2 = e2.familiesBySource[this.source];
              for (const e3 in c2) {
                const n3 = t2.layers[e3];
                if (!n3)
                  continue;
                let i3 = false, l3 = false;
                for (const t3 of c2[e3])
                  t3[0].type === "symbol" ? i3 = true : l3 = true;
                if (this.isSymbolTile === true && !i3)
                  continue;
                if (this.isSymbolTile === false && !l3)
                  continue;
                n3.version === 1 && B(`Vector tile source "${this.source}" layer "${e3}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const h3 = s2.encode(e3), p3 = [];
                for (let t3 = 0; t3 < n3.length; t3++) {
                  const r4 = n3.feature(t3), i4 = a2.getId(r4, e3);
                  p3.push({ feature: r4, id: i4, index: t3, sourceLayerIndex: h3 });
                }
                for (const t3 of c2[e3]) {
                  const e4 = t3[0];
                  this.isSymbolTile !== void 0 && e4.type === "symbol" !== this.isSymbolTile || e4.minzoom && this.zoom < Math.floor(e4.minzoom) || e4.maxzoom && this.zoom >= e4.maxzoom || e4.visibility !== "none" && (Mp2(t3, this.zoom, r3), (o2[e4.id] = e4.createBucket({ index: a2.bucketLayerIDs.length, layers: t3, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: h3, sourceID: this.source, enableTerrain: this.enableTerrain })).populate(p3, u2, this.tileID.canonical), a2.bucketLayerIDs.push(t3.map((t4) => t4.id)));
                }
              }
              let h2, p2, d2, f2;
              l2.trim();
              const y2 = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, m2 = z(u2.glyphDependencies, (t3) => Object.keys(t3).map(Number));
              Object.keys(m2).length ? n2.send("getGlyphs", { uid: this.uid, stacks: m2 }, (t3, e3) => {
                h2 || (h2 = t3, p2 = e3, b2.call(this));
              }, void 0, false, y2) : p2 = {};
              const g2 = Object.keys(u2.iconDependencies);
              g2.length ? n2.send("getImages", { icons: g2, source: this.source, tileID: this.tileID, type: "icons" }, (t3, e3) => {
                h2 || (h2 = t3, d2 = e3, b2.call(this));
              }, void 0, false, y2) : d2 = {};
              const v2 = Object.keys(u2.patternDependencies);
              function b2() {
                if (h2)
                  return i2(h2);
                if (p2 && d2 && f2) {
                  const t3 = new zp2(p2), e3 = new nc(d2, f2);
                  for (const n3 in o2) {
                    const i3 = o2[n3];
                    i3 instanceof dh2 ? (Mp2(i3.layers, this.zoom, r3), Jc2(i3, p2, t3.positions, d2, e3.iconPositions, this.showCollisionBoxes, this.tileID.canonical, this.tileZoom)) : i3.hasPattern && (i3 instanceof uu2 || i3 instanceof Bl2 || i3 instanceof Yl2) && (Mp2(i3.layers, this.zoom, r3), i3.addFeatures(u2, this.tileID.canonical, e3.patternPositions));
                  }
                  this.status = "done", i2(null, { buckets: x2(o2).filter((t4) => !t4.isEmpty()), featureIndex: a2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t3.image, lineAtlas: l2, imageAtlas: e3, glyphMap: this.returnDependencies ? p2 : null, iconMap: this.returnDependencies ? d2 : null, glyphPositions: this.returnDependencies ? t3.positions : null });
                }
              }
              v2.length ? n2.send("getImages", { icons: v2, source: this.source, tileID: this.tileID, type: "patterns" }, (t3, e3) => {
                h2 || (h2 = t3, f2 = e3, b2.call(this));
              }, void 0, false, y2) : f2 = {}, b2.call(this);
            }
          }
          function Mp2(t2, e2, r3) {
            const n2 = new as2(e2);
            for (const e3 of t2)
              e3.recalculate(n2, r3);
          }
          class Ep2 {
            constructor(t2) {
              this.entries = {}, this.scheduler = t2;
            }
            request(t2, e2, r3, n2) {
              const i2 = this.entries[t2] = this.entries[t2] || { callbacks: [] };
              if (i2.result) {
                const [t3, r4] = i2.result;
                return this.scheduler ? this.scheduler.add(() => {
                  n2(t3, r4);
                }, e2) : n2(t3, r4), () => {
                };
              }
              return i2.callbacks.push(n2), i2.cancel || (i2.cancel = r3((r4, n3) => {
                i2.result = [r4, n3];
                for (const t3 of i2.callbacks)
                  this.scheduler ? this.scheduler.add(() => {
                    t3(r4, n3);
                  }, e2) : t3(r4, n3);
                setTimeout(() => delete this.entries[t2], 3e3);
              })), () => {
                i2.result || (i2.callbacks = i2.callbacks.filter((t3) => t3 !== n2), i2.callbacks.length || (i2.cancel(), delete this.entries[t2]));
              };
            }
          }
          function Bp2(t2, e2, r3) {
            const n2 = JSON.stringify(t2.request);
            return t2.data && (this.deduped.entries[n2] = { result: [null, t2.data] }), this.deduped.request(n2, { type: "parseTile", isSymbolTile: t2.isSymbolTile, zoom: t2.tileZoom }, (e3) => {
              const n3 = St2(t2.request, (t3, n4, i2, s2) => {
                t3 ? e3(t3) : n4 && e3(null, { vectorTile: r3 ? void 0 : new Gl2.VectorTile(new Cu(n4)), rawData: n4, cacheControl: i2, expires: s2 });
              });
              return () => {
                n3.cancel(), e3();
              };
            }, e2);
          }
          t.ARRAY_TYPE = po2, t.AUTH_ERR_MSG = W, t.Actor = class {
            constructor(t2, e2, r3) {
              this.target = t2, this.parent = e2, this.mapId = r3, this.callbacks = {}, this.cancelCallbacks = {}, S(["receive"], this), this.target.addEventListener("message", this.receive, false), this.globalScope = D() ? t2 : a, this.scheduler = new Gh();
            }
            send(t2, e2, r3, n2, i2 = false, s2) {
              const a2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
              r3 && (r3.metadata = s2, this.callbacks[a2] = r3);
              const o2 = $2(this.globalScope) ? void 0 : [];
              return this.target.postMessage({ id: a2, type: t2, hasCallback: !!r3, targetMapId: n2, mustQueue: i2, sourceMapId: this.mapId, data: ci2(e2, o2) }, o2), { cancel: () => {
                r3 && delete this.callbacks[a2], this.target.postMessage({ id: a2, type: "<cancel>", targetMapId: n2, sourceMapId: this.mapId });
              } };
            }
            receive(t2) {
              const e2 = t2.data, r3 = e2.id;
              if (r3 && (!e2.targetMapId || this.mapId === e2.targetMapId))
                if (e2.type === "<cancel>") {
                  const t3 = this.cancelCallbacks[r3];
                  delete this.cancelCallbacks[r3], t3 && t3.cancel();
                } else if (e2.mustQueue || D()) {
                  const t3 = this.callbacks[r3];
                  this.cancelCallbacks[r3] = this.scheduler.add(() => this.processTask(r3, e2), t3 && t3.metadata || { type: "message" });
                } else
                  this.processTask(r3, e2);
            }
            processTask(t2, e2) {
              if (e2.type === "<response>") {
                const r3 = this.callbacks[t2];
                delete this.callbacks[t2], r3 && (e2.error ? r3(hi(e2.error)) : r3(null, hi(e2.data)));
              } else {
                const r3 = $2(this.globalScope) ? void 0 : [], n2 = e2.hasCallback ? (e3, n3) => {
                  delete this.cancelCallbacks[t2], this.target.postMessage({ id: t2, type: "<response>", sourceMapId: this.mapId, error: e3 ? ci2(e3) : null, data: ci2(n3, r3) }, r3);
                } : (t3) => {
                }, i2 = hi(e2.data);
                if (this.parent[e2.type])
                  this.parent[e2.type](e2.sourceMapId, i2, n2);
                else if (this.parent.getWorkerSource) {
                  const t3 = e2.type.split(".");
                  this.parent.getWorkerSource(e2.sourceMapId, t3[0], i2.source)[t3[1]](i2, n2);
                } else
                  n2(new Error(`Could not find function ${e2.type}`));
              }
            }
            remove() {
              this.scheduler.remove(), this.target.removeEventListener("message", this.receive, false);
            }
          }, t.CanonicalTileID = Xh, t.Color = ce2, t.ColorMode = mp2, t.CullFaceMode = vp2, t.DEMData = hp2, t.DataConstantProperty = ys2, t.DedupedRequest = Ep2, t.DepthMode = dp2, t.EXTENT = Oa2, t.Elevation = class {
            getAtPointOrZero(t2, e2 = 0) {
              return this.getAtPoint(t2, e2) || 0;
            }
            getAtPoint(t2, e2, r3 = true) {
              e2 == null && (e2 = null);
              const n2 = this._source();
              if (!n2)
                return e2;
              if (t2.y < 0 || t2.y > 1)
                return e2;
              const i2 = n2.getSource().maxzoom, s2 = 1 << i2, a2 = Math.floor(t2.x), o2 = t2.x - a2, l2 = new Hh(i2, a2, i2, Math.floor(o2 * s2), Math.floor(t2.y * s2)), u2 = this.findDEMTileFor(l2);
              if (!u2 || !u2.dem)
                return e2;
              const c2 = u2.dem, h2 = 1 << u2.tileID.canonical.z, p2 = (o2 * h2 - u2.tileID.canonical.x) * c2.dim, d2 = (t2.y * h2 - u2.tileID.canonical.y) * c2.dim, f2 = Math.floor(p2), y2 = Math.floor(d2);
              return (r3 ? this.exaggeration() : 1) * rr2(rr2(c2.get(f2, y2), c2.get(f2, y2 + 1), d2 - y2), rr2(c2.get(f2 + 1, y2), c2.get(f2 + 1, y2 + 1), d2 - y2), p2 - f2);
            }
            getAtTileOffset(t2, e2, r3) {
              const n2 = 1 << t2.canonical.z;
              return this.getAtPointOrZero(new $h2(t2.wrap + (t2.canonical.x + e2 / Oa2) / n2, (t2.canonical.y + r3 / Oa2) / n2));
            }
            getForTilePoints(t2, e2, r3, n2) {
              const i2 = kp2.create(this, t2, n2);
              return !!i2 && (e2.forEach((t3) => {
                t3[2] = this.exaggeration() * i2.getElevationAt(t3[0], t3[1], r3);
              }), true);
            }
            getMinMaxForTile(t2) {
              const e2 = this.findDEMTileFor(t2);
              if (!e2 || !e2.dem)
                return null;
              const r3 = e2.dem.tree, n2 = e2.tileID, i2 = 1 << t2.canonical.z - n2.canonical.z;
              let s2 = t2.canonical.x / i2 - n2.canonical.x, a2 = t2.canonical.y / i2 - n2.canonical.y, o2 = 0;
              for (let e3 = 0; e3 < t2.canonical.z - n2.canonical.z && !r3.leaves[o2]; e3++) {
                s2 *= 2, a2 *= 2;
                const t3 = 2 * Math.floor(a2) + Math.floor(s2);
                o2 = r3.childOffsets[o2] + t3, s2 %= 1, a2 %= 1;
              }
              return { min: this.exaggeration() * r3.minimums[o2], max: this.exaggeration() * r3.maximums[o2] };
            }
            getMinElevationBelowMSL() {
              throw new Error("Pure virtual method called.");
            }
            raycast(t2, e2, r3) {
              throw new Error("Pure virtual method called.");
            }
            pointCoordinate(t2) {
              throw new Error("Pure virtual method called.");
            }
            _source() {
              throw new Error("Pure virtual method called.");
            }
            exaggeration() {
              throw new Error("Pure virtual method called.");
            }
            findDEMTileFor(t2) {
              throw new Error("Pure virtual method called.");
            }
            get visibleDemTiles() {
              throw new Error("Getter must be implemented in subclass.");
            }
          }, t.ErrorEvent = Lt, t.EvaluationParameters = as2, t.Event = Vt2, t.Evented = Ft2, t.GlyphManager = Lc, t.ImagePosition = rc2, t.LineAtlas = Oh2, t.LngLat = Ch2, t.LngLatBounds = Eh2, t.LocalGlyphMode = Vc2, t.MAX_SAFE_INTEGER = o, t.MercatorCoordinate = $h2, t.ONE_EM = bu, t.OverscaledTileID = Hh, t.Properties = bs2, t.RGBAImage = No2, t.RequestManager = class {
            constructor(t2, e2, r3) {
              this._transformRequestFn = t2, this._customAccessToken = e2, this._silenceAuthErrors = !!r3, this._createSkuToken();
            }
            _createSkuToken() {
              const t2 = function() {
                let t3 = "";
                for (let e2 = 0; e2 < 10; e2++)
                  t3 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
                return { token: ["1", J, t3].join(""), tokenExpiresAt: Date.now() + 432e5 };
              }();
              this._skuToken = t2.token, this._skuTokenExpiresAt = t2.tokenExpiresAt;
            }
            _isSkuTokenExpired() {
              return Date.now() > this._skuTokenExpiresAt;
            }
            transformRequest(t2, e2) {
              return this._transformRequestFn && this._transformRequestFn(t2, e2) || { url: t2 };
            }
            normalizeStyleURL(t2, e2) {
              if (!Q2(t2))
                return t2;
              const r3 = rt(t2);
              return r3.path = `/styles/v1${r3.path}`, this._makeAPIURL(r3, this._customAccessToken || e2);
            }
            normalizeGlyphsURL(t2, e2) {
              if (!Q2(t2))
                return t2;
              const r3 = rt(t2);
              return r3.path = `/fonts/v1${r3.path}`, this._makeAPIURL(r3, this._customAccessToken || e2);
            }
            normalizeSourceURL(t2, e2) {
              if (!Q2(t2))
                return t2;
              const r3 = rt(t2);
              return r3.path = `/v4/${r3.authority}.json`, r3.params.push("secure"), this._makeAPIURL(r3, this._customAccessToken || e2);
            }
            normalizeSpriteURL(t2, e2, r3, n2) {
              const i2 = rt(t2);
              return Q2(t2) ? (i2.path = `/styles/v1${i2.path}/sprite${e2}${r3}`, this._makeAPIURL(i2, this._customAccessToken || n2)) : (i2.path += `${e2}${r3}`, nt2(i2));
            }
            normalizeTileURL(t2, e2, r3) {
              if (this._isSkuTokenExpired() && this._createSkuToken(), t2 && !Q2(t2))
                return t2;
              const n2 = rt(t2);
              n2.path = n2.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${e2 || r3 && n2.authority !== "raster" && r3 === 512 ? "@2x" : ""}${G2.supported ? ".webp" : "$1"}`), n2.authority === "raster" ? n2.path = `/${j2.RASTER_URL_PREFIX}${n2.path}` : (n2.path = n2.path.replace(/^.+\/v4\//, "/"), n2.path = `/${j2.TILE_URL_VERSION}${n2.path}`);
              const i2 = this._customAccessToken || function(t3) {
                for (const e3 of t3) {
                  const t4 = e3.match(/^access_token=(.*)$/);
                  if (t4)
                    return t4[1];
                }
                return null;
              }(n2.params) || j2.ACCESS_TOKEN;
              return j2.REQUIRE_ACCESS_TOKEN && i2 && this._skuToken && n2.params.push(`sku=${this._skuToken}`), this._makeAPIURL(n2, i2);
            }
            canonicalizeTileURL(t2, e2) {
              const r3 = rt(t2);
              if (!r3.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !r3.path.match(/\.[\w]+$/))
                return t2;
              let n2 = "mapbox://";
              r3.path.match(/^\/raster\/v1\//) ? n2 += `raster/${r3.path.replace(`/${j2.RASTER_URL_PREFIX}/`, "")}` : n2 += `tiles/${r3.path.replace(`/${j2.TILE_URL_VERSION}/`, "")}`;
              let i2 = r3.params;
              return e2 && (i2 = i2.filter((t3) => !t3.match(/^access_token=/))), i2.length && (n2 += `?${i2.join("&")}`), n2;
            }
            canonicalizeTileset(t2, e2) {
              const r3 = !!e2 && Q2(e2), n2 = [];
              for (const e3 of t2.tiles || [])
                tt(e3) ? n2.push(this.canonicalizeTileURL(e3, r3)) : n2.push(e3);
              return n2;
            }
            _makeAPIURL(t2, e2) {
              const r3 = "See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes", n2 = rt(j2.API_URL);
              if (t2.protocol = n2.protocol, t2.authority = n2.authority, t2.protocol === "http") {
                const e3 = t2.params.indexOf("secure");
                e3 >= 0 && t2.params.splice(e3, 1);
              }
              if (n2.path !== "/" && (t2.path = `${n2.path}${t2.path}`), !j2.REQUIRE_ACCESS_TOKEN)
                return nt2(t2);
              if (e2 = e2 || j2.ACCESS_TOKEN, !this._silenceAuthErrors) {
                if (!e2)
                  throw new Error(`An API access token is required to use Mapbox GL. ${r3}`);
                if (e2[0] === "s")
                  throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r3}`);
              }
              return t2.params = t2.params.filter((t3) => t3.indexOf("access_token") === -1), t2.params.push(`access_token=${e2 || ""}`), nt2(t2);
            }
          }, t.ResourceType = wt2, t.SegmentVector = $a2, t.SourceCache = bp2, t.StencilMode = yp2, t.StructArrayLayout1ui2 = Xs2, t.StructArrayLayout2f1f2i16 = Rs2, t.StructArrayLayout2i4 = zs, t.StructArrayLayout2ui4 = Zs2, t.StructArrayLayout3f12 = Ds, t.StructArrayLayout3ui6 = $s2, t.StructArrayLayout4i8 = Ts2, t.Texture = Mh2, t.Tile = tp2, t.Transitionable = us2, t.Uniform1f = xa2, t.Uniform1i = class extends ga2 {
            constructor(t2, e2) {
              super(t2, e2), this.current = 0;
            }
            set(t2) {
              this.current !== t2 && (this.current = t2, this.gl.uniform1i(this.location, t2));
            }
          }, t.Uniform2f = class extends ga2 {
            constructor(t2, e2) {
              super(t2, e2), this.current = [0, 0];
            }
            set(t2) {
              t2[0] === this.current[0] && t2[1] === this.current[1] || (this.current = t2, this.gl.uniform2f(this.location, t2[0], t2[1]));
            }
          }, t.Uniform3f = class extends ga2 {
            constructor(t2, e2) {
              super(t2, e2), this.current = [0, 0, 0];
            }
            set(t2) {
              t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] || (this.current = t2, this.gl.uniform3f(this.location, t2[0], t2[1], t2[2]));
            }
          }, t.Uniform4f = va, t.UniformColor = ba2, t.UniformMatrix3f = class extends ga2 {
            constructor(t2, e2) {
              super(t2, e2), this.current = _a2;
            }
            set(t2) {
              for (let e2 = 0; e2 < 9; e2++)
                if (t2[e2] !== this.current[e2]) {
                  this.current = t2, this.gl.uniformMatrix3fv(this.location, false, t2);
                  break;
                }
            }
          }, t.UniformMatrix4f = class extends ga2 {
            constructor(t2, e2) {
              super(t2, e2), this.current = wa2;
            }
            set(t2) {
              if (t2[12] !== this.current[12] || t2[0] !== this.current[0])
                return this.current = t2, void this.gl.uniformMatrix4fv(this.location, false, t2);
              for (let e2 = 1; e2 < 16; e2++)
                if (t2[e2] !== this.current[e2]) {
                  this.current = t2, this.gl.uniformMatrix4fv(this.location, false, t2);
                  break;
                }
            }
          }, t.UnwrappedTileID = Kh, t.ValidationError = Ut2, t.VectorTileWorkerSource = class extends Ft2 {
            constructor(t2, e2, r3, n2, i2) {
              super(), this.actor = t2, this.layerIndex = e2, this.availableImages = r3, this.loadVectorData = i2 || Bp2, this.loading = {}, this.loaded = {}, this.deduped = new Ep2(t2.scheduler), this.isSpriteLoaded = n2, this.scheduler = t2.scheduler;
            }
            loadTile(t2, e2) {
              const r3 = t2.uid, n2 = t2 && t2.request, i2 = n2 && n2.collectResourceTiming, s2 = this.loading[r3] = new Tp2(t2);
              s2.abort = this.loadVectorData(t2, (a2, o2) => {
                const l2 = !this.loading[r3];
                if (delete this.loading[r3], l2 || a2 || !o2)
                  return s2.status = "done", l2 || (this.loaded[r3] = s2), e2(a2);
                const u2 = o2.rawData, c2 = {};
                o2.expires && (c2.expires = o2.expires), o2.cacheControl && (c2.cacheControl = o2.cacheControl), s2.vectorTile = o2.vectorTile || new Gl2.VectorTile(new Cu(u2));
                const h2 = () => {
                  s2.parse(s2.vectorTile, this.layerIndex, this.availableImages, this.actor, (t3, r4) => {
                    if (t3 || !r4)
                      return e2(t3);
                    const s3 = {};
                    if (i2) {
                      const t4 = jh(n2);
                      t4.length > 0 && (s3.resourceTiming = JSON.parse(JSON.stringify(t4)));
                    }
                    e2(null, v({ rawTileData: u2.slice(0) }, r4, c2, s3));
                  });
                };
                this.isSpriteLoaded ? h2() : this.once("isSpriteLoaded", () => {
                  this.scheduler ? this.scheduler.add(h2, { type: "parseTile", isSymbolTile: t2.isSymbolTile, zoom: t2.tileZoom }) : h2();
                }), this.loaded = this.loaded || {}, this.loaded[r3] = s2;
              });
            }
            reloadTile(t2, e2) {
              const r3 = this.loaded, n2 = t2.uid, i2 = this;
              if (r3 && r3[n2]) {
                const s2 = r3[n2];
                s2.showCollisionBoxes = t2.showCollisionBoxes, s2.enableTerrain = !!t2.enableTerrain;
                const a2 = (t3, r4) => {
                  const n3 = s2.reloadCallback;
                  n3 && (delete s2.reloadCallback, s2.parse(s2.vectorTile, i2.layerIndex, this.availableImages, i2.actor, n3)), e2(t3, r4);
                };
                s2.status === "parsing" ? s2.reloadCallback = a2 : s2.status === "done" && (s2.vectorTile ? s2.parse(s2.vectorTile, this.layerIndex, this.availableImages, this.actor, a2) : a2());
              }
            }
            abortTile(t2, e2) {
              const r3 = t2.uid, n2 = this.loading[r3];
              n2 && (n2.abort && n2.abort(), delete this.loading[r3]), e2();
            }
            removeTile(t2, e2) {
              const r3 = this.loaded, n2 = t2.uid;
              r3 && r3[n2] && delete r3[n2], e2();
            }
          }, t.WritingMode = ic, t.ZoomHistory = pi, t.add = function(t2, e2, r3) {
            return t2[0] = e2[0] + r3[0], t2[1] = e2[1] + r3[1], t2[2] = e2[2] + r3[2], t2;
          }, t.addDynamicAttributes = uh2, t.altitudeFromMercatorZ = Uh2, t.asyncAll = g, t.bezier = d, t.bindAll = S, t.bufferConvexPolygon = function(t2, e2) {
            const r3 = [];
            for (let n2 = 0; n2 < t2.length; n2++) {
              const i2 = m(n2 - 1, -1, t2.length - 1), s2 = m(n2 + 1, -1, t2.length - 1), a2 = t2[n2], o2 = t2[s2], l2 = t2[i2].sub(a2).unit(), u2 = o2.sub(a2).unit(), c2 = u2.angleWithSep(l2.x, l2.y), h2 = l2.add(u2).unit().mult(-1 * e2 / Math.sin(c2 / 2));
              r3.push(a2.add(h2));
            }
            return r3;
          }, t.cacheEntryPossiblyAdded = function(t2) {
            bt2++, bt2 > gt2 && (t2.getActor().send("enforceCacheSizeLimit", mt2), bt2 = 0);
          }, t.clamp = y, t.clearTileCache = function(t2) {
            const e2 = a.caches.delete(dt);
            t2 && e2.catch(t2).then(() => t2());
          }, t.clipLine = Tc2, t.clone = function(t2) {
            var e2 = new po2(3);
            return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2;
          }, t.clone$1 = function(t2) {
            var e2 = new po2(16);
            return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2[4] = t2[4], e2[5] = t2[5], e2[6] = t2[6], e2[7] = t2[7], e2[8] = t2[8], e2[9] = t2[9], e2[10] = t2[10], e2[11] = t2[11], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15], e2;
          }, t.clone$2 = M2, t.collisionCircleLayout = vu, t.config = j2, t.conjugate = function(t2, e2) {
            return t2[0] = -e2[0], t2[1] = -e2[1], t2[2] = -e2[2], t2[3] = e2[3], t2;
          }, t.copy = function(t2, e2) {
            return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2;
          }, t.create = xo2, t.create$1 = function() {
            var t2 = new po2(16);
            return po2 != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
          }, t.create$2 = fo, t.createExpression = cn2, t.createFilter = An2, t.createLayout = Ss, t.createStyleLayer = function(t2) {
            return t2.type === "custom" ? new bh2(t2) : new kh2[t2.type](t2);
          }, t.cross = function(t2, e2, r3) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = r3[0], o2 = r3[1], l2 = r3[2];
            return t2[0] = i2 * l2 - s2 * o2, t2[1] = s2 * a2 - n2 * l2, t2[2] = n2 * o2 - i2 * a2, t2;
          }, t.degToRad = c, t.div = function(t2, e2, r3) {
            return t2[0] = e2[0] / r3[0], t2[1] = e2[1] / r3[1], t2[2] = e2[2] / r3[2], t2;
          }, t.dot = function(t2, e2) {
            return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2];
          }, t.dot$1 = function(t2, e2) {
            return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2] + t2[3] * e2[3];
          }, t.ease = f, t.easeCubicInOut = p, t.emitValidationErrors = ei2, t.endsWith = I2, t.enforceCacheSizeLimit = function(t2) {
            xt2(), ft2 && ft2.then((e2) => {
              e2.keys().then((r3) => {
                for (let n2 = 0; n2 < r3.length - t2; n2++)
                  e2.delete(r3[n2]);
              });
            });
          }, t.evaluateSizeForFeature = ku, t.evaluateSizeForZoom = Au, t.evaluateVariableOffset = Yc2, t.evented = rs2, t.exactEquals = function(t2, e2) {
            return t2[0] === e2[0] && t2[1] === e2[1] && t2[2] === e2[2] && t2[3] === e2[3];
          }, t.exactEquals$1 = function(t2, e2) {
            return t2[0] === e2[0] && t2[1] === e2[1] && t2[2] === e2[2];
          }, t.exported = q, t.exported$1 = G2, t.extend = v, t.filterObject = T, t.fromMat4 = function(t2, e2) {
            return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[4], t2[4] = e2[5], t2[5] = e2[6], t2[6] = e2[8], t2[7] = e2[9], t2[8] = e2[10], t2;
          }, t.fromQuat = function(t2, e2) {
            var r3 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = r3 + r3, o2 = n2 + n2, l2 = i2 + i2, u2 = r3 * a2, c2 = n2 * a2, h2 = n2 * o2, p2 = i2 * a2, d2 = i2 * o2, f2 = i2 * l2, y2 = s2 * a2, m2 = s2 * o2, g2 = s2 * l2;
            return t2[0] = 1 - h2 - f2, t2[1] = c2 + g2, t2[2] = p2 - m2, t2[3] = 0, t2[4] = c2 - g2, t2[5] = 1 - u2 - f2, t2[6] = d2 + y2, t2[7] = 0, t2[8] = p2 + m2, t2[9] = d2 - y2, t2[10] = 1 - u2 - h2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
          }, t.fromRotation = function(t2, e2) {
            var r3 = Math.sin(e2), n2 = Math.cos(e2);
            return t2[0] = n2, t2[1] = r3, t2[2] = 0, t2[3] = -r3, t2[4] = n2, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
          }, t.fromScaling = function(t2, e2) {
            return t2[0] = e2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = e2[1], t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = e2[2], t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
          }, t.furthestTileCorner = function(t2) {
            const e2 = Math.round((t2 + 45 + 360) % 360 / 90) % 4;
            return h[e2];
          }, t.getAABBPointSquareDist = function(t2, e2, r3) {
            let n2 = 0;
            for (let i2 = 0; i2 < 2; ++i2) {
              const s2 = r3 ? r3[i2] : 0;
              t2[i2] > s2 && (n2 += (t2[i2] - s2) * (t2[i2] - s2)), e2[i2] < s2 && (n2 += (s2 - e2[i2]) * (s2 - e2[i2]));
            }
            return n2;
          }, t.getAnchorAlignment = mc2, t.getAnchorJustification = Wc2, t.getBounds = function(t2) {
            let e2 = 1 / 0, r3 = 1 / 0, n2 = -1 / 0, s2 = -1 / 0;
            for (const i2 of t2)
              e2 = Math.min(e2, i2.x), r3 = Math.min(r3, i2.y), n2 = Math.max(n2, i2.x), s2 = Math.max(s2, i2.y);
            return { min: new i(e2, r3), max: new i(n2, s2) };
          }, t.getImage = Ct, t.getJSON = function(t2, e2) {
            return At2(v(t2, { type: "json" }), e2);
          }, t.getMapSessionAPI = ht2, t.getPerformanceMeasurement = jh, t.getRTLTextPluginStatus = ns2, t.getReferrer = kt2, t.getVideo = function(t2, e2) {
            const r3 = a.document.createElement("video");
            r3.muted = true, r3.onloadstart = function() {
              e2(null, r3);
            };
            for (let e3 = 0; e3 < t2.length; e3++) {
              const n2 = a.document.createElement("source");
              Tt2(t2[e3]) || (r3.crossOrigin = "Anonymous"), n2.src = t2[e3], r3.appendChild(n2);
            }
            return { cancel: () => {
            } };
          }, t.identity = yo2, t.identity$1 = Co2, t.invert = function(t2, e2) {
            var r3 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = e2[4], o2 = e2[5], l2 = e2[6], u2 = e2[7], c2 = e2[8], h2 = e2[9], p2 = e2[10], d2 = e2[11], f2 = e2[12], y2 = e2[13], m2 = e2[14], g2 = e2[15], x3 = r3 * o2 - n2 * a2, v2 = r3 * l2 - i2 * a2, b2 = r3 * u2 - s2 * a2, w3 = n2 * l2 - i2 * o2, _2 = n2 * u2 - s2 * o2, k3 = i2 * u2 - s2 * l2, A2 = c2 * y2 - h2 * f2, S2 = c2 * m2 - p2 * f2, I3 = c2 * g2 - d2 * f2, z2 = h2 * m2 - p2 * y2, T2 = h2 * g2 - d2 * y2, M3 = p2 * g2 - d2 * m2, E2 = x3 * M3 - v2 * T2 + b2 * z2 + w3 * I3 - _2 * S2 + k3 * A2;
            return E2 ? (t2[0] = (o2 * M3 - l2 * T2 + u2 * z2) * (E2 = 1 / E2), t2[1] = (i2 * T2 - n2 * M3 - s2 * z2) * E2, t2[2] = (y2 * k3 - m2 * _2 + g2 * w3) * E2, t2[3] = (p2 * _2 - h2 * k3 - d2 * w3) * E2, t2[4] = (l2 * I3 - a2 * M3 - u2 * S2) * E2, t2[5] = (r3 * M3 - i2 * I3 + s2 * S2) * E2, t2[6] = (m2 * b2 - f2 * k3 - g2 * v2) * E2, t2[7] = (c2 * k3 - p2 * b2 + d2 * v2) * E2, t2[8] = (a2 * T2 - o2 * I3 + u2 * A2) * E2, t2[9] = (n2 * I3 - r3 * T2 - s2 * A2) * E2, t2[10] = (f2 * _2 - y2 * b2 + g2 * x3) * E2, t2[11] = (h2 * b2 - c2 * _2 - d2 * x3) * E2, t2[12] = (o2 * S2 - a2 * z2 - l2 * A2) * E2, t2[13] = (r3 * z2 - n2 * S2 + i2 * A2) * E2, t2[14] = (y2 * v2 - f2 * w3 - m2 * x3) * E2, t2[15] = (c2 * w3 - h2 * v2 + p2 * x3) * E2, t2) : null;
          }, t.isMapAuthenticated = function(t2) {
            return pt2.has(t2);
          }, t.isMapboxURL = Q2, t.latFromMercatorY = Rh2, t.len = Mo2, t.length = vo2, t.length$1 = function(t2) {
            return Math.hypot(t2[0], t2[1], t2[2], t2[3]);
          }, t.loadVectorTile = Bp2, t.makeRequest = At2, t.mercatorXfromLng = Vh2, t.mercatorYfromLat = Lh2, t.mercatorZfromAltitude = Fh2, t.mul = function(t2, e2, r3) {
            return t2[0] = e2[0] * r3[0], t2[1] = e2[1] * r3[1], t2[2] = e2[2] * r3[2], t2[3] = e2[3] * r3[3], t2;
          }, t.mul$1 = go2, t.mul$2 = To2, t.multiply = mo2, t.multiply$1 = _o2, t.nextPowerOfTwo = k2, t.normalize = Ao2, t.normalize$1 = function(t2, e2) {
            var r3 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = r3 * r3 + n2 * n2 + i2 * i2 + s2 * s2;
            return a2 > 0 && (a2 = 1 / Math.sqrt(a2)), t2[0] = r3 * a2, t2[1] = n2 * a2, t2[2] = i2 * a2, t2[3] = s2 * a2, t2;
          }, t.number = rr2, t.ortho = function(t2, e2, r3, n2, i2, s2, a2) {
            var o2 = 1 / (e2 - r3), l2 = 1 / (n2 - i2), u2 = 1 / (s2 - a2);
            return t2[0] = -2 * o2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * l2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * u2, t2[11] = 0, t2[12] = (e2 + r3) * o2, t2[13] = (i2 + n2) * l2, t2[14] = (a2 + s2) * u2, t2[15] = 1, t2;
          }, t.pbf = Cu, t.perspective = function(t2, e2, r3, n2, i2) {
            var s2, a2 = 1 / Math.tan(e2 / 2);
            return t2[0] = a2 / r3, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = a2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, i2 != null && i2 !== 1 / 0 ? (t2[10] = (i2 + n2) * (s2 = 1 / (n2 - i2)), t2[14] = 2 * i2 * n2 * s2) : (t2[10] = -1, t2[14] = -2 * n2), t2;
          }, t.pick = function(t2, e2) {
            const r3 = {};
            for (let n2 = 0; n2 < e2.length; n2++) {
              const i2 = e2[n2];
              i2 in t2 && (r3[i2] = t2[i2]);
            }
            return r3;
          }, t.plugin = ss2, t.pointGeometry = i, t.polygonIntersectsBox = io2, t.polygonIntersectsPolygon = Ka2, t.polygonizeBounds = function(t2, e2, r3 = 0, n2 = true) {
            const s2 = new i(r3, r3), a2 = t2.sub(s2), o2 = e2.add(s2), l2 = [a2, new i(o2.x, a2.y), o2, new i(a2.x, o2.y)];
            return n2 && l2.push(a2), l2;
          }, t.posAttributes = Qh2, t.postMapLoadEvent = ut2, t.postTurnstileEvent = ot2, t.potpack = ec2, t.prevPowerOfTwo = function(t2) {
            return t2 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t2) / Math.LN2));
          }, t.radToDeg = function(t2) {
            return t2 * u;
          }, t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.registerForPluginStateChange = function(t2) {
            return t2({ pluginStatus: Wi2, pluginURL: Qi2 }), rs2.on("pluginStateChange", t2), t2;
          }, t.removeAuthState = function(t2) {
            pt2.delete(t2);
          }, t.renderColorRamp = Go2, t.rotateX = function(t2, e2, r3) {
            var n2 = Math.sin(r3), i2 = Math.cos(r3), s2 = e2[4], a2 = e2[5], o2 = e2[6], l2 = e2[7], u2 = e2[8], c2 = e2[9], h2 = e2[10], p2 = e2[11];
            return e2 !== t2 && (t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[4] = s2 * i2 + u2 * n2, t2[5] = a2 * i2 + c2 * n2, t2[6] = o2 * i2 + h2 * n2, t2[7] = l2 * i2 + p2 * n2, t2[8] = u2 * i2 - s2 * n2, t2[9] = c2 * i2 - a2 * n2, t2[10] = h2 * i2 - o2 * n2, t2[11] = p2 * i2 - l2 * n2, t2;
          }, t.rotateX$1 = Po2, t.rotateY = function(t2, e2, r3) {
            var n2 = Math.sin(r3), i2 = Math.cos(r3), s2 = e2[0], a2 = e2[1], o2 = e2[2], l2 = e2[3], u2 = e2[8], c2 = e2[9], h2 = e2[10], p2 = e2[11];
            return e2 !== t2 && (t2[4] = e2[4], t2[5] = e2[5], t2[6] = e2[6], t2[7] = e2[7], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 - u2 * n2, t2[1] = a2 * i2 - c2 * n2, t2[2] = o2 * i2 - h2 * n2, t2[3] = l2 * i2 - p2 * n2, t2[8] = s2 * n2 + u2 * i2, t2[9] = a2 * n2 + c2 * i2, t2[10] = o2 * n2 + h2 * i2, t2[11] = l2 * n2 + p2 * i2, t2;
          }, t.rotateZ = function(t2, e2, r3) {
            var n2 = Math.sin(r3), i2 = Math.cos(r3), s2 = e2[0], a2 = e2[1], o2 = e2[2], l2 = e2[3], u2 = e2[4], c2 = e2[5], h2 = e2[6], p2 = e2[7];
            return e2 !== t2 && (t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 + u2 * n2, t2[1] = a2 * i2 + c2 * n2, t2[2] = o2 * i2 + h2 * n2, t2[3] = l2 * i2 + p2 * n2, t2[4] = u2 * i2 - s2 * n2, t2[5] = c2 * i2 - a2 * n2, t2[6] = h2 * i2 - o2 * n2, t2[7] = p2 * i2 - l2 * n2, t2;
          }, t.rotateZ$1 = function(t2, e2, r3) {
            r3 *= 0.5;
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = Math.sin(r3), l2 = Math.cos(r3);
            return t2[0] = n2 * l2 + i2 * o2, t2[1] = i2 * l2 - n2 * o2, t2[2] = s2 * l2 + a2 * o2, t2[3] = a2 * l2 - s2 * o2, t2;
          }, t.scale = function(t2, e2, r3) {
            return t2[0] = e2[0] * r3, t2[1] = e2[1] * r3, t2[2] = e2[2] * r3, t2;
          }, t.scale$1 = function(t2, e2, r3) {
            var n2 = r3[0], i2 = r3[1], s2 = r3[2];
            return t2[0] = e2[0] * n2, t2[1] = e2[1] * n2, t2[2] = e2[2] * n2, t2[3] = e2[3] * n2, t2[4] = e2[4] * i2, t2[5] = e2[5] * i2, t2[6] = e2[6] * i2, t2[7] = e2[7] * i2, t2[8] = e2[8] * s2, t2[9] = e2[9] * s2, t2[10] = e2[10] * s2, t2[11] = e2[11] * s2, t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
          }, t.scale$2 = function(t2, e2, r3) {
            return t2[0] = e2[0] * r3, t2[1] = e2[1] * r3, t2[2] = e2[2] * r3, t2[3] = e2[3] * r3, t2;
          }, t.scaleAndAdd = ko2, t.setCacheLimits = function(t2, e2) {
            mt2 = t2, gt2 = e2;
          }, t.setRTLTextPlugin = function(t2, e2, r3 = false) {
            if (Wi2 === Ki2 || Wi2 === Hi2 || Wi2 === Yi2)
              throw new Error("setRTLTextPlugin cannot be called multiple times.");
            Qi2 = q.resolveURL(t2), Wi2 = Ki2, Ji2 = e2, es2(), r3 || is2();
          }, t.smoothstep = function(t2, e2, r3) {
            return (r3 = y((r3 - t2) / (e2 - t2), 0, 1)) * r3 * (3 - 2 * r3);
          }, t.spec = Rt, t.storeAuthState = function(t2, e2) {
            e2 ? pt2.add(t2) : pt2.delete(t2);
          }, t.sub = zo2, t.subtract = wo2, t.symbolSize = Su, t.transformMat3 = function(t2, e2, r3) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2];
            return t2[0] = n2 * r3[0] + i2 * r3[3] + s2 * r3[6], t2[1] = n2 * r3[1] + i2 * r3[4] + s2 * r3[7], t2[2] = n2 * r3[2] + i2 * r3[5] + s2 * r3[8], t2;
          }, t.transformMat4 = Eo2, t.transformMat4$1 = function(t2, e2, r3) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = r3[3] * n2 + r3[7] * i2 + r3[11] * s2 + r3[15];
            return t2[0] = (r3[0] * n2 + r3[4] * i2 + r3[8] * s2 + r3[12]) / (a2 = a2 || 1), t2[1] = (r3[1] * n2 + r3[5] * i2 + r3[9] * s2 + r3[13]) / a2, t2[2] = (r3[2] * n2 + r3[6] * i2 + r3[10] * s2 + r3[14]) / a2, t2;
          }, t.transformQuat = So2, t.translate = function(t2, e2, r3) {
            var n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, y2 = r3[0], m2 = r3[1], g2 = r3[2];
            return e2 === t2 ? (t2[12] = e2[0] * y2 + e2[4] * m2 + e2[8] * g2 + e2[12], t2[13] = e2[1] * y2 + e2[5] * m2 + e2[9] * g2 + e2[13], t2[14] = e2[2] * y2 + e2[6] * m2 + e2[10] * g2 + e2[14], t2[15] = e2[3] * y2 + e2[7] * m2 + e2[11] * g2 + e2[15]) : (i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], d2 = e2[10], f2 = e2[11], t2[0] = n2 = e2[0], t2[1] = i2, t2[2] = s2, t2[3] = a2, t2[4] = o2, t2[5] = l2, t2[6] = u2, t2[7] = c2, t2[8] = h2, t2[9] = p2, t2[10] = d2, t2[11] = f2, t2[12] = n2 * y2 + o2 * m2 + h2 * g2 + e2[12], t2[13] = i2 * y2 + l2 * m2 + p2 * g2 + e2[13], t2[14] = s2 * y2 + u2 * m2 + d2 * g2 + e2[14], t2[15] = a2 * y2 + c2 * m2 + f2 * g2 + e2[15]), t2;
          }, t.triggerPluginCompletionEvent = ts2, t.uniqueId = w2, t.validateCustomStyleLayer = function(t2) {
            const e2 = [], r3 = t2.id;
            return r3 === void 0 && e2.push({ message: `layers.${r3}: missing required property "id"` }), t2.render === void 0 && e2.push({ message: `layers.${r3}: missing required method "render"` }), t2.renderingMode && t2.renderingMode !== "2d" && t2.renderingMode !== "3d" && e2.push({ message: `layers.${r3}: property "renderingMode" must be either "2d" or "3d"` }), e2;
          }, t.validateFog = Wn2, t.validateLight = Jn2, t.validateStyle = Yn2, t.values = x2, t.vectorTile = Gl2, t.version = e, t.warnOnce = B, t.window = a, t.wrap = m;
        });
        define2(["./shared"], function(e) {
          "use strict";
          function t(e2) {
            const r3 = typeof e2;
            if (r3 === "number" || r3 === "boolean" || r3 === "string" || e2 == null)
              return JSON.stringify(e2);
            if (Array.isArray(e2)) {
              let r4 = "[";
              for (const o3 of e2)
                r4 += `${t(o3)},`;
              return `${r4}]`;
            }
            const o2 = Object.keys(e2).sort();
            let n2 = "{";
            for (let r4 = 0; r4 < o2.length; r4++)
              n2 += `${JSON.stringify(o2[r4])}:${t(e2[o2[r4]])},`;
            return `${n2}}`;
          }
          function r2(r3) {
            let o2 = "";
            for (const n2 of e.refProperties)
              o2 += `/${t(r3[n2])}`;
            return o2;
          }
          class o {
            constructor(e2) {
              this.keyCache = {}, e2 && this.replace(e2);
            }
            replace(e2) {
              this._layerConfigs = {}, this._layers = {}, this.update(e2, []);
            }
            update(t2, o2) {
              for (const r3 of t2) {
                this._layerConfigs[r3.id] = r3;
                const t3 = this._layers[r3.id] = e.createStyleLayer(r3);
                t3._featureFilter = e.createFilter(t3.filter), this.keyCache[r3.id] && delete this.keyCache[r3.id];
              }
              for (const e2 of o2)
                delete this.keyCache[e2], delete this._layerConfigs[e2], delete this._layers[e2];
              this.familiesBySource = {};
              const n2 = function(e2, t3) {
                const o3 = {};
                for (let n4 = 0; n4 < e2.length; n4++) {
                  const i2 = t3 && t3[e2[n4].id] || r2(e2[n4]);
                  t3 && (t3[e2[n4].id] = i2);
                  let s2 = o3[i2];
                  s2 || (s2 = o3[i2] = []), s2.push(e2[n4]);
                }
                const n3 = [];
                for (const e3 in o3)
                  n3.push(o3[e3]);
                return n3;
              }(e.values(this._layerConfigs), this.keyCache);
              for (const e2 of n2) {
                const t3 = e2.map((e3) => this._layers[e3.id]), r3 = t3[0];
                if (r3.visibility === "none")
                  continue;
                const o3 = r3.source || "";
                let n3 = this.familiesBySource[o3];
                n3 || (n3 = this.familiesBySource[o3] = {});
                const i2 = r3.sourceLayer || "_geojsonTileLayer";
                let s2 = n3[i2];
                s2 || (s2 = n3[i2] = []), s2.push(t3);
              }
            }
          }
          const { ImageBitmap: n } = e.window;
          class i {
            loadTile(t2, r3) {
              const { uid: o2, encoding: i2, rawImageData: s2, padding: a2, buildQuadTree: l2 } = t2, u2 = n && s2 instanceof n ? this.getImageData(s2, a2) : s2;
              r3(null, new e.DEMData(o2, u2, i2, a2 < 1, l2));
            }
            getImageData(t2, r3) {
              this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(t2.width, t2.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = t2.width, this.offscreenCanvas.height = t2.height, this.offscreenCanvasContext.drawImage(t2, 0, 0, t2.width, t2.height);
              const o2 = this.offscreenCanvasContext.getImageData(-r3, -r3, t2.width + 2 * r3, t2.height + 2 * r3);
              return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new e.RGBAImage({ width: o2.width, height: o2.height }, o2.data);
            }
          }
          var s = function e2(t2, r3) {
            var o2, n2 = t2 && t2.type;
            if (n2 === "FeatureCollection")
              for (o2 = 0; o2 < t2.features.length; o2++)
                e2(t2.features[o2], r3);
            else if (n2 === "GeometryCollection")
              for (o2 = 0; o2 < t2.geometries.length; o2++)
                e2(t2.geometries[o2], r3);
            else if (n2 === "Feature")
              e2(t2.geometry, r3);
            else if (n2 === "Polygon")
              a(t2.coordinates, r3);
            else if (n2 === "MultiPolygon")
              for (o2 = 0; o2 < t2.coordinates.length; o2++)
                a(t2.coordinates[o2], r3);
            return t2;
          };
          function a(e2, t2) {
            if (e2.length !== 0) {
              l(e2[0], t2);
              for (var r3 = 1; r3 < e2.length; r3++)
                l(e2[r3], !t2);
            }
          }
          function l(e2, t2) {
            for (var r3 = 0, o2 = 0, n2 = e2.length, i2 = n2 - 1; o2 < n2; i2 = o2++)
              r3 += (e2[o2][0] - e2[i2][0]) * (e2[i2][1] + e2[o2][1]);
            r3 >= 0 != !!t2 && e2.reverse();
          }
          const u = e.vectorTile.VectorTileFeature.prototype.toGeoJSON;
          class h {
            constructor(t2) {
              this._feature = t2, this.extent = e.EXTENT, this.type = t2.type, this.properties = t2.tags, "id" in t2 && !isNaN(t2.id) && (this.id = parseInt(t2.id, 10));
            }
            loadGeometry() {
              if (this._feature.type === 1) {
                const t2 = [];
                for (const r3 of this._feature.geometry)
                  t2.push([new e.pointGeometry(r3[0], r3[1])]);
                return t2;
              }
              {
                const t2 = [];
                for (const r3 of this._feature.geometry) {
                  const o2 = [];
                  for (const t3 of r3)
                    o2.push(new e.pointGeometry(t3[0], t3[1]));
                  t2.push(o2);
                }
                return t2;
              }
            }
            toGeoJSON(e2, t2, r3) {
              return u.call(this, e2, t2, r3);
            }
          }
          class c {
            constructor(t2) {
              this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.EXTENT, this.length = t2.length, this._features = t2;
            }
            feature(e2) {
              return new h(this._features[e2]);
            }
          }
          var f = e.vectorTile.VectorTileFeature, p = g;
          function g(e2, t2) {
            this.options = t2 || {}, this.features = e2, this.length = e2.length;
          }
          function d(e2, t2) {
            this.id = typeof e2.id == "number" ? e2.id : void 0, this.type = e2.type, this.rawGeometry = e2.type === 1 ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t2 || 4096;
          }
          g.prototype.feature = function(e2) {
            return new d(this.features[e2], this.options.extent);
          }, d.prototype.loadGeometry = function() {
            var t2 = this.rawGeometry;
            this.geometry = [];
            for (var r3 = 0; r3 < t2.length; r3++) {
              for (var o2 = t2[r3], n2 = [], i2 = 0; i2 < o2.length; i2++)
                n2.push(new e.pointGeometry(o2[i2][0], o2[i2][1]));
              this.geometry.push(n2);
            }
            return this.geometry;
          }, d.prototype.bbox = function() {
            this.geometry || this.loadGeometry();
            for (var e2 = this.geometry, t2 = 1 / 0, r3 = -1 / 0, o2 = 1 / 0, n2 = -1 / 0, i2 = 0; i2 < e2.length; i2++)
              for (var s2 = e2[i2], a2 = 0; a2 < s2.length; a2++) {
                var l2 = s2[a2];
                t2 = Math.min(t2, l2.x), r3 = Math.max(r3, l2.x), o2 = Math.min(o2, l2.y), n2 = Math.max(n2, l2.y);
              }
            return [t2, o2, r3, n2];
          }, d.prototype.toGeoJSON = f.prototype.toGeoJSON;
          var m = v, y = p;
          function v(t2) {
            var r3 = new e.pbf();
            return function(e2, t3) {
              for (var r4 in e2.layers)
                t3.writeMessage(3, x2, e2.layers[r4]);
            }(t2, r3), r3.finish();
          }
          function x2(e2, t2) {
            var r3;
            t2.writeVarintField(15, e2.version || 1), t2.writeStringField(1, e2.name || ""), t2.writeVarintField(5, e2.extent || 4096);
            var o2 = { keys: [], values: [], keycache: {}, valuecache: {} };
            for (r3 = 0; r3 < e2.length; r3++)
              o2.feature = e2.feature(r3), t2.writeMessage(2, w2, o2);
            var n2 = o2.keys;
            for (r3 = 0; r3 < n2.length; r3++)
              t2.writeStringField(3, n2[r3]);
            var i2 = o2.values;
            for (r3 = 0; r3 < i2.length; r3++)
              t2.writeMessage(4, T, i2[r3]);
          }
          function w2(e2, t2) {
            var r3 = e2.feature;
            r3.id !== void 0 && t2.writeVarintField(1, r3.id), t2.writeMessage(2, S, e2), t2.writeVarintField(3, r3.type), t2.writeMessage(4, b, r3);
          }
          function S(e2, t2) {
            var r3 = e2.feature, o2 = e2.keys, n2 = e2.values, i2 = e2.keycache, s2 = e2.valuecache;
            for (var a2 in r3.properties) {
              var l2 = i2[a2];
              l2 === void 0 && (o2.push(a2), i2[a2] = l2 = o2.length - 1), t2.writeVarint(l2);
              var u2 = r3.properties[a2], h2 = typeof u2;
              h2 !== "string" && h2 !== "boolean" && h2 !== "number" && (u2 = JSON.stringify(u2));
              var c2 = h2 + ":" + u2, f2 = s2[c2];
              f2 === void 0 && (n2.push(u2), s2[c2] = f2 = n2.length - 1), t2.writeVarint(f2);
            }
          }
          function M2(e2, t2) {
            return (t2 << 3) + (7 & e2);
          }
          function P(e2) {
            return e2 << 1 ^ e2 >> 31;
          }
          function b(e2, t2) {
            for (var r3 = e2.loadGeometry(), o2 = e2.type, n2 = 0, i2 = 0, s2 = r3.length, a2 = 0; a2 < s2; a2++) {
              var l2 = r3[a2], u2 = 1;
              o2 === 1 && (u2 = l2.length), t2.writeVarint(M2(1, u2));
              for (var h2 = o2 === 3 ? l2.length - 1 : l2.length, c2 = 0; c2 < h2; c2++) {
                c2 === 1 && o2 !== 1 && t2.writeVarint(M2(2, h2 - 1));
                var f2 = l2[c2].x - n2, p2 = l2[c2].y - i2;
                t2.writeVarint(P(f2)), t2.writeVarint(P(p2)), n2 += f2, i2 += p2;
              }
              o2 === 3 && t2.writeVarint(M2(7, 1));
            }
          }
          function T(e2, t2) {
            var r3 = typeof e2;
            r3 === "string" ? t2.writeStringField(1, e2) : r3 === "boolean" ? t2.writeBooleanField(7, e2) : r3 === "number" && (e2 % 1 != 0 ? t2.writeDoubleField(3, e2) : e2 < 0 ? t2.writeSVarintField(6, e2) : t2.writeVarintField(5, e2));
          }
          function k2(e2, t2, r3, o2, n2, i2) {
            if (n2 - o2 <= r3)
              return;
            const s2 = o2 + n2 >> 1;
            I2(e2, t2, s2, o2, n2, i2 % 2), k2(e2, t2, r3, o2, s2 - 1, i2 + 1), k2(e2, t2, r3, s2 + 1, n2, i2 + 1);
          }
          function I2(e2, t2, r3, o2, n2, i2) {
            for (; n2 > o2; ) {
              if (n2 - o2 > 600) {
                const s3 = n2 - o2 + 1, a3 = r3 - o2 + 1, l3 = Math.log(s3), u2 = 0.5 * Math.exp(2 * l3 / 3), h2 = 0.5 * Math.sqrt(l3 * u2 * (s3 - u2) / s3) * (a3 - s3 / 2 < 0 ? -1 : 1);
                I2(e2, t2, r3, Math.max(o2, Math.floor(r3 - a3 * u2 / s3 + h2)), Math.min(n2, Math.floor(r3 + (s3 - a3) * u2 / s3 + h2)), i2);
              }
              const s2 = t2[2 * r3 + i2];
              let a2 = o2, l2 = n2;
              for (_(e2, t2, o2, r3), t2[2 * n2 + i2] > s2 && _(e2, t2, o2, n2); a2 < l2; ) {
                for (_(e2, t2, a2, l2), a2++, l2--; t2[2 * a2 + i2] < s2; )
                  a2++;
                for (; t2[2 * l2 + i2] > s2; )
                  l2--;
              }
              t2[2 * o2 + i2] === s2 ? _(e2, t2, o2, l2) : (l2++, _(e2, t2, l2, n2)), l2 <= r3 && (o2 = l2 + 1), r3 <= l2 && (n2 = l2 - 1);
            }
          }
          function _(e2, t2, r3, o2) {
            L2(e2, r3, o2), L2(t2, 2 * r3, 2 * o2), L2(t2, 2 * r3 + 1, 2 * o2 + 1);
          }
          function L2(e2, t2, r3) {
            const o2 = e2[t2];
            e2[t2] = e2[r3], e2[r3] = o2;
          }
          function C(e2, t2, r3, o2) {
            const n2 = e2 - r3, i2 = t2 - o2;
            return n2 * n2 + i2 * i2;
          }
          m.fromVectorTileJs = v, m.fromGeojsonVt = function(e2, t2) {
            t2 = t2 || {};
            var r3 = {};
            for (var o2 in e2)
              r3[o2] = new p(e2[o2].features, t2), r3[o2].name = o2, r3[o2].version = t2.version, r3[o2].extent = t2.extent;
            return v({ layers: r3 });
          }, m.GeoJSONWrapper = y;
          const O = (e2) => e2[0], z = (e2) => e2[1];
          class E {
            constructor(e2, t2 = O, r3 = z, o2 = 64, n2 = Float64Array) {
              this.nodeSize = o2, this.points = e2;
              const i2 = e2.length < 65536 ? Uint16Array : Uint32Array, s2 = this.ids = new i2(e2.length), a2 = this.coords = new n2(2 * e2.length);
              for (let o3 = 0; o3 < e2.length; o3++)
                s2[o3] = o3, a2[2 * o3] = t2(e2[o3]), a2[2 * o3 + 1] = r3(e2[o3]);
              k2(s2, a2, o2, 0, s2.length - 1, 0);
            }
            range(e2, t2, r3, o2) {
              return function(e3, t3, r4, o3, n2, i2, s2) {
                const a2 = [0, e3.length - 1, 0], l2 = [];
                let u2, h2;
                for (; a2.length; ) {
                  const c2 = a2.pop(), f2 = a2.pop(), p2 = a2.pop();
                  if (f2 - p2 <= s2) {
                    for (let s3 = p2; s3 <= f2; s3++)
                      u2 = t3[2 * s3], h2 = t3[2 * s3 + 1], u2 >= r4 && u2 <= n2 && h2 >= o3 && h2 <= i2 && l2.push(e3[s3]);
                    continue;
                  }
                  const g2 = Math.floor((p2 + f2) / 2);
                  u2 = t3[2 * g2], h2 = t3[2 * g2 + 1], u2 >= r4 && u2 <= n2 && h2 >= o3 && h2 <= i2 && l2.push(e3[g2]);
                  const d2 = (c2 + 1) % 2;
                  (c2 === 0 ? r4 <= u2 : o3 <= h2) && (a2.push(p2), a2.push(g2 - 1), a2.push(d2)), (c2 === 0 ? n2 >= u2 : i2 >= h2) && (a2.push(g2 + 1), a2.push(f2), a2.push(d2));
                }
                return l2;
              }(this.ids, this.coords, e2, t2, r3, o2, this.nodeSize);
            }
            within(e2, t2, r3) {
              return function(e3, t3, r4, o2, n2, i2) {
                const s2 = [0, e3.length - 1, 0], a2 = [], l2 = n2 * n2;
                for (; s2.length; ) {
                  const u2 = s2.pop(), h2 = s2.pop(), c2 = s2.pop();
                  if (h2 - c2 <= i2) {
                    for (let n3 = c2; n3 <= h2; n3++)
                      C(t3[2 * n3], t3[2 * n3 + 1], r4, o2) <= l2 && a2.push(e3[n3]);
                    continue;
                  }
                  const f2 = Math.floor((c2 + h2) / 2), p2 = t3[2 * f2], g2 = t3[2 * f2 + 1];
                  C(p2, g2, r4, o2) <= l2 && a2.push(e3[f2]);
                  const d2 = (u2 + 1) % 2;
                  (u2 === 0 ? r4 - n2 <= p2 : o2 - n2 <= g2) && (s2.push(c2), s2.push(f2 - 1), s2.push(d2)), (u2 === 0 ? r4 + n2 >= p2 : o2 + n2 >= g2) && (s2.push(f2 + 1), s2.push(h2), s2.push(d2));
                }
                return a2;
              }(this.ids, this.coords, e2, t2, r3, this.nodeSize);
            }
          }
          const F2 = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e2) => e2 }, N = Math.fround || (Z2 = new Float32Array(1), (e2) => (Z2[0] = +e2, Z2[0]));
          var Z2;
          class G2 {
            constructor(e2) {
              this.options = D(Object.create(F2), e2), this.trees = new Array(this.options.maxZoom + 1);
            }
            load(e2) {
              const { log: t2, minZoom: r3, maxZoom: o2, nodeSize: n2 } = this.options;
              t2 && console.time("total time");
              const i2 = `prepare ${e2.length} points`;
              t2 && console.time(i2), this.points = e2;
              let s2 = [];
              for (let t3 = 0; t3 < e2.length; t3++)
                e2[t3].geometry && s2.push(Y(e2[t3], t3));
              this.trees[o2 + 1] = new E(s2, $2, B, n2, Float32Array), t2 && console.timeEnd(i2);
              for (let e3 = o2; e3 >= r3; e3--) {
                const r4 = +Date.now();
                s2 = this._cluster(s2, e3), this.trees[e3] = new E(s2, $2, B, n2, Float32Array), t2 && console.log("z%d: %d clusters in %dms", e3, s2.length, +Date.now() - r4);
              }
              return t2 && console.timeEnd("total time"), this;
            }
            getClusters(e2, t2) {
              let r3 = ((e2[0] + 180) % 360 + 360) % 360 - 180;
              const o2 = Math.max(-90, Math.min(90, e2[1]));
              let n2 = e2[2] === 180 ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180;
              const i2 = Math.max(-90, Math.min(90, e2[3]));
              if (e2[2] - e2[0] >= 360)
                r3 = -180, n2 = 180;
              else if (r3 > n2) {
                const e3 = this.getClusters([r3, o2, 180, i2], t2), s3 = this.getClusters([-180, o2, n2, i2], t2);
                return e3.concat(s3);
              }
              const s2 = this.trees[this._limitZoom(t2)], a2 = s2.range(V(r3), j2(i2), V(n2), j2(o2)), l2 = [];
              for (const e3 of a2) {
                const t3 = s2.points[e3];
                l2.push(t3.numPoints ? W(t3) : this.points[t3.index]);
              }
              return l2;
            }
            getChildren(e2) {
              const t2 = this._getOriginId(e2), r3 = this._getOriginZoom(e2), o2 = "No cluster with the specified id.", n2 = this.trees[r3];
              if (!n2)
                throw new Error(o2);
              const i2 = n2.points[t2];
              if (!i2)
                throw new Error(o2);
              const s2 = this.options.radius / (this.options.extent * Math.pow(2, r3 - 1)), a2 = n2.within(i2.x, i2.y, s2), l2 = [];
              for (const t3 of a2) {
                const r4 = n2.points[t3];
                r4.parentId === e2 && l2.push(r4.numPoints ? W(r4) : this.points[r4.index]);
              }
              if (l2.length === 0)
                throw new Error(o2);
              return l2;
            }
            getLeaves(e2, t2, r3) {
              const o2 = [];
              return this._appendLeaves(o2, e2, t2 = t2 || 10, r3 = r3 || 0, 0), o2;
            }
            getTile(e2, t2, r3) {
              const o2 = this.trees[this._limitZoom(e2)], n2 = Math.pow(2, e2), { extent: i2, radius: s2 } = this.options, a2 = s2 / i2, l2 = (r3 - a2) / n2, u2 = (r3 + 1 + a2) / n2, h2 = { features: [] };
              return this._addTileFeatures(o2.range((t2 - a2) / n2, l2, (t2 + 1 + a2) / n2, u2), o2.points, t2, r3, n2, h2), t2 === 0 && this._addTileFeatures(o2.range(1 - a2 / n2, l2, 1, u2), o2.points, n2, r3, n2, h2), t2 === n2 - 1 && this._addTileFeatures(o2.range(0, l2, a2 / n2, u2), o2.points, -1, r3, n2, h2), h2.features.length ? h2 : null;
            }
            getClusterExpansionZoom(e2) {
              let t2 = this._getOriginZoom(e2) - 1;
              for (; t2 <= this.options.maxZoom; ) {
                const r3 = this.getChildren(e2);
                if (t2++, r3.length !== 1)
                  break;
                e2 = r3[0].properties.cluster_id;
              }
              return t2;
            }
            _appendLeaves(e2, t2, r3, o2, n2) {
              const i2 = this.getChildren(t2);
              for (const t3 of i2) {
                const i3 = t3.properties;
                if (i3 && i3.cluster ? n2 + i3.point_count <= o2 ? n2 += i3.point_count : n2 = this._appendLeaves(e2, i3.cluster_id, r3, o2, n2) : n2 < o2 ? n2++ : e2.push(t3), e2.length === r3)
                  break;
              }
              return n2;
            }
            _addTileFeatures(e2, t2, r3, o2, n2, i2) {
              for (const s2 of e2) {
                const e3 = t2[s2], a2 = e3.numPoints;
                let l2, u2, h2;
                if (a2)
                  l2 = X(e3), u2 = e3.x, h2 = e3.y;
                else {
                  const t3 = this.points[e3.index];
                  l2 = t3.properties, u2 = V(t3.geometry.coordinates[0]), h2 = j2(t3.geometry.coordinates[1]);
                }
                const c2 = { type: 1, geometry: [[Math.round(this.options.extent * (u2 * n2 - r3)), Math.round(this.options.extent * (h2 * n2 - o2))]], tags: l2 };
                let f2;
                a2 ? f2 = e3.id : this.options.generateId ? f2 = e3.index : this.points[e3.index].id && (f2 = this.points[e3.index].id), f2 !== void 0 && (c2.id = f2), i2.features.push(c2);
              }
            }
            _limitZoom(e2) {
              return Math.max(this.options.minZoom, Math.min(+e2, this.options.maxZoom + 1));
            }
            _cluster(e2, t2) {
              const r3 = [], { radius: o2, extent: n2, reduce: i2, minPoints: s2 } = this.options, a2 = o2 / (n2 * Math.pow(2, t2));
              for (let o3 = 0; o3 < e2.length; o3++) {
                const n3 = e2[o3];
                if (n3.zoom <= t2)
                  continue;
                n3.zoom = t2;
                const l2 = this.trees[t2 + 1], u2 = l2.within(n3.x, n3.y, a2), h2 = n3.numPoints || 1;
                let c2 = h2;
                for (const e3 of u2) {
                  const r4 = l2.points[e3];
                  r4.zoom > t2 && (c2 += r4.numPoints || 1);
                }
                if (c2 >= s2) {
                  let e3 = n3.x * h2, s3 = n3.y * h2, a3 = i2 && h2 > 1 ? this._map(n3, true) : null;
                  const f2 = (o3 << 5) + (t2 + 1) + this.points.length;
                  for (const r4 of u2) {
                    const o4 = l2.points[r4];
                    if (o4.zoom <= t2)
                      continue;
                    o4.zoom = t2;
                    const u3 = o4.numPoints || 1;
                    e3 += o4.x * u3, s3 += o4.y * u3, o4.parentId = f2, i2 && (a3 || (a3 = this._map(n3, true)), i2(a3, this._map(o4)));
                  }
                  n3.parentId = f2, r3.push(J(e3 / c2, s3 / c2, f2, c2, a3));
                } else if (r3.push(n3), c2 > 1)
                  for (const e3 of u2) {
                    const o4 = l2.points[e3];
                    o4.zoom <= t2 || (o4.zoom = t2, r3.push(o4));
                  }
              }
              return r3;
            }
            _getOriginId(e2) {
              return e2 - this.points.length >> 5;
            }
            _getOriginZoom(e2) {
              return (e2 - this.points.length) % 32;
            }
            _map(e2, t2) {
              if (e2.numPoints)
                return t2 ? D({}, e2.properties) : e2.properties;
              const r3 = this.points[e2.index].properties, o2 = this.options.map(r3);
              return t2 && o2 === r3 ? D({}, o2) : o2;
            }
          }
          function J(e2, t2, r3, o2, n2) {
            return { x: N(e2), y: N(t2), zoom: 1 / 0, id: r3, parentId: -1, numPoints: o2, properties: n2 };
          }
          function Y(e2, t2) {
            const [r3, o2] = e2.geometry.coordinates;
            return { x: N(V(r3)), y: N(j2(o2)), zoom: 1 / 0, index: t2, parentId: -1 };
          }
          function W(e2) {
            return { type: "Feature", id: e2.id, properties: X(e2), geometry: { type: "Point", coordinates: [(t2 = e2.x, 360 * (t2 - 0.5)), A(e2.y)] } };
            var t2;
          }
          function X(e2) {
            const t2 = e2.numPoints, r3 = t2 >= 1e4 ? `${Math.round(t2 / 1e3)}k` : t2 >= 1e3 ? Math.round(t2 / 100) / 10 + "k" : t2;
            return D(D({}, e2.properties), { cluster: true, cluster_id: e2.id, point_count: t2, point_count_abbreviated: r3 });
          }
          function V(e2) {
            return e2 / 360 + 0.5;
          }
          function j2(e2) {
            const t2 = Math.sin(e2 * Math.PI / 180), r3 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
            return r3 < 0 ? 0 : r3 > 1 ? 1 : r3;
          }
          function A(e2) {
            const t2 = (180 - 360 * e2) * Math.PI / 180;
            return 360 * Math.atan(Math.exp(t2)) / Math.PI - 90;
          }
          function D(e2, t2) {
            for (const r3 in t2)
              e2[r3] = t2[r3];
            return e2;
          }
          function $2(e2) {
            return e2.x;
          }
          function B(e2) {
            return e2.y;
          }
          function R(e2, t2, r3, o2) {
            for (var n2, i2 = o2, s2 = r3 - t2 >> 1, a2 = r3 - t2, l2 = e2[t2], u2 = e2[t2 + 1], h2 = e2[r3], c2 = e2[r3 + 1], f2 = t2 + 3; f2 < r3; f2 += 3) {
              var p2 = q(e2[f2], e2[f2 + 1], l2, u2, h2, c2);
              if (p2 > i2)
                n2 = f2, i2 = p2;
              else if (p2 === i2) {
                var g2 = Math.abs(f2 - s2);
                g2 < a2 && (n2 = f2, a2 = g2);
              }
            }
            i2 > o2 && (n2 - t2 > 3 && R(e2, t2, n2, o2), e2[n2 + 2] = i2, r3 - n2 > 3 && R(e2, n2, r3, o2));
          }
          function q(e2, t2, r3, o2, n2, i2) {
            var s2 = n2 - r3, a2 = i2 - o2;
            if (s2 !== 0 || a2 !== 0) {
              var l2 = ((e2 - r3) * s2 + (t2 - o2) * a2) / (s2 * s2 + a2 * a2);
              l2 > 1 ? (r3 = n2, o2 = i2) : l2 > 0 && (r3 += s2 * l2, o2 += a2 * l2);
            }
            return (s2 = e2 - r3) * s2 + (a2 = t2 - o2) * a2;
          }
          function U2(e2, t2, r3, o2) {
            var n2 = { id: e2 === void 0 ? null : e2, type: t2, geometry: r3, tags: o2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
            return function(e3) {
              var t3 = e3.geometry, r4 = e3.type;
              if (r4 === "Point" || r4 === "MultiPoint" || r4 === "LineString")
                Q2(e3, t3);
              else if (r4 === "Polygon" || r4 === "MultiLineString")
                for (var o3 = 0; o3 < t3.length; o3++)
                  Q2(e3, t3[o3]);
              else if (r4 === "MultiPolygon")
                for (o3 = 0; o3 < t3.length; o3++)
                  for (var n3 = 0; n3 < t3[o3].length; n3++)
                    Q2(e3, t3[o3][n3]);
            }(n2), n2;
          }
          function Q2(e2, t2) {
            for (var r3 = 0; r3 < t2.length; r3 += 3)
              e2.minX = Math.min(e2.minX, t2[r3]), e2.minY = Math.min(e2.minY, t2[r3 + 1]), e2.maxX = Math.max(e2.maxX, t2[r3]), e2.maxY = Math.max(e2.maxY, t2[r3 + 1]);
          }
          function H(e2, t2, r3, o2) {
            if (t2.geometry) {
              var n2 = t2.geometry.coordinates, i2 = t2.geometry.type, s2 = Math.pow(r3.tolerance / ((1 << r3.maxZoom) * r3.extent), 2), a2 = [], l2 = t2.id;
              if (r3.promoteId ? l2 = t2.properties[r3.promoteId] : r3.generateId && (l2 = o2 || 0), i2 === "Point")
                K2(n2, a2);
              else if (i2 === "MultiPoint")
                for (var u2 = 0; u2 < n2.length; u2++)
                  K2(n2[u2], a2);
              else if (i2 === "LineString")
                ee2(n2, a2, s2, false);
              else if (i2 === "MultiLineString") {
                if (r3.lineMetrics) {
                  for (u2 = 0; u2 < n2.length; u2++)
                    ee2(n2[u2], a2 = [], s2, false), e2.push(U2(l2, "LineString", a2, t2.properties));
                  return;
                }
                te2(n2, a2, s2, false);
              } else if (i2 === "Polygon")
                te2(n2, a2, s2, true);
              else {
                if (i2 !== "MultiPolygon") {
                  if (i2 === "GeometryCollection") {
                    for (u2 = 0; u2 < t2.geometry.geometries.length; u2++)
                      H(e2, { id: l2, geometry: t2.geometry.geometries[u2], properties: t2.properties }, r3, o2);
                    return;
                  }
                  throw new Error("Input data is not a valid GeoJSON object.");
                }
                for (u2 = 0; u2 < n2.length; u2++) {
                  var h2 = [];
                  te2(n2[u2], h2, s2, true), a2.push(h2);
                }
              }
              e2.push(U2(l2, i2, a2, t2.properties));
            }
          }
          function K2(e2, t2) {
            t2.push(re2(e2[0])), t2.push(oe2(e2[1])), t2.push(0);
          }
          function ee2(e2, t2, r3, o2) {
            for (var n2, i2, s2 = 0, a2 = 0; a2 < e2.length; a2++) {
              var l2 = re2(e2[a2][0]), u2 = oe2(e2[a2][1]);
              t2.push(l2), t2.push(u2), t2.push(0), a2 > 0 && (s2 += o2 ? (n2 * u2 - l2 * i2) / 2 : Math.sqrt(Math.pow(l2 - n2, 2) + Math.pow(u2 - i2, 2))), n2 = l2, i2 = u2;
            }
            var h2 = t2.length - 3;
            t2[2] = 1, R(t2, 0, h2, r3), t2[h2 + 2] = 1, t2.size = Math.abs(s2), t2.start = 0, t2.end = t2.size;
          }
          function te2(e2, t2, r3, o2) {
            for (var n2 = 0; n2 < e2.length; n2++) {
              var i2 = [];
              ee2(e2[n2], i2, r3, o2), t2.push(i2);
            }
          }
          function re2(e2) {
            return e2 / 360 + 0.5;
          }
          function oe2(e2) {
            var t2 = Math.sin(e2 * Math.PI / 180), r3 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
            return r3 < 0 ? 0 : r3 > 1 ? 1 : r3;
          }
          function ne2(e2, t2, r3, o2, n2, i2, s2, a2) {
            if (o2 /= t2, i2 >= (r3 /= t2) && s2 < o2)
              return e2;
            if (s2 < r3 || i2 >= o2)
              return null;
            for (var l2 = [], u2 = 0; u2 < e2.length; u2++) {
              var h2 = e2[u2], c2 = h2.geometry, f2 = h2.type, p2 = n2 === 0 ? h2.minX : h2.minY, g2 = n2 === 0 ? h2.maxX : h2.maxY;
              if (p2 >= r3 && g2 < o2)
                l2.push(h2);
              else if (!(g2 < r3 || p2 >= o2)) {
                var d2 = [];
                if (f2 === "Point" || f2 === "MultiPoint")
                  ie(c2, d2, r3, o2, n2);
                else if (f2 === "LineString")
                  se2(c2, d2, r3, o2, n2, false, a2.lineMetrics);
                else if (f2 === "MultiLineString")
                  le2(c2, d2, r3, o2, n2, false);
                else if (f2 === "Polygon")
                  le2(c2, d2, r3, o2, n2, true);
                else if (f2 === "MultiPolygon")
                  for (var m2 = 0; m2 < c2.length; m2++) {
                    var y2 = [];
                    le2(c2[m2], y2, r3, o2, n2, true), y2.length && d2.push(y2);
                  }
                if (d2.length) {
                  if (a2.lineMetrics && f2 === "LineString") {
                    for (m2 = 0; m2 < d2.length; m2++)
                      l2.push(U2(h2.id, f2, d2[m2], h2.tags));
                    continue;
                  }
                  f2 !== "LineString" && f2 !== "MultiLineString" || (d2.length === 1 ? (f2 = "LineString", d2 = d2[0]) : f2 = "MultiLineString"), f2 !== "Point" && f2 !== "MultiPoint" || (f2 = d2.length === 3 ? "Point" : "MultiPoint"), l2.push(U2(h2.id, f2, d2, h2.tags));
                }
              }
            }
            return l2.length ? l2 : null;
          }
          function ie(e2, t2, r3, o2, n2) {
            for (var i2 = 0; i2 < e2.length; i2 += 3) {
              var s2 = e2[i2 + n2];
              s2 >= r3 && s2 <= o2 && (t2.push(e2[i2]), t2.push(e2[i2 + 1]), t2.push(e2[i2 + 2]));
            }
          }
          function se2(e2, t2, r3, o2, n2, i2, s2) {
            for (var a2, l2, u2 = ae2(e2), h2 = n2 === 0 ? he2 : ce2, c2 = e2.start, f2 = 0; f2 < e2.length - 3; f2 += 3) {
              var p2 = e2[f2], g2 = e2[f2 + 1], d2 = e2[f2 + 2], m2 = e2[f2 + 3], y2 = e2[f2 + 4], v2 = n2 === 0 ? p2 : g2, x3 = n2 === 0 ? m2 : y2, w3 = false;
              s2 && (a2 = Math.sqrt(Math.pow(p2 - m2, 2) + Math.pow(g2 - y2, 2))), v2 < r3 ? x3 > r3 && (l2 = h2(u2, p2, g2, m2, y2, r3), s2 && (u2.start = c2 + a2 * l2)) : v2 > o2 ? x3 < o2 && (l2 = h2(u2, p2, g2, m2, y2, o2), s2 && (u2.start = c2 + a2 * l2)) : ue2(u2, p2, g2, d2), x3 < r3 && v2 >= r3 && (l2 = h2(u2, p2, g2, m2, y2, r3), w3 = true), x3 > o2 && v2 <= o2 && (l2 = h2(u2, p2, g2, m2, y2, o2), w3 = true), !i2 && w3 && (s2 && (u2.end = c2 + a2 * l2), t2.push(u2), u2 = ae2(e2)), s2 && (c2 += a2);
            }
            var S2 = e2.length - 3;
            p2 = e2[S2], g2 = e2[S2 + 1], d2 = e2[S2 + 2], (v2 = n2 === 0 ? p2 : g2) >= r3 && v2 <= o2 && ue2(u2, p2, g2, d2), S2 = u2.length - 3, i2 && S2 >= 3 && (u2[S2] !== u2[0] || u2[S2 + 1] !== u2[1]) && ue2(u2, u2[0], u2[1], u2[2]), u2.length && t2.push(u2);
          }
          function ae2(e2) {
            var t2 = [];
            return t2.size = e2.size, t2.start = e2.start, t2.end = e2.end, t2;
          }
          function le2(e2, t2, r3, o2, n2, i2) {
            for (var s2 = 0; s2 < e2.length; s2++)
              se2(e2[s2], t2, r3, o2, n2, i2, false);
          }
          function ue2(e2, t2, r3, o2) {
            e2.push(t2), e2.push(r3), e2.push(o2);
          }
          function he2(e2, t2, r3, o2, n2, i2) {
            var s2 = (i2 - t2) / (o2 - t2);
            return e2.push(i2), e2.push(r3 + (n2 - r3) * s2), e2.push(1), s2;
          }
          function ce2(e2, t2, r3, o2, n2, i2) {
            var s2 = (i2 - r3) / (n2 - r3);
            return e2.push(t2 + (o2 - t2) * s2), e2.push(i2), e2.push(1), s2;
          }
          function fe2(e2, t2) {
            for (var r3 = [], o2 = 0; o2 < e2.length; o2++) {
              var n2, i2 = e2[o2], s2 = i2.type;
              if (s2 === "Point" || s2 === "MultiPoint" || s2 === "LineString")
                n2 = pe(i2.geometry, t2);
              else if (s2 === "MultiLineString" || s2 === "Polygon") {
                n2 = [];
                for (var a2 = 0; a2 < i2.geometry.length; a2++)
                  n2.push(pe(i2.geometry[a2], t2));
              } else if (s2 === "MultiPolygon")
                for (n2 = [], a2 = 0; a2 < i2.geometry.length; a2++) {
                  for (var l2 = [], u2 = 0; u2 < i2.geometry[a2].length; u2++)
                    l2.push(pe(i2.geometry[a2][u2], t2));
                  n2.push(l2);
                }
              r3.push(U2(i2.id, s2, n2, i2.tags));
            }
            return r3;
          }
          function pe(e2, t2) {
            var r3 = [];
            r3.size = e2.size, e2.start !== void 0 && (r3.start = e2.start, r3.end = e2.end);
            for (var o2 = 0; o2 < e2.length; o2 += 3)
              r3.push(e2[o2] + t2, e2[o2 + 1], e2[o2 + 2]);
            return r3;
          }
          function ge2(e2, t2) {
            if (e2.transformed)
              return e2;
            var r3, o2, n2, i2 = 1 << e2.z, s2 = e2.x, a2 = e2.y;
            for (r3 = 0; r3 < e2.features.length; r3++) {
              var l2 = e2.features[r3], u2 = l2.geometry, h2 = l2.type;
              if (l2.geometry = [], h2 === 1)
                for (o2 = 0; o2 < u2.length; o2 += 2)
                  l2.geometry.push(de2(u2[o2], u2[o2 + 1], t2, i2, s2, a2));
              else
                for (o2 = 0; o2 < u2.length; o2++) {
                  var c2 = [];
                  for (n2 = 0; n2 < u2[o2].length; n2 += 2)
                    c2.push(de2(u2[o2][n2], u2[o2][n2 + 1], t2, i2, s2, a2));
                  l2.geometry.push(c2);
                }
            }
            return e2.transformed = true, e2;
          }
          function de2(e2, t2, r3, o2, n2, i2) {
            return [Math.round(r3 * (e2 * o2 - n2)), Math.round(r3 * (t2 * o2 - i2))];
          }
          function me2(e2, t2, r3, o2, n2) {
            for (var i2 = t2 === n2.maxZoom ? 0 : n2.tolerance / ((1 << t2) * n2.extent), s2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: r3, y: o2, z: t2, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a2 = 0; a2 < e2.length; a2++) {
              s2.numFeatures++, ye2(s2, e2[a2], i2, n2);
              var l2 = e2[a2].minX, u2 = e2[a2].minY, h2 = e2[a2].maxX, c2 = e2[a2].maxY;
              l2 < s2.minX && (s2.minX = l2), u2 < s2.minY && (s2.minY = u2), h2 > s2.maxX && (s2.maxX = h2), c2 > s2.maxY && (s2.maxY = c2);
            }
            return s2;
          }
          function ye2(e2, t2, r3, o2) {
            var n2 = t2.geometry, i2 = t2.type, s2 = [];
            if (i2 === "Point" || i2 === "MultiPoint")
              for (var a2 = 0; a2 < n2.length; a2 += 3)
                s2.push(n2[a2]), s2.push(n2[a2 + 1]), e2.numPoints++, e2.numSimplified++;
            else if (i2 === "LineString")
              ve2(s2, n2, e2, r3, false, false);
            else if (i2 === "MultiLineString" || i2 === "Polygon")
              for (a2 = 0; a2 < n2.length; a2++)
                ve2(s2, n2[a2], e2, r3, i2 === "Polygon", a2 === 0);
            else if (i2 === "MultiPolygon")
              for (var l2 = 0; l2 < n2.length; l2++) {
                var u2 = n2[l2];
                for (a2 = 0; a2 < u2.length; a2++)
                  ve2(s2, u2[a2], e2, r3, true, a2 === 0);
              }
            if (s2.length) {
              var h2 = t2.tags || null;
              if (i2 === "LineString" && o2.lineMetrics) {
                for (var c2 in h2 = {}, t2.tags)
                  h2[c2] = t2.tags[c2];
                h2.mapbox_clip_start = n2.start / n2.size, h2.mapbox_clip_end = n2.end / n2.size;
              }
              var f2 = { geometry: s2, type: i2 === "Polygon" || i2 === "MultiPolygon" ? 3 : i2 === "LineString" || i2 === "MultiLineString" ? 2 : 1, tags: h2 };
              t2.id !== null && (f2.id = t2.id), e2.features.push(f2);
            }
          }
          function ve2(e2, t2, r3, o2, n2, i2) {
            var s2 = o2 * o2;
            if (o2 > 0 && t2.size < (n2 ? s2 : o2))
              r3.numPoints += t2.length / 3;
            else {
              for (var a2 = [], l2 = 0; l2 < t2.length; l2 += 3)
                (o2 === 0 || t2[l2 + 2] > s2) && (r3.numSimplified++, a2.push(t2[l2]), a2.push(t2[l2 + 1])), r3.numPoints++;
              n2 && function(e3, t3) {
                for (var r4 = 0, o3 = 0, n3 = e3.length, i3 = n3 - 2; o3 < n3; i3 = o3, o3 += 2)
                  r4 += (e3[o3] - e3[i3]) * (e3[o3 + 1] + e3[i3 + 1]);
                if (r4 > 0 === t3)
                  for (o3 = 0, n3 = e3.length; o3 < n3 / 2; o3 += 2) {
                    var s3 = e3[o3], a3 = e3[o3 + 1];
                    e3[o3] = e3[n3 - 2 - o3], e3[o3 + 1] = e3[n3 - 1 - o3], e3[n3 - 2 - o3] = s3, e3[n3 - 1 - o3] = a3;
                  }
              }(a2, i2), e2.push(a2);
            }
          }
          function xe2(e2, t2) {
            var r3 = (t2 = this.options = function(e3, t3) {
              for (var r4 in t3)
                e3[r4] = t3[r4];
              return e3;
            }(Object.create(this.options), t2)).debug;
            if (r3 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24)
              throw new Error("maxZoom should be in the 0-24 range");
            if (t2.promoteId && t2.generateId)
              throw new Error("promoteId and generateId cannot be used together.");
            var o2 = function(e3, t3) {
              var r4 = [];
              if (e3.type === "FeatureCollection")
                for (var o3 = 0; o3 < e3.features.length; o3++)
                  H(r4, e3.features[o3], t3, o3);
              else
                H(r4, e3.type === "Feature" ? e3 : { geometry: e3 }, t3);
              return r4;
            }(e2, t2);
            this.tiles = {}, this.tileCoords = [], r3 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (o2 = function(e3, t3) {
              var r4 = t3.buffer / t3.extent, o3 = e3, n2 = ne2(e3, 1, -1 - r4, r4, 0, -1, 2, t3), i2 = ne2(e3, 1, 1 - r4, 2 + r4, 0, -1, 2, t3);
              return (n2 || i2) && (o3 = ne2(e3, 1, -r4, 1 + r4, 0, -1, 2, t3) || [], n2 && (o3 = fe2(n2, 1).concat(o3)), i2 && (o3 = o3.concat(fe2(i2, -1)))), o3;
            }(o2, t2)).length && this.splitTile(o2, 0, 0, 0), r3 && (o2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          function we2(e2, t2, r3) {
            return 32 * ((1 << e2) * r3 + t2) + e2;
          }
          function Se(e2, t2) {
            const r3 = e2.tileID.canonical;
            if (!this._geoJSONIndex)
              return t2(null, null);
            const o2 = this._geoJSONIndex.getTile(r3.z, r3.x, r3.y);
            if (!o2)
              return t2(null, null);
            const n2 = new c(o2.features);
            let i2 = m(n2);
            i2.byteOffset === 0 && i2.byteLength === i2.buffer.byteLength || (i2 = new Uint8Array(i2)), t2(null, { vectorTile: n2, rawData: i2.buffer });
          }
          xe2.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, xe2.prototype.splitTile = function(e2, t2, r3, o2, n2, i2, s2) {
            for (var a2 = [e2, t2, r3, o2], l2 = this.options, u2 = l2.debug; a2.length; ) {
              o2 = a2.pop(), r3 = a2.pop(), t2 = a2.pop(), e2 = a2.pop();
              var h2 = 1 << t2, c2 = we2(t2, r3, o2), f2 = this.tiles[c2];
              if (!f2 && (u2 > 1 && console.time("creation"), f2 = this.tiles[c2] = me2(e2, t2, r3, o2, l2), this.tileCoords.push({ z: t2, x: r3, y: o2 }), u2)) {
                u2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, r3, o2, f2.numFeatures, f2.numPoints, f2.numSimplified), console.timeEnd("creation"));
                var p2 = "z" + t2;
                this.stats[p2] = (this.stats[p2] || 0) + 1, this.total++;
              }
              if (f2.source = e2, n2) {
                if (t2 === l2.maxZoom || t2 === n2)
                  continue;
                var g2 = 1 << n2 - t2;
                if (r3 !== Math.floor(i2 / g2) || o2 !== Math.floor(s2 / g2))
                  continue;
              } else if (t2 === l2.indexMaxZoom || f2.numPoints <= l2.indexMaxPoints)
                continue;
              if (f2.source = null, e2.length !== 0) {
                u2 > 1 && console.time("clipping");
                var d2, m2, y2, v2, x3, w3, S2 = 0.5 * l2.buffer / l2.extent, M3 = 0.5 - S2, P2 = 0.5 + S2, b2 = 1 + S2;
                d2 = m2 = y2 = v2 = null, x3 = ne2(e2, h2, r3 - S2, r3 + P2, 0, f2.minX, f2.maxX, l2), w3 = ne2(e2, h2, r3 + M3, r3 + b2, 0, f2.minX, f2.maxX, l2), e2 = null, x3 && (d2 = ne2(x3, h2, o2 - S2, o2 + P2, 1, f2.minY, f2.maxY, l2), m2 = ne2(x3, h2, o2 + M3, o2 + b2, 1, f2.minY, f2.maxY, l2), x3 = null), w3 && (y2 = ne2(w3, h2, o2 - S2, o2 + P2, 1, f2.minY, f2.maxY, l2), v2 = ne2(w3, h2, o2 + M3, o2 + b2, 1, f2.minY, f2.maxY, l2), w3 = null), u2 > 1 && console.timeEnd("clipping"), a2.push(d2 || [], t2 + 1, 2 * r3, 2 * o2), a2.push(m2 || [], t2 + 1, 2 * r3, 2 * o2 + 1), a2.push(y2 || [], t2 + 1, 2 * r3 + 1, 2 * o2), a2.push(v2 || [], t2 + 1, 2 * r3 + 1, 2 * o2 + 1);
              }
            }
          }, xe2.prototype.getTile = function(e2, t2, r3) {
            var o2 = this.options, n2 = o2.extent, i2 = o2.debug;
            if (e2 < 0 || e2 > 24)
              return null;
            var s2 = 1 << e2, a2 = we2(e2, t2 = (t2 % s2 + s2) % s2, r3);
            if (this.tiles[a2])
              return ge2(this.tiles[a2], n2);
            i2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t2, r3);
            for (var l2, u2 = e2, h2 = t2, c2 = r3; !l2 && u2 > 0; )
              u2--, h2 = Math.floor(h2 / 2), c2 = Math.floor(c2 / 2), l2 = this.tiles[we2(u2, h2, c2)];
            return l2 && l2.source ? (i2 > 1 && console.log("found parent tile z%d-%d-%d", u2, h2, c2), i2 > 1 && console.time("drilling down"), this.splitTile(l2.source, u2, h2, c2, e2, t2, r3), i2 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? ge2(this.tiles[a2], n2) : null) : null;
          };
          class Me2 extends e.VectorTileWorkerSource {
            constructor(e2, t2, r3, o2, n2) {
              super(e2, t2, r3, o2, Se), n2 && (this.loadGeoJSON = n2);
            }
            loadData(t2, r3) {
              const o2 = t2 && t2.request, n2 = o2 && o2.collectResourceTiming;
              this.loadGeoJSON(t2, (i2, a2) => {
                if (i2 || !a2)
                  return r3(i2);
                if (typeof a2 != "object")
                  return r3(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
                {
                  s(a2, true);
                  try {
                    if (t2.filter) {
                      const r4 = e.createExpression(t2.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                      if (r4.result === "error")
                        throw new Error(r4.value.map((e2) => `${e2.key}: ${e2.message}`).join(", "));
                      const o3 = a2.features.filter((e2) => r4.value.evaluate({ zoom: 0 }, e2));
                      a2 = { type: "FeatureCollection", features: o3 };
                    }
                    this._geoJSONIndex = t2.cluster ? new G2(function({ superclusterOptions: t3, clusterProperties: r4 }) {
                      if (!r4 || !t3)
                        return t3;
                      const o3 = {}, n3 = {}, i3 = { accumulated: null, zoom: 0 }, s2 = { properties: null }, a3 = Object.keys(r4);
                      for (const t4 of a3) {
                        const [i4, s3] = r4[t4], a4 = e.createExpression(s3), l3 = e.createExpression(typeof i4 == "string" ? [i4, ["accumulated"], ["get", t4]] : i4);
                        o3[t4] = a4.value, n3[t4] = l3.value;
                      }
                      return t3.map = (e2) => {
                        s2.properties = e2;
                        const t4 = {};
                        for (const e3 of a3)
                          t4[e3] = o3[e3].evaluate(i3, s2);
                        return t4;
                      }, t3.reduce = (e2, t4) => {
                        s2.properties = t4;
                        for (const t5 of a3)
                          i3.accumulated = e2[t5], e2[t5] = n3[t5].evaluate(i3, s2);
                      }, t3;
                    }(t2)).load(a2.features) : function(e2, t3) {
                      return new xe2(e2, t3);
                    }(a2, t2.geojsonVtOptions);
                  } catch (i3) {
                    return r3(i3);
                  }
                  this.loaded = {};
                  const l2 = {};
                  if (n2) {
                    const r4 = e.getPerformanceMeasurement(o2);
                    r4 && (l2.resourceTiming = {}, l2.resourceTiming[t2.source] = JSON.parse(JSON.stringify(r4)));
                  }
                  r3(null, l2);
                }
              });
            }
            reloadTile(e2, t2) {
              const r3 = this.loaded;
              return r3 && r3[e2.uid] ? super.reloadTile(e2, t2) : this.loadTile(e2, t2);
            }
            loadGeoJSON(t2, r3) {
              if (t2.request)
                e.getJSON(t2.request, r3);
              else {
                if (typeof t2.data != "string")
                  return r3(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
                try {
                  return r3(null, JSON.parse(t2.data));
                } catch (e2) {
                  return r3(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
                }
              }
            }
            getClusterExpansionZoom(e2, t2) {
              try {
                t2(null, this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId));
              } catch (e3) {
                t2(e3);
              }
            }
            getClusterChildren(e2, t2) {
              try {
                t2(null, this._geoJSONIndex.getChildren(e2.clusterId));
              } catch (e3) {
                t2(e3);
              }
            }
            getClusterLeaves(e2, t2) {
              try {
                t2(null, this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset));
              } catch (e3) {
                t2(e3);
              }
            }
          }
          class Pe2 {
            constructor(t2) {
              this.self = t2, this.actor = new e.Actor(t2, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = false, this.workerSourceTypes = { vector: e.VectorTileWorkerSource, geojson: Me2 }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e2, t3) => {
                if (this.workerSourceTypes[e2])
                  throw new Error(`Worker source with name "${e2}" already registered.`);
                this.workerSourceTypes[e2] = t3;
              }, this.self.registerRTLTextPlugin = (t3) => {
                if (e.plugin.isParsed())
                  throw new Error("RTL text plugin already registered.");
                e.plugin.applyArabicShaping = t3.applyArabicShaping, e.plugin.processBidirectionalText = t3.processBidirectionalText, e.plugin.processStyledBidirectionalText = t3.processStyledBidirectionalText;
              };
            }
            checkIfReady(e2, t2, r3) {
              r3();
            }
            setReferrer(e2, t2) {
              this.referrer = t2;
            }
            spriteLoaded(t2, r3) {
              this.isSpriteLoaded = r3;
              for (const o2 in this.workerSources[t2]) {
                const n2 = this.workerSources[t2][o2];
                for (const t3 in n2)
                  n2[t3] instanceof e.VectorTileWorkerSource && (n2[t3].isSpriteLoaded = r3, n2[t3].fire(new e.Event("isSpriteLoaded")));
              }
            }
            setImages(e2, t2, r3) {
              this.availableImages[e2] = t2;
              for (const r4 in this.workerSources[e2]) {
                const o2 = this.workerSources[e2][r4];
                for (const e3 in o2)
                  o2[e3].availableImages = t2;
              }
              r3();
            }
            enableTerrain(e2, t2, r3) {
              this.terrain = t2, r3();
            }
            setLayers(e2, t2, r3) {
              this.getLayerIndex(e2).replace(t2), r3();
            }
            updateLayers(e2, t2, r3) {
              this.getLayerIndex(e2).update(t2.layers, t2.removedIds), r3();
            }
            loadTile(t2, r3, o2) {
              const n2 = this.enableTerrain ? e.extend({ enableTerrain: this.terrain }, r3) : r3;
              this.getWorkerSource(t2, r3.type, r3.source).loadTile(n2, o2);
            }
            loadDEMTile(t2, r3, o2) {
              const n2 = this.enableTerrain ? e.extend({ buildQuadTree: this.terrain }, r3) : r3;
              this.getDEMWorkerSource(t2, r3.source).loadTile(n2, o2);
            }
            reloadTile(t2, r3, o2) {
              const n2 = this.enableTerrain ? e.extend({ enableTerrain: this.terrain }, r3) : r3;
              this.getWorkerSource(t2, r3.type, r3.source).reloadTile(n2, o2);
            }
            abortTile(e2, t2, r3) {
              this.getWorkerSource(e2, t2.type, t2.source).abortTile(t2, r3);
            }
            removeTile(e2, t2, r3) {
              this.getWorkerSource(e2, t2.type, t2.source).removeTile(t2, r3);
            }
            removeSource(e2, t2, r3) {
              if (!this.workerSources[e2] || !this.workerSources[e2][t2.type] || !this.workerSources[e2][t2.type][t2.source])
                return;
              const o2 = this.workerSources[e2][t2.type][t2.source];
              delete this.workerSources[e2][t2.type][t2.source], o2.removeSource !== void 0 ? o2.removeSource(t2, r3) : r3();
            }
            loadWorkerSource(e2, t2, r3) {
              try {
                this.self.importScripts(t2.url), r3();
              } catch (e3) {
                r3(e3.toString());
              }
            }
            syncRTLPluginState(t2, r3, o2) {
              try {
                e.plugin.setState(r3);
                const t3 = e.plugin.getPluginURL();
                if (e.plugin.isLoaded() && !e.plugin.isParsed() && t3 != null) {
                  this.self.importScripts(t3);
                  const r4 = e.plugin.isParsed();
                  o2(r4 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t3}`), r4);
                }
              } catch (e2) {
                o2(e2.toString());
              }
            }
            getAvailableImages(e2) {
              let t2 = this.availableImages[e2];
              return t2 || (t2 = []), t2;
            }
            getLayerIndex(e2) {
              let t2 = this.layerIndexes[e2];
              return t2 || (t2 = this.layerIndexes[e2] = new o()), t2;
            }
            getWorkerSource(e2, t2, r3) {
              return this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t2] || (this.workerSources[e2][t2] = {}), this.workerSources[e2][t2][r3] || (this.workerSources[e2][t2][r3] = new this.workerSourceTypes[t2]({ send: (t3, r4, o2, n2, i2, s2) => {
                this.actor.send(t3, r4, o2, e2, i2, s2);
              }, scheduler: this.actor.scheduler }, this.getLayerIndex(e2), this.getAvailableImages(e2), this.isSpriteLoaded)), this.workerSources[e2][t2][r3];
            }
            getDEMWorkerSource(e2, t2) {
              return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t2] || (this.demWorkerSources[e2][t2] = new i()), this.demWorkerSources[e2][t2];
            }
            enforceCacheSizeLimit(t2, r3) {
              e.enforceCacheSizeLimit(r3);
            }
            getWorkerPerformanceMetrics(e2, t2, r3) {
              r3(void 0, void 0);
            }
          }
          return typeof WorkerGlobalScope != "undefined" && typeof self != "undefined" && self instanceof WorkerGlobalScope && (self.worker = new Pe2(self)), Pe2;
        });
        define2(["./shared"], function(t) {
          "use strict";
          var e = i;
          function i(t2) {
            return !function(t3) {
              return typeof window == "undefined" || typeof document == "undefined" ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
                if (!("Worker" in window && "Blob" in window && "URL" in window))
                  return false;
                var t4, e3, i2 = new Blob([""], { type: "text/javascript" }), o2 = URL.createObjectURL(i2);
                try {
                  e3 = new Worker(o2), t4 = true;
                } catch (e4) {
                  t4 = false;
                }
                return e3 && e3.terminate(), URL.revokeObjectURL(o2), t4;
              }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
                var t4 = document.createElement("canvas");
                t4.width = t4.height = 1;
                var e3 = t4.getContext("2d");
                if (!e3)
                  return false;
                var i2 = e3.getImageData(0, 0, 1, 1);
                return i2 && i2.width === t4.width;
              }() ? (o[e2 = t3 && t3.failIfMajorPerformanceCaveat] === void 0 && (o[e2] = function(t4) {
                var e3, o2 = function(t5) {
                  var e4 = document.createElement("canvas"), o3 = Object.create(i.webGLContextAttributes);
                  return o3.failIfMajorPerformanceCaveat = t5, e4.getContext("webgl", o3) || e4.getContext("experimental-webgl", o3);
                }(t4);
                if (!o2)
                  return false;
                try {
                  e3 = o2.createShader(o2.VERTEX_SHADER);
                } catch (t5) {
                  return false;
                }
                return !(!e3 || o2.isContextLost()) && (o2.shaderSource(e3, "void main() {}"), o2.compileShader(e3), o2.getShaderParameter(e3, o2.COMPILE_STATUS) === true);
              }(e2)), o[e2] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
              var e2;
            }(t2);
          }
          var o = {};
          function r2(t2, e2) {
            if (Array.isArray(t2)) {
              if (!Array.isArray(e2) || t2.length !== e2.length)
                return false;
              for (let i2 = 0; i2 < t2.length; i2++)
                if (!r2(t2[i2], e2[i2]))
                  return false;
              return true;
            }
            if (typeof t2 == "object" && t2 !== null && e2 !== null) {
              if (typeof e2 != "object")
                return false;
              if (Object.keys(t2).length !== Object.keys(e2).length)
                return false;
              for (const i2 in t2)
                if (!r2(t2[i2], e2[i2]))
                  return false;
              return true;
            }
            return t2 === e2;
          }
          i.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true };
          const a = { create: function(e2, i2, o2) {
            const r3 = t.window.document.createElement(e2);
            return i2 !== void 0 && (r3.className = i2), o2 && o2.appendChild(r3), r3;
          }, createNS: function(e2, i2) {
            return t.window.document.createElementNS(e2, i2);
          } }, n = t.window.document && t.window.document.documentElement.style, s = n && n.userSelect !== void 0 ? "userSelect" : "WebkitUserSelect";
          let l;
          a.disableDrag = function() {
            n && s && (l = n[s], n[s] = "none");
          }, a.enableDrag = function() {
            n && s && (n[s] = l);
          }, a.setTransform = function(t2, e2) {
            t2.style.transform = e2;
          };
          let c = false;
          try {
            const e2 = Object.defineProperty({}, "passive", { get() {
              c = true;
            } });
            t.window.addEventListener("test", e2, e2), t.window.removeEventListener("test", e2, e2);
          } catch (t2) {
            c = false;
          }
          a.addEventListener = function(t2, e2, i2, o2 = {}) {
            t2.addEventListener(e2, i2, "passive" in o2 && c ? o2 : o2.capture);
          }, a.removeEventListener = function(t2, e2, i2, o2 = {}) {
            t2.removeEventListener(e2, i2, "passive" in o2 && c ? o2 : o2.capture);
          };
          const h = function(e2) {
            e2.preventDefault(), e2.stopPropagation(), t.window.removeEventListener("click", h, true);
          };
          function d(e2, i2, o2) {
            const r3 = e2.offsetWidth === i2.width ? 1 : e2.offsetWidth / i2.width;
            return new t.pointGeometry((o2.clientX - i2.left) * r3, (o2.clientY - i2.top) * r3);
          }
          a.suppressClick = function() {
            t.window.addEventListener("click", h, true), t.window.setTimeout(() => {
              t.window.removeEventListener("click", h, true);
            }, 0);
          }, a.mousePos = function(t2, e2) {
            const i2 = t2.getBoundingClientRect();
            return d(t2, i2, e2);
          }, a.touchPos = function(t2, e2) {
            const i2 = t2.getBoundingClientRect(), o2 = [];
            for (let r3 = 0; r3 < e2.length; r3++)
              o2.push(d(t2, i2, e2[r3]));
            return o2;
          }, a.mouseButton = function(e2) {
            return t.window.InstallTrigger !== void 0 && e2.button === 2 && e2.ctrlKey && t.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : e2.button;
          }, a.remove = function(t2) {
            t2.parentNode && t2.parentNode.removeChild(t2);
          };
          class u {
            constructor(t2, e2) {
              this.pos = t2, this.dir = e2;
            }
            intersectsPlane(e2, i2, o2) {
              const r3 = t.dot(i2, this.dir);
              if (Math.abs(r3) < 1e-6)
                return false;
              const a2 = t.dot(t.sub(t.create(), e2, this.pos), i2) / r3, n2 = t.scaleAndAdd(t.create(), this.pos, this.dir, a2);
              return t.copy(o2, n2), true;
            }
          }
          class _ {
            constructor(t2, e2) {
              this.points = t2, this.planes = e2;
            }
            static fromInvProjectionMatrix(e2, i2, o2) {
              const r3 = Math.pow(2, o2), a2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((o3) => {
                const a3 = t.transformMat4([], o3, e2), n3 = 1 / a3[3] / i2 * r3;
                return t.mul(a3, a3, [n3, n3, 1 / a3[3], n3]);
              }), n2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((e3) => {
                const i3 = t.sub([], a2[e3[0]], a2[e3[1]]), o3 = t.sub([], a2[e3[2]], a2[e3[1]]), r4 = t.normalize([], t.cross([], i3, o3)), n3 = -t.dot(r4, a2[e3[1]]);
                return r4.concat(n3);
              });
              return new _(a2, n2);
            }
          }
          class p {
            constructor(e2, i2) {
              this.min = e2, this.max = i2, this.center = t.scale([], t.add([], this.min, this.max), 0.5);
            }
            quadrant(e2) {
              const i2 = [e2 % 2 == 0, e2 < 2], o2 = t.clone(this.min), r3 = t.clone(this.max);
              for (let t2 = 0; t2 < i2.length; t2++)
                o2[t2] = i2[t2] ? this.min[t2] : this.center[t2], r3[t2] = i2[t2] ? this.center[t2] : this.max[t2];
              return r3[2] = this.max[2], new p(o2, r3);
            }
            distanceX(t2) {
              return Math.max(Math.min(this.max[0], t2[0]), this.min[0]) - t2[0];
            }
            distanceY(t2) {
              return Math.max(Math.min(this.max[1], t2[1]), this.min[1]) - t2[1];
            }
            distanceZ(t2) {
              return Math.max(Math.min(this.max[2], t2[2]), this.min[2]) - t2[2];
            }
            intersects(e2) {
              const i2 = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
              let o2 = true;
              for (let r3 = 0; r3 < e2.planes.length; r3++) {
                const a2 = e2.planes[r3];
                let n2 = 0;
                for (let e3 = 0; e3 < i2.length; e3++)
                  n2 += t.dot$1(a2, i2[e3]) >= 0;
                if (n2 === 0)
                  return 0;
                n2 !== i2.length && (o2 = false);
              }
              if (o2)
                return 2;
              for (let t2 = 0; t2 < 3; t2++) {
                let i3 = Number.MAX_VALUE, o3 = -Number.MAX_VALUE;
                for (let r3 = 0; r3 < e2.points.length; r3++) {
                  const a2 = e2.points[r3][t2] - this.min[t2];
                  i3 = Math.min(i3, a2), o3 = Math.max(o3, a2);
                }
                if (o3 < 0 || i3 > this.max[t2] - this.min[t2])
                  return 0;
              }
              return 1;
            }
          }
          function m(t2) {
            const { userImage: e2 } = t2;
            return !!(e2 && e2.render && e2.render()) && (t2.data.replace(new Uint8Array(e2.data.buffer)), true);
          }
          class f extends t.Evented {
            constructor() {
              super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new t.RGBAImage({ width: 1, height: 1 }), this.dirty = true;
            }
            isLoaded() {
              return this.loaded;
            }
            setLoaded(t2) {
              if (this.loaded !== t2 && (this.loaded = t2, t2)) {
                for (const { ids: t3, callback: e2 } of this.requestors)
                  this._notify(t3, e2);
                this.requestors = [];
              }
            }
            getImage(t2) {
              return this.images[t2];
            }
            addImage(t2, e2) {
              this._validate(t2, e2) && (this.images[t2] = e2);
            }
            _validate(e2, i2) {
              let o2 = true;
              return this._validateStretch(i2.stretchX, i2.data && i2.data.width) || (this.fire(new t.ErrorEvent(new Error(`Image "${e2}" has invalid "stretchX" value`))), o2 = false), this._validateStretch(i2.stretchY, i2.data && i2.data.height) || (this.fire(new t.ErrorEvent(new Error(`Image "${e2}" has invalid "stretchY" value`))), o2 = false), this._validateContent(i2.content, i2) || (this.fire(new t.ErrorEvent(new Error(`Image "${e2}" has invalid "content" value`))), o2 = false), o2;
            }
            _validateStretch(t2, e2) {
              if (!t2)
                return true;
              let i2 = 0;
              for (const o2 of t2) {
                if (o2[0] < i2 || o2[1] < o2[0] || e2 < o2[1])
                  return false;
                i2 = o2[1];
              }
              return true;
            }
            _validateContent(t2, e2) {
              return !(t2 && (t2.length !== 4 || t2[0] < 0 || e2.data.width < t2[0] || t2[1] < 0 || e2.data.height < t2[1] || t2[2] < 0 || e2.data.width < t2[2] || t2[3] < 0 || e2.data.height < t2[3] || t2[2] < t2[0] || t2[3] < t2[1]));
            }
            updateImage(t2, e2) {
              e2.version = this.images[t2].version + 1, this.images[t2] = e2, this.updatedImages[t2] = true;
            }
            removeImage(t2) {
              const e2 = this.images[t2];
              delete this.images[t2], delete this.patterns[t2], e2.userImage && e2.userImage.onRemove && e2.userImage.onRemove();
            }
            listImages() {
              return Object.keys(this.images);
            }
            getImages(t2, e2) {
              let i2 = true;
              if (!this.isLoaded())
                for (const e3 of t2)
                  this.images[e3] || (i2 = false);
              this.isLoaded() || i2 ? this._notify(t2, e2) : this.requestors.push({ ids: t2, callback: e2 });
            }
            _notify(e2, i2) {
              const o2 = {};
              for (const i3 of e2) {
                this.images[i3] || this.fire(new t.Event("styleimagemissing", { id: i3 }));
                const e3 = this.images[i3];
                e3 ? o2[i3] = { data: e3.data.clone(), pixelRatio: e3.pixelRatio, sdf: e3.sdf, version: e3.version, stretchX: e3.stretchX, stretchY: e3.stretchY, content: e3.content, hasRenderCallback: Boolean(e3.userImage && e3.userImage.render) } : t.warnOnce(`Image "${i3}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
              }
              i2(null, o2);
            }
            getPixelSize() {
              const { width: t2, height: e2 } = this.atlasImage;
              return { width: t2, height: e2 };
            }
            getPattern(e2) {
              const i2 = this.patterns[e2], o2 = this.getImage(e2);
              if (!o2)
                return null;
              if (i2 && i2.position.version === o2.version)
                return i2.position;
              if (i2)
                i2.position.version = o2.version;
              else {
                const i3 = { w: o2.data.width + 2, h: o2.data.height + 2, x: 0, y: 0 }, r3 = new t.ImagePosition(i3, o2);
                this.patterns[e2] = { bin: i3, position: r3 };
              }
              return this._updatePatternAtlas(), this.patterns[e2].position;
            }
            bind(e2) {
              const i2 = e2.gl;
              this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new t.Texture(e2, this.atlasImage, i2.RGBA), this.atlasTexture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE);
            }
            _updatePatternAtlas() {
              const e2 = [];
              for (const t2 in this.patterns)
                e2.push(this.patterns[t2].bin);
              const { w: i2, h: o2 } = t.potpack(e2), r3 = this.atlasImage;
              r3.resize({ width: i2 || 1, height: o2 || 1 });
              for (const e3 in this.patterns) {
                const { bin: i3 } = this.patterns[e3], o3 = i3.x + 1, a2 = i3.y + 1, n2 = this.images[e3].data, s2 = n2.width, l2 = n2.height;
                t.RGBAImage.copy(n2, r3, { x: 0, y: 0 }, { x: o3, y: a2 }, { width: s2, height: l2 }), t.RGBAImage.copy(n2, r3, { x: 0, y: l2 - 1 }, { x: o3, y: a2 - 1 }, { width: s2, height: 1 }), t.RGBAImage.copy(n2, r3, { x: 0, y: 0 }, { x: o3, y: a2 + l2 }, { width: s2, height: 1 }), t.RGBAImage.copy(n2, r3, { x: s2 - 1, y: 0 }, { x: o3 - 1, y: a2 }, { width: 1, height: l2 }), t.RGBAImage.copy(n2, r3, { x: 0, y: 0 }, { x: o3 + s2, y: a2 }, { width: 1, height: l2 });
              }
              this.dirty = true;
            }
            beginFrame() {
              this.callbackDispatchedThisFrame = {};
            }
            dispatchRenderCallbacks(t2) {
              for (const e2 of t2) {
                if (this.callbackDispatchedThisFrame[e2])
                  continue;
                this.callbackDispatchedThisFrame[e2] = true;
                const t3 = this.images[e2];
                m(t3) && this.updateImage(e2, t3);
              }
            }
          }
          const g = new t.Properties({ anchor: new t.DataConstantProperty(t.spec.light.anchor), position: new class {
            constructor() {
              this.specification = t.spec.light.position;
            }
            possiblyEvaluate(e2, i2) {
              return function([e3, i3, o2]) {
                const r3 = t.degToRad(i3 + 90), a2 = t.degToRad(o2);
                return { x: e3 * Math.cos(r3) * Math.sin(a2), y: e3 * Math.sin(r3) * Math.sin(a2), z: e3 * Math.cos(a2), azimuthal: i3, polar: o2 };
              }(e2.expression.evaluate(i2));
            }
            interpolate(e2, i2, o2) {
              return { x: t.number(e2.x, i2.x, o2), y: t.number(e2.y, i2.y, o2), z: t.number(e2.z, i2.z, o2), azimuthal: t.number(e2.azimuthal, i2.azimuthal, o2), polar: t.number(e2.polar, i2.polar, o2) };
            }
          }(), color: new t.DataConstantProperty(t.spec.light.color), intensity: new t.DataConstantProperty(t.spec.light.intensity) }), v = "-transition";
          class x2 extends t.Evented {
            constructor(e2) {
              super(), this._transitionable = new t.Transitionable(g), this.setLight(e2), this._transitioning = this._transitionable.untransitioned();
            }
            getLight() {
              return this._transitionable.serialize();
            }
            setLight(e2, i2 = {}) {
              if (!this._validate(t.validateLight, e2, i2))
                for (const i3 in e2) {
                  const o2 = e2[i3];
                  t.endsWith(i3, v) ? this._transitionable.setTransition(i3.slice(0, -v.length), o2) : this._transitionable.setValue(i3, o2);
                }
            }
            updateTransitions(t2) {
              this._transitioning = this._transitionable.transitioned(t2, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(t2) {
              this.properties = this._transitioning.possiblyEvaluate(t2);
            }
            _validate(e2, i2, o2) {
              return (!o2 || o2.validate !== false) && t.emitValidationErrors(this, e2.call(t.validateStyle, t.extend({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: t.spec })));
            }
          }
          const y = new t.Properties({ source: new t.DataConstantProperty(t.spec.terrain.source), exaggeration: new t.DataConstantProperty(t.spec.terrain.exaggeration) }), b = "-transition";
          class w2 extends t.Evented {
            constructor(e2) {
              super(), this._transitionable = new t.Transitionable(y), this.set(e2), this._transitioning = this._transitionable.untransitioned();
            }
            get() {
              return this._transitionable.serialize();
            }
            set(e2) {
              for (const i2 in e2) {
                const o2 = e2[i2];
                t.endsWith(i2, b) ? this._transitionable.setTransition(i2.slice(0, -b.length), o2) : this._transitionable.setValue(i2, o2);
              }
            }
            updateTransitions(t2) {
              this._transitioning = this._transitionable.transitioned(t2, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(t2) {
              this.properties = this._transitioning.possiblyEvaluate(t2);
            }
          }
          function T(e2, i2, o2, r3) {
            const a2 = t.smoothstep(45, 65, o2), [n2, s2] = E(e2, r3), l2 = t.length(i2);
            let c2 = 1 - Math.min(1, Math.exp((l2 - n2) / (s2 - n2) * -6));
            return c2 *= c2 * c2, c2 = Math.min(1, 1.00747 * c2), c2 * a2 * e2.alpha;
          }
          function E(t2, e2) {
            const i2 = 0.5 / Math.tan(0.5 * e2);
            return [t2.range[0] + i2, t2.range[1] + i2];
          }
          const C = new t.Properties({ range: new t.DataConstantProperty(t.spec.fog.range), color: new t.DataConstantProperty(t.spec.fog.color), "horizon-blend": new t.DataConstantProperty(t.spec.fog["horizon-blend"]) }), S = "-transition";
          class I2 extends t.Evented {
            constructor(e2) {
              super(), this._transitionable = new t.Transitionable(C), this.set(e2), this._transitioning = this._transitionable.untransitioned();
            }
            get state() {
              return { range: this.properties.get("range"), horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
            }
            get() {
              return this._transitionable.serialize();
            }
            set(e2, i2 = {}) {
              if (!this._validate(t.validateFog, e2, i2))
                for (const i3 in e2) {
                  const o2 = e2[i3];
                  t.endsWith(i3, S) ? this._transitionable.setTransition(i3.slice(0, -S.length), o2) : this._transitionable.setValue(i3, o2);
                }
            }
            getOpacity(e2) {
              const i2 = this.properties && this.properties.get("color") || 1;
              return t.smoothstep(45, 65, e2) * i2.a;
            }
            getOpacityAtLatLng(e2, i2) {
              return function(e3, i3, o2) {
                const r3 = t.MercatorCoordinate.fromLngLat(i3), a2 = o2.elevation ? o2.elevation.getAtPointOrZero(r3) : 0, n2 = [r3.x, r3.y, a2];
                return t.transformMat4$1(n2, n2, o2.mercatorFogMatrix), T(e3, n2, o2.pitch, o2._fov);
              }(this.state, e2, i2);
            }
            getFovAdjustedRange(t2) {
              return E(this.state, t2);
            }
            updateTransitions(t2) {
              this._transitioning = this._transitionable.transitioned(t2, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(t2) {
              this.properties = this._transitioning.possiblyEvaluate(t2);
            }
            _validate(e2, i2, o2) {
              return (!o2 || o2.validate !== false) && t.emitValidationErrors(this, e2.call(t.validateStyle, t.extend({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: t.spec })));
            }
          }
          class M2 {
            constructor(e2, i2) {
              this.workerPool = e2, this.actors = [], this.currentActor = 0, this.id = t.uniqueId();
              const o2 = this.workerPool.acquire(this.id);
              for (let t2 = 0; t2 < o2.length; t2++) {
                const e3 = new M2.Actor(o2[t2], i2, this.id);
                e3.name = `Worker ${t2}`, this.actors.push(e3);
              }
              this.ready = false, this.broadcast("checkIfReady", null, () => {
                this.ready = true;
              });
            }
            broadcast(e2, i2, o2) {
              t.asyncAll(this.actors, (t2, o3) => {
                t2.send(e2, i2, o3);
              }, o2 = o2 || function() {
              });
            }
            getActor() {
              return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
            }
            remove() {
              this.actors.forEach((t2) => {
                t2.remove();
              }), this.actors = [], this.workerPool.release(this.id);
            }
          }
          function z(e2, i2, o2) {
            return i2 * (t.EXTENT / (e2.tileSize * Math.pow(2, o2 - e2.tileID.overscaledZ)));
          }
          M2.Actor = t.Actor;
          class D {
            constructor(t2, e2, i2, o2) {
              this.screenBounds = t2, this.cameraPoint = e2, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i2, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this.screenGeometry.map((t3) => o2.pointCoordinate3D(t3)), this.cameraGeometry = this.bufferedCameraGeometry(0);
            }
            static createFromScreenPoints(e2, i2) {
              let o2, r3;
              if (e2 instanceof t.pointGeometry || typeof e2[0] == "number") {
                const a2 = t.pointGeometry.convert(e2);
                o2 = [t.pointGeometry.convert(e2)], r3 = i2.isPointAboveHorizon(a2);
              } else {
                const a2 = t.pointGeometry.convert(e2[0]), n2 = t.pointGeometry.convert(e2[1]);
                o2 = [a2, n2], r3 = t.polygonizeBounds(a2, n2).every((t2) => i2.isPointAboveHorizon(t2));
              }
              return new D(o2, i2.getCameraPoint(), r3, i2);
            }
            isPointQuery() {
              return this.screenBounds.length === 1;
            }
            bufferedScreenGeometry(e2) {
              return t.polygonizeBounds(this.screenBounds[0], this.screenBounds.length === 1 ? this.screenBounds[0] : this.screenBounds[1], e2);
            }
            bufferedCameraGeometry(e2) {
              const i2 = this.screenBounds[0], o2 = this.screenBounds.length === 1 ? this.screenBounds[0].add(new t.pointGeometry(1, 1)) : this.screenBounds[1], r3 = t.polygonizeBounds(i2, o2, 0, false);
              return this.cameraPoint.y > o2.y && (this.cameraPoint.x > i2.x && this.cameraPoint.x < o2.x ? r3.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o2.x ? r3[2] = this.cameraPoint : this.cameraPoint.x <= i2.x && (r3[3] = this.cameraPoint)), t.bufferConvexPolygon(r3, e2);
            }
            containsTile(e2, i2, o2) {
              const r3 = e2.queryPadding + 1, a2 = o2 ? this._bufferedCameraMercator(r3, i2).map((t2) => e2.tileID.getTilePoint(t2)) : this._bufferedScreenMercator(r3, i2).map((t2) => e2.tileID.getTilePoint(t2)), n2 = this.screenGeometryMercator.map((t2) => e2.tileID.getTileVec3(t2)), s2 = n2.map((e3) => new t.pointGeometry(e3[0], e3[1])), l2 = i2.getFreeCameraOptions().position || new t.MercatorCoordinate(0, 0, 0), c2 = e2.tileID.getTileVec3(l2), h2 = n2.map((e3) => {
                const i3 = t.sub(e3, e3, c2);
                return t.normalize(i3, i3), new u(c2, i3);
              }), d2 = z(e2, 1, i2.zoom);
              if (t.polygonIntersectsBox(a2, 0, 0, t.EXTENT, t.EXTENT))
                return { queryGeometry: this, tilespaceGeometry: s2, tilespaceRays: h2, bufferedTilespaceGeometry: a2, bufferedTilespaceBounds: (_2 = t.getBounds(a2), _2.min.x = t.clamp(_2.min.x, 0, t.EXTENT), _2.min.y = t.clamp(_2.min.y, 0, t.EXTENT), _2.max.x = t.clamp(_2.max.x, 0, t.EXTENT), _2.max.y = t.clamp(_2.max.y, 0, t.EXTENT), _2), tile: e2, tileID: e2.tileID, pixelToTileUnitsFactor: d2 };
              var _2;
            }
            _bufferedScreenMercator(t2, e2) {
              const i2 = A(t2);
              if (this._screenRaycastCache[i2])
                return this._screenRaycastCache[i2];
              {
                const o2 = this.bufferedScreenGeometry(t2).map((t3) => e2.pointCoordinate3D(t3));
                return this._screenRaycastCache[i2] = o2, o2;
              }
            }
            _bufferedCameraMercator(t2, e2) {
              const i2 = A(t2);
              if (this._cameraRaycastCache[i2])
                return this._cameraRaycastCache[i2];
              {
                const o2 = this.bufferedCameraGeometry(t2).map((t3) => e2.pointCoordinate3D(t3));
                return this._cameraRaycastCache[i2] = o2, o2;
              }
            }
          }
          function A(t2) {
            return 100 * t2 | 0;
          }
          function P(e2, i2, o2) {
            const r3 = function(r4, a2) {
              if (r4)
                return o2(r4);
              if (a2) {
                const r5 = t.pick(t.extend(a2, e2), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
                a2.vector_layers && (r5.vectorLayers = a2.vector_layers, r5.vectorLayerIds = r5.vectorLayers.map((t2) => t2.id)), r5.tiles = i2.canonicalizeTileset(r5, e2.url), o2(null, r5);
              }
            };
            return e2.url ? t.getJSON(i2.transformRequest(i2.normalizeSourceURL(e2.url), t.ResourceType.Source), r3) : t.exported.frame(() => r3(null, e2));
          }
          class L2 {
            constructor(e2, i2, o2) {
              this.bounds = t.LngLatBounds.convert(this.validateBounds(e2)), this.minzoom = i2 || 0, this.maxzoom = o2 || 24;
            }
            validateBounds(t2) {
              return Array.isArray(t2) && t2.length === 4 ? [Math.max(-180, t2[0]), Math.max(-90, t2[1]), Math.min(180, t2[2]), Math.min(90, t2[3])] : [-180, -90, 180, 90];
            }
            contains(e2) {
              const i2 = Math.pow(2, e2.z), o2 = Math.floor(t.mercatorXfromLng(this.bounds.getWest()) * i2), r3 = Math.floor(t.mercatorYfromLat(this.bounds.getNorth()) * i2), a2 = Math.ceil(t.mercatorXfromLng(this.bounds.getEast()) * i2), n2 = Math.ceil(t.mercatorYfromLat(this.bounds.getSouth()) * i2);
              return e2.x >= o2 && e2.x < a2 && e2.y >= r3 && e2.y < n2;
            }
          }
          class R {
            constructor(t2, e2, i2) {
              this.context = t2;
              const o2 = t2.gl;
              this.buffer = o2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), t2.bindElementBuffer.set(this.buffer), o2.bufferData(o2.ELEMENT_ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? o2.DYNAMIC_DRAW : o2.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
            }
            bind() {
              this.context.bindElementBuffer.set(this.buffer);
            }
            updateData(t2) {
              const e2 = this.context.gl;
              this.context.unbindVAO(), this.bind(), e2.bufferSubData(e2.ELEMENT_ARRAY_BUFFER, 0, t2.arrayBuffer);
            }
            destroy() {
              this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
          }
          const k2 = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
          class F2 {
            constructor(t2, e2, i2, o2) {
              this.length = e2.length, this.attributes = i2, this.itemSize = e2.bytesPerElement, this.dynamicDraw = o2, this.context = t2;
              const r3 = t2.gl;
              this.buffer = r3.createBuffer(), t2.bindVertexBuffer.set(this.buffer), r3.bufferData(r3.ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? r3.DYNAMIC_DRAW : r3.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
            }
            bind() {
              this.context.bindVertexBuffer.set(this.buffer);
            }
            updateData(t2) {
              const e2 = this.context.gl;
              this.bind(), e2.bufferSubData(e2.ARRAY_BUFFER, 0, t2.arrayBuffer);
            }
            enableAttributes(t2, e2) {
              for (let i2 = 0; i2 < this.attributes.length; i2++) {
                const o2 = e2.attributes[this.attributes[i2].name];
                o2 !== void 0 && t2.enableVertexAttribArray(o2);
              }
            }
            setVertexAttribPointers(t2, e2, i2) {
              for (let o2 = 0; o2 < this.attributes.length; o2++) {
                const r3 = this.attributes[o2], a2 = e2.attributes[r3.name];
                a2 !== void 0 && t2.vertexAttribPointer(a2, r3.components, t2[k2[r3.type]], false, this.itemSize, r3.offset + this.itemSize * (i2 || 0));
              }
            }
            destroy() {
              this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
          }
          class B {
            constructor(t2) {
              this.gl = t2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
            }
            get() {
              return this.current;
            }
            set(t2) {
            }
            getDefault() {
              return this.default;
            }
            setDefault() {
              this.set(this.default);
            }
          }
          class O extends B {
            getDefault() {
              return t.Color.transparent;
            }
            set(t2) {
              const e2 = this.current;
              (t2.r !== e2.r || t2.g !== e2.g || t2.b !== e2.b || t2.a !== e2.a || this.dirty) && (this.gl.clearColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = false);
            }
          }
          class U2 extends B {
            getDefault() {
              return 1;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.clearDepth(t2), this.current = t2, this.dirty = false);
            }
          }
          class N extends B {
            getDefault() {
              return 0;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.clearStencil(t2), this.current = t2, this.dirty = false);
            }
          }
          class G2 extends B {
            getDefault() {
              return [true, true, true, true];
            }
            set(t2) {
              const e2 = this.current;
              (t2[0] !== e2[0] || t2[1] !== e2[1] || t2[2] !== e2[2] || t2[3] !== e2[3] || this.dirty) && (this.gl.colorMask(t2[0], t2[1], t2[2], t2[3]), this.current = t2, this.dirty = false);
            }
          }
          class Z2 extends B {
            getDefault() {
              return true;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.depthMask(t2), this.current = t2, this.dirty = false);
            }
          }
          class V extends B {
            getDefault() {
              return 255;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.stencilMask(t2), this.current = t2, this.dirty = false);
            }
          }
          class j2 extends B {
            getDefault() {
              return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
            }
            set(t2) {
              const e2 = this.current;
              (t2.func !== e2.func || t2.ref !== e2.ref || t2.mask !== e2.mask || this.dirty) && (this.gl.stencilFunc(t2.func, t2.ref, t2.mask), this.current = t2, this.dirty = false);
            }
          }
          class q extends B {
            getDefault() {
              const t2 = this.gl;
              return [t2.KEEP, t2.KEEP, t2.KEEP];
            }
            set(t2) {
              const e2 = this.current;
              (t2[0] !== e2[0] || t2[1] !== e2[1] || t2[2] !== e2[2] || this.dirty) && (this.gl.stencilOp(t2[0], t2[1], t2[2]), this.current = t2, this.dirty = false);
            }
          }
          class W extends B {
            getDefault() {
              return false;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e2 = this.gl;
              t2 ? e2.enable(e2.STENCIL_TEST) : e2.disable(e2.STENCIL_TEST), this.current = t2, this.dirty = false;
            }
          }
          class $2 extends B {
            getDefault() {
              return [0, 1];
            }
            set(t2) {
              const e2 = this.current;
              (t2[0] !== e2[0] || t2[1] !== e2[1] || this.dirty) && (this.gl.depthRange(t2[0], t2[1]), this.current = t2, this.dirty = false);
            }
          }
          class X extends B {
            getDefault() {
              return false;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e2 = this.gl;
              t2 ? e2.enable(e2.DEPTH_TEST) : e2.disable(e2.DEPTH_TEST), this.current = t2, this.dirty = false;
            }
          }
          class H extends B {
            getDefault() {
              return this.gl.LESS;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.depthFunc(t2), this.current = t2, this.dirty = false);
            }
          }
          class K2 extends B {
            getDefault() {
              return false;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e2 = this.gl;
              t2 ? e2.enable(e2.BLEND) : e2.disable(e2.BLEND), this.current = t2, this.dirty = false;
            }
          }
          class Y extends B {
            getDefault() {
              const t2 = this.gl;
              return [t2.ONE, t2.ZERO];
            }
            set(t2) {
              const e2 = this.current;
              (t2[0] !== e2[0] || t2[1] !== e2[1] || this.dirty) && (this.gl.blendFunc(t2[0], t2[1]), this.current = t2, this.dirty = false);
            }
          }
          class Q2 extends B {
            getDefault() {
              return t.Color.transparent;
            }
            set(t2) {
              const e2 = this.current;
              (t2.r !== e2.r || t2.g !== e2.g || t2.b !== e2.b || t2.a !== e2.a || this.dirty) && (this.gl.blendColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = false);
            }
          }
          class J extends B {
            getDefault() {
              return this.gl.FUNC_ADD;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.blendEquation(t2), this.current = t2, this.dirty = false);
            }
          }
          class tt extends B {
            getDefault() {
              return false;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e2 = this.gl;
              t2 ? e2.enable(e2.CULL_FACE) : e2.disable(e2.CULL_FACE), this.current = t2, this.dirty = false;
            }
          }
          class et extends B {
            getDefault() {
              return this.gl.BACK;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.cullFace(t2), this.current = t2, this.dirty = false);
            }
          }
          class it2 extends B {
            getDefault() {
              return this.gl.CCW;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.frontFace(t2), this.current = t2, this.dirty = false);
            }
          }
          class ot2 extends B {
            getDefault() {
              return null;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.useProgram(t2), this.current = t2, this.dirty = false);
            }
          }
          class rt extends B {
            getDefault() {
              return this.gl.TEXTURE0;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.activeTexture(t2), this.current = t2, this.dirty = false);
            }
          }
          class at2 extends B {
            getDefault() {
              const t2 = this.gl;
              return [0, 0, t2.drawingBufferWidth, t2.drawingBufferHeight];
            }
            set(t2) {
              const e2 = this.current;
              (t2[0] !== e2[0] || t2[1] !== e2[1] || t2[2] !== e2[2] || t2[3] !== e2[3] || this.dirty) && (this.gl.viewport(t2[0], t2[1], t2[2], t2[3]), this.current = t2, this.dirty = false);
            }
          }
          class nt2 extends B {
            getDefault() {
              return null;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e2 = this.gl;
              e2.bindFramebuffer(e2.FRAMEBUFFER, t2), this.current = t2, this.dirty = false;
            }
          }
          class st2 extends B {
            getDefault() {
              return null;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e2 = this.gl;
              e2.bindRenderbuffer(e2.RENDERBUFFER, t2), this.current = t2, this.dirty = false;
            }
          }
          class lt2 extends B {
            getDefault() {
              return null;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e2 = this.gl;
              e2.bindTexture(e2.TEXTURE_2D, t2), this.current = t2, this.dirty = false;
            }
          }
          class ct2 extends B {
            getDefault() {
              return null;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e2 = this.gl;
              e2.bindBuffer(e2.ARRAY_BUFFER, t2), this.current = t2, this.dirty = false;
            }
          }
          class ht2 extends B {
            getDefault() {
              return null;
            }
            set(t2) {
              const e2 = this.gl;
              e2.bindBuffer(e2.ELEMENT_ARRAY_BUFFER, t2), this.current = t2, this.dirty = false;
            }
          }
          class dt extends B {
            constructor(t2) {
              super(t2), this.vao = t2.extVertexArrayObject;
            }
            getDefault() {
              return null;
            }
            set(t2) {
              this.vao && (t2 !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(t2), this.current = t2, this.dirty = false);
            }
          }
          class ut2 extends B {
            getDefault() {
              return 4;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e2 = this.gl;
              e2.pixelStorei(e2.UNPACK_ALIGNMENT, t2), this.current = t2, this.dirty = false;
            }
          }
          class _t extends B {
            getDefault() {
              return false;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e2 = this.gl;
              e2.pixelStorei(e2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t2), this.current = t2, this.dirty = false;
            }
          }
          class pt2 extends B {
            getDefault() {
              return false;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e2 = this.gl;
              e2.pixelStorei(e2.UNPACK_FLIP_Y_WEBGL, t2), this.current = t2, this.dirty = false;
            }
          }
          class mt2 extends B {
            constructor(t2, e2) {
              super(t2), this.context = t2, this.parent = e2;
            }
            getDefault() {
              return null;
            }
          }
          class ft2 extends mt2 {
            setDirty() {
              this.dirty = true;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              this.context.bindFramebuffer.set(this.parent);
              const e2 = this.gl;
              e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, t2, 0), this.current = t2, this.dirty = false;
            }
          }
          class gt2 extends mt2 {
            attachment() {
              return this.gl.DEPTH_ATTACHMENT;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              this.context.bindFramebuffer.set(this.parent);
              const e2 = this.gl;
              e2.framebufferRenderbuffer(e2.FRAMEBUFFER, this.attachment(), e2.RENDERBUFFER, t2), this.current = t2, this.dirty = false;
            }
          }
          class vt2 extends gt2 {
            attachment() {
              return this.gl.DEPTH_STENCIL_ATTACHMENT;
            }
          }
          class xt2 {
            constructor(t2, e2, i2, o2) {
              this.context = t2, this.width = e2, this.height = i2;
              const r3 = this.framebuffer = t2.gl.createFramebuffer();
              this.colorAttachment = new ft2(t2, r3), o2 && (this.depthAttachment = new gt2(t2, r3));
            }
            destroy() {
              const t2 = this.context.gl, e2 = this.colorAttachment.get();
              if (e2 && t2.deleteTexture(e2), this.depthAttachment) {
                const e3 = this.depthAttachment.get();
                e3 && t2.deleteRenderbuffer(e3);
              }
              t2.deleteFramebuffer(this.framebuffer);
            }
          }
          class yt2 {
            constructor(t2) {
              this.gl = t2, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new O(this), this.clearDepth = new U2(this), this.clearStencil = new N(this), this.colorMask = new G2(this), this.depthMask = new Z2(this), this.stencilMask = new V(this), this.stencilFunc = new j2(this), this.stencilOp = new q(this), this.stencilTest = new W(this), this.depthRange = new $2(this), this.depthTest = new X(this), this.depthFunc = new H(this), this.blend = new K2(this), this.blendFunc = new Y(this), this.blendColor = new Q2(this), this.blendEquation = new J(this), this.cullFace = new tt(this), this.cullFaceSide = new et(this), this.frontFace = new it2(this), this.program = new ot2(this), this.activeTexture = new rt(this), this.viewport = new at2(this), this.bindFramebuffer = new nt2(this), this.bindRenderbuffer = new st2(this), this.bindTexture = new lt2(this), this.bindVertexBuffer = new ct2(this), this.bindElementBuffer = new ht2(this), this.bindVertexArrayOES = this.extVertexArrayObject && new dt(this), this.pixelStoreUnpack = new ut2(this), this.pixelStoreUnpackPremultiplyAlpha = new _t(this), this.pixelStoreUnpackFlipY = new pt2(this), this.extTextureFilterAnisotropic = t2.getExtension("EXT_texture_filter_anisotropic") || t2.getExtension("MOZ_EXT_texture_filter_anisotropic") || t2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureFilterAnisotropicForceOff = false, this.extTextureHalfFloat = t2.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (t2.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = t2.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = t2.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = t2.getParameter(t2.MAX_TEXTURE_SIZE);
            }
            setDefault() {
              this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
            }
            setDirty() {
              this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = true), this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
            }
            createIndexBuffer(t2, e2) {
              return new R(this, t2, e2);
            }
            createVertexBuffer(t2, e2, i2) {
              return new F2(this, t2, e2, i2);
            }
            createRenderbuffer(t2, e2, i2) {
              const o2 = this.gl, r3 = o2.createRenderbuffer();
              return this.bindRenderbuffer.set(r3), o2.renderbufferStorage(o2.RENDERBUFFER, t2, e2, i2), this.bindRenderbuffer.set(null), r3;
            }
            createFramebuffer(t2, e2, i2) {
              return new xt2(this, t2, e2, i2);
            }
            clear({ color: t2, depth: e2, stencil: i2 }) {
              const o2 = this.gl;
              let r3 = 0;
              t2 && (r3 |= o2.COLOR_BUFFER_BIT, this.clearColor.set(t2), this.colorMask.set([true, true, true, true])), e2 !== void 0 && (r3 |= o2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(e2), this.depthMask.set(true)), i2 !== void 0 && (r3 |= o2.STENCIL_BUFFER_BIT, this.clearStencil.set(i2), this.stencilMask.set(255)), o2.clear(r3);
            }
            setCullFace(t2) {
              t2.enable === false ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(t2.mode), this.frontFace.set(t2.frontFace));
            }
            setDepthMode(t2) {
              t2.func !== this.gl.ALWAYS || t2.mask ? (this.depthTest.set(true), this.depthFunc.set(t2.func), this.depthMask.set(t2.mask), this.depthRange.set(t2.range)) : this.depthTest.set(false);
            }
            setStencilMode(t2) {
              t2.test.func !== this.gl.ALWAYS || t2.mask ? (this.stencilTest.set(true), this.stencilMask.set(t2.mask), this.stencilOp.set([t2.fail, t2.depthFail, t2.pass]), this.stencilFunc.set({ func: t2.test.func, ref: t2.ref, mask: t2.test.mask })) : this.stencilTest.set(false);
            }
            setColorMode(e2) {
              r2(e2.blendFunction, t.ColorMode.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e2.blendFunction), this.blendColor.set(e2.blendColor)), this.colorMask.set(e2.mask);
            }
            unbindVAO() {
              this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
            }
          }
          class bt2 extends t.Evented {
            constructor(e2, i2, o2, r3) {
              super(), this.id = e2, this.dispatcher = o2, this.setEventedParent(r3), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = t.extend({ type: "raster" }, i2), t.extend(this, t.pick(i2, ["url", "scheme", "tileSize"]));
            }
            load() {
              this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = P(this._options, this.map._requestManager, (e2, i2) => {
                this._tileJSONRequest = null, this._loaded = true, e2 ? this.fire(new t.ErrorEvent(e2)) : i2 && (t.extend(this, i2), i2.bounds && (this.tileBounds = new L2(i2.bounds, this.minzoom, this.maxzoom)), t.postTurnstileEvent(i2.tiles), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })));
              });
            }
            loaded() {
              return this._loaded;
            }
            onAdd(t2) {
              this.map = t2, this.load();
            }
            onRemove() {
              this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
            serialize() {
              return t.extend({}, this._options);
            }
            hasTile(t2) {
              return !this.tileBounds || this.tileBounds.contains(t2.canonical);
            }
            loadTile(e2, i2) {
              const o2 = t.exported.devicePixelRatio >= 2, r3 = this.map._requestManager.normalizeTileURL(e2.tileID.canonical.url(this.tiles, this.scheme), o2, this.tileSize);
              e2.request = t.getImage(this.map._requestManager.transformRequest(r3, t.ResourceType.Tile), (o3, r4, a2, n2) => {
                if (delete e2.request, e2.aborted)
                  e2.state = "unloaded", i2(null);
                else if (o3)
                  e2.state = "errored", i2(o3);
                else if (r4) {
                  this.map._refreshExpiredTiles && e2.setExpiryData({ cacheControl: a2, expires: n2 });
                  const o4 = this.map.painter.context, s2 = o4.gl;
                  e2.texture = this.map.painter.getTileTexture(r4.width), e2.texture ? e2.texture.update(r4, { useMipmap: true }) : (e2.texture = new t.Texture(o4, r4, s2.RGBA, { useMipmap: true }), e2.texture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE, s2.LINEAR_MIPMAP_NEAREST), o4.extTextureFilterAnisotropic && s2.texParameterf(s2.TEXTURE_2D, o4.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, o4.extTextureFilterAnisotropicMax)), e2.state = "loaded", t.cacheEntryPossiblyAdded(this.dispatcher), i2(null);
                }
              });
            }
            abortTile(t2, e2) {
              t2.request && (t2.request.cancel(), delete t2.request), e2();
            }
            unloadTile(t2, e2) {
              t2.texture && this.map.painter.saveTileTexture(t2.texture), e2();
            }
            hasTransition() {
              return false;
            }
          }
          let wt2;
          var Tt2 = t.createLayout([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
          class Et2 extends t.Evented {
            constructor(t2, e2, i2, o2) {
              super(), this.id = t2, this.dispatcher = i2, this.coordinates = e2.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(o2), this.options = e2;
            }
            load(e2, i2) {
              this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this.url = this.options.url, t.getImage(this.map._requestManager.transformRequest(this.url, t.ResourceType.Image), (o2, r3) => {
                this._loaded = true, o2 ? this.fire(new t.ErrorEvent(o2)) : r3 && (this.image = t.exported.getImageData(r3), e2 && (this.coordinates = e2), i2 && i2(), this._finishLoading());
              });
            }
            loaded() {
              return this._loaded;
            }
            updateImage(t2) {
              return this.image && t2.url ? (this.options.url = t2.url, this.load(t2.coordinates, () => {
                this.texture = null;
              }), this) : this;
            }
            _finishLoading() {
              this.map && (this.setCoordinates(this.coordinates), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })));
            }
            onAdd(t2) {
              this.map = t2, this.load();
            }
            setCoordinates(e2) {
              this.coordinates = e2;
              const i2 = e2.map(t.MercatorCoordinate.fromLngLat);
              this.tileID = function(e3) {
                let i3 = 1 / 0, o3 = 1 / 0, r3 = -1 / 0, a2 = -1 / 0;
                for (const t2 of e3)
                  i3 = Math.min(i3, t2.x), o3 = Math.min(o3, t2.y), r3 = Math.max(r3, t2.x), a2 = Math.max(a2, t2.y);
                const n2 = Math.max(r3 - i3, a2 - o3), s2 = Math.max(0, Math.floor(-Math.log(n2) / Math.LN2)), l2 = Math.pow(2, s2);
                return new t.CanonicalTileID(s2, Math.floor((i3 + r3) / 2 * l2), Math.floor((o3 + a2) / 2 * l2));
              }(i2), this.minzoom = this.maxzoom = this.tileID.z;
              const o2 = i2.map((t2) => this.tileID.getTilePoint(t2)._round());
              return this._boundsArray = new t.StructArrayLayout4i8(), this._boundsArray.emplaceBack(o2[0].x, o2[0].y, 0, 0), this._boundsArray.emplaceBack(o2[1].x, o2[1].y, t.EXTENT, 0), this._boundsArray.emplaceBack(o2[3].x, o2[3].y, 0, t.EXTENT), this._boundsArray.emplaceBack(o2[2].x, o2[2].y, t.EXTENT, t.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })), this;
            }
            prepare() {
              if (Object.keys(this.tiles).length === 0 || !this.image)
                return;
              const e2 = this.map.painter.context, i2 = e2.gl;
              this.boundsBuffer || (this.boundsBuffer = e2.createVertexBuffer(this._boundsArray, Tt2.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new t.Texture(e2, this.image, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
              for (const t2 in this.tiles) {
                const e3 = this.tiles[t2];
                e3.state !== "loaded" && (e3.state = "loaded", e3.texture = this.texture);
              }
            }
            loadTile(t2, e2) {
              this.tileID && this.tileID.equals(t2.tileID.canonical) ? (this.tiles[String(t2.tileID.wrap)] = t2, t2.buckets = {}, e2(null)) : (t2.state = "errored", e2(null));
            }
            serialize() {
              return { type: "image", url: this.options.url, coordinates: this.coordinates };
            }
            hasTransition() {
              return false;
            }
          }
          const Ct = { vector: class extends t.Evented {
            constructor(e2, i2, o2, r3) {
              if (super(), this.id = e2, this.dispatcher = o2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, t.extend(this, t.pick(i2, ["url", "scheme", "tileSize", "promoteId"])), this._options = t.extend({ type: "vector" }, i2), this._collectResourceTiming = i2.collectResourceTiming, this.tileSize !== 512)
                throw new Error("vector tile sources must have a tileSize of 512");
              this.setEventedParent(r3), this._tileWorkers = {}, this._deduped = new t.DedupedRequest();
            }
            load() {
              this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = P(this._options, this.map._requestManager, (e2, i2) => {
                this._tileJSONRequest = null, this._loaded = true, e2 ? this.fire(new t.ErrorEvent(e2)) : i2 && (t.extend(this, i2), i2.bounds && (this.tileBounds = new L2(i2.bounds, this.minzoom, this.maxzoom)), t.postTurnstileEvent(i2.tiles, this.map._requestManager._customAccessToken), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })));
              });
            }
            loaded() {
              return this._loaded;
            }
            hasTile(t2) {
              return !this.tileBounds || this.tileBounds.contains(t2.canonical);
            }
            onAdd(t2) {
              this.map = t2, this.load();
            }
            setSourceProperty(t2) {
              this._tileJSONRequest && this._tileJSONRequest.cancel(), t2();
              const e2 = this.map.style._getSourceCaches(this.id);
              for (const t3 of e2)
                t3.clearTiles();
              this.load();
            }
            setTiles(t2) {
              return this.setSourceProperty(() => {
                this._options.tiles = t2;
              }), this;
            }
            setUrl(t2) {
              return this.setSourceProperty(() => {
                this.url = t2, this._options.url = t2;
              }), this;
            }
            onRemove() {
              this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
            serialize() {
              return t.extend({}, this._options);
            }
            loadTile(e2, i2) {
              const o2 = this.map._requestManager.normalizeTileURL(e2.tileID.canonical.url(this.tiles, this.scheme)), r3 = { request: this.map._requestManager.transformRequest(o2, t.ResourceType.Tile), data: void 0, uid: e2.uid, tileID: e2.tileID, tileZoom: e2.tileZoom, zoom: e2.tileID.overscaledZ, tileSize: this.tileSize * e2.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: t.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: e2.isSymbolTile };
              if (r3.request.collectResourceTiming = this._collectResourceTiming, e2.actor && e2.state !== "expired")
                e2.state === "loading" ? e2.reloadCallback = i2 : e2.request = e2.actor.send("reloadTile", r3, a2.bind(this));
              else if (e2.actor = this._tileWorkers[o2] = this._tileWorkers[o2] || this.dispatcher.getActor(), this.dispatcher.ready)
                e2.request = e2.actor.send("loadTile", r3, a2.bind(this), void 0, true);
              else {
                const i3 = t.loadVectorTile.call({ deduped: this._deduped }, r3, (t2, i4) => {
                  t2 || !i4 ? a2.call(this, t2) : (r3.data = { cacheControl: i4.cacheControl, expires: i4.expires, rawData: i4.rawData.slice(0) }, e2.actor && e2.actor.send("loadTile", r3, a2.bind(this), void 0, true));
                }, true);
                e2.request = { cancel: i3 };
              }
              function a2(o3, r4) {
                return delete e2.request, e2.aborted ? i2(null) : o3 && o3.status !== 404 ? i2(o3) : (r4 && r4.resourceTiming && (e2.resourceTiming = r4.resourceTiming), this.map._refreshExpiredTiles && r4 && e2.setExpiryData(r4), e2.loadVectorData(r4, this.map.painter), t.cacheEntryPossiblyAdded(this.dispatcher), i2(null), void (e2.reloadCallback && (this.loadTile(e2, e2.reloadCallback), e2.reloadCallback = null)));
              }
            }
            abortTile(t2) {
              t2.request && (t2.request.cancel(), delete t2.request), t2.actor && t2.actor.send("abortTile", { uid: t2.uid, type: this.type, source: this.id });
            }
            unloadTile(t2) {
              t2.unloadVectorData(), t2.actor && t2.actor.send("removeTile", { uid: t2.uid, type: this.type, source: this.id });
            }
            hasTransition() {
              return false;
            }
            afterUpdate() {
              this._tileWorkers = {};
            }
          }, raster: bt2, "raster-dem": class extends bt2 {
            constructor(e2, i2, o2, r3) {
              super(e2, i2, o2, r3), this.type = "raster-dem", this.maxzoom = 22, this._options = t.extend({ type: "raster-dem" }, i2), this.encoding = i2.encoding || "mapbox";
            }
            loadTile(e2, i2) {
              const o2 = this.map._requestManager.normalizeTileURL(e2.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize);
              function r3(t2, o3) {
                t2 && (e2.state = "errored", i2(t2)), o3 && (e2.dem = o3, e2.dem.onDeserialize(), e2.needsHillshadePrepare = true, e2.needsDEMTextureUpload = true, e2.state = "loaded", i2(null));
              }
              e2.request = t.getImage(this.map._requestManager.transformRequest(o2, t.ResourceType.Tile), function(o3, a2, n2, s2) {
                if (delete e2.request, e2.aborted)
                  e2.state = "unloaded", i2(null);
                else if (o3)
                  e2.state = "errored", i2(o3);
                else if (a2) {
                  this.map._refreshExpiredTiles && e2.setExpiryData({ cacheControl: n2, expires: s2 });
                  const i3 = t.window.ImageBitmap && a2 instanceof t.window.ImageBitmap && (wt2 == null && (wt2 = t.window.OffscreenCanvas && new t.window.OffscreenCanvas(1, 1).getContext("2d") && typeof t.window.createImageBitmap == "function"), wt2), o4 = 1 - (a2.width - t.prevPowerOfTwo(a2.width)) / 2;
                  o4 < 1 || e2.neighboringTiles || (e2.neighboringTiles = this._getNeighboringTiles(e2.tileID));
                  const l2 = i3 ? a2 : t.exported.getImageData(a2, o4), c2 = { uid: e2.uid, coord: e2.tileID, source: this.id, rawImageData: l2, encoding: this.encoding, padding: o4 };
                  e2.actor && e2.state !== "expired" || (e2.actor = this.dispatcher.getActor(), e2.actor.send("loadDEMTile", c2, r3.bind(this), void 0, true));
                }
              }.bind(this));
            }
            _getNeighboringTiles(e2) {
              const i2 = e2.canonical, o2 = Math.pow(2, i2.z), r3 = (i2.x - 1 + o2) % o2, a2 = i2.x === 0 ? e2.wrap - 1 : e2.wrap, n2 = (i2.x + 1 + o2) % o2, s2 = i2.x + 1 === o2 ? e2.wrap + 1 : e2.wrap, l2 = {};
              return l2[new t.OverscaledTileID(e2.overscaledZ, a2, i2.z, r3, i2.y).key] = { backfilled: false }, l2[new t.OverscaledTileID(e2.overscaledZ, s2, i2.z, n2, i2.y).key] = { backfilled: false }, i2.y > 0 && (l2[new t.OverscaledTileID(e2.overscaledZ, a2, i2.z, r3, i2.y - 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e2.overscaledZ, e2.wrap, i2.z, i2.x, i2.y - 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e2.overscaledZ, s2, i2.z, n2, i2.y - 1).key] = { backfilled: false }), i2.y + 1 < o2 && (l2[new t.OverscaledTileID(e2.overscaledZ, a2, i2.z, r3, i2.y + 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e2.overscaledZ, e2.wrap, i2.z, i2.x, i2.y + 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e2.overscaledZ, s2, i2.z, n2, i2.y + 1).key] = { backfilled: false }), l2;
            }
            unloadTile(t2) {
              t2.demTexture && this.map.painter.saveTileTexture(t2.demTexture), t2.fbo && (t2.fbo.destroy(), delete t2.fbo), t2.dem && delete t2.dem, delete t2.neighboringTiles, t2.state = "unloaded";
            }
          }, geojson: class extends t.Evented {
            constructor(e2, i2, o2, r3) {
              super(), this.id = e2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._loaded = false, this.actor = o2.getActor(), this.setEventedParent(r3), this._data = i2.data, this._options = t.extend({}, i2), this._collectResourceTiming = i2.collectResourceTiming, i2.maxzoom !== void 0 && (this.maxzoom = i2.maxzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId;
              const a2 = t.EXTENT / this.tileSize;
              this.workerOptions = t.extend({ source: this.id, cluster: i2.cluster || false, geojsonVtOptions: { buffer: (i2.buffer !== void 0 ? i2.buffer : 128) * a2, tolerance: (i2.tolerance !== void 0 ? i2.tolerance : 0.375) * a2, extent: t.EXTENT, maxZoom: this.maxzoom, lineMetrics: i2.lineMetrics || false, generateId: i2.generateId || false }, superclusterOptions: { maxZoom: i2.clusterMaxZoom !== void 0 ? i2.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i2.clusterMinPoints || 2), extent: t.EXTENT, radius: (i2.clusterRadius !== void 0 ? i2.clusterRadius : 50) * a2, log: false, generateId: i2.generateId || false }, clusterProperties: i2.clusterProperties, filter: i2.filter }, i2.workerOptions);
            }
            onAdd(t2) {
              this.map = t2, this.setData(this._data);
            }
            setData(t2) {
              return this._data = t2, this._updateWorkerData(), this;
            }
            getClusterExpansionZoom(t2, e2) {
              return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: t2, source: this.id }, e2), this;
            }
            getClusterChildren(t2, e2) {
              return this.actor.send("geojson.getClusterChildren", { clusterId: t2, source: this.id }, e2), this;
            }
            getClusterLeaves(t2, e2, i2, o2) {
              return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: t2, limit: e2, offset: i2 }, o2), this;
            }
            _updateWorkerData() {
              if (this._pendingLoad)
                return void (this._coalesce = true);
              this.fire(new t.Event("dataloading", { dataType: "source" })), this._loaded = false;
              const e2 = t.extend({}, this.workerOptions), i2 = this._data;
              typeof i2 == "string" ? (e2.request = this.map._requestManager.transformRequest(t.exported.resolveURL(i2), t.ResourceType.Source), e2.request.collectResourceTiming = this._collectResourceTiming) : e2.data = JSON.stringify(i2), this._pendingLoad = this.actor.send(`${this.type}.loadData`, e2, (e3, i3) => {
                if (this._loaded = true, this._pendingLoad = null, e3)
                  this.fire(new t.ErrorEvent(e3));
                else {
                  const e4 = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
                  this._collectResourceTiming && i3 && i3.resourceTiming && i3.resourceTiming[this.id] && (e4.resourceTiming = i3.resourceTiming[this.id]), this.fire(new t.Event("data", e4)), this._metadataFired = true;
                }
                this._coalesce && (this._updateWorkerData(), this._coalesce = false);
              });
            }
            loaded() {
              return this._loaded;
            }
            loadTile(e2, i2) {
              const o2 = e2.actor ? "reloadTile" : "loadTile";
              e2.actor = this.actor, e2.request = this.actor.send(o2, { type: this.type, uid: e2.uid, tileID: e2.tileID, tileZoom: e2.tileZoom, zoom: e2.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: t.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }, (t2, r3) => (delete e2.request, e2.unloadVectorData(), e2.aborted ? i2(null) : t2 ? i2(t2) : (e2.loadVectorData(r3, this.map.painter, o2 === "reloadTile"), i2(null))), void 0, o2 === "loadTile");
            }
            abortTile(t2) {
              t2.request && (t2.request.cancel(), delete t2.request), t2.aborted = true;
            }
            unloadTile(t2) {
              t2.unloadVectorData(), this.actor.send("removeTile", { uid: t2.uid, type: this.type, source: this.id });
            }
            onRemove() {
              this._pendingLoad && this._pendingLoad.cancel();
            }
            serialize() {
              return t.extend({}, this._options, { type: this.type, data: this._data });
            }
            hasTransition() {
              return false;
            }
          }, video: class extends Et2 {
            constructor(t2, e2, i2, o2) {
              super(t2, e2, i2, o2), this.roundZoom = true, this.type = "video", this.options = e2;
            }
            load() {
              this._loaded = false;
              const e2 = this.options;
              this.urls = [];
              for (const i2 of e2.urls)
                this.urls.push(this.map._requestManager.transformRequest(i2, t.ResourceType.Source).url);
              t.getVideo(this.urls, (e3, i2) => {
                this._loaded = true, e3 ? this.fire(new t.ErrorEvent(e3)) : i2 && (this.video = i2, this.video.loop = true, this.video.addEventListener("playing", () => {
                  this.map.triggerRepaint();
                }), this.map && this.video.play(), this._finishLoading());
              });
            }
            pause() {
              this.video && this.video.pause();
            }
            play() {
              this.video && this.video.play();
            }
            seek(e2) {
              if (this.video) {
                const i2 = this.video.seekable;
                e2 < i2.start(0) || e2 > i2.end(0) ? this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i2.start(0)} and ${i2.end(0)}-second mark.`))) : this.video.currentTime = e2;
              }
            }
            getVideo() {
              return this.video;
            }
            onAdd(t2) {
              this.map || (this.map = t2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
            }
            prepare() {
              if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2)
                return;
              const e2 = this.map.painter.context, i2 = e2.gl;
              this.boundsBuffer || (this.boundsBuffer = e2.createVertexBuffer(this._boundsArray, Tt2.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new t.Texture(e2, this.video, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
              for (const t2 in this.tiles) {
                const e3 = this.tiles[t2];
                e3.state !== "loaded" && (e3.state = "loaded", e3.texture = this.texture);
              }
            }
            serialize() {
              return { type: "video", urls: this.urls, coordinates: this.coordinates };
            }
            hasTransition() {
              return this.video && !this.video.paused;
            }
          }, image: Et2, canvas: class extends Et2 {
            constructor(e2, i2, o2, r3) {
              super(e2, i2, o2, r3), i2.coordinates ? Array.isArray(i2.coordinates) && i2.coordinates.length === 4 && !i2.coordinates.some((t2) => !Array.isArray(t2) || t2.length !== 2 || t2.some((t3) => typeof t3 != "number")) || this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e2}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e2}`, null, 'missing required property "coordinates"'))), i2.animate && typeof i2.animate != "boolean" && this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e2}`, null, 'optional "animate" property must be a boolean value'))), i2.canvas ? typeof i2.canvas == "string" || i2.canvas instanceof t.window.HTMLCanvasElement || this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e2}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e2}`, null, 'missing required property "canvas"'))), this.options = i2, this.animate = i2.animate === void 0 || i2.animate;
            }
            load() {
              this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof t.window.HTMLCanvasElement ? this.options.canvas : t.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = true, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = false);
              }, this._finishLoading());
            }
            getCanvas() {
              return this.canvas;
            }
            onAdd(t2) {
              this.map = t2, this.load(), this.canvas && this.animate && this.play();
            }
            onRemove() {
              this.pause();
            }
            prepare() {
              let e2 = false;
              if (this.canvas.width !== this.width && (this.width = this.canvas.width, e2 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e2 = true), this._hasInvalidDimensions())
                return;
              if (Object.keys(this.tiles).length === 0)
                return;
              const i2 = this.map.painter.context, o2 = i2.gl;
              this.boundsBuffer || (this.boundsBuffer = i2.createVertexBuffer(this._boundsArray, Tt2.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (e2 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new t.Texture(i2, this.canvas, o2.RGBA, { premultiply: true });
              for (const t2 in this.tiles) {
                const e3 = this.tiles[t2];
                e3.state !== "loaded" && (e3.state = "loaded", e3.texture = this.texture);
              }
            }
            serialize() {
              return { type: "canvas", coordinates: this.coordinates };
            }
            hasTransition() {
              return this._playing;
            }
            _hasInvalidDimensions() {
              for (const t2 of [this.canvas.width, this.canvas.height])
                if (isNaN(t2) || t2 <= 0)
                  return true;
              return false;
            }
          } }, St2 = function(e2, i2, o2, r3) {
            const a2 = new Ct[i2.type](e2, i2, o2, r3);
            if (a2.id !== e2)
              throw new Error(`Expected Source id to be ${e2} instead of ${a2.id}`);
            return t.bindAll(["load", "abort", "unload", "serialize", "prepare"], a2), a2;
          };
          function It2(e2, i2) {
            const o2 = t.identity([]);
            return t.scale$1(o2, o2, [0.5 * e2.width, 0.5 * -e2.height, 1]), t.translate(o2, o2, [1, -1, 0]), t.multiply(o2, o2, e2.calculateProjMatrix(i2.toUnwrapped()));
          }
          function Mt2(t2, e2, i2, o2, r3, a2, n2, s2 = false) {
            const l2 = t2.tilesIn(o2, n2, s2);
            l2.sort(Dt2);
            const c2 = [];
            for (const o3 of l2)
              c2.push({ wrappedTileID: o3.tile.tileID.wrapped().key, queryResults: o3.tile.queryRenderedFeatures(e2, i2, t2._state, o3, r3, a2, It2(t2.transform, o3.tile.tileID), s2) });
            const h2 = function(t3) {
              const e3 = {}, i3 = {};
              for (const o3 of t3) {
                const t4 = o3.queryResults, r4 = o3.wrappedTileID, a3 = i3[r4] = i3[r4] || {};
                for (const i4 in t4) {
                  const o4 = t4[i4], r5 = a3[i4] = a3[i4] || {}, n3 = e3[i4] = e3[i4] || [];
                  for (const t5 of o4)
                    r5[t5.featureIndex] || (r5[t5.featureIndex] = true, n3.push(t5));
                }
              }
              return e3;
            }(c2);
            for (const e3 in h2)
              h2[e3].forEach((e4) => {
                const i3 = e4.feature, o3 = t2.getFeatureState(i3.layer["source-layer"], i3.id);
                i3.source = i3.layer.source, i3.layer["source-layer"] && (i3.sourceLayer = i3.layer["source-layer"]), i3.state = o3;
              });
            return h2;
          }
          function zt2(t2, e2) {
            const i2 = t2.getRenderableIds().map((e3) => t2.getTileByID(e3)), o2 = [], r3 = {};
            for (let t3 = 0; t3 < i2.length; t3++) {
              const a2 = i2[t3], n2 = a2.tileID.canonical.key;
              r3[n2] || (r3[n2] = true, a2.querySourceFeatures(o2, e2));
            }
            return o2;
          }
          function Dt2(t2, e2) {
            const i2 = t2.tileID, o2 = e2.tileID;
            return i2.overscaledZ - o2.overscaledZ || i2.canonical.y - o2.canonical.y || i2.wrap - o2.wrap || i2.canonical.x - o2.canonical.x;
          }
          function At2() {
            return $r2.workerClass != null ? new $r2.workerClass() : new t.window.Worker($r2.workerUrl);
          }
          const Pt2 = "mapboxgl_preloaded_worker_pool";
          class Lt {
            constructor() {
              this.active = {};
            }
            acquire(t2) {
              if (!this.workers)
                for (this.workers = []; this.workers.length < Lt.workerCount; )
                  this.workers.push(new At2());
              return this.active[t2] = true, this.workers.slice();
            }
            release(t2) {
              delete this.active[t2], this.numActive() === 0 && (this.workers.forEach((t3) => {
                t3.terminate();
              }), this.workers = null);
            }
            isPreloaded() {
              return !!this.active[Pt2];
            }
            numActive() {
              return Object.keys(this.active).length;
            }
          }
          let Rt;
          function kt2() {
            return Rt || (Rt = new Lt()), Rt;
          }
          function Ft2(e2, i2) {
            const o2 = {};
            for (const t2 in e2)
              t2 !== "ref" && (o2[t2] = e2[t2]);
            return t.refProperties.forEach((t2) => {
              t2 in i2 && (o2[t2] = i2[t2]);
            }), o2;
          }
          function Bt2(t2) {
            t2 = t2.slice();
            const e2 = Object.create(null);
            for (let i2 = 0; i2 < t2.length; i2++)
              e2[t2[i2].id] = t2[i2];
            for (let i2 = 0; i2 < t2.length; i2++)
              "ref" in t2[i2] && (t2[i2] = Ft2(t2[i2], e2[t2[i2].ref]));
            return t2;
          }
          Lt.workerCount = 2;
          const Ot2 = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog" };
          function Ut2(t2, e2, i2) {
            i2.push({ command: Ot2.addSource, args: [t2, e2[t2]] });
          }
          function Nt2(t2, e2, i2) {
            e2.push({ command: Ot2.removeSource, args: [t2] }), i2[t2] = true;
          }
          function Gt2(t2, e2, i2, o2) {
            Nt2(t2, i2, o2), Ut2(t2, e2, i2);
          }
          function Zt2(t2, e2, i2) {
            let o2;
            for (o2 in t2[i2])
              if (t2[i2].hasOwnProperty(o2) && o2 !== "data" && !r2(t2[i2][o2], e2[i2][o2]))
                return false;
            for (o2 in e2[i2])
              if (e2[i2].hasOwnProperty(o2) && o2 !== "data" && !r2(t2[i2][o2], e2[i2][o2]))
                return false;
            return true;
          }
          function Vt2(t2, e2, i2, o2, a2, n2) {
            let s2;
            for (s2 in e2 = e2 || {}, t2 = t2 || {})
              t2.hasOwnProperty(s2) && (r2(t2[s2], e2[s2]) || i2.push({ command: n2, args: [o2, s2, e2[s2], a2] }));
            for (s2 in e2)
              e2.hasOwnProperty(s2) && !t2.hasOwnProperty(s2) && (r2(t2[s2], e2[s2]) || i2.push({ command: n2, args: [o2, s2, e2[s2], a2] }));
          }
          function jt(t2) {
            return t2.id;
          }
          function qt2(t2, e2) {
            return t2[e2.id] = e2, t2;
          }
          class Wt {
            constructor(t2, e2) {
              this.reset(t2, e2);
            }
            reset(t2, e2) {
              this.points = t2 || [], this._distances = [0];
              for (let t3 = 1; t3 < this.points.length; t3++)
                this._distances[t3] = this._distances[t3 - 1] + this.points[t3].dist(this.points[t3 - 1]);
              this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
            }
            lerp(e2) {
              if (this.points.length === 1)
                return this.points[0];
              e2 = t.clamp(e2, 0, 1);
              let i2 = 1, o2 = this._distances[i2];
              const r3 = e2 * this.paddedLength + this.padding;
              for (; o2 < r3 && i2 < this._distances.length; )
                o2 = this._distances[++i2];
              const a2 = i2 - 1, n2 = this._distances[a2], s2 = o2 - n2, l2 = s2 > 0 ? (r3 - n2) / s2 : 0;
              return this.points[a2].mult(1 - l2).add(this.points[i2].mult(l2));
            }
          }
          class $t2 {
            constructor(t2, e2, i2) {
              const o2 = this.boxCells = [], r3 = this.circleCells = [];
              this.xCellCount = Math.ceil(t2 / i2), this.yCellCount = Math.ceil(e2 / i2);
              for (let t3 = 0; t3 < this.xCellCount * this.yCellCount; t3++)
                o2.push([]), r3.push([]);
              this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t2, this.height = e2, this.xScale = this.xCellCount / t2, this.yScale = this.yCellCount / e2, this.boxUid = 0, this.circleUid = 0;
            }
            keysLength() {
              return this.boxKeys.length + this.circleKeys.length;
            }
            insert(t2, e2, i2, o2, r3) {
              this._forEachCell(e2, i2, o2, r3, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t2), this.bboxes.push(e2), this.bboxes.push(i2), this.bboxes.push(o2), this.bboxes.push(r3);
            }
            insertCircle(t2, e2, i2, o2) {
              this._forEachCell(e2 - o2, i2 - o2, e2 + o2, i2 + o2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t2), this.circles.push(e2), this.circles.push(i2), this.circles.push(o2);
            }
            _insertBoxCell(t2, e2, i2, o2, r3, a2) {
              this.boxCells[r3].push(a2);
            }
            _insertCircleCell(t2, e2, i2, o2, r3, a2) {
              this.circleCells[r3].push(a2);
            }
            _query(t2, e2, i2, o2, r3, a2) {
              if (i2 < 0 || t2 > this.width || o2 < 0 || e2 > this.height)
                return !r3 && [];
              const n2 = [];
              if (t2 <= 0 && e2 <= 0 && this.width <= i2 && this.height <= o2) {
                if (r3)
                  return true;
                for (let t3 = 0; t3 < this.boxKeys.length; t3++)
                  n2.push({ key: this.boxKeys[t3], x1: this.bboxes[4 * t3], y1: this.bboxes[4 * t3 + 1], x2: this.bboxes[4 * t3 + 2], y2: this.bboxes[4 * t3 + 3] });
                for (let t3 = 0; t3 < this.circleKeys.length; t3++) {
                  const e3 = this.circles[3 * t3], i3 = this.circles[3 * t3 + 1], o3 = this.circles[3 * t3 + 2];
                  n2.push({ key: this.circleKeys[t3], x1: e3 - o3, y1: i3 - o3, x2: e3 + o3, y2: i3 + o3 });
                }
                return a2 ? n2.filter(a2) : n2;
              }
              return this._forEachCell(t2, e2, i2, o2, this._queryCell, n2, { hitTest: r3, seenUids: { box: {}, circle: {} } }, a2), r3 ? n2.length > 0 : n2;
            }
            _queryCircle(t2, e2, i2, o2, r3) {
              const a2 = t2 - i2, n2 = t2 + i2, s2 = e2 - i2, l2 = e2 + i2;
              if (n2 < 0 || a2 > this.width || l2 < 0 || s2 > this.height)
                return !o2 && [];
              const c2 = [];
              return this._forEachCell(a2, s2, n2, l2, this._queryCellCircle, c2, { hitTest: o2, circle: { x: t2, y: e2, radius: i2 }, seenUids: { box: {}, circle: {} } }, r3), o2 ? c2.length > 0 : c2;
            }
            query(t2, e2, i2, o2, r3) {
              return this._query(t2, e2, i2, o2, false, r3);
            }
            hitTest(t2, e2, i2, o2, r3) {
              return this._query(t2, e2, i2, o2, true, r3);
            }
            hitTestCircle(t2, e2, i2, o2) {
              return this._queryCircle(t2, e2, i2, true, o2);
            }
            _queryCell(t2, e2, i2, o2, r3, a2, n2, s2) {
              const l2 = n2.seenUids, c2 = this.boxCells[r3];
              if (c2 !== null) {
                const r4 = this.bboxes;
                for (const h3 of c2)
                  if (!l2.box[h3]) {
                    l2.box[h3] = true;
                    const c3 = 4 * h3;
                    if (t2 <= r4[c3 + 2] && e2 <= r4[c3 + 3] && i2 >= r4[c3 + 0] && o2 >= r4[c3 + 1] && (!s2 || s2(this.boxKeys[h3]))) {
                      if (n2.hitTest)
                        return a2.push(true), true;
                      a2.push({ key: this.boxKeys[h3], x1: r4[c3], y1: r4[c3 + 1], x2: r4[c3 + 2], y2: r4[c3 + 3] });
                    }
                  }
              }
              const h2 = this.circleCells[r3];
              if (h2 !== null) {
                const r4 = this.circles;
                for (const c3 of h2)
                  if (!l2.circle[c3]) {
                    l2.circle[c3] = true;
                    const h3 = 3 * c3;
                    if (this._circleAndRectCollide(r4[h3], r4[h3 + 1], r4[h3 + 2], t2, e2, i2, o2) && (!s2 || s2(this.circleKeys[c3]))) {
                      if (n2.hitTest)
                        return a2.push(true), true;
                      {
                        const t3 = r4[h3], e3 = r4[h3 + 1], i3 = r4[h3 + 2];
                        a2.push({ key: this.circleKeys[c3], x1: t3 - i3, y1: e3 - i3, x2: t3 + i3, y2: e3 + i3 });
                      }
                    }
                  }
              }
            }
            _queryCellCircle(t2, e2, i2, o2, r3, a2, n2, s2) {
              const l2 = n2.circle, c2 = n2.seenUids, h2 = this.boxCells[r3];
              if (h2 !== null) {
                const t3 = this.bboxes;
                for (const e3 of h2)
                  if (!c2.box[e3]) {
                    c2.box[e3] = true;
                    const i3 = 4 * e3;
                    if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, t3[i3 + 0], t3[i3 + 1], t3[i3 + 2], t3[i3 + 3]) && (!s2 || s2(this.boxKeys[e3])))
                      return a2.push(true), true;
                  }
              }
              const d2 = this.circleCells[r3];
              if (d2 !== null) {
                const t3 = this.circles;
                for (const e3 of d2)
                  if (!c2.circle[e3]) {
                    c2.circle[e3] = true;
                    const i3 = 3 * e3;
                    if (this._circlesCollide(t3[i3], t3[i3 + 1], t3[i3 + 2], l2.x, l2.y, l2.radius) && (!s2 || s2(this.circleKeys[e3])))
                      return a2.push(true), true;
                  }
              }
            }
            _forEachCell(t2, e2, i2, o2, r3, a2, n2, s2) {
              const l2 = this._convertToXCellCoord(t2), c2 = this._convertToYCellCoord(e2), h2 = this._convertToXCellCoord(i2), d2 = this._convertToYCellCoord(o2);
              for (let u2 = l2; u2 <= h2; u2++)
                for (let l3 = c2; l3 <= d2; l3++)
                  if (r3.call(this, t2, e2, i2, o2, this.xCellCount * l3 + u2, a2, n2, s2))
                    return;
            }
            _convertToXCellCoord(t2) {
              return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t2 * this.xScale)));
            }
            _convertToYCellCoord(t2) {
              return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t2 * this.yScale)));
            }
            _circlesCollide(t2, e2, i2, o2, r3, a2) {
              const n2 = o2 - t2, s2 = r3 - e2, l2 = i2 + a2;
              return l2 * l2 > n2 * n2 + s2 * s2;
            }
            _circleAndRectCollide(t2, e2, i2, o2, r3, a2, n2) {
              const s2 = (a2 - o2) / 2, l2 = Math.abs(t2 - (o2 + s2));
              if (l2 > s2 + i2)
                return false;
              const c2 = (n2 - r3) / 2, h2 = Math.abs(e2 - (r3 + c2));
              if (h2 > c2 + i2)
                return false;
              if (l2 <= s2 || h2 <= c2)
                return true;
              const d2 = l2 - s2, u2 = h2 - c2;
              return d2 * d2 + u2 * u2 <= i2 * i2;
            }
          }
          const Xt = Math.tan(85 * Math.PI / 180);
          function Ht(e2, i2, o2, r3, a2) {
            const n2 = t.create$1();
            return i2 ? (t.scale$1(n2, n2, [1 / a2, 1 / a2, 1]), o2 || t.rotateZ(n2, n2, r3.angle)) : t.multiply(n2, r3.labelPlaneMatrix, e2), n2;
          }
          function Kt2(e2, i2, o2, r3, a2) {
            if (i2) {
              const i3 = t.clone$1(e2);
              return t.scale$1(i3, i3, [a2, a2, 1]), o2 || t.rotateZ(i3, i3, -r3.angle), i3;
            }
            return r3.glCoordMatrix;
          }
          function Yt(e2, i2, o2 = 0) {
            const r3 = [e2.x, e2.y, o2, 1];
            o2 ? t.transformMat4(r3, r3, i2) : le2(r3, r3, i2);
            const a2 = r3[3];
            return { point: new t.pointGeometry(r3[0] / a2, r3[1] / a2), signedDistanceFromCamera: a2 };
          }
          function Qt2(t2, e2) {
            return Math.min(0.5 + t2 / e2 * 0.5, 1.5);
          }
          function Jt2(t2, e2) {
            const i2 = t2[0] / t2[3], o2 = t2[1] / t2[3];
            return i2 >= -e2[0] && i2 <= e2[0] && o2 >= -e2[1] && o2 <= e2[1];
          }
          function te2(e2, i2, o2, r3, a2, n2, s2, l2, c2) {
            const h2 = r3 ? e2.textSizeData : e2.iconSizeData, d2 = t.evaluateSizeForZoom(h2, o2.transform.zoom), u2 = [256 / o2.width * 2 + 1, 256 / o2.height * 2 + 1], _2 = r3 ? e2.text.dynamicLayoutVertexArray : e2.icon.dynamicLayoutVertexArray;
            _2.clear();
            const p2 = e2.lineVertexArray, m2 = r3 ? e2.text.placedSymbolArray : e2.icon.placedSymbolArray, f2 = o2.transform.width / o2.transform.height;
            let g2 = false;
            for (let r4 = 0; r4 < m2.length; r4++) {
              const v2 = m2.get(r4);
              if (v2.writingMode !== t.WritingMode.vertical || g2 || r4 !== 0 && m2.get(r4 - 1).writingMode === t.WritingMode.horizontal || (g2 = true), v2.hidden || v2.writingMode === t.WritingMode.vertical && !g2) {
                se2(v2.numGlyphs, _2);
                continue;
              }
              g2 = false;
              const x3 = c2 ? c2({ x: v2.anchorX, y: v2.anchorY }) : 0, y2 = [v2.anchorX, v2.anchorY, x3, 1];
              if (t.transformMat4(y2, y2, i2), !Jt2(y2, u2)) {
                se2(v2.numGlyphs, _2);
                continue;
              }
              const b2 = Qt2(o2.transform.cameraToCenterDistance, y2[3]), w3 = t.evaluateSizeForFeature(h2, d2, v2), T2 = s2 ? w3 / b2 : w3 * b2, E2 = new t.pointGeometry(v2.anchorX, v2.anchorY), C2 = Yt(E2, a2, x3);
              if (C2.signedDistanceFromCamera <= 0) {
                se2(v2.numGlyphs, _2);
                continue;
              }
              const S2 = C2.point;
              let I3 = {};
              const M3 = s2 ? null : c2, z2 = oe2(v2, T2, false, l2, i2, a2, n2, e2.glyphOffsetArray, p2, _2, S2, E2, I3, f2, M3);
              g2 = z2.useVertical, M3 && z2.needsFlipping && (I3 = {}), (z2.notEnoughRoom || g2 || z2.needsFlipping && oe2(v2, T2, true, l2, i2, a2, n2, e2.glyphOffsetArray, p2, _2, S2, E2, I3, f2, M3).notEnoughRoom) && se2(v2.numGlyphs, _2);
            }
            r3 ? e2.text.dynamicLayoutVertexBuffer.updateData(_2) : e2.icon.dynamicLayoutVertexBuffer.updateData(_2);
          }
          function ee2(t2, e2, i2, o2, r3, a2, n2, s2, l2, c2, h2, d2, u2) {
            const _2 = s2.glyphStartIndex + s2.numGlyphs, p2 = s2.lineStartIndex, m2 = s2.lineStartIndex + s2.lineLength, f2 = e2.getoffsetX(s2.glyphStartIndex), g2 = e2.getoffsetX(_2 - 1), v2 = ae2(t2 * f2, i2, o2, r3, a2, n2, s2.segment, p2, m2, l2, c2, h2, d2, u2, true);
            if (!v2)
              return null;
            const x3 = ae2(t2 * g2, i2, o2, r3, a2, n2, s2.segment, p2, m2, l2, c2, h2, d2, u2, true);
            return x3 ? { first: v2, last: x3 } : null;
          }
          function ie(e2, i2, o2, r3) {
            return e2.writingMode === t.WritingMode.horizontal && Math.abs(o2.y - i2.y) > Math.abs(o2.x - i2.x) * r3 ? { useVertical: true } : e2.writingMode === t.WritingMode.vertical ? i2.y < o2.y ? { needsFlipping: true } : null : e2.flipState !== 0 && function(t2, e3, i3) {
              const o3 = (e3.x - t2.x) * i3;
              return o3 === 0 || Math.abs((e3.y - t2.y) / o3) > Xt;
            }(i2, o2, r3) ? e2.flipState === 1 ? { needsFlipping: true } : null : i2.x > o2.x ? { needsFlipping: true } : null;
          }
          function oe2(e2, i2, o2, r3, a2, n2, s2, l2, c2, h2, d2, u2, _2, p2, m2) {
            const f2 = i2 / 24, g2 = e2.lineOffsetX * f2, v2 = e2.lineOffsetY * f2;
            let x3;
            if (e2.numGlyphs > 1) {
              const t2 = e2.glyphStartIndex + e2.numGlyphs, i3 = e2.lineStartIndex, a3 = e2.lineStartIndex + e2.lineLength, h3 = ee2(f2, l2, g2, v2, o2, d2, u2, e2, c2, n2, _2, m2);
              if (!h3)
                return { notEnoughRoom: true };
              const y2 = Yt(h3.first.point, s2).point, b2 = Yt(h3.last.point, s2).point;
              if (r3 && !o2) {
                const t3 = ie(e2, y2, b2, p2);
                if (e2.flipState = t3 && t3.needsFlipping ? 1 : 2, t3)
                  return t3;
              }
              x3 = [h3.first];
              for (let r4 = e2.glyphStartIndex + 1; r4 < t2 - 1; r4++)
                x3.push(ae2(f2 * l2.getoffsetX(r4), g2, v2, o2, d2, u2, e2.segment, i3, a3, c2, n2, _2, m2));
              x3.push(h3.last);
            } else {
              if (r3 && !o2) {
                const i4 = Yt(u2, a2).point, o3 = e2.lineStartIndex + e2.segment + 1, r4 = new t.pointGeometry(c2.getx(o3), c2.gety(o3)), n3 = Yt(r4, a2), s3 = ie(e2, i4, n3.signedDistanceFromCamera > 0 ? n3.point : re2(u2, r4, i4, 1, a2), p2);
                if (e2.flipState = s3 && s3.needsFlipping ? 1 : 2, s3)
                  return s3;
              }
              const i3 = ae2(f2 * l2.getoffsetX(e2.glyphStartIndex), g2, v2, o2, d2, u2, e2.segment, e2.lineStartIndex, e2.lineStartIndex + e2.lineLength, c2, n2, _2, m2);
              if (!i3)
                return { notEnoughRoom: true };
              x3 = [i3];
            }
            for (const e3 of x3)
              t.addDynamicAttributes(h2, e3.point, e3.angle);
            return {};
          }
          function re2(t2, e2, i2, o2, r3, a2) {
            const n2 = t2.add(t2.sub(e2)._unit()), s2 = Yt(n2, r3, a2 ? a2(n2) : 0).point, l2 = i2.sub(s2);
            return i2.add(l2._mult(o2 / l2.mag()));
          }
          function ae2(e2, i2, o2, r3, a2, n2, s2, l2, c2, h2, d2, u2, _2, p2, m2) {
            const f2 = r3 ? e2 - i2 : e2 + i2;
            let g2 = f2 > 0 ? 1 : -1, v2 = 0;
            r3 && (g2 *= -1, v2 = Math.PI), g2 < 0 && (v2 += Math.PI);
            let x3 = g2 > 0 ? l2 + s2 : l2 + s2 + 1, y2 = a2, b2 = a2, w3 = 0, T2 = 0;
            const E2 = Math.abs(f2), C2 = [], S2 = [];
            let I3 = n2;
            const M3 = () => {
              const e3 = x3 - g2;
              return w3 === 0 ? n2 : new t.pointGeometry(h2.getx(e3), h2.gety(e3));
            }, z2 = () => re2(M3(), I3, b2, E2 - w3 + 1, d2, _2);
            for (; w3 + T2 <= E2; ) {
              if (x3 += g2, x3 < l2 || x3 >= c2)
                return null;
              if (b2 = y2, C2.push(y2), p2 && S2.push(I3 || M3()), y2 = u2[x3], y2 === void 0) {
                I3 = new t.pointGeometry(h2.getx(x3), h2.gety(x3));
                const e3 = Yt(I3, d2, _2 ? _2(I3) : 0);
                y2 = e3.signedDistanceFromCamera > 0 ? u2[x3] = e3.point : z2();
              } else
                I3 = null;
              w3 += T2, T2 = b2.dist(y2);
            }
            m2 && _2 && (I3 = I3 || new t.pointGeometry(h2.getx(x3), h2.gety(x3)), u2[x3] = y2 = u2[x3] === void 0 ? y2 : z2(), T2 = b2.dist(y2));
            const D2 = (E2 - w3) / T2, A2 = y2.sub(b2), P2 = A2.mult(D2)._add(b2);
            o2 && P2._add(A2._unit()._perp()._mult(o2 * g2));
            const L3 = v2 + Math.atan2(y2.y - b2.y, y2.x - b2.x);
            return C2.push(P2), p2 && (I3 = I3 || new t.pointGeometry(h2.getx(x3), h2.gety(x3)), S2.push(function(e3, i3, o3) {
              const r4 = 1 - o3;
              return new t.pointGeometry(e3.x * r4 + i3.x * o3, e3.y * r4 + i3.y * o3);
            }(S2.length > 0 ? S2[S2.length - 1] : I3, I3, D2))), { point: P2, angle: L3, path: C2, tilePath: S2 };
          }
          const ne2 = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
          function se2(t2, e2) {
            for (let i2 = 0; i2 < t2; i2++) {
              const t3 = e2.length;
              e2.resize(t3 + 4), e2.float32.set(ne2, 3 * t3);
            }
          }
          function le2(t2, e2, i2) {
            const o2 = e2[0], r3 = e2[1];
            return t2[0] = i2[0] * o2 + i2[4] * r3 + i2[12], t2[1] = i2[1] * o2 + i2[5] * r3 + i2[13], t2[3] = i2[3] * o2 + i2[7] * r3 + i2[15], t2;
          }
          const ce2 = 100;
          class he2 {
            constructor(t2, e2, i2 = new $t2(t2.width + 200, t2.height + 200, 25), o2 = new $t2(t2.width + 200, t2.height + 200, 25)) {
              this.transform = t2, this.grid = i2, this.ignoredGrid = o2, this.pitchfactor = Math.cos(t2._pitch) * t2.cameraToCenterDistance, this.screenRightBoundary = t2.width + ce2, this.screenBottomBoundary = t2.height + ce2, this.gridRightBoundary = t2.width + 200, this.gridBottomBoundary = t2.height + 200, this.fogState = e2;
            }
            placeCollisionBox(t2, e2, i2, o2, r3, a2, n2) {
              const s2 = this.projectAndGetPerspectiveRatio(a2, e2.anchorPointX, e2.anchorPointY, e2.elevation, e2.tileID), l2 = r3 * s2.perspectiveRatio, c2 = (e2.x1 * t2 + i2.x - e2.padding) * l2 + s2.point.x, h2 = (e2.y1 * t2 + i2.y - e2.padding) * l2 + s2.point.y, d2 = (e2.x2 * t2 + i2.x + e2.padding) * l2 + s2.point.x, u2 = (e2.y2 * t2 + i2.y + e2.padding) * l2 + s2.point.y, _2 = s2.perspectiveRatio <= 0.55 || s2.aboveHorizon;
              return !this.isInsideGrid(c2, h2, d2, u2) || !o2 && this.grid.hitTest(c2, h2, d2, u2, n2) || _2 ? { box: [], offscreen: false } : { box: [c2, h2, d2, u2], offscreen: this.isOffscreen(c2, h2, d2, u2) };
            }
            placeCollisionCircles(e2, i2, o2, r3, a2, n2, s2, l2, c2, h2, d2, u2, _2, p2) {
              const m2 = [], f2 = this.transform.elevation, g2 = f2 ? (t2) => f2.getAtTileOffset(p2, t2.x, t2.y) : (t2) => 0, v2 = new t.pointGeometry(i2.anchorX, i2.anchorY), x3 = g2(v2), y2 = this.projectAndGetPerspectiveRatio(n2, v2.x, v2.y, x3, p2), { perspectiveRatio: b2 } = y2, w3 = (h2 ? a2 / b2 : a2 * b2) / t.ONE_EM, T2 = Yt(v2, s2, x3).point, E2 = y2.signedDistanceFromCamera > 0 ? ee2(w3, r3, i2.lineOffsetX * w3, i2.lineOffsetY * w3, false, T2, v2, i2, o2, s2, {}, f2 && !h2 ? g2 : null, h2 && !!f2) : null;
              let C2 = false, S2 = false, I3 = true;
              if (E2 && !y2.aboveHorizon) {
                const i3 = 0.5 * u2 * b2 + _2, o3 = new t.pointGeometry(-100, -100), r4 = new t.pointGeometry(this.screenRightBoundary, this.screenBottomBoundary), a3 = new Wt(), n3 = E2.first, s3 = E2.last;
                let h3 = [];
                for (let t2 = n3.path.length - 1; t2 >= 1; t2--)
                  h3.push(n3.path[t2]);
                for (let t2 = 1; t2 < s3.path.length; t2++)
                  h3.push(s3.path[t2]);
                const p3 = 2.5 * i3;
                if (l2) {
                  const t2 = h3.map(f2 ? (t3, e3) => {
                    const i4 = g2(e3 < n3.path.length - 1 ? n3.tilePath[n3.path.length - 1 - e3] : s3.tilePath[e3 - n3.path.length + 2]);
                    return Yt(t3, l2, i4);
                  } : (t3) => Yt(t3, l2));
                  h3 = t2.some((t3) => t3.signedDistanceFromCamera <= 0) ? [] : t2.map((t3) => t3.point);
                }
                let v3 = [];
                if (h3.length > 0) {
                  const e3 = h3[0].clone(), i4 = h3[0].clone();
                  for (let t2 = 1; t2 < h3.length; t2++)
                    e3.x = Math.min(e3.x, h3[t2].x), e3.y = Math.min(e3.y, h3[t2].y), i4.x = Math.max(i4.x, h3[t2].x), i4.y = Math.max(i4.y, h3[t2].y);
                  v3 = e3.x >= o3.x && i4.x <= r4.x && e3.y >= o3.y && i4.y <= r4.y ? [h3] : i4.x < o3.x || e3.x > r4.x || i4.y < o3.y || e3.y > r4.y ? [] : t.clipLine([h3], o3.x, o3.y, r4.x, r4.y);
                }
                for (const t2 of v3) {
                  a3.reset(t2, 0.25 * i3);
                  let o4 = 0;
                  o4 = a3.length <= 0.5 * i3 ? 1 : Math.ceil(a3.paddedLength / p3) + 1;
                  for (let t3 = 0; t3 < o4; t3++) {
                    const r5 = t3 / Math.max(o4 - 1, 1), n4 = a3.lerp(r5), s4 = n4.x + ce2, l3 = n4.y + ce2;
                    m2.push(s4, l3, i3, 0);
                    const h4 = s4 - i3, u3 = l3 - i3, _3 = s4 + i3, p4 = l3 + i3;
                    if (I3 = I3 && this.isOffscreen(h4, u3, _3, p4), S2 = S2 || this.isInsideGrid(h4, u3, _3, p4), !e2 && this.grid.hitTestCircle(s4, l3, i3, d2) && (C2 = true, !c2))
                      return { circles: [], offscreen: false, collisionDetected: C2 };
                  }
                }
              }
              return { circles: !c2 && C2 || !S2 ? [] : m2, offscreen: I3, collisionDetected: C2 };
            }
            queryRenderedSymbols(e2) {
              if (e2.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)
                return {};
              const i2 = [];
              let o2 = 1 / 0, r3 = 1 / 0, a2 = -1 / 0, n2 = -1 / 0;
              for (const s3 of e2) {
                const e3 = new t.pointGeometry(s3.x + ce2, s3.y + ce2);
                o2 = Math.min(o2, e3.x), r3 = Math.min(r3, e3.y), a2 = Math.max(a2, e3.x), n2 = Math.max(n2, e3.y), i2.push(e3);
              }
              const s2 = this.grid.query(o2, r3, a2, n2).concat(this.ignoredGrid.query(o2, r3, a2, n2)), l2 = {}, c2 = {};
              for (const e3 of s2) {
                const o3 = e3.key;
                if (l2[o3.bucketInstanceId] === void 0 && (l2[o3.bucketInstanceId] = {}), l2[o3.bucketInstanceId][o3.featureIndex])
                  continue;
                const r4 = [new t.pointGeometry(e3.x1, e3.y1), new t.pointGeometry(e3.x2, e3.y1), new t.pointGeometry(e3.x2, e3.y2), new t.pointGeometry(e3.x1, e3.y2)];
                t.polygonIntersectsPolygon(i2, r4) && (l2[o3.bucketInstanceId][o3.featureIndex] = true, c2[o3.bucketInstanceId] === void 0 && (c2[o3.bucketInstanceId] = []), c2[o3.bucketInstanceId].push(o3.featureIndex));
              }
              return c2;
            }
            insertCollisionBox(t2, e2, i2, o2, r3) {
              (e2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r3 }, t2[0], t2[1], t2[2], t2[3]);
            }
            insertCollisionCircles(t2, e2, i2, o2, r3) {
              const a2 = e2 ? this.ignoredGrid : this.grid, n2 = { bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r3 };
              for (let e3 = 0; e3 < t2.length; e3 += 4)
                a2.insertCircle(n2, t2[e3], t2[e3 + 1], t2[e3 + 2]);
            }
            projectAndGetPerspectiveRatio(e2, i2, o2, r3, a2) {
              const n2 = [i2, o2, r3 || 0, 1];
              let s2 = false;
              if (r3 || this.transform.pitch > 0) {
                t.transformMat4(n2, n2, e2);
                let l2 = false;
                this.fogState && a2 && (l2 = function(e3, i3, o3, r4, a3, n3) {
                  const s3 = n3.calculateFogTileMatrix(a3), l3 = [i3, o3, r4];
                  return t.transformMat4$1(l3, l3, s3), T(e3, l3, n3.pitch, n3._fov);
                }(this.fogState, i2, o2, r3 || 0, a2.toUnwrapped(), this.transform) > 0.9), s2 = n2[2] > n2[3] || l2;
              } else
                le2(n2, n2, e2);
              return { point: new t.pointGeometry((n2[0] / n2[3] + 1) / 2 * this.transform.width + ce2, (-n2[1] / n2[3] + 1) / 2 * this.transform.height + ce2), perspectiveRatio: Math.min(0.5 + this.transform.cameraToCenterDistance / n2[3] * 0.5, 1.5), signedDistanceFromCamera: n2[3], aboveHorizon: s2 };
            }
            isOffscreen(t2, e2, i2, o2) {
              return i2 < ce2 || t2 >= this.screenRightBoundary || o2 < ce2 || e2 > this.screenBottomBoundary;
            }
            isInsideGrid(t2, e2, i2, o2) {
              return i2 >= 0 && t2 < this.gridRightBoundary && o2 >= 0 && e2 < this.gridBottomBoundary;
            }
            getViewportMatrix() {
              const e2 = t.identity([]);
              return t.translate(e2, e2, [-100, -100, 0]), e2;
            }
          }
          class de2 {
            constructor(t2, e2, i2, o2) {
              this.opacity = t2 ? Math.max(0, Math.min(1, t2.opacity + (t2.placed ? e2 : -e2))) : o2 && i2 ? 1 : 0, this.placed = i2;
            }
            isHidden() {
              return this.opacity === 0 && !this.placed;
            }
          }
          class ue2 {
            constructor(t2, e2, i2, o2, r3) {
              this.text = new de2(t2 ? t2.text : null, e2, i2, r3), this.icon = new de2(t2 ? t2.icon : null, e2, o2, r3);
            }
            isHidden() {
              return this.text.isHidden() && this.icon.isHidden();
            }
          }
          class _e2 {
            constructor(t2, e2, i2) {
              this.text = t2, this.icon = e2, this.skipFade = i2;
            }
          }
          class pe {
            constructor() {
              this.invProjMatrix = t.create$1(), this.viewportMatrix = t.create$1(), this.circles = [];
            }
          }
          class me2 {
            constructor(t2, e2, i2, o2, r3) {
              this.bucketInstanceId = t2, this.featureIndex = e2, this.sourceLayerIndex = i2, this.bucketIndex = o2, this.tileID = r3;
            }
          }
          class fe2 {
            constructor(t2) {
              this.crossSourceCollisions = t2, this.maxGroupID = 0, this.collisionGroups = {};
            }
            get(t2) {
              if (this.crossSourceCollisions)
                return { ID: 0, predicate: null };
              if (!this.collisionGroups[t2]) {
                const e2 = ++this.maxGroupID;
                this.collisionGroups[t2] = { ID: e2, predicate: (t3) => t3.collisionGroupID === e2 };
              }
              return this.collisionGroups[t2];
            }
          }
          function ge2(e2, i2, o2, r3, a2) {
            const { horizontalAlign: n2, verticalAlign: s2 } = t.getAnchorAlignment(e2), l2 = -(n2 - 0.5) * i2, c2 = -(s2 - 0.5) * o2, h2 = t.evaluateVariableOffset(e2, r3);
            return new t.pointGeometry(l2 + h2[0] * a2, c2 + h2[1] * a2);
          }
          function ve2(e2, i2, o2, r3, a2) {
            const n2 = new t.pointGeometry(e2, i2);
            return o2 && n2._rotate(r3 ? a2 : -a2), n2;
          }
          class xe2 {
            constructor(t2, e2, i2, o2, r3) {
              this.transform = t2.clone(), this.collisionIndex = new he2(this.transform, r3), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = e2, this.retainedQueryData = {}, this.collisionGroups = new fe2(i2), this.collisionCircleArrays = {}, this.prevPlacement = o2, o2 && (o2.prevPlacement = void 0), this.placedOrientations = {};
            }
            getBucketParts(e2, i2, o2, r3) {
              const a2 = o2.getBucket(i2), n2 = o2.latestFeatureIndex;
              if (!a2 || !n2 || i2.id !== a2.layerIds[0])
                return;
              const s2 = o2.collisionBoxArray, l2 = a2.layers[0].layout, c2 = Math.pow(2, this.transform.zoom - o2.tileID.overscaledZ), h2 = o2.tileSize / t.EXTENT, d2 = this.transform.calculateProjMatrix(o2.tileID.toUnwrapped()), u2 = l2.get("text-pitch-alignment") === "map", _2 = l2.get("text-rotation-alignment") === "map", p2 = z(o2, 1, this.transform.zoom), m2 = Ht(d2, u2, _2, this.transform, p2);
              let f2 = null;
              if (u2) {
                const e3 = Kt2(d2, u2, _2, this.transform, p2);
                f2 = t.multiply([], this.transform.labelPlaneMatrix, e3);
              }
              this.retainedQueryData[a2.bucketInstanceId] = new me2(a2.bucketInstanceId, n2, a2.sourceLayerIndex, a2.index, o2.tileID);
              const g2 = { bucket: a2, layout: l2, posMatrix: d2, textLabelPlaneMatrix: m2, labelToScreenMatrix: f2, scale: c2, textPixelRatio: h2, holdingForFade: o2.holdingForFade(), collisionBoxArray: s2, partiallyEvaluatedTextSize: t.evaluateSizeForZoom(a2.textSizeData, this.transform.zoom), partiallyEvaluatedIconSize: t.evaluateSizeForZoom(a2.iconSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(a2.sourceID) };
              if (r3)
                for (const t2 of a2.sortKeyRanges) {
                  const { sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: r4 } = t2;
                  e2.push({ sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: r4, parameters: g2 });
                }
              else
                e2.push({ symbolInstanceStart: 0, symbolInstanceEnd: a2.symbolInstances.length, parameters: g2 });
            }
            attemptAnchorPlacement(t2, e2, i2, o2, r3, a2, n2, s2, l2, c2, h2, d2, u2, _2, p2, m2, f2, g2) {
              const v2 = [d2.textOffset0, d2.textOffset1], x3 = ge2(t2, i2, o2, v2, r3), y2 = this.collisionIndex.placeCollisionBox(r3, e2, ve2(x3.x, x3.y, a2, n2, this.transform.angle), h2, s2, l2, c2.predicate);
              if ((!m2 || this.collisionIndex.placeCollisionBox(_2.getSymbolInstanceIconSize(g2, this.transform.zoom, u2), m2, ve2(x3.x, x3.y, a2, n2, this.transform.angle), h2, s2, l2, c2.predicate).box.length !== 0) && y2.box.length > 0) {
                let e3;
                return this.prevPlacement && this.prevPlacement.variableOffsets[d2.crossTileID] && this.prevPlacement.placements[d2.crossTileID] && this.prevPlacement.placements[d2.crossTileID].text && (e3 = this.prevPlacement.variableOffsets[d2.crossTileID].anchor), this.variableOffsets[d2.crossTileID] = { textOffset: v2, width: i2, height: o2, anchor: t2, textScale: r3, prevAnchor: e3 }, this.markUsedJustification(_2, t2, d2, p2), _2.allowVerticalPlacement && (this.markUsedOrientation(_2, p2, d2), this.placedOrientations[d2.crossTileID] = p2), { shift: x3, placedGlyphBoxes: y2 };
              }
            }
            placeLayerBucketPart(e2, i2, o2) {
              const { bucket: r3, layout: a2, posMatrix: n2, textLabelPlaneMatrix: s2, labelToScreenMatrix: l2, textPixelRatio: c2, holdingForFade: h2, collisionBoxArray: d2, partiallyEvaluatedTextSize: u2, partiallyEvaluatedIconSize: _2, collisionGroup: p2 } = e2.parameters, m2 = a2.get("text-optional"), f2 = a2.get("icon-optional"), g2 = a2.get("text-allow-overlap"), v2 = a2.get("icon-allow-overlap"), x3 = a2.get("text-rotation-alignment") === "map", y2 = a2.get("text-pitch-alignment") === "map", b2 = a2.get("icon-text-fit") !== "none", w3 = a2.get("symbol-z-order") === "viewport-y", T2 = g2 && (v2 || !r3.hasIconData() || f2), E2 = v2 && (g2 || !r3.hasTextData() || m2);
              !r3.collisionArrays && d2 && r3.deserializeCollisionBoxes(d2), o2 && r3.updateCollisionDebugBuffers(this.transform.zoom, d2);
              const C2 = (e3, d3, w4) => {
                if (i2[e3.crossTileID])
                  return;
                if (h2)
                  return void (this.placements[e3.crossTileID] = new _e2(false, false, false));
                let C3 = false, S2 = false, I3 = true, M3 = null, z2 = { box: null, offscreen: null }, D2 = { box: null, offscreen: null }, A2 = null, P2 = null, L3 = null, R2 = 0, k3 = 0, F3 = 0;
                w4.textFeatureIndex ? R2 = w4.textFeatureIndex : e3.useRuntimeCollisionCircles && (R2 = e3.featureIndex), w4.verticalTextFeatureIndex && (k3 = w4.verticalTextFeatureIndex);
                const B2 = (t2) => {
                  t2.tileID = this.retainedQueryData[r3.bucketInstanceId].tileID, (this.transform.elevation || t2.elevation) && (t2.elevation = this.transform.elevation ? this.transform.elevation.getAtTileOffset(this.retainedQueryData[r3.bucketInstanceId].tileID, t2.anchorPointX, t2.anchorPointY) : 0);
                }, O2 = w4.textBox;
                if (O2) {
                  B2(O2);
                  const i3 = (i4) => {
                    let o4 = t.WritingMode.horizontal;
                    if (r3.allowVerticalPlacement && !i4 && this.prevPlacement) {
                      const t2 = this.prevPlacement.placedOrientations[e3.crossTileID];
                      t2 && (this.placedOrientations[e3.crossTileID] = t2, o4 = t2, this.markUsedOrientation(r3, o4, e3));
                    }
                    return o4;
                  }, o3 = (i4, o4) => {
                    if (r3.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && w4.verticalTextBox) {
                      for (const e4 of r3.writingModes)
                        if (e4 === t.WritingMode.vertical ? (z2 = o4(), D2 = z2) : z2 = i4(), z2 && z2.box && z2.box.length)
                          break;
                    } else
                      z2 = i4();
                  };
                  if (a2.get("text-variable-anchor")) {
                    let s3 = a2.get("text-variable-anchor");
                    if (this.prevPlacement && this.prevPlacement.variableOffsets[e3.crossTileID]) {
                      const t2 = this.prevPlacement.variableOffsets[e3.crossTileID];
                      s3.indexOf(t2.anchor) > 0 && (s3 = s3.filter((e4) => e4 !== t2.anchor), s3.unshift(t2.anchor));
                    }
                    const l3 = (t2, i4, o4) => {
                      const a3 = r3.getSymbolInstanceTextSize(u2, e3, this.transform.zoom, d3), l4 = (t2.x2 - t2.x1) * a3 + 2 * t2.padding, h4 = (t2.y2 - t2.y1) * a3 + 2 * t2.padding, m3 = b2 && !v2 ? i4 : null;
                      m3 && B2(m3);
                      let f3 = { box: [], offscreen: false };
                      const w5 = g2 ? 2 * s3.length : s3.length;
                      for (let i5 = 0; i5 < w5; ++i5) {
                        const g3 = this.attemptAnchorPlacement(s3[i5 % s3.length], t2, l4, h4, a3, x3, y2, c2, n2, p2, i5 >= s3.length, e3, d3, r3, o4, m3, u2, _2);
                        if (g3 && (f3 = g3.placedGlyphBoxes, f3 && f3.box && f3.box.length)) {
                          C3 = true, M3 = g3.shift;
                          break;
                        }
                      }
                      return f3;
                    };
                    o3(() => l3(O2, w4.iconBox, t.WritingMode.horizontal), () => {
                      const i4 = w4.verticalTextBox;
                      return i4 && B2(i4), r3.allowVerticalPlacement && !(z2 && z2.box && z2.box.length) && e3.numVerticalGlyphVertices > 0 && i4 ? l3(i4, w4.verticalIconBox, t.WritingMode.vertical) : { box: null, offscreen: null };
                    }), z2 && (C3 = z2.box, I3 = z2.offscreen);
                    const h3 = i3(z2 && z2.box);
                    if (!C3 && this.prevPlacement) {
                      const t2 = this.prevPlacement.variableOffsets[e3.crossTileID];
                      t2 && (this.variableOffsets[e3.crossTileID] = t2, this.markUsedJustification(r3, t2.anchor, e3, h3));
                    }
                  } else {
                    const a3 = (i4, o4) => {
                      const a4 = r3.getSymbolInstanceTextSize(u2, e3, this.transform.zoom, d3), s3 = this.collisionIndex.placeCollisionBox(a4, i4, new t.pointGeometry(0, 0), g2, c2, n2, p2.predicate);
                      return s3 && s3.box && s3.box.length && (this.markUsedOrientation(r3, o4, e3), this.placedOrientations[e3.crossTileID] = o4), s3;
                    };
                    o3(() => a3(O2, t.WritingMode.horizontal), () => {
                      const i4 = w4.verticalTextBox;
                      return r3.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && i4 ? (B2(i4), a3(i4, t.WritingMode.vertical)) : { box: null, offscreen: null };
                    }), i3(z2 && z2.box && z2.box.length);
                  }
                }
                if (A2 = z2, C3 = A2 && A2.box && A2.box.length > 0, I3 = A2 && A2.offscreen, e3.useRuntimeCollisionCircles) {
                  const i3 = r3.text.placedSymbolArray.get(e3.centerJustifiedTextSymbolIndex >= 0 ? e3.centerJustifiedTextSymbolIndex : e3.verticalPlacedTextSymbolIndex), c3 = t.evaluateSizeForFeature(r3.textSizeData, u2, i3), h3 = a2.get("text-padding");
                  P2 = this.collisionIndex.placeCollisionCircles(g2, i3, r3.lineVertexArray, r3.glyphOffsetArray, c3, n2, s2, l2, o2, y2, p2.predicate, e3.collisionCircleDiameter, h3, this.retainedQueryData[r3.bucketInstanceId].tileID), C3 = g2 || P2.circles.length > 0 && !P2.collisionDetected, I3 = I3 && P2.offscreen;
                }
                if (w4.iconFeatureIndex && (F3 = w4.iconFeatureIndex), w4.iconBox) {
                  const e4 = (e5) => {
                    B2(e5);
                    const i3 = b2 && M3 ? ve2(M3.x, M3.y, x3, y2, this.transform.angle) : new t.pointGeometry(0, 0), o3 = r3.getSymbolInstanceIconSize(_2, this.transform.zoom, d3);
                    return this.collisionIndex.placeCollisionBox(o3, e5, i3, v2, c2, n2, p2.predicate);
                  };
                  D2 && D2.box && D2.box.length && w4.verticalIconBox ? (L3 = e4(w4.verticalIconBox), S2 = L3.box.length > 0) : (L3 = e4(w4.iconBox), S2 = L3.box.length > 0), I3 = I3 && L3.offscreen;
                }
                const U3 = m2 || e3.numHorizontalGlyphVertices === 0 && e3.numVerticalGlyphVertices === 0, N2 = f2 || e3.numIconVertices === 0;
                if (U3 || N2 ? N2 ? U3 || (S2 = S2 && C3) : C3 = S2 && C3 : S2 = C3 = S2 && C3, C3 && A2 && A2.box && this.collisionIndex.insertCollisionBox(A2.box, a2.get("text-ignore-placement"), r3.bucketInstanceId, D2 && D2.box && k3 ? k3 : R2, p2.ID), S2 && L3 && this.collisionIndex.insertCollisionBox(L3.box, a2.get("icon-ignore-placement"), r3.bucketInstanceId, F3, p2.ID), P2 && (C3 && this.collisionIndex.insertCollisionCircles(P2.circles, a2.get("text-ignore-placement"), r3.bucketInstanceId, R2, p2.ID), o2)) {
                  const t2 = r3.bucketInstanceId;
                  let e4 = this.collisionCircleArrays[t2];
                  e4 === void 0 && (e4 = this.collisionCircleArrays[t2] = new pe());
                  for (let t3 = 0; t3 < P2.circles.length; t3 += 4)
                    e4.circles.push(P2.circles[t3 + 0]), e4.circles.push(P2.circles[t3 + 1]), e4.circles.push(P2.circles[t3 + 2]), e4.circles.push(P2.collisionDetected ? 1 : 0);
                }
                this.placements[e3.crossTileID] = new _e2(C3 || T2, S2 || E2, I3 || r3.justReloaded), i2[e3.crossTileID] = true;
              };
              if (w3) {
                const t2 = r3.getSortedSymbolIndexes(this.transform.angle);
                for (let e3 = t2.length - 1; e3 >= 0; --e3) {
                  const i3 = t2[e3];
                  C2(r3.symbolInstances.get(i3), i3, r3.collisionArrays[i3]);
                }
              } else
                for (let t2 = e2.symbolInstanceStart; t2 < e2.symbolInstanceEnd; t2++)
                  C2(r3.symbolInstances.get(t2), t2, r3.collisionArrays[t2]);
              if (o2 && r3.bucketInstanceId in this.collisionCircleArrays) {
                const e3 = this.collisionCircleArrays[r3.bucketInstanceId];
                t.invert(e3.invProjMatrix, n2), e3.viewportMatrix = this.collisionIndex.getViewportMatrix();
              }
              r3.justReloaded = false;
            }
            markUsedJustification(e2, i2, o2, r3) {
              let a2;
              a2 = r3 === t.WritingMode.vertical ? o2.verticalPlacedTextSymbolIndex : { left: o2.leftJustifiedTextSymbolIndex, center: o2.centerJustifiedTextSymbolIndex, right: o2.rightJustifiedTextSymbolIndex }[t.getAnchorJustification(i2)];
              const n2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex, o2.verticalPlacedTextSymbolIndex];
              for (const t2 of n2)
                t2 >= 0 && (e2.text.placedSymbolArray.get(t2).crossTileID = a2 >= 0 && t2 !== a2 ? 0 : o2.crossTileID);
            }
            markUsedOrientation(e2, i2, o2) {
              const r3 = i2 === t.WritingMode.horizontal || i2 === t.WritingMode.horizontalOnly ? i2 : 0, a2 = i2 === t.WritingMode.vertical ? i2 : 0, n2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex];
              for (const t2 of n2)
                e2.text.placedSymbolArray.get(t2).placedOrientation = r3;
              o2.verticalPlacedTextSymbolIndex && (e2.text.placedSymbolArray.get(o2.verticalPlacedTextSymbolIndex).placedOrientation = a2);
            }
            commit(t2) {
              this.commitTime = t2, this.zoomAtLastRecencyCheck = this.transform.zoom;
              const e2 = this.prevPlacement;
              let i2 = false;
              this.prevZoomAdjustment = e2 ? e2.zoomAdjustment(this.transform.zoom) : 0;
              const o2 = e2 ? e2.symbolFadeChange(t2) : 1, r3 = e2 ? e2.opacities : {}, a2 = e2 ? e2.variableOffsets : {}, n2 = e2 ? e2.placedOrientations : {};
              for (const t3 in this.placements) {
                const e3 = this.placements[t3], a3 = r3[t3];
                a3 ? (this.opacities[t3] = new ue2(a3, o2, e3.text, e3.icon), i2 = i2 || e3.text !== a3.text.placed || e3.icon !== a3.icon.placed) : (this.opacities[t3] = new ue2(null, o2, e3.text, e3.icon, e3.skipFade), i2 = i2 || e3.text || e3.icon);
              }
              for (const t3 in r3) {
                const e3 = r3[t3];
                if (!this.opacities[t3]) {
                  const r4 = new ue2(e3, o2, false, false);
                  r4.isHidden() || (this.opacities[t3] = r4, i2 = i2 || e3.text.placed || e3.icon.placed);
                }
              }
              for (const t3 in a2)
                this.variableOffsets[t3] || !this.opacities[t3] || this.opacities[t3].isHidden() || (this.variableOffsets[t3] = a2[t3]);
              for (const t3 in n2)
                this.placedOrientations[t3] || !this.opacities[t3] || this.opacities[t3].isHidden() || (this.placedOrientations[t3] = n2[t3]);
              i2 ? this.lastPlacementChangeTime = t2 : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = e2 ? e2.lastPlacementChangeTime : t2);
            }
            updateLayerOpacities(t2, e2) {
              const i2 = {};
              for (const o2 of e2) {
                const e3 = o2.getBucket(t2);
                e3 && o2.latestFeatureIndex && t2.id === e3.layerIds[0] && this.updateBucketOpacities(e3, i2, o2.collisionBoxArray);
              }
            }
            updateBucketOpacities(e2, i2, o2) {
              e2.hasTextData() && e2.text.opacityVertexArray.clear(), e2.hasIconData() && e2.icon.opacityVertexArray.clear(), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexArray.clear(), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexArray.clear();
              const r3 = e2.layers[0].layout, a2 = new ue2(null, 0, false, false, true), n2 = r3.get("text-allow-overlap"), s2 = r3.get("icon-allow-overlap"), l2 = r3.get("text-variable-anchor"), c2 = r3.get("text-rotation-alignment") === "map", h2 = r3.get("text-pitch-alignment") === "map", d2 = r3.get("icon-text-fit") !== "none", u2 = new ue2(null, 0, n2 && (s2 || !e2.hasIconData() || r3.get("icon-optional")), s2 && (n2 || !e2.hasTextData() || r3.get("text-optional")), true);
              !e2.collisionArrays && o2 && (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) && e2.deserializeCollisionBoxes(o2);
              const _2 = (t2, e3, i3) => {
                for (let o3 = 0; o3 < e3 / 4; o3++)
                  t2.opacityVertexArray.emplaceBack(i3);
              };
              for (let o3 = 0; o3 < e2.symbolInstances.length; o3++) {
                const r4 = e2.symbolInstances.get(o3), { numHorizontalGlyphVertices: n3, numVerticalGlyphVertices: s3, crossTileID: p2 } = r4;
                let m2 = this.opacities[p2];
                i2[p2] ? m2 = a2 : m2 || (m2 = u2, this.opacities[p2] = m2), i2[p2] = true;
                const f2 = r4.numIconVertices > 0, g2 = this.placedOrientations[r4.crossTileID], v2 = g2 === t.WritingMode.vertical, x3 = g2 === t.WritingMode.horizontal || g2 === t.WritingMode.horizontalOnly;
                if (n3 > 0 || s3 > 0) {
                  const t2 = Me2(m2.text);
                  _2(e2.text, n3, v2 ? ze2 : t2), _2(e2.text, s3, x3 ? ze2 : t2);
                  const i3 = m2.text.isHidden();
                  [r4.rightJustifiedTextSymbolIndex, r4.centerJustifiedTextSymbolIndex, r4.leftJustifiedTextSymbolIndex].forEach((t3) => {
                    t3 >= 0 && (e2.text.placedSymbolArray.get(t3).hidden = i3 || v2 ? 1 : 0);
                  }), r4.verticalPlacedTextSymbolIndex >= 0 && (e2.text.placedSymbolArray.get(r4.verticalPlacedTextSymbolIndex).hidden = i3 || x3 ? 1 : 0);
                  const o4 = this.variableOffsets[r4.crossTileID];
                  o4 && this.markUsedJustification(e2, o4.anchor, r4, g2);
                  const a3 = this.placedOrientations[r4.crossTileID];
                  a3 && (this.markUsedJustification(e2, "left", r4, a3), this.markUsedOrientation(e2, a3, r4));
                }
                if (f2) {
                  const t2 = Me2(m2.icon);
                  r4.placedIconSymbolIndex >= 0 && (_2(e2.icon, r4.numIconVertices, v2 ? ze2 : t2), e2.icon.placedSymbolArray.get(r4.placedIconSymbolIndex).hidden = m2.icon.isHidden()), r4.verticalPlacedIconSymbolIndex >= 0 && (_2(e2.icon, r4.numVerticalIconVertices, x3 ? ze2 : t2), e2.icon.placedSymbolArray.get(r4.verticalPlacedIconSymbolIndex).hidden = m2.icon.isHidden());
                }
                if (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) {
                  const i3 = e2.collisionArrays[o3];
                  if (i3) {
                    let o4 = new t.pointGeometry(0, 0);
                    if (i3.textBox || i3.verticalTextBox) {
                      let t2 = true;
                      if (l2) {
                        const e3 = this.variableOffsets[p2];
                        e3 ? (o4 = ge2(e3.anchor, e3.width, e3.height, e3.textOffset, e3.textScale), c2 && o4._rotate(h2 ? this.transform.angle : -this.transform.angle)) : t2 = false;
                      }
                      i3.textBox && ye2(e2.textCollisionBox.collisionVertexArray, m2.text.placed, !t2 || v2, o4.x, o4.y), i3.verticalTextBox && ye2(e2.textCollisionBox.collisionVertexArray, m2.text.placed, !t2 || x3, o4.x, o4.y);
                    }
                    const r5 = Boolean(!x3 && i3.verticalIconBox);
                    i3.iconBox && ye2(e2.iconCollisionBox.collisionVertexArray, m2.icon.placed, r5, d2 ? o4.x : 0, d2 ? o4.y : 0), i3.verticalIconBox && ye2(e2.iconCollisionBox.collisionVertexArray, m2.icon.placed, !r5, d2 ? o4.x : 0, d2 ? o4.y : 0);
                  }
                }
              }
              if (e2.sortFeatures(this.transform.angle), this.retainedQueryData[e2.bucketInstanceId] && (this.retainedQueryData[e2.bucketInstanceId].featureSortOrder = e2.featureSortOrder), e2.hasTextData() && e2.text.opacityVertexBuffer && e2.text.opacityVertexBuffer.updateData(e2.text.opacityVertexArray), e2.hasIconData() && e2.icon.opacityVertexBuffer && e2.icon.opacityVertexBuffer.updateData(e2.icon.opacityVertexArray), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexBuffer && e2.iconCollisionBox.collisionVertexBuffer.updateData(e2.iconCollisionBox.collisionVertexArray), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexBuffer && e2.textCollisionBox.collisionVertexBuffer.updateData(e2.textCollisionBox.collisionVertexArray), e2.bucketInstanceId in this.collisionCircleArrays) {
                const t2 = this.collisionCircleArrays[e2.bucketInstanceId];
                e2.placementInvProjMatrix = t2.invProjMatrix, e2.placementViewportMatrix = t2.viewportMatrix, e2.collisionCircleArray = t2.circles, delete this.collisionCircleArrays[e2.bucketInstanceId];
              }
            }
            symbolFadeChange(t2) {
              return this.fadeDuration === 0 ? 1 : (t2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
            }
            zoomAdjustment(t2) {
              return Math.max(0, (this.transform.zoom - t2) / 1.5);
            }
            hasTransitions(t2) {
              return this.stale || t2 - this.lastPlacementChangeTime < this.fadeDuration;
            }
            stillRecent(t2, e2) {
              const i2 = this.zoomAtLastRecencyCheck === e2 ? 1 - this.zoomAdjustment(e2) : 1;
              return this.zoomAtLastRecencyCheck = e2, this.commitTime + this.fadeDuration * i2 > t2;
            }
            setStale() {
              this.stale = true;
            }
          }
          function ye2(t2, e2, i2, o2, r3) {
            t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r3 || 0), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r3 || 0), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r3 || 0), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r3 || 0);
          }
          const be2 = Math.pow(2, 25), we2 = Math.pow(2, 24), Te = Math.pow(2, 17), Ee = Math.pow(2, 16), Ce2 = Math.pow(2, 9), Se = Math.pow(2, 8), Ie2 = Math.pow(2, 1);
          function Me2(t2) {
            if (t2.opacity === 0 && !t2.placed)
              return 0;
            if (t2.opacity === 1 && t2.placed)
              return 4294967295;
            const e2 = t2.placed ? 1 : 0, i2 = Math.floor(127 * t2.opacity);
            return i2 * be2 + e2 * we2 + i2 * Te + e2 * Ee + i2 * Ce2 + e2 * Se + i2 * Ie2 + e2;
          }
          const ze2 = 0;
          class De2 {
            constructor(t2) {
              this._sortAcrossTiles = t2.layout.get("symbol-z-order") !== "viewport-y" && t2.layout.get("symbol-sort-key").constantOr(1) !== void 0, this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
            }
            continuePlacement(t2, e2, i2, o2, r3) {
              const a2 = this._bucketParts;
              for (; this._currentTileIndex < t2.length; )
                if (e2.getBucketParts(a2, o2, t2[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r3())
                  return true;
              for (this._sortAcrossTiles && (this._sortAcrossTiles = false, a2.sort((t3, e3) => t3.sortKey - e3.sortKey)); this._currentPartIndex < a2.length; )
                if (e2.placeLayerBucketPart(a2[this._currentPartIndex], this._seenCrossTileIDs, i2), this._currentPartIndex++, r3())
                  return true;
              return false;
            }
          }
          class Ae2 {
            constructor(t2, e2, i2, o2, r3, a2, n2, s2) {
              this.placement = new xe2(t2, r3, a2, n2, s2), this._currentPlacementIndex = e2.length - 1, this._forceFullPlacement = i2, this._showCollisionBoxes = o2, this._done = false;
            }
            isDone() {
              return this._done;
            }
            continuePlacement(e2, i2, o2) {
              const r3 = t.exported.now(), a2 = () => {
                const e3 = t.exported.now() - r3;
                return !this._forceFullPlacement && e3 > 2;
              };
              for (; this._currentPlacementIndex >= 0; ) {
                const t2 = i2[e2[this._currentPlacementIndex]], r4 = this.placement.collisionIndex.transform.zoom;
                if (t2.type === "symbol" && (!t2.minzoom || t2.minzoom <= r4) && (!t2.maxzoom || t2.maxzoom > r4)) {
                  if (this._inProgressLayer || (this._inProgressLayer = new De2(t2)), this._inProgressLayer.continuePlacement(o2[t2.source], this.placement, this._showCollisionBoxes, t2, a2))
                    return;
                  delete this._inProgressLayer;
                }
                this._currentPlacementIndex--;
              }
              this._done = true;
            }
            commit(t2) {
              return this.placement.commit(t2), this.placement;
            }
          }
          const Pe2 = 512 / t.EXTENT / 2;
          class Le2 {
            constructor(t2, e2, i2) {
              this.tileID = t2, this.indexedSymbolInstances = {}, this.bucketInstanceId = i2;
              for (let i3 = 0; i3 < e2.length; i3++) {
                const o2 = e2.get(i3), r3 = o2.key;
                this.indexedSymbolInstances[r3] || (this.indexedSymbolInstances[r3] = []), this.indexedSymbolInstances[r3].push({ crossTileID: o2.crossTileID, coord: this.getScaledCoordinates(o2, t2) });
              }
            }
            getScaledCoordinates(e2, i2) {
              const o2 = Pe2 / Math.pow(2, i2.canonical.z - this.tileID.canonical.z);
              return { x: Math.floor((i2.canonical.x * t.EXTENT + e2.anchorX) * o2), y: Math.floor((i2.canonical.y * t.EXTENT + e2.anchorY) * o2) };
            }
            findMatches(t2, e2, i2) {
              const o2 = this.tileID.canonical.z < e2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e2.canonical.z);
              for (let r3 = 0; r3 < t2.length; r3++) {
                const a2 = t2.get(r3);
                if (a2.crossTileID)
                  continue;
                const n2 = this.indexedSymbolInstances[a2.key];
                if (!n2)
                  continue;
                const s2 = this.getScaledCoordinates(a2, e2);
                for (const t3 of n2)
                  if (Math.abs(t3.coord.x - s2.x) <= o2 && Math.abs(t3.coord.y - s2.y) <= o2 && !i2[t3.crossTileID]) {
                    i2[t3.crossTileID] = true, a2.crossTileID = t3.crossTileID;
                    break;
                  }
              }
            }
          }
          class Re2 {
            constructor() {
              this.maxCrossTileID = 0;
            }
            generate() {
              return ++this.maxCrossTileID;
            }
          }
          class ke {
            constructor() {
              this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
            }
            handleWrapJump(t2) {
              const e2 = Math.round((t2 - this.lng) / 360);
              if (e2 !== 0)
                for (const t3 in this.indexes) {
                  const i2 = this.indexes[t3], o2 = {};
                  for (const t4 in i2) {
                    const r3 = i2[t4];
                    r3.tileID = r3.tileID.unwrapTo(r3.tileID.wrap + e2), o2[r3.tileID.key] = r3;
                  }
                  this.indexes[t3] = o2;
                }
              this.lng = t2;
            }
            addBucket(t2, e2, i2) {
              if (this.indexes[t2.overscaledZ] && this.indexes[t2.overscaledZ][t2.key]) {
                if (this.indexes[t2.overscaledZ][t2.key].bucketInstanceId === e2.bucketInstanceId)
                  return false;
                this.removeBucketCrossTileIDs(t2.overscaledZ, this.indexes[t2.overscaledZ][t2.key]);
              }
              for (let t3 = 0; t3 < e2.symbolInstances.length; t3++)
                e2.symbolInstances.get(t3).crossTileID = 0;
              this.usedCrossTileIDs[t2.overscaledZ] || (this.usedCrossTileIDs[t2.overscaledZ] = {});
              const o2 = this.usedCrossTileIDs[t2.overscaledZ];
              for (const i3 in this.indexes) {
                const r3 = this.indexes[i3];
                if (Number(i3) > t2.overscaledZ)
                  for (const i4 in r3) {
                    const a2 = r3[i4];
                    a2.tileID.isChildOf(t2) && a2.findMatches(e2.symbolInstances, t2, o2);
                  }
                else {
                  const a2 = r3[t2.scaledTo(Number(i3)).key];
                  a2 && a2.findMatches(e2.symbolInstances, t2, o2);
                }
              }
              for (let t3 = 0; t3 < e2.symbolInstances.length; t3++) {
                const r3 = e2.symbolInstances.get(t3);
                r3.crossTileID || (r3.crossTileID = i2.generate(), o2[r3.crossTileID] = true);
              }
              return this.indexes[t2.overscaledZ] === void 0 && (this.indexes[t2.overscaledZ] = {}), this.indexes[t2.overscaledZ][t2.key] = new Le2(t2, e2.symbolInstances, e2.bucketInstanceId), true;
            }
            removeBucketCrossTileIDs(t2, e2) {
              for (const i2 in e2.indexedSymbolInstances)
                for (const o2 of e2.indexedSymbolInstances[i2])
                  delete this.usedCrossTileIDs[t2][o2.crossTileID];
            }
            removeStaleBuckets(t2) {
              let e2 = false;
              for (const i2 in this.indexes) {
                const o2 = this.indexes[i2];
                for (const r3 in o2)
                  t2[o2[r3].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, o2[r3]), delete o2[r3], e2 = true);
              }
              return e2;
            }
          }
          class Fe {
            constructor() {
              this.layerIndexes = {}, this.crossTileIDs = new Re2(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
            }
            addLayer(t2, e2, i2) {
              let o2 = this.layerIndexes[t2.id];
              o2 === void 0 && (o2 = this.layerIndexes[t2.id] = new ke());
              let r3 = false;
              const a2 = {};
              o2.handleWrapJump(i2);
              for (const i3 of e2) {
                const e3 = i3.getBucket(t2);
                e3 && t2.id === e3.layerIds[0] && (e3.bucketInstanceId || (e3.bucketInstanceId = ++this.maxBucketInstanceId), o2.addBucket(i3.tileID, e3, this.crossTileIDs) && (r3 = true), a2[e3.bucketInstanceId] = true);
              }
              return o2.removeStaleBuckets(a2) && (r3 = true), r3;
            }
            pruneUnusedLayers(t2) {
              const e2 = {};
              t2.forEach((t3) => {
                e2[t3] = true;
              });
              for (const t3 in this.layerIndexes)
                e2[t3] || delete this.layerIndexes[t3];
            }
          }
          const Be2 = (e2, i2) => t.emitValidationErrors(e2, i2 && i2.filter((t2) => t2.identifier !== "source.canvas")), Oe2 = t.pick(Ot2, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog"]), Ue = t.pick(Ot2, ["setCenter", "setZoom", "setBearing", "setPitch"]), Ne = function() {
            const e2 = {}, i2 = t.spec.$version;
            for (const o2 in t.spec.$root) {
              const r3 = t.spec.$root[o2];
              if (r3.required) {
                let t2 = null;
                t2 = o2 === "version" ? i2 : r3.type === "array" ? [] : {}, t2 != null && (e2[o2] = t2);
              }
            }
            return e2;
          }(), Ge2 = { fill: true, line: true, background: true, hillshade: true, raster: true };
          class Ze2 extends t.Evented {
            constructor(e2, i2 = {}) {
              super(), this.map = e2, this.dispatcher = new M2(kt2(), this), this.imageManager = new f(), this.imageManager.setEventedParent(this), this.glyphManager = new t.GlyphManager(e2._requestManager, i2.localFontFamily ? t.LocalGlyphMode.all : i2.localIdeographFontFamily ? t.LocalGlyphMode.ideographs : t.LocalGlyphMode.none, i2.localFontFamily || i2.localIdeographFontFamily), this.lineAtlas = new t.LineAtlas(256, 512), this.crossTileSymbolIndex = new Fe(), this._layers = {}, this._num3DLayers = 0, this._numSymbolLayers = 0, this._numCircleLayers = 0, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this.zoomHistory = new t.ZoomHistory(), this._loaded = false, this._availableImages = [], this._order = [], this._drapedFirstOrder = [], this._markersNeedUpdate = false, this._resetUpdates(), this.dispatcher.broadcast("setReferrer", t.getReferrer());
              const o2 = this;
              this._rtlTextPluginCallback = Ze2.registerForPluginStateChange((e3) => {
                o2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: e3.pluginStatus, pluginURL: e3.pluginURL }, (e4, i3) => {
                  if (t.triggerPluginCompletionEvent(e4), i3 && i3.every((t2) => t2))
                    for (const t2 in o2._sourceCaches) {
                      const e5 = o2._sourceCaches[t2], i4 = e5.getSource().type;
                      i4 !== "vector" && i4 !== "geojson" || e5.reload();
                    }
                });
              }), this.on("data", (t2) => {
                if (t2.dataType !== "source" || t2.sourceDataType !== "metadata")
                  return;
                const e3 = this.getSource(t2.sourceId);
                if (e3 && e3.vectorLayerIds)
                  for (const t3 in this._layers) {
                    const i3 = this._layers[t3];
                    i3.source === e3.id && this._validateLayer(i3);
                  }
              });
            }
            loadURL(e2, i2 = {}) {
              this.fire(new t.Event("dataloading", { dataType: "style" }));
              const o2 = typeof i2.validate == "boolean" ? i2.validate : !t.isMapboxURL(e2);
              e2 = this.map._requestManager.normalizeStyleURL(e2, i2.accessToken);
              const r3 = this.map._requestManager.transformRequest(e2, t.ResourceType.Style);
              this._request = t.getJSON(r3, (e3, i3) => {
                this._request = null, e3 ? this.fire(new t.ErrorEvent(e3)) : i3 && this._load(i3, o2);
              });
            }
            loadJSON(e2, i2 = {}) {
              this.fire(new t.Event("dataloading", { dataType: "style" })), this._request = t.exported.frame(() => {
                this._request = null, this._load(e2, i2.validate !== false);
              });
            }
            loadEmpty() {
              this.fire(new t.Event("dataloading", { dataType: "style" })), this._load(Ne, false);
            }
            _updateLayerCount(t2, e2) {
              const i2 = e2 ? 1 : -1;
              t2.is3D() && (this._num3DLayers += i2), t2.type === "circle" && (this._numCircleLayers += i2), t2.type === "symbol" && (this._numSymbolLayers += i2);
            }
            _load(e2, i2) {
              if (i2 && Be2(this, t.validateStyle(e2)))
                return;
              this._loaded = true, this.stylesheet = e2;
              for (const t2 in e2.sources)
                this.addSource(t2, e2.sources[t2], { validate: false });
              this._changed = false, e2.sprite ? this._loadSprite(e2.sprite) : (this.imageManager.setLoaded(true), this.dispatcher.broadcast("spriteLoaded", true)), this.glyphManager.setURL(e2.glyphs);
              const o2 = Bt2(this.stylesheet.layers);
              this._order = o2.map((t2) => t2.id), this._layers = {}, this._serializedLayers = {};
              for (let e3 of o2)
                e3 = t.createStyleLayer(e3), e3.setEventedParent(this, { layer: { id: e3.id } }), this._layers[e3.id] = e3, this._serializedLayers[e3.id] = e3.serialize(), this._updateLayerCount(e3, true);
              this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new x2(this.stylesheet.light), this.stylesheet.terrain && this._createTerrain(this.stylesheet.terrain), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this._updateDrapeFirstLayers(), this.fire(new t.Event("data", { dataType: "style" })), this.fire(new t.Event("style.load"));
            }
            _loadSprite(e2) {
              this._spriteRequest = function(e3, i2, o2) {
                let r3, a2, n2;
                const s2 = t.exported.devicePixelRatio > 1 ? "@2x" : "";
                let l2 = t.getJSON(i2.transformRequest(i2.normalizeSpriteURL(e3, s2, ".json"), t.ResourceType.SpriteJSON), (t2, e4) => {
                  l2 = null, n2 || (n2 = t2, r3 = e4, h2());
                }), c2 = t.getImage(i2.transformRequest(i2.normalizeSpriteURL(e3, s2, ".png"), t.ResourceType.SpriteImage), (t2, e4) => {
                  c2 = null, n2 || (n2 = t2, a2 = e4, h2());
                });
                function h2() {
                  if (n2)
                    o2(n2);
                  else if (r3 && a2) {
                    const e4 = t.exported.getImageData(a2), i3 = {};
                    for (const o3 in r3) {
                      const { width: a3, height: n3, x: s3, y: l3, sdf: c3, pixelRatio: h3, stretchX: d2, stretchY: u2, content: _2 } = r3[o3], p2 = new t.RGBAImage({ width: a3, height: n3 });
                      t.RGBAImage.copy(e4, p2, { x: s3, y: l3 }, { x: 0, y: 0 }, { width: a3, height: n3 }), i3[o3] = { data: p2, pixelRatio: h3, sdf: c3, stretchX: d2, stretchY: u2, content: _2 };
                    }
                    o2(null, i3);
                  }
                }
                return { cancel() {
                  l2 && (l2.cancel(), l2 = null), c2 && (c2.cancel(), c2 = null);
                } };
              }(e2, this.map._requestManager, (e3, i2) => {
                if (this._spriteRequest = null, e3)
                  this.fire(new t.ErrorEvent(e3));
                else if (i2)
                  for (const t2 in i2)
                    this.imageManager.addImage(t2, i2[t2]);
                this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.dispatcher.broadcast("spriteLoaded", true), this.fire(new t.Event("data", { dataType: "style" }));
              });
            }
            _validateLayer(e2) {
              const i2 = this.getSource(e2.source);
              if (!i2)
                return;
              const o2 = e2.sourceLayer;
              o2 && (i2.type === "geojson" || i2.vectorLayerIds && i2.vectorLayerIds.indexOf(o2) === -1) && this.fire(new t.ErrorEvent(new Error(`Source layer "${o2}" does not exist on source "${i2.id}" as specified by style layer "${e2.id}"`)));
            }
            loaded() {
              if (!this._loaded)
                return false;
              if (Object.keys(this._updatedSources).length)
                return false;
              for (const t2 in this._sourceCaches)
                if (!this._sourceCaches[t2].loaded())
                  return false;
              return !!this.imageManager.isLoaded();
            }
            _serializeLayers(t2) {
              const e2 = [];
              for (const i2 of t2) {
                const t3 = this._layers[i2];
                t3.type !== "custom" && e2.push(t3.serialize());
              }
              return e2;
            }
            hasTransitions() {
              if (this.light && this.light.hasTransition())
                return true;
              if (this.fog && this.fog.hasTransition())
                return true;
              for (const t2 in this._sourceCaches)
                if (this._sourceCaches[t2].hasTransition())
                  return true;
              for (const t2 in this._layers)
                if (this._layers[t2].hasTransition())
                  return true;
              return false;
            }
            get order() {
              return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order;
            }
            isLayerDraped(t2) {
              return !!this.terrain && Ge2[t2.type];
            }
            _checkLoaded() {
              if (!this._loaded)
                throw new Error("Style is not done loading");
            }
            update(e2) {
              if (!this._loaded)
                return;
              const i2 = this._changed;
              if (this._changed) {
                const t2 = Object.keys(this._updatedLayers), i3 = Object.keys(this._removedLayers);
                (t2.length || i3.length) && this._updateWorkerLayers(t2, i3);
                for (const t3 in this._updatedSources) {
                  const e3 = this._updatedSources[t3];
                  e3 === "reload" ? this._reloadSource(t3) : e3 === "clear" && this._clearSource(t3);
                }
                this._updateTilesForChangedImages();
                for (const t3 in this._updatedPaintProps)
                  this._layers[t3].updateTransitions(e2);
                this.light.updateTransitions(e2), this.fog && this.fog.updateTransitions(e2), this._resetUpdates();
              }
              const o2 = {};
              for (const t2 in this._sourceCaches) {
                const e3 = this._sourceCaches[t2];
                o2[t2] = e3.used, e3.used = false;
              }
              for (const t2 of this._order) {
                const i3 = this._layers[t2];
                if (i3.recalculate(e2, this._availableImages), !i3.isHidden(e2.zoom)) {
                  const t3 = this._getLayerSourceCache(i3);
                  t3 && (t3.used = true);
                }
                const o3 = this.map.painter;
                if (o3) {
                  const t3 = i3.getProgramIds();
                  if (!t3)
                    continue;
                  const r3 = i3.getProgramConfiguration(e2.zoom);
                  for (const e3 of t3)
                    o3.useProgram(e3, r3);
                }
              }
              for (const e3 in o2) {
                const i3 = this._sourceCaches[e3];
                o2[e3] !== i3.used && i3.getSource().fire(new t.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: i3.getSource().id }));
              }
              this.light.recalculate(e2), this.terrain && this.terrain.recalculate(e2), this.fog && this.fog.recalculate(e2), this.z = e2.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = false), i2 && this.fire(new t.Event("data", { dataType: "style" }));
            }
            _updateTilesForChangedImages() {
              const t2 = Object.keys(this._changedImages);
              if (t2.length) {
                for (const e2 in this._sourceCaches)
                  this._sourceCaches[e2].reloadTilesForDependencies(["icons", "patterns"], t2);
                this._changedImages = {};
              }
            }
            _updateWorkerLayers(t2, e2) {
              this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(t2), removedIds: e2 });
            }
            _resetUpdates() {
              this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
            }
            setState(e2) {
              if (this._checkLoaded(), Be2(this, t.validateStyle(e2)))
                return false;
              (e2 = t.clone$2(e2)).layers = Bt2(e2.layers);
              const i2 = function(t2, e3) {
                if (!t2)
                  return [{ command: Ot2.setStyle, args: [e3] }];
                let i3 = [];
                try {
                  if (!r2(t2.version, e3.version))
                    return [{ command: Ot2.setStyle, args: [e3] }];
                  r2(t2.center, e3.center) || i3.push({ command: Ot2.setCenter, args: [e3.center] }), r2(t2.zoom, e3.zoom) || i3.push({ command: Ot2.setZoom, args: [e3.zoom] }), r2(t2.bearing, e3.bearing) || i3.push({ command: Ot2.setBearing, args: [e3.bearing] }), r2(t2.pitch, e3.pitch) || i3.push({ command: Ot2.setPitch, args: [e3.pitch] }), r2(t2.sprite, e3.sprite) || i3.push({ command: Ot2.setSprite, args: [e3.sprite] }), r2(t2.glyphs, e3.glyphs) || i3.push({ command: Ot2.setGlyphs, args: [e3.glyphs] }), r2(t2.transition, e3.transition) || i3.push({ command: Ot2.setTransition, args: [e3.transition] }), r2(t2.light, e3.light) || i3.push({ command: Ot2.setLight, args: [e3.light] }), r2(t2.fog, e3.fog) || i3.push({ command: Ot2.setFog, args: [e3.fog] });
                  const o3 = {}, a2 = [];
                  !function(t3, e4, i4, o4) {
                    let a3;
                    for (a3 in e4 = e4 || {}, t3 = t3 || {})
                      t3.hasOwnProperty(a3) && (e4.hasOwnProperty(a3) || Nt2(a3, i4, o4));
                    for (a3 in e4)
                      e4.hasOwnProperty(a3) && (t3.hasOwnProperty(a3) ? r2(t3[a3], e4[a3]) || (t3[a3].type === "geojson" && e4[a3].type === "geojson" && Zt2(t3, e4, a3) ? i4.push({ command: Ot2.setGeoJSONSourceData, args: [a3, e4[a3].data] }) : Gt2(a3, e4, i4, o4)) : Ut2(a3, e4, i4));
                  }(t2.sources, e3.sources, a2, o3);
                  const n2 = [];
                  t2.layers && t2.layers.forEach((t3) => {
                    o3[t3.source] ? i3.push({ command: Ot2.removeLayer, args: [t3.id] }) : n2.push(t3);
                  });
                  let s2 = t2.terrain;
                  s2 && o3[s2.source] && (i3.push({ command: Ot2.setTerrain, args: [void 0] }), s2 = void 0), i3 = i3.concat(a2), r2(s2, e3.terrain) || i3.push({ command: Ot2.setTerrain, args: [e3.terrain] }), function(t3, e4, i4) {
                    e4 = e4 || [];
                    const o4 = (t3 = t3 || []).map(jt), a3 = e4.map(jt), n3 = t3.reduce(qt2, {}), s3 = e4.reduce(qt2, {}), l2 = o4.slice(), c2 = Object.create(null);
                    let h2, d2, u2, _2, p2, m2, f2;
                    for (h2 = 0, d2 = 0; h2 < o4.length; h2++)
                      u2 = o4[h2], s3.hasOwnProperty(u2) ? d2++ : (i4.push({ command: Ot2.removeLayer, args: [u2] }), l2.splice(l2.indexOf(u2, d2), 1));
                    for (h2 = 0, d2 = 0; h2 < a3.length; h2++)
                      u2 = a3[a3.length - 1 - h2], l2[l2.length - 1 - h2] !== u2 && (n3.hasOwnProperty(u2) ? (i4.push({ command: Ot2.removeLayer, args: [u2] }), l2.splice(l2.lastIndexOf(u2, l2.length - d2), 1)) : d2++, m2 = l2[l2.length - h2], i4.push({ command: Ot2.addLayer, args: [s3[u2], m2] }), l2.splice(l2.length - h2, 0, u2), c2[u2] = true);
                    for (h2 = 0; h2 < a3.length; h2++)
                      if (u2 = a3[h2], _2 = n3[u2], p2 = s3[u2], !c2[u2] && !r2(_2, p2))
                        if (r2(_2.source, p2.source) && r2(_2["source-layer"], p2["source-layer"]) && r2(_2.type, p2.type)) {
                          for (f2 in Vt2(_2.layout, p2.layout, i4, u2, null, Ot2.setLayoutProperty), Vt2(_2.paint, p2.paint, i4, u2, null, Ot2.setPaintProperty), r2(_2.filter, p2.filter) || i4.push({ command: Ot2.setFilter, args: [u2, p2.filter] }), r2(_2.minzoom, p2.minzoom) && r2(_2.maxzoom, p2.maxzoom) || i4.push({ command: Ot2.setLayerZoomRange, args: [u2, p2.minzoom, p2.maxzoom] }), _2)
                            _2.hasOwnProperty(f2) && f2 !== "layout" && f2 !== "paint" && f2 !== "filter" && f2 !== "metadata" && f2 !== "minzoom" && f2 !== "maxzoom" && (f2.indexOf("paint.") === 0 ? Vt2(_2[f2], p2[f2], i4, u2, f2.slice(6), Ot2.setPaintProperty) : r2(_2[f2], p2[f2]) || i4.push({ command: Ot2.setLayerProperty, args: [u2, f2, p2[f2]] }));
                          for (f2 in p2)
                            p2.hasOwnProperty(f2) && !_2.hasOwnProperty(f2) && f2 !== "layout" && f2 !== "paint" && f2 !== "filter" && f2 !== "metadata" && f2 !== "minzoom" && f2 !== "maxzoom" && (f2.indexOf("paint.") === 0 ? Vt2(_2[f2], p2[f2], i4, u2, f2.slice(6), Ot2.setPaintProperty) : r2(_2[f2], p2[f2]) || i4.push({ command: Ot2.setLayerProperty, args: [u2, f2, p2[f2]] }));
                        } else
                          i4.push({ command: Ot2.removeLayer, args: [u2] }), m2 = l2[l2.lastIndexOf(u2) + 1], i4.push({ command: Ot2.addLayer, args: [p2, m2] });
                  }(n2, e3.layers, i3);
                } catch (t3) {
                  console.warn("Unable to compute style diff:", t3), i3 = [{ command: Ot2.setStyle, args: [e3] }];
                }
                return i3;
              }(this.serialize(), e2).filter((t2) => !(t2.command in Ue));
              if (i2.length === 0)
                return false;
              const o2 = i2.filter((t2) => !(t2.command in Oe2));
              if (o2.length > 0)
                throw new Error(`Unimplemented: ${o2.map((t2) => t2.command).join(", ")}.`);
              return i2.forEach((t2) => {
                t2.command !== "setTransition" && this[t2.command].apply(this, t2.args);
              }), this.stylesheet = e2, true;
            }
            addImage(e2, i2) {
              if (this.getImage(e2))
                return this.fire(new t.ErrorEvent(new Error("An image with this name already exists.")));
              this.imageManager.addImage(e2, i2), this._afterImageUpdated(e2);
            }
            updateImage(t2, e2) {
              this.imageManager.updateImage(t2, e2);
            }
            getImage(t2) {
              return this.imageManager.getImage(t2);
            }
            removeImage(e2) {
              if (!this.getImage(e2))
                return this.fire(new t.ErrorEvent(new Error("No image with this name exists.")));
              this.imageManager.removeImage(e2), this._afterImageUpdated(e2);
            }
            _afterImageUpdated(e2) {
              this._availableImages = this.imageManager.listImages(), this._changedImages[e2] = true, this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t.Event("data", { dataType: "style" }));
            }
            listImages() {
              return this._checkLoaded(), this.imageManager.listImages();
            }
            addSource(e2, i2, o2 = {}) {
              if (this._checkLoaded(), this.getSource(e2) !== void 0)
                throw new Error("There is already a source with this ID");
              if (!i2.type)
                throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i2).join(", ")}.`);
              if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(t.validateStyle.source, `sources.${e2}`, i2, null, o2))
                return;
              this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = true);
              const r3 = St2(e2, i2, this.dispatcher, this);
              r3.setEventedParent(this, () => ({ isSourceLoaded: this.loaded(), source: r3.serialize(), sourceId: e2 }));
              const a2 = (i3) => {
                const o3 = (i3 ? "symbol:" : "other:") + e2, a3 = this._sourceCaches[o3] = new t.SourceCache(o3, r3, i3);
                (i3 ? this._symbolSourceCaches : this._otherSourceCaches)[e2] = a3, a3.style = this, a3.onAdd(this.map);
              };
              a2(false), i2.type !== "vector" && i2.type !== "geojson" || a2(true), r3.onAdd && r3.onAdd(this.map), this._changed = true;
            }
            removeSource(e2) {
              this._checkLoaded();
              const i2 = this.getSource(e2);
              if (i2 === void 0)
                throw new Error("There is no source with this ID");
              for (const i3 in this._layers)
                if (this._layers[i3].source === e2)
                  return this.fire(new t.ErrorEvent(new Error(`Source "${e2}" cannot be removed while layer "${i3}" is using it.`)));
              if (this.terrain && this.terrain.get().source === e2)
                return this.fire(new t.ErrorEvent(new Error(`Source "${e2}" cannot be removed while terrain is using it.`)));
              const o2 = this._getSourceCaches(e2);
              for (const e3 of o2)
                delete this._sourceCaches[e3.id], delete this._updatedSources[e3.id], e3.fire(new t.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: e3.getSource().id })), e3.setEventedParent(null), e3.clearTiles();
              delete this._otherSourceCaches[e2], delete this._symbolSourceCaches[e2], i2.setEventedParent(null), i2.onRemove && i2.onRemove(this.map), this._changed = true;
            }
            setGeoJSONSourceData(t2, e2) {
              this._checkLoaded(), this.getSource(t2).setData(e2), this._changed = true;
            }
            getSource(t2) {
              const e2 = this._getSourceCache(t2);
              return e2 && e2.getSource();
            }
            addLayer(e2, i2, o2 = {}) {
              this._checkLoaded();
              const r3 = e2.id;
              if (this.getLayer(r3))
                return void this.fire(new t.ErrorEvent(new Error(`Layer with id "${r3}" already exists on this map`)));
              let a2;
              if (e2.type === "custom") {
                if (Be2(this, t.validateCustomStyleLayer(e2)))
                  return;
                a2 = t.createStyleLayer(e2);
              } else {
                if (typeof e2.source == "object" && (this.addSource(r3, e2.source), e2 = t.clone$2(e2), e2 = t.extend(e2, { source: r3 })), this._validate(t.validateStyle.layer, `layers.${r3}`, e2, { arrayIndex: -1 }, o2))
                  return;
                a2 = t.createStyleLayer(e2), this._validateLayer(a2), a2.setEventedParent(this, { layer: { id: r3 } }), this._serializedLayers[a2.id] = a2.serialize(), this._updateLayerCount(a2, true);
              }
              const n2 = i2 ? this._order.indexOf(i2) : this._order.length;
              if (i2 && n2 === -1)
                return void this.fire(new t.ErrorEvent(new Error(`Layer with id "${i2}" does not exist on this map.`)));
              this._order.splice(n2, 0, r3), this._layerOrderChanged = true, this._layers[r3] = a2;
              const s2 = this._getLayerSourceCache(a2);
              if (this._removedLayers[r3] && a2.source && s2 && a2.type !== "custom") {
                const t2 = this._removedLayers[r3];
                delete this._removedLayers[r3], t2.type !== a2.type ? this._updatedSources[a2.source] = "clear" : (this._updatedSources[a2.source] = "reload", s2.pause());
              }
              this._updateLayer(a2), a2.onAdd && a2.onAdd(this.map), this._updateDrapeFirstLayers();
            }
            moveLayer(e2, i2) {
              if (this._checkLoaded(), this._changed = true, !this._layers[e2])
                return void this.fire(new t.ErrorEvent(new Error(`The layer '${e2}' does not exist in the map's style and cannot be moved.`)));
              if (e2 === i2)
                return;
              const o2 = this._order.indexOf(e2);
              this._order.splice(o2, 1);
              const r3 = i2 ? this._order.indexOf(i2) : this._order.length;
              i2 && r3 === -1 ? this.fire(new t.ErrorEvent(new Error(`Layer with id "${i2}" does not exist on this map.`))) : (this._order.splice(r3, 0, e2), this._layerOrderChanged = true, this._updateDrapeFirstLayers());
            }
            removeLayer(e2) {
              this._checkLoaded();
              const i2 = this._layers[e2];
              if (!i2)
                return void this.fire(new t.ErrorEvent(new Error(`The layer '${e2}' does not exist in the map's style and cannot be removed.`)));
              i2.setEventedParent(null), this._updateLayerCount(i2, false);
              const o2 = this._order.indexOf(e2);
              this._order.splice(o2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e2] = i2, delete this._layers[e2], delete this._serializedLayers[e2], delete this._updatedLayers[e2], delete this._updatedPaintProps[e2], i2.onRemove && i2.onRemove(this.map), this._updateDrapeFirstLayers();
            }
            getLayer(t2) {
              return this._layers[t2];
            }
            hasLayer(t2) {
              return t2 in this._layers;
            }
            hasLayerType(t2) {
              for (const e2 in this._layers)
                if (this._layers[e2].type === t2)
                  return true;
              return false;
            }
            setLayerZoomRange(e2, i2, o2) {
              this._checkLoaded();
              const r3 = this.getLayer(e2);
              r3 ? r3.minzoom === i2 && r3.maxzoom === o2 || (i2 != null && (r3.minzoom = i2), o2 != null && (r3.maxzoom = o2), this._updateLayer(r3)) : this.fire(new t.ErrorEvent(new Error(`The layer '${e2}' does not exist in the map's style and cannot have zoom extent.`)));
            }
            setFilter(e2, i2, o2 = {}) {
              this._checkLoaded();
              const a2 = this.getLayer(e2);
              if (a2) {
                if (!r2(a2.filter, i2))
                  return i2 == null ? (a2.filter = void 0, void this._updateLayer(a2)) : void (this._validate(t.validateStyle.filter, `layers.${a2.id}.filter`, i2, null, o2) || (a2.filter = t.clone$2(i2), this._updateLayer(a2)));
              } else
                this.fire(new t.ErrorEvent(new Error(`The layer '${e2}' does not exist in the map's style and cannot be filtered.`)));
            }
            getFilter(e2) {
              return t.clone$2(this.getLayer(e2).filter);
            }
            setLayoutProperty(e2, i2, o2, a2 = {}) {
              this._checkLoaded();
              const n2 = this.getLayer(e2);
              n2 ? r2(n2.getLayoutProperty(i2), o2) || (n2.setLayoutProperty(i2, o2, a2), this._updateLayer(n2)) : this.fire(new t.ErrorEvent(new Error(`The layer '${e2}' does not exist in the map's style and cannot be styled.`)));
            }
            getLayoutProperty(e2, i2) {
              const o2 = this.getLayer(e2);
              if (o2)
                return o2.getLayoutProperty(i2);
              this.fire(new t.ErrorEvent(new Error(`The layer '${e2}' does not exist in the map's style.`)));
            }
            setPaintProperty(e2, i2, o2, a2 = {}) {
              this._checkLoaded();
              const n2 = this.getLayer(e2);
              n2 ? r2(n2.getPaintProperty(i2), o2) || (n2.setPaintProperty(i2, o2, a2) && this._updateLayer(n2), this._changed = true, this._updatedPaintProps[e2] = true) : this.fire(new t.ErrorEvent(new Error(`The layer '${e2}' does not exist in the map's style and cannot be styled.`)));
            }
            getPaintProperty(t2, e2) {
              return this.getLayer(t2).getPaintProperty(e2);
            }
            setFeatureState(e2, i2) {
              this._checkLoaded();
              const o2 = e2.source, r3 = e2.sourceLayer, a2 = this.getSource(o2);
              if (a2 === void 0)
                return void this.fire(new t.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
              const n2 = a2.type;
              if (n2 === "geojson" && r3)
                return void this.fire(new t.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
              if (n2 === "vector" && !r3)
                return void this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
              e2.id === void 0 && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided.")));
              const s2 = this._getSourceCaches(o2);
              for (const t2 of s2)
                t2.setFeatureState(r3, e2.id, i2);
            }
            removeFeatureState(e2, i2) {
              this._checkLoaded();
              const o2 = e2.source, r3 = this.getSource(o2);
              if (r3 === void 0)
                return void this.fire(new t.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
              const a2 = r3.type, n2 = a2 === "vector" ? e2.sourceLayer : void 0;
              if (a2 === "vector" && !n2)
                return void this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
              if (i2 && typeof e2.id != "string" && typeof e2.id != "number")
                return void this.fire(new t.ErrorEvent(new Error("A feature id is required to remove its specific state property.")));
              const s2 = this._getSourceCaches(o2);
              for (const t2 of s2)
                t2.removeFeatureState(n2, e2.id, i2);
            }
            getFeatureState(e2) {
              this._checkLoaded();
              const i2 = e2.source, o2 = e2.sourceLayer, r3 = this.getSource(i2);
              if (r3 !== void 0) {
                if (r3.type !== "vector" || o2)
                  return e2.id === void 0 && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), this._getSourceCaches(i2)[0].getFeatureState(o2, e2.id);
                this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
              } else
                this.fire(new t.ErrorEvent(new Error(`The source '${i2}' does not exist in the map's style.`)));
            }
            getTransition() {
              return t.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
            }
            serialize() {
              const e2 = {};
              for (const t2 in this._sourceCaches) {
                const i2 = this._sourceCaches[t2].getSource();
                e2[i2.id] || (e2[i2.id] = i2.serialize());
              }
              return t.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, terrain: this.stylesheet.terrain, fog: this.stylesheet.fog, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, sources: e2, layers: this._serializeLayers(this._order) }, (t2) => t2 !== void 0);
            }
            _updateLayer(t2) {
              this._updatedLayers[t2.id] = true;
              const e2 = this._getLayerSourceCache(t2);
              t2.source && !this._updatedSources[t2.source] && e2 && e2.getSource().type !== "raster" && (this._updatedSources[t2.source] = "reload", e2.pause()), this._changed = true;
            }
            _flattenAndSortRenderedFeatures(t2) {
              const e2 = (t3) => this._layers[t3].type === "fill-extrusion", i2 = {}, o2 = [];
              for (let r4 = this._order.length - 1; r4 >= 0; r4--) {
                const a2 = this._order[r4];
                if (e2(a2)) {
                  i2[a2] = r4;
                  for (const e3 of t2) {
                    const t3 = e3[a2];
                    if (t3)
                      for (const e4 of t3)
                        o2.push(e4);
                  }
                }
              }
              o2.sort((t3, e3) => e3.intersectionZ - t3.intersectionZ);
              const r3 = [];
              for (let a2 = this._order.length - 1; a2 >= 0; a2--) {
                const n2 = this._order[a2];
                if (e2(n2))
                  for (let t3 = o2.length - 1; t3 >= 0; t3--) {
                    const e3 = o2[t3].feature;
                    if (i2[e3.layer.id] < a2)
                      break;
                    r3.push(e3), o2.pop();
                  }
                else
                  for (const e3 of t2) {
                    const t3 = e3[n2];
                    if (t3)
                      for (const e4 of t3)
                        r3.push(e4.feature);
                  }
              }
              return r3;
            }
            queryRenderedFeatures(e2, i2, o2) {
              i2 && i2.filter && this._validate(t.validateStyle.filter, "queryRenderedFeatures.filter", i2.filter, null, i2);
              const r3 = {};
              if (i2 && i2.layers) {
                if (!Array.isArray(i2.layers))
                  return this.fire(new t.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
                for (const e3 of i2.layers) {
                  const i3 = this._layers[e3];
                  if (!i3)
                    return this.fire(new t.ErrorEvent(new Error(`The layer '${e3}' does not exist in the map's style and cannot be queried for features.`))), [];
                  r3[i3.source] = true;
                }
              }
              const a2 = [];
              i2.availableImages = this._availableImages;
              const n2 = i2 && i2.layers ? i2.layers.some((t2) => {
                const e3 = this.getLayer(t2);
                return e3 && e3.is3D();
              }) : this.has3DLayers(), s2 = D.createFromScreenPoints(e2, o2);
              for (const t2 in this._sourceCaches) {
                const e3 = this._sourceCaches[t2].getSource().id;
                i2.layers && !r3[e3] || a2.push(Mt2(this._sourceCaches[t2], this._layers, this._serializedLayers, s2, i2, o2, n2, !!this.map._showQueryGeometry));
              }
              return this.placement && a2.push(function(t2, e3, i3, o3, r4, a3, n3) {
                const s3 = {}, l2 = a3.queryRenderedSymbols(o3), c2 = [];
                for (const t3 of Object.keys(l2).map(Number))
                  c2.push(n3[t3]);
                c2.sort(Dt2);
                for (const i4 of c2) {
                  const o4 = i4.featureIndex.lookupSymbolFeatures(l2[i4.bucketInstanceId], e3, i4.bucketIndex, i4.sourceLayerIndex, r4.filter, r4.layers, r4.availableImages, t2);
                  for (const t3 in o4) {
                    const e4 = s3[t3] = s3[t3] || [], r5 = o4[t3];
                    r5.sort((t4, e5) => {
                      const o5 = i4.featureSortOrder;
                      if (o5) {
                        const i5 = o5.indexOf(t4.featureIndex);
                        return o5.indexOf(e5.featureIndex) - i5;
                      }
                      return e5.featureIndex - t4.featureIndex;
                    });
                    for (const t4 of r5)
                      e4.push(t4);
                  }
                }
                for (const e4 in s3)
                  s3[e4].forEach((o4) => {
                    const r5 = o4.feature, a4 = i3(t2[e4]).getFeatureState(r5.layer["source-layer"], r5.id);
                    r5.source = r5.layer.source, r5.layer["source-layer"] && (r5.sourceLayer = r5.layer["source-layer"]), r5.state = a4;
                  });
                return s3;
              }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), s2.screenGeometry, i2, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(a2);
            }
            querySourceFeatures(e2, i2) {
              i2 && i2.filter && this._validate(t.validateStyle.filter, "querySourceFeatures.filter", i2.filter, null, i2);
              const o2 = this._getSourceCaches(e2);
              let r3 = [];
              for (const t2 of o2)
                r3 = r3.concat(zt2(t2, i2));
              return r3;
            }
            addSourceType(t2, e2, i2) {
              return Ze2.getSourceType(t2) ? i2(new Error(`A source type called "${t2}" already exists.`)) : (Ze2.setSourceType(t2, e2), e2.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: t2, url: e2.workerSourceURL }, i2) : i2(null, null));
            }
            getLight() {
              return this.light.getLight();
            }
            setLight(e2, i2 = {}) {
              this._checkLoaded();
              const o2 = this.light.getLight();
              let a2 = false;
              for (const t2 in e2)
                if (!r2(e2[t2], o2[t2])) {
                  a2 = true;
                  break;
                }
              if (!a2)
                return;
              const n2 = { now: t.exported.now(), transition: t.extend({ duration: 300, delay: 0 }, this.stylesheet.transition) };
              this.light.setLight(e2, i2), this.light.updateTransitions(n2);
            }
            getTerrain() {
              return this.terrain ? this.terrain.get() : null;
            }
            setTerrain(e2) {
              if (this._checkLoaded(), !e2)
                return delete this.terrain, delete this.stylesheet.terrain, this.dispatcher.broadcast("enableTerrain", false), this._force3DLayerUpdate(), void (this._markersNeedUpdate = true);
              if (typeof e2.source == "object") {
                const i2 = "terrain-dem-src";
                this.addSource(i2, e2.source), e2 = t.clone$2(e2), e2 = t.extend(e2, { source: i2 });
              }
              if (!this._validate(t.validateStyle.terrain, "terrain", e2)) {
                if (this.terrain) {
                  const i2 = this.terrain, o2 = i2.get();
                  for (const a2 in e2)
                    if (!r2(e2[a2], o2[a2])) {
                      i2.set(e2), this.stylesheet.terrain = e2;
                      const o3 = { now: t.exported.now(), transition: t.extend({ duration: 0 }, this.stylesheet.transition) };
                      i2.updateTransitions(o3);
                      break;
                    }
                } else
                  this._createTerrain(e2);
                this._updateDrapeFirstLayers(), this._markersNeedUpdate = true;
              }
            }
            _createFog(e2) {
              const i2 = this.fog = new I2(e2);
              this.stylesheet.fog = e2;
              const o2 = { now: t.exported.now(), transition: t.extend({ duration: 0 }, this.stylesheet.transition) };
              i2.updateTransitions(o2);
            }
            _updateMarkersOpacity() {
              this.map._markers.length !== 0 && this.map._requestDomTask(() => {
                for (const t2 of this.map._markers)
                  t2._evaluateOpacity();
              });
            }
            getFog() {
              return this.fog ? this.fog.get() : null;
            }
            setFog(e2) {
              if (this._checkLoaded(), !e2)
                return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = true);
              if (this.fog) {
                const i2 = this.fog, o2 = i2.get();
                for (const a2 in e2)
                  if (!r2(e2[a2], o2[a2])) {
                    i2.set(e2), this.stylesheet.fog = e2;
                    const o3 = { now: t.exported.now(), transition: t.extend({ duration: 0 }, this.stylesheet.transition) };
                    i2.updateTransitions(o3);
                    break;
                  }
              } else
                this._createFog(e2);
              this._markersNeedUpdate = true;
            }
            _updateDrapeFirstLayers() {
              if (!this.map._optimizeForTerrain || !this.terrain)
                return;
              const t2 = this._order.filter((t3) => this.isLayerDraped(this._layers[t3])), e2 = this._order.filter((t3) => !this.isLayerDraped(this._layers[t3]));
              this._drapedFirstOrder = [], this._drapedFirstOrder.push(...t2), this._drapedFirstOrder.push(...e2);
            }
            _createTerrain(e2) {
              const i2 = this.terrain = new w2(e2);
              this.stylesheet.terrain = e2, this.dispatcher.broadcast("enableTerrain", true), this._force3DLayerUpdate();
              const o2 = { now: t.exported.now(), transition: t.extend({ duration: 0 }, this.stylesheet.transition) };
              i2.updateTransitions(o2);
            }
            _force3DLayerUpdate() {
              for (const t2 in this._layers) {
                const e2 = this._layers[t2];
                e2.type === "fill-extrusion" && this._updateLayer(e2);
              }
            }
            _validate(e2, i2, o2, r3, a2 = {}) {
              return (!a2 || a2.validate !== false) && Be2(this, e2.call(t.validateStyle, t.extend({ key: i2, style: this.serialize(), value: o2, styleSpec: t.spec }, r3)));
            }
            _remove() {
              this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), t.evented.off("pluginStateChange", this._rtlTextPluginCallback);
              for (const t2 in this._layers)
                this._layers[t2].setEventedParent(null);
              for (const t2 in this._sourceCaches)
                this._sourceCaches[t2].clearTiles(), this._sourceCaches[t2].setEventedParent(null);
              this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
            }
            _clearSource(t2) {
              const e2 = this._getSourceCaches(t2);
              for (const t3 of e2)
                t3.clearTiles();
            }
            _reloadSource(t2) {
              const e2 = this._getSourceCaches(t2);
              for (const t3 of e2)
                t3.resume(), t3.reload();
            }
            _updateSources(t2) {
              for (const e2 in this._sourceCaches)
                this._sourceCaches[e2].update(t2);
            }
            _generateCollisionBoxes() {
              for (const t2 in this._sourceCaches) {
                const e2 = this._sourceCaches[t2];
                e2.resume(), e2.reload();
              }
            }
            _updatePlacement(e2, i2, o2, r3, a2 = false) {
              let n2 = false, s2 = false;
              const l2 = {};
              for (const t2 of this._order) {
                const i3 = this._layers[t2];
                if (i3.type !== "symbol")
                  continue;
                if (!l2[i3.source]) {
                  const t3 = this._getLayerSourceCache(i3);
                  if (!t3)
                    continue;
                  l2[i3.source] = t3.getRenderableIds(true).map((e3) => t3.getTileByID(e3)).sort((t4, e3) => e3.tileID.overscaledZ - t4.tileID.overscaledZ || (t4.tileID.isLessThan(e3.tileID) ? -1 : 1));
                }
                const o3 = this.crossTileSymbolIndex.addLayer(i3, l2[i3.source], e2.center.lng);
                n2 = n2 || o3;
              }
              if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), a2 = a2 || this._layerOrderChanged || o2 === 0, this._layerOrderChanged && this.fire(new t.Event("neworder")), (a2 || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t.exported.now(), e2.zoom)) && (this.pauseablePlacement = new Ae2(e2, this._order, a2, i2, o2, r3, this.placement, this.fog ? this.fog.state : null), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t.exported.now()), s2 = true), n2 && this.pauseablePlacement.placement.setStale()), s2 || n2)
                for (const t2 of this._order) {
                  const e3 = this._layers[t2];
                  e3.type === "symbol" && this.placement.updateLayerOpacities(e3, l2[e3.source]);
                }
              return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t.exported.now());
            }
            _releaseSymbolFadeTiles() {
              for (const t2 in this._sourceCaches)
                this._sourceCaches[t2].releaseSymbolFadeTiles();
            }
            getImages(t2, e2, i2) {
              this.imageManager.getImages(e2.icons, i2), this._updateTilesForChangedImages();
              const o2 = (t3) => {
                t3 && t3.setDependencies(e2.tileID.key, e2.type, e2.icons);
              };
              o2(this._otherSourceCaches[e2.source]), o2(this._symbolSourceCaches[e2.source]);
            }
            getGlyphs(t2, e2, i2) {
              this.glyphManager.getGlyphs(e2.stacks, i2);
            }
            getResource(e2, i2, o2) {
              return t.makeRequest(i2, o2);
            }
            _getSourceCache(t2) {
              return this._otherSourceCaches[t2];
            }
            _getLayerSourceCache(t2) {
              return t2.type === "symbol" ? this._symbolSourceCaches[t2.source] : this._otherSourceCaches[t2.source];
            }
            _getSourceCaches(t2) {
              const e2 = [];
              return this._otherSourceCaches[t2] && e2.push(this._otherSourceCaches[t2]), this._symbolSourceCaches[t2] && e2.push(this._symbolSourceCaches[t2]), e2;
            }
            has3DLayers() {
              return this._num3DLayers > 0;
            }
            hasSymbolLayers() {
              return this._numSymbolLayers > 0;
            }
            hasCircleLayers() {
              return this._numCircleLayers > 0;
            }
          }
          Ze2.getSourceType = function(t2) {
            return Ct[t2];
          }, Ze2.setSourceType = function(t2, e2) {
            Ct[t2] = e2;
          }, Ze2.registerForPluginStateChange = t.registerForPluginStateChange;
          var Ve2 = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}\n#endif", je2 = "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}";
          let qe2 = {}, We = {};
          qe2 = Ke2("", "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\n#ifdef TERRAIN_DEM_NEAREST_FILTER\nreturn u_exaggeration*tl;\n#endif\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {float nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {return currentElevation(apos);}\n#endif\nfloat unpack_depth(vec4 rgba_depth)\n{const vec4 bit_shift=vec4(1.0/(256.0*256.0*256.0),1.0/(256.0*256.0),1.0/256.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;vec4 bounds=vec4(d,vec2(1.0)-d);h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif", true), We = Ke2("#ifdef FOG\nuniform float u_fog_temporal_offset;float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif", "#ifdef FOG\nuniform mat4 u_fog_matrix;vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", true);
          const $e2 = Ke2("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered."), Xe2 = Ve2;
          var He = { background: Ke2("uniform vec4 u_color;uniform float u_opacity;void main() {vec4 out_color=u_color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), backgroundPattern: Ke2("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_mix);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), circle: Ke2("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float height=circle_elevation(circle_center);vec4 world_center=vec4(circle_center,height,1);vec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);vec4 occlusion_world_center=vec4(circle_center,cantilevered_height,1);vec4 occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nvec4 occlusion_world_center=world_center;vec4 occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"), clippingMask: Ke2("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: Ke2("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\ngl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec3 pos=vec3(floor(a_pos*0.5)+extrude,elevation(floor(a_pos*0.5)));gl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), heatmapTexture: Ke2("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: Ke2("varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=u_matrix*vec4(a_pos,elevation(a_pos),1.0);gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Ke2("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: Ke2("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);}"), fill: Ke2("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillOutline: Ke2("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillOutlinePattern: Ke2("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=mix(color1,color2,u_fade);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillPattern: Ke2("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_fade);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillExtrusion: Ke2("varying vec4 v_color;void main() {vec4 color=v_color;\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;varying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;\n#ifdef TERRAIN\nvec2 centroid_pos=a_centroid_pos;bool flat_roof=centroid_pos.x !=0.0;float ele=elevation(pos_nx.xy);float hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);vec3 pos=vec3(pos_nx.xy,h);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);\n#else\nvec3 pos=vec3(pos_nx.xy,t > 0.0 ? height : base);gl_Position=u_matrix*vec4(pos,1);\n#endif\nfloat colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.rgb+=clamp(color.rgb*directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), fillExtrusionPattern: Ke2("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_fade);out_color=out_color*v_lighting;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;\n#ifdef TERRAIN\nvec2 centroid_pos=a_centroid_pos;bool flat_roof=centroid_pos.x !=0.0;float ele=elevation(pos_nx.xy);float hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);vec3 p=vec3(pos_nx.xy,h);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);\n#else\nvec3 p=vec3(pos_nx.xy,z);gl_Position=u_matrix*vec4(p,1);\n#endif\nvec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"), hillshadePrepare: Ke2("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos);float f=getElevation(v_pos+vec2(epsilon.x,0));float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float h=getElevation(v_pos+vec2(0,epsilon.y));float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Ke2("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), line: Ke2("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 out_color=color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), lineGradient: Ke2("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), linePattern: Ke2("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), lineSDF: Ke2("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_mix;uniform vec3 u_scale;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash_from\n#pragma mapbox: define lowp vec4 dash_to\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dash_from\n#pragma mapbox: initialize mediump vec4 dash_to\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfwidth=min(dash_from.z*u_scale.y,dash_to.z*u_scale.z);float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/sdfwidth;alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);vec4 out_color=color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform vec2 u_texsize;uniform mediump vec3 u_scale;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash_from\n#pragma mapbox: define lowp vec4 dash_to\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dash_from\n#pragma mapbox: initialize mediump vec4 dash_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nfloat tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;float scaleA=dash_from.z==0.0 ? 0.0 : tileZoomRatio/(dash_from.z*fromScale);float scaleB=dash_to.z==0.0 ? 0.0 : tileZoomRatio/(dash_to.z*toScale);float heightA=dash_from.y;float heightB=dash_to.y;v_tex_a=vec2(a_linesofar*scaleA/floorwidth,(-normal.y*heightA+dash_from.x+0.5)/u_texsize.y);v_tex_b=vec2(a_linesofar*scaleB/floorwidth,(-normal.y*heightB+dash_to.x+0.5)/u_texsize.y);v_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), raster: Ke2("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), symbolIcon: Ke2("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}float h=elevation(a_pos);vec4 projectedPoint=u_matrix*vec4(a_pos,h,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),h,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h,1.0);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0);\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\nfloat occlusion_fade=occlusionFade(projectedPoint);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projectedPoint.w <=0.0 || occlusion_fade==0.0));v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));}"), symbolSDF: Ke2("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}float h=elevation(a_pos);vec4 projectedPoint=u_matrix*vec4(a_pos,h,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),h,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h,1.0);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\nfloat occlusion_fade=occlusionFade(projectedPoint);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projectedPoint.w <=0.0 || occlusion_fade==0.0));float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), symbolTextAndIcon: Ke2("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}float h=elevation(a_pos);vec4 projectedPoint=u_matrix*vec4(a_pos,h,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),h,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h,1.0);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale);\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\nfloat occlusion_fade=occlusionFade(projectedPoint);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projectedPoint.w <=0.0 || occlusion_fade==0.0));float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"), terrainRaster: Ke2("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef FOG\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\nconst float skirtOffset=24575.0;const float wireframeOffset=0.00015;void main() {v_pos0=a_texture_pos/8192.0;float skirt=float(a_pos.x >=skirtOffset);float elevation=elevation(a_texture_pos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=u_skirt_height*u_skirt_height*wireframeOffset;\n#endif\nvec2 decodedPos=a_pos-vec2(skirt*skirtOffset,0.0);gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n}"), terrainDepth: Ke2("#ifdef GL_ES\nprecision highp float;\n#endif\nvec4 pack_depth(float ndc_z) {float depth=ndc_z*0.5+0.5;const vec4 bit_shift=vec4(256.0*256.0*256.0,256.0*256.0,256.0,1.0);const vec4 bit_mask =vec4(0.0,1.0/256.0,1.0/256.0,1.0/256.0);vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}varying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying float v_depth;void main() {float elevation=elevation(a_texture_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"), skybox: Ke2("\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", je2), skyboxGradient: Ke2("varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", je2), skyboxCapture: Ke2("\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}", "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}") };
          function Ke2(t2, e2, i2) {
            const o2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, r3 = /uniform (highp |mediump |lowp )?([\w]+) ([\w]+)([\s]*)([\w]*)/g, a2 = e2.match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g), n2 = t2.match(r3), s2 = e2.match(r3), l2 = Ve2.match(r3);
            let c2 = s2 ? s2.concat(n2) : n2;
            i2 || (qe2.staticUniforms && (c2 = qe2.staticUniforms.concat(c2)), We.staticUniforms && (c2 = We.staticUniforms.concat(c2))), c2 && (c2 = c2.concat(l2));
            const h2 = {};
            return { fragmentSource: t2 = t2.replace(o2, (t3, e3, i3, o3, r4) => (h2[r4] = true, e3 === "define" ? `
#ifndef HAS_UNIFORM_u_${r4}
varying ${i3} ${o3} ${r4};
#else
uniform ${i3} ${o3} u_${r4};
#endif
` : `
#ifdef HAS_UNIFORM_u_${r4}
    ${i3} ${o3} ${r4} = u_${r4};
#endif
`)), vertexSource: e2 = e2.replace(o2, (t3, e3, i3, o3, r4) => {
              const a3 = o3 === "float" ? "vec2" : "vec4", n3 = r4.match(/color/) ? "color" : a3;
              return h2[r4] ? e3 === "define" ? `
#ifndef HAS_UNIFORM_u_${r4}
uniform lowp float u_${r4}_t;
attribute ${i3} ${a3} a_${r4};
varying ${i3} ${o3} ${r4};
#else
uniform ${i3} ${o3} u_${r4};
#endif
` : n3 === "vec4" ? `
#ifndef HAS_UNIFORM_u_${r4}
    ${r4} = a_${r4};
#else
    ${i3} ${o3} ${r4} = u_${r4};
#endif
` : `
#ifndef HAS_UNIFORM_u_${r4}
    ${r4} = unpack_mix_${n3}(a_${r4}, u_${r4}_t);
#else
    ${i3} ${o3} ${r4} = u_${r4};
#endif
` : e3 === "define" ? `
#ifndef HAS_UNIFORM_u_${r4}
uniform lowp float u_${r4}_t;
attribute ${i3} ${a3} a_${r4};
#else
uniform ${i3} ${o3} u_${r4};
#endif
` : n3 === "vec4" ? `
#ifndef HAS_UNIFORM_u_${r4}
    ${i3} ${o3} ${r4} = a_${r4};
#else
    ${i3} ${o3} ${r4} = u_${r4};
#endif
` : `
#ifndef HAS_UNIFORM_u_${r4}
    ${i3} ${o3} ${r4} = unpack_mix_${n3}(a_${r4}, u_${r4}_t);
#else
    ${i3} ${o3} ${r4} = u_${r4};
#endif
`;
            }), staticAttributes: a2, staticUniforms: c2 };
          }
          class Ye2 {
            constructor() {
              this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
            }
            bind(t2, e2, i2, o2, r3, a2, n2, s2) {
              this.context = t2;
              let l2 = this.boundPaintVertexBuffers.length !== o2.length;
              for (let t3 = 0; !l2 && t3 < o2.length; t3++)
                this.boundPaintVertexBuffers[t3] !== o2[t3] && (l2 = true);
              t2.extVertexArrayObject && this.vao && this.boundProgram === e2 && this.boundLayoutVertexBuffer === i2 && !l2 && this.boundIndexBuffer === r3 && this.boundVertexOffset === a2 && this.boundDynamicVertexBuffer === n2 && this.boundDynamicVertexBuffer2 === s2 ? (t2.bindVertexArrayOES.set(this.vao), n2 && n2.bind(), r3 && r3.dynamicDraw && r3.bind(), s2 && s2.bind()) : this.freshBind(e2, i2, o2, r3, a2, n2, s2);
            }
            freshBind(t2, e2, i2, o2, r3, a2, n2) {
              let s2;
              const l2 = t2.numAttributes, c2 = this.context, h2 = c2.gl;
              if (c2.extVertexArrayObject)
                this.vao && this.destroy(), this.vao = c2.extVertexArrayObject.createVertexArrayOES(), c2.bindVertexArrayOES.set(this.vao), s2 = 0, this.boundProgram = t2, this.boundLayoutVertexBuffer = e2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = o2, this.boundVertexOffset = r3, this.boundDynamicVertexBuffer = a2, this.boundDynamicVertexBuffer2 = n2;
              else {
                s2 = c2.currentNumAttributes || 0;
                for (let t3 = l2; t3 < s2; t3++)
                  h2.disableVertexAttribArray(t3);
              }
              e2.enableAttributes(h2, t2);
              for (const e3 of i2)
                e3.enableAttributes(h2, t2);
              a2 && a2.enableAttributes(h2, t2), n2 && n2.enableAttributes(h2, t2), e2.bind(), e2.setVertexAttribPointers(h2, t2, r3);
              for (const e3 of i2)
                e3.bind(), e3.setVertexAttribPointers(h2, t2, r3);
              a2 && (a2.bind(), a2.setVertexAttribPointers(h2, t2, r3)), o2 && o2.bind(), n2 && (n2.bind(), n2.setVertexAttribPointers(h2, t2, r3)), c2.currentNumAttributes = l2;
            }
            destroy() {
              this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
            }
          }
          function Qe2(e2, i2) {
            const o2 = Math.pow(2, i2.canonical.z), r3 = i2.canonical.y;
            return [new t.MercatorCoordinate(0, r3 / o2).toLngLat().lat, new t.MercatorCoordinate(0, (r3 + 1) / o2).toLngLat().lat];
          }
          function Je2(e2, i2, o2, r3, a2, n2, s2) {
            const l2 = e2.context, c2 = l2.gl, h2 = o2.fbo;
            if (!h2)
              return;
            e2.prepareDrawTile(i2);
            const d2 = e2.useProgram("hillshade");
            l2.activeTexture.set(c2.TEXTURE0), c2.bindTexture(c2.TEXTURE_2D, h2.colorAttachment.get());
            const u2 = ((t2, e3, i3, o3) => {
              const r4 = i3.paint.get("hillshade-shadow-color"), a3 = i3.paint.get("hillshade-highlight-color"), n3 = i3.paint.get("hillshade-accent-color");
              let s3 = i3.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
              i3.paint.get("hillshade-illumination-anchor") === "viewport" && (s3 -= t2.transform.angle);
              const l3 = !t2.options.moving;
              return { u_matrix: o3 || t2.transform.calculateProjMatrix(e3.tileID.toUnwrapped(), l3), u_image: 0, u_latrange: Qe2(0, e3.tileID), u_light: [i3.paint.get("hillshade-exaggeration"), s3], u_shadow: r4, u_highlight: a3, u_accent: n3 };
            })(e2, o2, r3, e2.terrain ? i2.projMatrix : null);
            e2.prepareDrawProgram(l2, d2, i2.toUnwrapped()), d2.draw(l2, c2.TRIANGLES, a2, n2, s2, t.CullFaceMode.disabled, u2, r3.id, e2.rasterBoundsBuffer, e2.quadTriangleIndexBuffer, e2.rasterBoundsSegments);
          }
          function ti2(e2, i2, o2) {
            if (!i2.needsDEMTextureUpload)
              return;
            const r3 = e2.context, a2 = r3.gl;
            r3.pixelStoreUnpackPremultiplyAlpha.set(false), i2.demTexture = i2.demTexture || e2.getTileTexture(o2.stride);
            const n2 = o2.getPixels();
            i2.demTexture ? i2.demTexture.update(n2, { premultiply: false }) : i2.demTexture = new t.Texture(r3, n2, a2.RGBA, { premultiply: false }), i2.needsDEMTextureUpload = false;
          }
          function ei2(e2, i2, o2, r3, a2, n2) {
            const s2 = e2.context, l2 = s2.gl;
            if (!i2.dem)
              return;
            const c2 = i2.dem;
            if (s2.activeTexture.set(l2.TEXTURE1), ti2(e2, i2, c2), !i2.demTexture)
              return;
            i2.demTexture.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
            const h2 = c2.dim;
            s2.activeTexture.set(l2.TEXTURE0);
            let d2 = i2.fbo;
            if (!d2) {
              const e3 = new t.Texture(s2, { width: h2, height: h2, data: null }, l2.RGBA);
              e3.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), d2 = i2.fbo = s2.createFramebuffer(h2, h2, true), d2.colorAttachment.set(e3.texture);
            }
            s2.bindFramebuffer.set(d2.framebuffer), s2.viewport.set([0, 0, h2, h2]), e2.useProgram("hillshadePrepare").draw(s2, l2.TRIANGLES, r3, a2, n2, t.CullFaceMode.disabled, ((e3, i3) => {
              const o3 = i3.stride, r4 = t.create$1();
              return t.ortho(r4, 0, t.EXTENT, -t.EXTENT, 0, 0, 1), t.translate(r4, r4, [0, -t.EXTENT, 0]), { u_matrix: r4, u_image: 1, u_dimension: [o3, o3], u_zoom: e3.overscaledZ, u_unpack: i3.unpackVector };
            })(i2.tileID, c2), o2.id, e2.rasterBoundsBuffer, e2.quadTriangleIndexBuffer, e2.rasterBoundsSegments), i2.needsHillshadePrepare = false;
          }
          const ii2 = (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_image0: new t.Uniform1i(e2, i2.u_image0), u_skirt_height: new t.Uniform1f(e2, i2.u_skirt_height) }), oi2 = (t2, e2) => ({ u_matrix: t2, u_image0: 0, u_skirt_height: e2 }), ri = new class {
            constructor() {
              this.operations = {};
            }
            newMorphing(t2, e2, i2, o2, r3) {
              if (t2 in this.operations) {
                const e3 = this.operations[t2];
                e3.to.tileID.key !== i2.tileID.key && (e3.queued = i2);
              } else
                this.operations[t2] = { startTime: o2, phase: 0, duration: r3, from: e2, to: i2, queued: null };
            }
            getMorphValuesForProxy(t2) {
              if (!(t2 in this.operations))
                return null;
              const e2 = this.operations[t2];
              return { from: e2.from, to: e2.to, phase: e2.phase };
            }
            update(t2) {
              for (const e2 in this.operations) {
                const i2 = this.operations[e2];
                for (i2.phase = (t2 - i2.startTime) / i2.duration; i2.phase >= 1 || !this._validOp(i2); )
                  if (!this._nextOp(i2, t2)) {
                    delete this.operations[e2];
                    break;
                  }
              }
            }
            _nextOp(t2, e2) {
              return !!t2.queued && (t2.from = t2.to, t2.to = t2.queued, t2.queued = null, t2.phase = 0, t2.startTime = e2, true);
            }
            _validOp(t2) {
              return t2.from.hasData() && t2.to.hasData();
            }
          }(), ai2 = { 0: null, 1: "TERRAIN_VERTEX_MORPHING", 2: "TERRAIN_WIREFRAME" };
          function ni2(t2, e2) {
            const i2 = 1 << t2.z;
            return !e2 && (t2.x === 0 || t2.x === i2 - 1) || t2.y === 0 || t2.y === i2 - 1;
          }
          const si = (t2) => ({ u_matrix: t2 });
          function li2(e2, i2, o2, r3, a2) {
            if (a2 > 0) {
              const n2 = t.exported.now(), s2 = (n2 - e2.timeAdded) / a2, l2 = i2 ? (n2 - i2.timeAdded) / a2 : -1, c2 = o2.getSource(), h2 = r3.coveringZoomLevel({ tileSize: c2.tileSize, roundZoom: c2.roundZoom }), d2 = !i2 || Math.abs(i2.tileID.overscaledZ - h2) > Math.abs(e2.tileID.overscaledZ - h2), u2 = d2 && e2.refreshedUponExpiration ? 1 : t.clamp(d2 ? s2 : 1 - l2, 0, 1);
              return e2.refreshedUponExpiration && s2 >= 1 && (e2.refreshedUponExpiration = false), i2 ? { opacity: 1, mix: 1 - u2 } : { opacity: u2, mix: 0 };
            }
            return { opacity: 1, mix: 0 };
          }
          class ci2 extends t.SourceCache {
            constructor(t2) {
              const e2 = St2("proxy", { type: "geojson", maxzoom: t2.transform.maxZoom }, new M2(kt2(), null), t2.style);
              super("proxy", e2, false), e2.setEventedParent(this), this.map = this.getSource().map = t2, this.used = this._sourceLoaded = true, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
            }
            update(e2, i2, o2) {
              if (e2.freezeTileCoverage)
                return;
              this.transform = e2;
              const r3 = e2.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((i3, o3) => {
                if (i3[o3.key] = "", !this._tiles[o3.key]) {
                  const i4 = new t.Tile(o3, this._source.tileSize * o3.overscaleFactor(), e2.tileZoom);
                  i4.state = "loaded", this._tiles[o3.key] = i4;
                }
                return i3;
              }, {});
              for (const t2 in this._tiles)
                t2 in r3 || (this.freeFBO(t2), this._tiles[t2].state = "unloaded", delete this._tiles[t2]);
            }
            freeFBO(t2) {
              const e2 = this.proxyCachedFBO[t2];
              if (e2 !== void 0) {
                const i2 = Object.values(e2);
                this.renderCachePool.push(...i2), delete this.proxyCachedFBO[t2];
              }
            }
            deallocRenderCache() {
              this.renderCache.forEach((t2) => t2.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
            }
          }
          class hi extends t.OverscaledTileID {
            constructor(t2, e2, i2) {
              super(t2.overscaledZ, t2.wrap, t2.canonical.z, t2.canonical.x, t2.canonical.y), this.proxyTileKey = e2, this.projMatrix = i2;
            }
          }
          class di extends t.Elevation {
            constructor(e2, i2) {
              super(), this.painter = e2, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
              const [o2, r3, a2] = function(e3) {
                const i3 = new t.StructArrayLayout4i8(), o3 = new t.StructArrayLayout3ui6(), r4 = 131;
                i3.reserve(17161), o3.reserve(33800);
                const a3 = t.EXTENT / 128, n3 = t.EXTENT + a3 / 2, s3 = n3 + a3;
                for (let e4 = -a3; e4 < s3; e4 += a3)
                  for (let o4 = -a3; o4 < s3; o4 += a3) {
                    const r5 = o4 < 0 || o4 > n3 || e4 < 0 || e4 > n3 ? 24575 : 0, a4 = t.clamp(Math.round(o4), 0, t.EXTENT), s4 = t.clamp(Math.round(e4), 0, t.EXTENT);
                    i3.emplaceBack(a4 + r5, s4, a4, s4);
                  }
                const l2 = (t2, e4) => {
                  const i4 = e4 * r4 + t2;
                  o3.emplaceBack(i4 + 1, i4, i4 + r4), o3.emplaceBack(i4 + r4, i4 + r4 + 1, i4 + 1);
                };
                for (let t2 = 1; t2 < 129; t2++)
                  for (let e4 = 1; e4 < 129; e4++)
                    l2(e4, t2);
                return [0, 129].forEach((t2) => {
                  for (let e4 = 0; e4 < 130; e4++)
                    l2(e4, t2), l2(t2, e4);
                }), [i3, o3, 32768];
              }(), n2 = e2.context;
              this.gridBuffer = n2.createVertexBuffer(o2, Tt2.members), this.gridIndexBuffer = n2.createIndexBuffer(r3), this.gridSegments = t.SegmentVector.simpleSegment(0, 0, o2.length, r3.length), this.gridNoSkirtSegments = t.SegmentVector.simpleSegment(0, 0, o2.length, a2), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new ci2(i2.map), this.orthoMatrix = t.create$1(), t.ortho(this.orthoMatrix, 0, t.EXTENT, 0, t.EXTENT, 0, 1);
              const s2 = n2.gl;
              this._overlapStencilMode = new t.StencilMode({ func: s2.GEQUAL, mask: 255 }, 0, 255, s2.KEEP, s2.KEEP, s2.REPLACE), this._previousZoom = e2.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i2, this._useVertexMorphing = true, this._exaggeration = 1;
            }
            set style(t2) {
              t2.on("data", this._onStyleDataEvent.bind(this)), t2.on("neworder", this._checkRenderCacheEfficiency.bind(this)), this._style = t2, this._checkRenderCacheEfficiency();
            }
            update(e2, i2, o2) {
              if (e2 && e2.terrain) {
                this._style !== e2 && (this.style = e2), this.enabled = true;
                const r3 = e2.terrain.properties;
                this.sourceCache = e2._getSourceCache(r3.get("source")), this._exaggeration = r3.get("exaggeration");
                const a2 = () => {
                  this.sourceCache.used && t.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                  const e3 = this.sourceCache.getSource().tileSize / 128, o3 = this.proxySourceCache.getSource().tileSize;
                  this.sourceCache.update(i2, e3 * o3, true), this._findCoveringTileCache[this.sourceCache.id] = {};
                };
                this.sourceCache.usedForTerrain || (this._findCoveringTileCache[this.sourceCache.id] = {}, this.sourceCache.usedForTerrain = true, a2(), this._initializing = true), a2(), i2.updateElevation(!o2), this._findCoveringTileCache[this.proxySourceCache.id] = {}, this.proxySourceCache.update(i2), this._emptyDEMTextureDirty = true;
              } else
                this._disable();
            }
            _checkRenderCacheEfficiency() {
              const e2 = this.renderCacheEfficiency(this._style);
              this._style.map._optimizeForTerrain || e2.efficiency !== 100 && t.warnOnce(`Terrain render cache efficiency is not optimal (${e2.efficiency}%) and performance
                may be affected negatively, consider placing all background, fill and line layers before layer
                with id '${e2.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`);
            }
            _onStyleDataEvent(t2) {
              t2.coord && t2.dataType === "source" ? this._clearRenderCacheForTile(t2.sourceCacheId, t2.coord) : t2.dataType === "style" && (this._invalidateRenderCache = true);
            }
            _disable() {
              if (this.enabled && (this.enabled = false, this._sharedDepthStencil = void 0, this.proxySourceCache.deallocRenderCache(), this._style))
                for (const t2 in this._style._sourceCaches)
                  this._style._sourceCaches[t2].usedForTerrain = false;
            }
            destroy() {
              this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this.pool.forEach((t2) => t2.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), delete this._depthFBO, delete this._depthTexture);
            }
            _source() {
              return this.enabled ? this.sourceCache : null;
            }
            exaggeration() {
              return this._exaggeration;
            }
            get visibleDemTiles() {
              return this._visibleDemTiles;
            }
            get drapeBufferSize() {
              const t2 = 2 * this.proxySourceCache.getSource().tileSize;
              return [t2, t2];
            }
            set useVertexMorphing(t2) {
              this._useVertexMorphing = t2;
            }
            updateTileBinding(e2) {
              if (!this.enabled)
                return;
              this.prevTerrainTileForTile = this.terrainTileForTile;
              const i2 = this.proxySourceCache, o2 = this.painter.transform;
              this._initializing && (this._initializing = o2._centerAltitude === 0 && this.getAtPointOrZero(t.MercatorCoordinate.fromLngLat(o2.center), -1) === -1, this._emptyDEMTextureDirty = !this._initializing);
              const r3 = this.proxyCoords = i2.getIds().map((t2) => {
                const e3 = i2.getTileByID(t2).tileID;
                return e3.projMatrix = o2.calculateProjMatrix(e3.toUnwrapped()), e3;
              });
              !function(e3, i3) {
                const o3 = i3.transform.pointCoordinate(i3.transform.getCameraPoint()), r4 = new t.pointGeometry(o3.x, o3.y);
                e3.sort((e4, i4) => {
                  if (i4.overscaledZ - e4.overscaledZ)
                    return i4.overscaledZ - e4.overscaledZ;
                  const o4 = new t.pointGeometry(e4.canonical.x + (1 << e4.canonical.z) * e4.wrap, e4.canonical.y), a3 = new t.pointGeometry(i4.canonical.x + (1 << i4.canonical.z) * i4.wrap, i4.canonical.y), n3 = r4.mult(1 << e4.canonical.z);
                  return n3.x -= 0.5, n3.y -= 0.5, n3.distSqr(o4) - n3.distSqr(a3);
                });
              }(r3, this.painter), this._previousZoom = o2.zoom;
              const a2 = this.proxyToSource || {};
              this.proxyToSource = {}, r3.forEach((t2) => {
                this.proxyToSource[t2.key] = {};
              }), this.terrainTileForTile = {};
              const n2 = this._style._sourceCaches;
              for (const t2 in n2) {
                const i3 = n2[t2];
                if (!i3.used)
                  continue;
                if (i3 !== this.sourceCache && (this._findCoveringTileCache[i3.id] = {}), this._setupProxiedCoordsForOrtho(i3, e2[t2], a2), i3.usedForTerrain)
                  continue;
                const o3 = e2[t2];
                i3.getSource().reparseOverscaled && this._assignTerrainTiles(o3);
              }
              this.proxiedCoords[i2.id] = r3.map((t2) => new hi(t2, t2.key, this.orthoMatrix)), this._assignTerrainTiles(r3), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(a2), this.renderingToTexture = false, this._updateTimestamp = t.exported.now();
              const s2 = {};
              this._visibleDemTiles = [];
              for (const t2 of this.proxyCoords) {
                const e3 = this.terrainTileForTile[t2.key];
                if (!e3)
                  continue;
                const i3 = e3.tileID.key;
                i3 in s2 || (this._visibleDemTiles.push(e3), s2[i3] = i3);
              }
            }
            _assignTerrainTiles(t2) {
              this._initializing || t2.forEach((t3) => {
                if (this.terrainTileForTile[t3.key])
                  return;
                const e2 = this._findTileCoveringTileID(t3, this.sourceCache);
                e2 && (this.terrainTileForTile[t3.key] = e2);
              });
            }
            _prepareDEMTextures() {
              const t2 = this.painter.context, e2 = t2.gl;
              for (const i2 in this.terrainTileForTile) {
                const o2 = this.terrainTileForTile[i2], r3 = o2.dem;
                !r3 || o2.demTexture && !o2.needsDEMTextureUpload || (t2.activeTexture.set(e2.TEXTURE1), ti2(this.painter, o2, r3));
              }
            }
            _prepareDemTileUniforms(t2, e2, i2, o2) {
              if (!e2 || e2.demTexture == null)
                return false;
              const r3 = t2.tileID.canonical, a2 = Math.pow(2, e2.tileID.canonical.z - r3.z), n2 = o2 || "";
              return i2[`u_dem_tl${n2}`] = [r3.x * a2 % 1, r3.y * a2 % 1], i2[`u_dem_scale${n2}`] = a2, true;
            }
            get emptyDEMTexture() {
              return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
            }
            _getLoadedAreaMinimum() {
              let t2 = 0;
              const e2 = this._visibleDemTiles.reduce((e3, i2) => {
                if (!i2.dem)
                  return e3;
                const o2 = i2.dem.tree.minimums[0];
                return o2 > 0 && t2++, e3 + o2;
              }, 0);
              return t2 ? e2 / t2 : 0;
            }
            _updateEmptyDEMTexture() {
              const e2 = this.painter.context, i2 = e2.gl;
              e2.activeTexture.set(i2.TEXTURE2);
              const o2 = this._getLoadedAreaMinimum(), r3 = { width: 1, height: 1, data: new Uint8Array(t.DEMData.pack(o2, this.sourceCache.getSource().encoding)) };
              this._emptyDEMTextureDirty = false;
              let a2 = this._emptyDEMTexture;
              return a2 ? a2.update(r3, { premultiply: false }) : a2 = this._emptyDEMTexture = new t.Texture(e2, r3, i2.RGBA, { premultiply: false }), a2;
            }
            setupElevationDraw(e2, i2, o2) {
              const r3 = this.painter.context, a2 = r3.gl, n2 = (s2 = this.sourceCache.getSource().encoding, { u_dem: 2, u_dem_prev: 4, u_dem_unpack: t.DEMData.getUnpackVector(s2), u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_exaggeration: 0 });
              var s2;
              n2.u_dem_size = this.sourceCache.getSource().tileSize, n2.u_exaggeration = this.exaggeration();
              let l2 = null, c2 = null, h2 = 1;
              if (o2 && o2.morphing && this._useVertexMorphing) {
                const t2 = o2.morphing.srcDemTile, i3 = o2.morphing.dstDemTile;
                h2 = o2.morphing.phase, t2 && i3 && (this._prepareDemTileUniforms(e2, t2, n2, "_prev") && (c2 = t2), this._prepareDemTileUniforms(e2, i3, n2) && (l2 = i3));
              }
              if (c2 && l2 ? (r3.activeTexture.set(a2.TEXTURE2), l2.demTexture.bind(a2.NEAREST, a2.CLAMP_TO_EDGE, a2.NEAREST), r3.activeTexture.set(a2.TEXTURE4), c2.demTexture.bind(a2.NEAREST, a2.CLAMP_TO_EDGE, a2.NEAREST), n2.u_dem_lerp = h2) : (l2 = this.terrainTileForTile[e2.tileID.key], r3.activeTexture.set(a2.TEXTURE2), (this._prepareDemTileUniforms(e2, l2, n2) ? l2.demTexture : this.emptyDEMTexture).bind(a2.NEAREST, a2.CLAMP_TO_EDGE, a2.NEAREST)), o2 && o2.useDepthForOcclusion && (r3.activeTexture.set(a2.TEXTURE3), this._depthTexture.bind(a2.NEAREST, a2.CLAMP_TO_EDGE, a2.NEAREST), n2.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height]), o2 && o2.useMeterToDem && l2) {
                const e3 = (1 << l2.tileID.canonical.z) * t.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
                n2.u_meter_to_dem = e3;
              }
              o2 && o2.labelPlaneMatrixInv && (n2.u_label_plane_matrix_inv = o2.labelPlaneMatrixInv), i2.setTerrainUniformValues(r3, n2);
            }
            renderToBackBuffer(e2) {
              const i2 = this.painter, o2 = this.painter.context;
              e2.length !== 0 && (o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), this.renderingToTexture = false, function(e3, i3, o3, r3, a2) {
                const n2 = e3.context, s2 = n2.gl;
                let l2, c2;
                const h2 = e3.options.showTerrainWireframe ? 2 : 0, d2 = (t2, i4) => {
                  if (c2 === t2)
                    return;
                  const o4 = [ai2[t2]];
                  i4 && o4.push(ai2[h2]), l2 = e3.useProgram("terrainRaster", null, o4), c2 = t2;
                }, u2 = e3.colorModeForRenderPass(), _2 = new t.DepthMode(s2.LEQUAL, t.DepthMode.ReadWrite, e3.depthRangeFor3D);
                ri.update(a2);
                const p2 = e3.transform, m2 = 6 * Math.pow(1.5, 22 - p2.zoom) * i3.exaggeration();
                (h2 ? [false, true] : [false]).forEach((h3) => {
                  c2 = -1;
                  const f2 = h3 ? s2.LINES : s2.TRIANGLES, [g2, v2] = h3 ? i3.getWirefameBuffer() : [i3.gridIndexBuffer, i3.gridSegments];
                  for (const c3 of r3) {
                    const r4 = o3.getTile(c3), b2 = t.StencilMode.disabled, w3 = i3.prevTerrainTileForTile[c3.key], T2 = i3.terrainTileForTile[c3.key];
                    y2 = T2, (x3 = w3) != null && y2 != null && x3.hasData() && y2.hasData() && x3.demTexture != null && y2.demTexture != null && x3.tileID.key !== y2.tileID.key && ri.newMorphing(c3.key, w3, T2, a2, 250), n2.activeTexture.set(s2.TEXTURE0), r4.texture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE, s2.LINEAR_MIPMAP_NEAREST);
                    const E2 = ri.getMorphValuesForProxy(c3.key), C2 = E2 ? 1 : 0;
                    let S2;
                    E2 && (S2 = { morphing: { srcDemTile: E2.from, dstDemTile: E2.to, phase: t.easeCubicInOut(E2.phase) } });
                    const I3 = oi2(c3.projMatrix, ni2(c3.canonical, p2.renderWorldCopies) ? m2 / 10 : m2);
                    d2(C2, h3), i3.setupElevationDraw(r4, l2, S2), e3.prepareDrawProgram(n2, l2, c3.toUnwrapped()), l2.draw(n2, f2, _2, b2, u2, t.CullFaceMode.backCCW, I3, "terrain_raster", i3.gridBuffer, g2, v2);
                  }
                  var x3, y2;
                });
              }(i2, this, this.proxySourceCache, e2, this._updateTimestamp), this.renderingToTexture = true, e2.splice(0, e2.length));
            }
            renderBatch(e2) {
              if (this._drapedRenderBatches.length === 0)
                return e2 + 1;
              this.renderingToTexture = true;
              const i2 = this.painter, o2 = this.painter.context, r3 = this.proxySourceCache, a2 = this.proxiedCoords[r3.id], n2 = this._drapedRenderBatches.shift(), s2 = [], l2 = i2.style.order;
              let c2 = 0;
              for (const h2 of a2) {
                const a3 = r3.getTileByID(h2.proxyTileKey), d2 = r3.proxyCachedFBO[h2.key] ? r3.proxyCachedFBO[h2.key][e2] : void 0, u2 = d2 !== void 0 ? r3.renderCache[d2] : this.pool[c2++], _2 = d2 !== void 0;
                if (a3.texture = u2.tex, _2 && !u2.dirty) {
                  s2.push(a3.tileID);
                  continue;
                }
                let p2;
                o2.bindFramebuffer.set(u2.fb.framebuffer), this.renderedToTile = false, u2.dirty && (o2.clear({ color: t.Color.transparent }), u2.dirty = false);
                for (let t2 = n2.start; t2 <= n2.end; ++t2) {
                  const e3 = i2.style._layers[l2[t2]];
                  if (e3.isHidden(i2.transform.zoom))
                    continue;
                  const r4 = i2.style._getLayerSourceCache(e3), a4 = r4 ? this.proxyToSource[h2.key][r4.id] : [h2];
                  if (!a4)
                    continue;
                  const n3 = a4;
                  o2.viewport.set([0, 0, u2.fb.width, u2.fb.height]), p2 !== (r4 ? r4.id : null) && (this._setupStencil(u2, a4, e3, r4), p2 = r4 ? r4.id : null), i2.renderLayer(i2, r4, e3, n3);
                }
                this.renderedToTile ? (u2.dirty = true, s2.push(a3.tileID)) : _2 || --c2, c2 === 5 && (c2 = 0, this.renderToBackBuffer(s2));
              }
              return this.renderToBackBuffer(s2), this.renderingToTexture = false, o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), n2.end + 1;
            }
            postRender() {
            }
            renderCacheEfficiency(t2) {
              const e2 = t2.order.length;
              if (e2 === 0)
                return { efficiency: 100 };
              let i2, o2 = 0, r3 = 0, a2 = false;
              for (let n2 = 0; n2 < e2; ++n2) {
                const e3 = t2._layers[t2.order[n2]];
                this._style.isLayerDraped(e3) ? (a2 && ++o2, ++r3) : a2 || (a2 = true, i2 = e3.id);
              }
              return r3 === 0 ? { efficiency: 100 } : { efficiency: 100 * (1 - o2 / r3), firstUndrapedLayer: i2 };
            }
            getMinElevationBelowMSL() {
              let t2 = 0;
              return this._visibleDemTiles.filter((t3) => t3.dem).forEach((e2) => {
                t2 = Math.min(t2, e2.dem.tree.minimums[0]);
              }), t2 === 0 ? t2 : (t2 - 30) * this._exaggeration;
            }
            raycast(t2, e2, i2) {
              if (!this._visibleDemTiles)
                return null;
              const o2 = this._visibleDemTiles.filter((t3) => t3.dem).map((o3) => {
                const r3 = o3.tileID, a2 = Math.pow(2, r3.overscaledZ), { x: n2, y: s2 } = r3.canonical, l2 = n2 / a2, c2 = (n2 + 1) / a2, h2 = s2 / a2, d2 = (s2 + 1) / a2;
                return { minx: l2, miny: h2, maxx: c2, maxy: d2, t: o3.dem.tree.raycastRoot(l2, h2, c2, d2, t2, e2, i2), tile: o3 };
              });
              o2.sort((t3, e3) => (t3.t !== null ? t3.t : Number.MAX_VALUE) - (e3.t !== null ? e3.t : Number.MAX_VALUE));
              for (const r3 of o2) {
                if (r3.t == null)
                  return null;
                const o3 = r3.tile.dem.tree.raycast(r3.minx, r3.miny, r3.maxx, r3.maxy, t2, e2, i2);
                if (o3 != null)
                  return o3;
              }
              return null;
            }
            _createFBO() {
              const e2 = this.painter.context, i2 = e2.gl, o2 = this.drapeBufferSize;
              e2.activeTexture.set(i2.TEXTURE0);
              const r3 = new t.Texture(e2, { width: o2[0], height: o2[1], data: null }, i2.RGBA);
              r3.bind(i2.LINEAR, i2.CLAMP_TO_EDGE);
              const a2 = e2.createFramebuffer(o2[0], o2[1], false);
              return a2.colorAttachment.set(r3.texture), a2.depthAttachment = new vt2(e2, a2.framebuffer), this._sharedDepthStencil === void 0 ? (this._sharedDepthStencil = e2.createRenderbuffer(e2.gl.DEPTH_STENCIL, o2[0], o2[1]), this._stencilRef = 0, a2.depthAttachment.set(this._sharedDepthStencil), e2.clear({ stencil: 0 })) : a2.depthAttachment.set(this._sharedDepthStencil), e2.extTextureFilterAnisotropic && !e2.extTextureFilterAnisotropicForceOff && i2.texParameterf(i2.TEXTURE_2D, e2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, e2.extTextureFilterAnisotropicMax), { fb: a2, tex: r3, dirty: false };
            }
            _initFBOPool() {
              for (; this.pool.length < Math.min(5, this.proxyCoords.length); )
                this.pool.push(this._createFBO());
            }
            _shouldDisableRenderCache() {
              if (this._style.light && this._style.light.hasTransition())
                return true;
              for (const t2 in this._style._sourceCaches)
                if (this._style._sourceCaches[t2].hasTransition())
                  return true;
              return this._style.order.some((t2) => {
                const e2 = this._style._layers[t2], i2 = e2.isHidden(this.painter.transform.zoom), o2 = e2.getCrossfadeParameters(), r3 = !!o2 && o2.t !== 1, a2 = e2.hasTransition();
                return e2.type !== "custom" && !i2 && (r3 || a2);
              });
            }
            _clearRasterFadeFromRenderCache() {
              let t2 = false;
              for (const e2 in this._style._sourceCaches)
                if (this._style._sourceCaches[e2]._source instanceof bt2) {
                  t2 = true;
                  break;
                }
              if (t2)
                for (let t3 = 0; t3 < this._style.order.length; ++t3) {
                  const e2 = this._style._layers[this._style.order[t3]], i2 = e2.isHidden(this.painter.transform.zoom), o2 = this._style._getLayerSourceCache(e2);
                  if (e2.type !== "raster" || i2 || !o2)
                    continue;
                  const r3 = e2.paint.get("raster-fade-duration");
                  for (const t4 of this.proxyCoords) {
                    const e3 = this.proxyToSource[t4.key][o2.id];
                    if (e3)
                      for (const t5 of e3) {
                        const e4 = li2(o2.getTile(t5), o2.findLoadedParent(t5, 0), o2, this.painter.transform, r3);
                        (e4.opacity !== 1 || e4.mix !== 0) && this._clearRenderCacheForTile(o2.id, t5);
                      }
                  }
                }
            }
            _setupDrapedRenderBatches() {
              const t2 = this._style.order, e2 = t2.length;
              if (e2 === 0)
                return;
              const i2 = [];
              let o2, r3 = 0, a2 = this._style._layers[t2[r3]];
              for (; !this._style.isLayerDraped(a2) && a2.isHidden(this.painter.transform.zoom) && ++r3 < e2; )
                a2 = this._style._layers[t2[r3]];
              for (; r3 < e2; ++r3) {
                const e3 = this._style._layers[t2[r3]];
                e3.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(e3) ? o2 === void 0 && (o2 = r3) : o2 !== void 0 && (i2.push({ start: o2, end: r3 - 1 }), o2 = void 0));
              }
              o2 !== void 0 && i2.push({ start: o2, end: r3 - 1 }), this._drapedRenderBatches = i2;
            }
            _setupRenderCache(t2) {
              const e2 = this.proxySourceCache;
              if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {
                if (this._invalidateRenderCache = false, e2.renderCache.length > e2.renderCachePool.length) {
                  const t3 = Object.values(e2.proxyCachedFBO);
                  e2.proxyCachedFBO = {};
                  for (let i3 = 0; i3 < t3.length; ++i3) {
                    const o3 = Object.values(t3[i3]);
                    e2.renderCachePool.push(...o3);
                  }
                }
                return;
              }
              this._clearRasterFadeFromRenderCache();
              const i2 = this.proxyCoords, o2 = this._tilesDirty;
              for (let r4 = i2.length - 1; r4 >= 0; r4--) {
                const a2 = i2[r4];
                if (e2.getTileByID(a2.key), e2.proxyCachedFBO[a2.key] !== void 0) {
                  const i3 = t2[a2.key], r5 = this.proxyToSource[a2.key];
                  let n2 = 0;
                  for (const t3 in r5) {
                    const e3 = r5[t3], a3 = i3[t3];
                    if (!a3 || a3.length !== e3.length || e3.some((e4, i4) => e4 !== a3[i4] || o2[t3] && o2[t3].hasOwnProperty(e4.key))) {
                      n2 = -1;
                      break;
                    }
                    ++n2;
                  }
                  for (const t3 in e2.proxyCachedFBO[a2.key])
                    e2.renderCache[e2.proxyCachedFBO[a2.key][t3]].dirty = n2 < 0 || n2 !== Object.values(i3).length;
                }
              }
              const r3 = [...this._drapedRenderBatches];
              r3.sort((t3, e3) => e3.end - e3.start - (t3.end - t3.start));
              for (const t3 of r3)
                for (const o3 of i2) {
                  if (e2.proxyCachedFBO[o3.key])
                    continue;
                  let i3 = e2.renderCachePool.pop();
                  i3 === void 0 && e2.renderCache.length < 50 && (i3 = e2.renderCache.length, e2.renderCache.push(this._createFBO())), i3 !== void 0 && (e2.proxyCachedFBO[o3.key] = {}, e2.proxyCachedFBO[o3.key][t3.start] = i3, e2.renderCache[i3].dirty = true);
                }
              this._tilesDirty = {};
            }
            _setupStencil(t2, e2, i2, o2) {
              if (!o2 || !this._sourceTilesOverlap[o2.id])
                return void (this._overlapStencilType && (this._overlapStencilType = false));
              const r3 = this.painter.context, a2 = r3.gl;
              if (e2.length <= 1)
                return void (this._overlapStencilType = false);
              let n2;
              if (i2.isTileClipped())
                n2 = e2.length, this._overlapStencilMode.test = { func: a2.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
              else {
                if (!(e2[0].overscaledZ > e2[e2.length - 1].overscaledZ))
                  return void (this._overlapStencilType = false);
                n2 = 1, this._overlapStencilMode.test = { func: a2.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
              }
              this._stencilRef + n2 > 255 && (r3.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += n2, this._overlapStencilMode.ref = this._stencilRef, i2.isTileClipped() && this._renderTileClippingMasks(e2, this._overlapStencilMode.ref);
            }
            stencilModeForRTTOverlap(e2) {
              return this.renderingToTexture && this._overlapStencilType ? (this._overlapStencilType === "Clip" && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[e2.key]), this._overlapStencilMode) : t.StencilMode.disabled;
            }
            _renderTileClippingMasks(e2, i2) {
              const o2 = this.painter, r3 = this.painter.context, a2 = r3.gl;
              o2._tileClippingMaskIDs = {}, r3.setColorMode(t.ColorMode.disabled), r3.setDepthMode(t.DepthMode.disabled);
              const n2 = o2.useProgram("clippingMask");
              for (const s2 of e2) {
                const e3 = o2._tileClippingMaskIDs[s2.key] = --i2;
                n2.draw(r3, a2.TRIANGLES, t.DepthMode.disabled, new t.StencilMode({ func: a2.ALWAYS, mask: 0 }, e3, 255, a2.KEEP, a2.KEEP, a2.REPLACE), t.ColorMode.disabled, t.CullFaceMode.disabled, si(s2.projMatrix), "$clipping", o2.tileExtentBuffer, o2.quadTriangleIndexBuffer, o2.tileExtentSegments);
              }
            }
            pointCoordinate(e2) {
              const i2 = this.painter.transform;
              if (e2.x < 0 || e2.x > i2.width || e2.y < 0 || e2.y > i2.height)
                return null;
              const o2 = [e2.x, e2.y, 1, 1];
              t.transformMat4(o2, o2, i2.pixelMatrixInverse), t.scale$2(o2, o2, 1 / o2[3]), o2[0] /= i2.worldSize, o2[1] /= i2.worldSize;
              const r3 = i2._camera.position, a2 = t.mercatorZfromAltitude(1, i2.center.lat), n2 = [r3[0], r3[1], r3[2] / a2, 0], s2 = t.subtract([], o2.slice(0, 3), n2);
              t.normalize(s2, s2);
              const l2 = this.raycast(n2, s2, this._exaggeration);
              return l2 !== null && l2 ? (t.scaleAndAdd(n2, n2, s2, l2), n2[3] = n2[2], n2[2] *= a2, n2) : null;
            }
            drawDepth() {
              const e2 = this.painter, i2 = e2.context, o2 = this.proxySourceCache, r3 = Math.ceil(e2.width), a2 = Math.ceil(e2.height);
              if (!this._depthFBO || this._depthFBO.width === r3 && this._depthFBO.height === a2 || (this._depthFBO.destroy(), delete this._depthFBO, delete this._depthTexture), !this._depthFBO) {
                const e3 = i2.gl, o3 = i2.createFramebuffer(r3, a2, true);
                i2.activeTexture.set(e3.TEXTURE0);
                const n2 = new t.Texture(i2, { width: r3, height: a2, data: null }, e3.RGBA);
                n2.bind(e3.NEAREST, e3.CLAMP_TO_EDGE), o3.colorAttachment.set(n2.texture);
                const s2 = i2.createRenderbuffer(i2.gl.DEPTH_COMPONENT16, r3, a2);
                o3.depthAttachment.set(s2), this._depthFBO = o3, this._depthTexture = n2;
              }
              i2.bindFramebuffer.set(this._depthFBO.framebuffer), i2.viewport.set([0, 0, r3, a2]), function(e3, i3, o3, r4) {
                const a3 = e3.context, n2 = a3.gl;
                a3.clear({ depth: 1 });
                const s2 = e3.useProgram("terrainDepth"), l2 = new t.DepthMode(n2.LESS, t.DepthMode.ReadWrite, e3.depthRangeFor3D);
                for (const e4 of r4) {
                  const r5 = o3.getTile(e4), c2 = oi2(e4.projMatrix, 0);
                  i3.setupElevationDraw(r5, s2), s2.draw(a3, n2.TRIANGLES, l2, t.StencilMode.disabled, t.ColorMode.unblended, t.CullFaceMode.backCCW, c2, "terrain_depth", i3.gridBuffer, i3.gridIndexBuffer, i3.gridNoSkirtSegments);
                }
              }(e2, this, o2, this.proxyCoords);
            }
            _setupProxiedCoordsForOrtho(t2, e2, i2) {
              if (t2.getSource() instanceof Et2)
                return this._setupProxiedCoordsForImageSource(t2, e2, i2);
              this._findCoveringTileCache[t2.id] = this._findCoveringTileCache[t2.id] || {};
              const o2 = this.proxiedCoords[t2.id] = [], r3 = this.proxyCoords;
              for (let e3 = 0; e3 < r3.length; e3++) {
                const a3 = r3[e3], n2 = this._findTileCoveringTileID(a3, t2);
                if (n2) {
                  const e4 = this._createProxiedId(a3, n2, i2[a3.key] && i2[a3.key][t2.id]);
                  o2.push(e4), this.proxyToSource[a3.key][t2.id] = [e4];
                }
              }
              let a2 = false;
              for (let r4 = 0; r4 < e2.length; r4++) {
                const n2 = t2.getTile(e2[r4]);
                if (!n2 || !n2.hasData())
                  continue;
                const s2 = this._findTileCoveringTileID(n2.tileID, this.proxySourceCache);
                if (s2 && s2.tileID.canonical.z !== n2.tileID.canonical.z) {
                  const e3 = this.proxyToSource[s2.tileID.key][t2.id], r5 = this._createProxiedId(s2.tileID, n2, i2[s2.tileID.key] && i2[s2.tileID.key][t2.id]);
                  e3 ? e3.splice(e3.length - 1, 0, r5) : this.proxyToSource[s2.tileID.key][t2.id] = [r5], o2.push(r5), a2 = true;
                }
              }
              this._sourceTilesOverlap[t2.id] = a2;
            }
            _setupProxiedCoordsForImageSource(e2, i2, o2) {
              if (!e2.getSource().loaded())
                return;
              const r3 = this.proxiedCoords[e2.id] = [], a2 = this.proxyCoords, n2 = e2.getSource(), s2 = new t.pointGeometry(n2.tileID.x, n2.tileID.y)._div(1 << n2.tileID.z), l2 = n2.coordinates.map(t.MercatorCoordinate.fromLngLat).reduce((t2, e3) => (t2.min.x = Math.min(t2.min.x, e3.x - s2.x), t2.min.y = Math.min(t2.min.y, e3.y - s2.y), t2.max.x = Math.max(t2.max.x, e3.x - s2.x), t2.max.y = Math.max(t2.max.y, e3.y - s2.y), t2), { min: new t.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE), max: new t.pointGeometry(-Number.MAX_VALUE, -Number.MAX_VALUE) }), c2 = (e3, i3) => {
                const o3 = e3.wrap + e3.canonical.x / (1 << e3.canonical.z), r4 = e3.canonical.y / (1 << e3.canonical.z), a3 = t.EXTENT / (1 << e3.canonical.z), n3 = i3.wrap + i3.canonical.x / (1 << i3.canonical.z), s3 = i3.canonical.y / (1 << i3.canonical.z);
                return o3 + a3 < n3 + l2.min.x || o3 > n3 + l2.max.x || r4 + a3 < s3 + l2.min.y || r4 > s3 + l2.max.y;
              };
              for (let t2 = 0; t2 < a2.length; t2++) {
                const n3 = a2[t2];
                for (let t3 = 0; t3 < i2.length; t3++) {
                  const a3 = e2.getTile(i2[t3]);
                  if (!a3 || !a3.hasData())
                    continue;
                  if (c2(n3, a3.tileID))
                    continue;
                  const s3 = this._createProxiedId(n3, a3, o2[n3.key] && o2[n3.key][e2.id]), l3 = this.proxyToSource[n3.key][e2.id];
                  l3 ? l3.push(s3) : this.proxyToSource[n3.key][e2.id] = [s3], r3.push(s3);
                }
              }
            }
            _createProxiedId(e2, i2, o2) {
              let r3 = this.orthoMatrix;
              if (o2) {
                const t2 = o2.find((t3) => t3.key === i2.tileID.key);
                if (t2)
                  return t2;
              }
              if (i2.tileID.key !== e2.key) {
                const o3 = e2.canonical.z - i2.tileID.canonical.z;
                let a2, n2, s2;
                r3 = t.create$1();
                const l2 = i2.tileID.wrap - e2.wrap << e2.overscaledZ;
                o3 > 0 ? (a2 = t.EXTENT >> o3, n2 = a2 * ((i2.tileID.canonical.x << o3) - e2.canonical.x + l2), s2 = a2 * ((i2.tileID.canonical.y << o3) - e2.canonical.y)) : (a2 = t.EXTENT << -o3, n2 = t.EXTENT * (i2.tileID.canonical.x - (e2.canonical.x + l2 << -o3)), s2 = t.EXTENT * (i2.tileID.canonical.y - (e2.canonical.y << -o3))), t.ortho(r3, 0, a2, 0, a2, 0, 1), t.translate(r3, r3, [n2, s2, 0]);
              }
              return new hi(i2.tileID, e2.key, r3);
            }
            _findTileCoveringTileID(e2, i2) {
              let o2 = i2.getTile(e2);
              if (o2 && o2.hasData())
                return o2;
              const r3 = this._findCoveringTileCache[i2.id], a2 = r3[e2.key];
              if (o2 = a2 ? i2.getTileByID(a2) : null, o2 && o2.hasData() || a2 === null)
                return o2;
              let n2 = o2 ? o2.tileID : e2, s2 = n2.overscaledZ;
              const l2 = i2.getSource().minzoom, c2 = [];
              if (!a2) {
                const r4 = i2.getSource().maxzoom;
                if (e2.canonical.z >= r4) {
                  const o3 = e2.canonical.z - r4;
                  i2.getSource().reparseOverscaled ? (s2 = Math.max(e2.canonical.z + 2, i2.transform.tileZoom), n2 = new t.OverscaledTileID(s2, e2.wrap, r4, e2.canonical.x >> o3, e2.canonical.y >> o3)) : o3 !== 0 && (s2 = r4, n2 = new t.OverscaledTileID(s2, e2.wrap, r4, e2.canonical.x >> o3, e2.canonical.y >> o3));
                }
                n2.key !== e2.key && (c2.push(n2.key), o2 = i2.getTile(n2));
              }
              const h2 = (t2) => {
                c2.forEach((e3) => {
                  r3[e3] = t2;
                }), c2.length = 0;
              };
              for (s2 -= 1; s2 >= l2 && (!o2 || !o2.hasData()); s2--) {
                o2 && h2(o2.tileID.key);
                const t2 = n2.calculateScaledKey(s2);
                if (o2 = i2.getTileByID(t2), o2 && o2.hasData())
                  break;
                const e3 = r3[t2];
                if (e3 === null)
                  break;
                e3 === void 0 ? c2.push(t2) : o2 = i2.getTileByID(e3);
              }
              return h2(o2 ? o2.tileID.key : null), o2 && o2.hasData() ? o2 : null;
            }
            findDEMTileFor(t2) {
              return this.enabled ? this._findTileCoveringTileID(t2, this.sourceCache) : null;
            }
            prepareDrawTile(t2) {
              this.renderedToTile = true;
            }
            _clearRenderCacheForTile(t2, e2) {
              let i2 = this._tilesDirty[t2];
              i2 || (i2 = this._tilesDirty[t2] = {}), i2[e2.key] = true;
            }
            getWirefameBuffer() {
              if (!this.wireframeSegments) {
                const e2 = function(e3) {
                  let i2, o2, r3;
                  const a2 = new t.StructArrayLayout2ui4(), n2 = 131;
                  for (o2 = 1; o2 < 129; o2++) {
                    for (i2 = 1; i2 < 129; i2++)
                      r3 = o2 * n2 + i2, a2.emplaceBack(r3, r3 + 1), a2.emplaceBack(r3, r3 + n2), a2.emplaceBack(r3 + 1, r3 + n2), o2 === 128 && a2.emplaceBack(r3 + n2, r3 + n2 + 1);
                    a2.emplaceBack(r3 + 1, r3 + 1 + n2);
                  }
                  return a2;
                }();
                this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(e2), this.wireframeSegments = t.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, e2.length);
              }
              return [this.wireframeIndexBuffer, this.wireframeSegments];
            }
          }
          function ui(t2) {
            const e2 = [];
            for (let i2 = 0; i2 < t2.length; i2++) {
              if (t2[i2] === null)
                continue;
              const o2 = t2[i2].split(" ");
              e2.push(o2.pop());
            }
            return e2;
          }
          class _i {
            static cacheKey(t2, e2, i2) {
              let o2 = `${t2}${i2 ? i2.cacheKey : ""}`;
              for (const t3 of e2)
                o2 += `/${t3}`;
              return o2;
            }
            constructor(e2, i2, o2, r3, a2, n2) {
              const s2 = e2.gl;
              this.program = s2.createProgram();
              const l2 = ui(o2.staticAttributes), c2 = r3 ? r3.getBinderAttributes() : [], h2 = l2.concat(c2), d2 = o2.staticUniforms ? ui(o2.staticUniforms) : [], u2 = r3 ? r3.getBinderUniforms() : [], _2 = d2.concat(u2), p2 = [];
              for (const t2 of _2)
                p2.indexOf(t2) < 0 && p2.push(t2);
              let m2 = r3 ? r3.defines() : [];
              m2 = m2.concat(n2.map((t2) => `#define ${t2}`));
              const f2 = m2.concat($e2.fragmentSource, Xe2, We.fragmentSource, o2.fragmentSource).join("\n"), g2 = m2.concat($e2.vertexSource, Xe2, We.vertexSource, qe2.vertexSource, o2.vertexSource).join("\n"), v2 = s2.createShader(s2.FRAGMENT_SHADER);
              if (s2.isContextLost())
                return void (this.failedToCreate = true);
              s2.shaderSource(v2, f2), s2.compileShader(v2), s2.attachShader(this.program, v2);
              const x3 = s2.createShader(s2.VERTEX_SHADER);
              if (s2.isContextLost())
                return void (this.failedToCreate = true);
              s2.shaderSource(x3, g2), s2.compileShader(x3), s2.attachShader(this.program, x3), this.attributes = {};
              const y2 = {};
              this.numAttributes = h2.length;
              for (let t2 = 0; t2 < this.numAttributes; t2++)
                h2[t2] && (s2.bindAttribLocation(this.program, t2, h2[t2]), this.attributes[h2[t2]] = t2);
              s2.linkProgram(this.program), s2.deleteShader(x3), s2.deleteShader(v2);
              for (let t2 = 0; t2 < p2.length; t2++) {
                const e3 = p2[t2];
                if (e3 && !y2[e3]) {
                  const t3 = s2.getUniformLocation(this.program, e3);
                  t3 && (y2[e3] = t3);
                }
              }
              this.fixedUniforms = a2(e2, y2), this.binderUniforms = r3 ? r3.getUniforms(e2, y2) : [], n2.indexOf("TERRAIN") !== -1 && (this.terrainUniforms = ((e3, i3) => ({ u_dem: new t.Uniform1i(e3, i3.u_dem), u_dem_prev: new t.Uniform1i(e3, i3.u_dem_prev), u_dem_unpack: new t.Uniform4f(e3, i3.u_dem_unpack), u_dem_tl: new t.Uniform2f(e3, i3.u_dem_tl), u_dem_scale: new t.Uniform1f(e3, i3.u_dem_scale), u_dem_tl_prev: new t.Uniform2f(e3, i3.u_dem_tl_prev), u_dem_scale_prev: new t.Uniform1f(e3, i3.u_dem_scale_prev), u_dem_size: new t.Uniform1f(e3, i3.u_dem_size), u_dem_lerp: new t.Uniform1f(e3, i3.u_dem_lerp), u_exaggeration: new t.Uniform1f(e3, i3.u_exaggeration), u_depth: new t.Uniform1i(e3, i3.u_depth), u_depth_size_inv: new t.Uniform2f(e3, i3.u_depth_size_inv), u_meter_to_dem: new t.Uniform1f(e3, i3.u_meter_to_dem), u_label_plane_matrix_inv: new t.UniformMatrix4f(e3, i3.u_label_plane_matrix_inv) }))(e2, y2)), n2.indexOf("FOG") !== -1 && (this.fogUniforms = ((e3, i3) => ({ u_fog_matrix: new t.UniformMatrix4f(e3, i3.u_fog_matrix), u_fog_range: new t.Uniform2f(e3, i3.u_fog_range), u_fog_color: new t.Uniform4f(e3, i3.u_fog_color), u_fog_horizon_blend: new t.Uniform1f(e3, i3.u_fog_horizon_blend), u_fog_temporal_offset: new t.Uniform1f(e3, i3.u_fog_temporal_offset) }))(e2, y2));
            }
            setTerrainUniformValues(t2, e2) {
              if (!this.terrainUniforms)
                return;
              const i2 = this.terrainUniforms;
              if (!this.failedToCreate) {
                t2.program.set(this.program);
                for (const t3 in e2)
                  i2[t3].set(e2[t3]);
              }
            }
            setFogUniformValues(t2, e2) {
              if (!this.fogUniforms)
                return;
              const i2 = this.fogUniforms;
              if (!this.failedToCreate) {
                t2.program.set(this.program);
                for (const t3 in e2)
                  i2[t3].location && i2[t3].set(e2[t3]);
              }
            }
            draw(t2, e2, i2, o2, r3, a2, n2, s2, l2, c2, h2, d2, u2, _2, p2, m2) {
              const f2 = t2.gl;
              if (this.failedToCreate)
                return;
              t2.program.set(this.program), t2.setDepthMode(i2), t2.setStencilMode(o2), t2.setColorMode(r3), t2.setCullFace(a2);
              for (const t3 in this.fixedUniforms)
                this.fixedUniforms[t3].set(n2[t3]);
              _2 && _2.setUniforms(t2, this.binderUniforms, d2, { zoom: u2 });
              const g2 = { [f2.LINES]: 2, [f2.TRIANGLES]: 3, [f2.LINE_STRIP]: 1 }[e2];
              for (const i3 of h2.get()) {
                const o3 = i3.vaos || (i3.vaos = {});
                (o3[s2] || (o3[s2] = new Ye2())).bind(t2, this, l2, _2 ? _2.getPaintVertexBuffers() : [], c2, i3.vertexOffset, p2, m2), f2.drawElements(e2, i3.primitiveLength * g2, f2.UNSIGNED_SHORT, i3.primitiveOffset * g2 * 2);
              }
            }
          }
          function pi(t2, e2, i2) {
            const o2 = 1 / z(i2, 1, e2.transform.tileZoom), r3 = Math.pow(2, i2.tileID.overscaledZ), a2 = i2.tileSize * Math.pow(2, e2.transform.tileZoom) / r3, n2 = a2 * (i2.tileID.canonical.x + i2.tileID.wrap * r3), s2 = a2 * i2.tileID.canonical.y;
            return { u_image: 0, u_texsize: i2.imageAtlasTexture.size, u_scale: [o2, t2.fromScale, t2.toScale], u_fade: t2.t, u_pixel_coord_upper: [n2 >> 16, s2 >> 16], u_pixel_coord_lower: [65535 & n2, 65535 & s2] };
          }
          const mi = (e2, i2, o2, r3) => {
            const a2 = i2.style.light, n2 = a2.properties.get("position"), s2 = [n2.x, n2.y, n2.z], l2 = t.create$2();
            a2.properties.get("anchor") === "viewport" && (t.fromRotation(l2, -i2.transform.angle), t.transformMat3(s2, s2, l2));
            const c2 = a2.properties.get("color");
            return { u_matrix: e2, u_lightpos: s2, u_lightintensity: a2.properties.get("intensity"), u_lightcolor: [c2.r, c2.g, c2.b], u_vertical_gradient: +o2, u_opacity: r3 };
          }, fi = (e2, i2, o2, r3, a2, n2, s2) => t.extend(mi(e2, i2, o2, r3), pi(n2, i2, s2), { u_height_factor: -Math.pow(2, a2.overscaledZ) / s2.tileSize / 8 }), gi = (t2) => ({ u_matrix: t2 }), vi2 = (e2, i2, o2, r3) => t.extend(gi(e2), pi(o2, i2, r3)), xi2 = (t2, e2) => ({ u_matrix: t2, u_world: e2 }), yi2 = (e2, i2, o2, r3, a2) => t.extend(vi2(e2, i2, o2, r3), { u_world: a2 }), bi2 = (e2, i2, o2, r3) => {
            const a2 = e2.transform;
            let n2;
            if (r3.paint.get("circle-pitch-alignment") === "map") {
              const t2 = z(o2, 1, a2.zoom);
              n2 = [t2, t2];
            } else
              n2 = a2.pixelsToGLUnits;
            return { u_camera_to_center_distance: a2.cameraToCenterDistance, u_matrix: e2.translatePosMatrix(i2.projMatrix, o2, r3.paint.get("circle-translate"), r3.paint.get("circle-translate-anchor")), u_device_pixel_ratio: t.exported.devicePixelRatio, u_extrude_scale: n2 };
          }, wi2 = (t2) => {
            const e2 = [];
            return t2.paint.get("circle-pitch-alignment") === "map" && e2.push("PITCH_WITH_MAP"), t2.paint.get("circle-pitch-scale") === "map" && e2.push("SCALE_WITH_MAP"), e2;
          }, Ti2 = (e2, i2, o2) => {
            const r3 = t.EXTENT / o2.tileSize;
            return { u_matrix: e2, u_camera_to_center_distance: i2.cameraToCenterDistance, u_extrude_scale: [i2.pixelsToGLUnits[0] / r3, i2.pixelsToGLUnits[1] / r3] };
          }, Ei2 = (t2, e2, i2 = 1) => ({ u_matrix: t2, u_color: e2, u_overlay: 0, u_overlay_scale: i2 }), Ci2 = (t2, e2, i2, o2) => ({ u_matrix: t2, u_extrude_scale: z(e2, 1, i2), u_intensity: o2 }), Si2 = (e2, i2, o2, r3) => {
            const a2 = e2.transform;
            return { u_matrix: Ai2(e2, i2, o2, r3), u_ratio: 1 / z(i2, 1, a2.zoom), u_device_pixel_ratio: t.exported.devicePixelRatio, u_units_to_pixels: [1 / a2.pixelsToGLUnits[0], 1 / a2.pixelsToGLUnits[1]] };
          }, Ii2 = (e2, i2, o2, r3, a2) => t.extend(Si2(e2, i2, o2, r3), { u_image: 0, u_image_height: a2 }), Mi2 = (e2, i2, o2, r3, a2) => {
            const n2 = e2.transform, s2 = Di2(i2, n2);
            return { u_matrix: Ai2(e2, i2, o2, a2), u_texsize: i2.imageAtlasTexture.size, u_ratio: 1 / z(i2, 1, n2.zoom), u_device_pixel_ratio: t.exported.devicePixelRatio, u_image: 0, u_scale: [s2, r3.fromScale, r3.toScale], u_fade: r3.t, u_units_to_pixels: [1 / n2.pixelsToGLUnits[0], 1 / n2.pixelsToGLUnits[1]] };
          }, zi2 = (e2, i2, o2, r3, a2) => {
            const n2 = Di2(i2, e2.transform);
            return t.extend(Si2(e2, i2, o2, a2), { u_texsize: i2.lineAtlasTexture.size, u_scale: [n2, r3.fromScale, r3.toScale], u_image: 0, u_mix: r3.t });
          };
          function Di2(t2, e2) {
            return 1 / z(t2, 1, e2.tileZoom);
          }
          function Ai2(t2, e2, i2, o2) {
            return t2.translatePosMatrix(o2 || e2.tileID.projMatrix, e2, i2.paint.get("line-translate"), i2.paint.get("line-translate-anchor"));
          }
          const Pi2 = (t2, e2, i2, o2, r3) => {
            return { u_matrix: t2, u_tl_parent: e2, u_scale_parent: i2, u_buffer_scale: 1, u_fade_t: o2.mix, u_opacity: o2.opacity * r3.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: r3.paint.get("raster-brightness-min"), u_brightness_high: r3.paint.get("raster-brightness-max"), u_saturation_factor: (n2 = r3.paint.get("raster-saturation"), n2 > 0 ? 1 - 1 / (1.001 - n2) : -n2), u_contrast_factor: (a2 = r3.paint.get("raster-contrast"), a2 > 0 ? 1 / (1 - a2) : 1 + a2), u_spin_weights: Li2(r3.paint.get("raster-hue-rotate")) };
            var a2, n2;
          };
          function Li2(t2) {
            t2 *= Math.PI / 180;
            const e2 = Math.sin(t2), i2 = Math.cos(t2);
            return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * e2 - i2 + 1) / 3, (Math.sqrt(3) * e2 - i2 + 1) / 3];
          }
          const Ri = (t2, e2, i2, o2, r3, a2, n2, s2, l2, c2) => {
            const h2 = r3.transform;
            return { u_is_size_zoom_constant: +(t2 === "constant" || t2 === "source"), u_is_size_feature_constant: +(t2 === "constant" || t2 === "camera"), u_size_t: e2 ? e2.uSizeT : 0, u_size: e2 ? e2.uSize : 0, u_camera_to_center_distance: h2.cameraToCenterDistance, u_pitch: h2.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i2, u_aspect_ratio: h2.width / h2.height, u_fade_change: r3.options.fadeDuration ? r3.symbolFadeChange : 1, u_matrix: a2, u_label_plane_matrix: n2, u_coord_matrix: s2, u_is_text: +l2, u_pitch_with_map: +o2, u_texsize: c2, u_texture: 0 };
          }, ki2 = (e2, i2, o2, r3, a2, n2, s2, l2, c2, h2, d2) => {
            const { cameraToCenterDistance: u2, _pitch: _2 } = a2.transform;
            return t.extend(Ri(e2, i2, o2, r3, a2, n2, s2, l2, c2, h2), { u_gamma_scale: r3 ? u2 * Math.cos(a2.terrain ? 0 : _2) : 1, u_device_pixel_ratio: t.exported.devicePixelRatio, u_is_halo: +d2 });
          }, Fi2 = (e2, i2, o2, r3, a2, n2, s2, l2, c2, h2) => t.extend(ki2(e2, i2, o2, r3, a2, n2, s2, l2, true, c2, true), { u_texsize_icon: h2, u_texture_icon: 1 }), Bi2 = (t2, e2, i2) => ({ u_matrix: t2, u_opacity: e2, u_color: i2 }), Oi2 = (e2, i2, o2, r3, a2, n2) => t.extend(function(t2, e3, i3, o3) {
            const r4 = i3.imageManager.getPattern(t2.from.toString()), a3 = i3.imageManager.getPattern(t2.to.toString()), { width: n3, height: s2 } = i3.imageManager.getPixelSize(), l2 = Math.pow(2, o3.tileID.overscaledZ), c2 = o3.tileSize * Math.pow(2, i3.transform.tileZoom) / l2, h2 = c2 * (o3.tileID.canonical.x + o3.tileID.wrap * l2), d2 = c2 * o3.tileID.canonical.y;
            return { u_image: 0, u_pattern_tl_a: r4.tl, u_pattern_br_a: r4.br, u_pattern_tl_b: a3.tl, u_pattern_br_b: a3.br, u_texsize: [n3, s2], u_mix: e3.t, u_pattern_size_a: r4.displaySize, u_pattern_size_b: a3.displaySize, u_scale_a: e3.fromScale, u_scale_b: e3.toScale, u_tile_units_to_pixels: 1 / z(o3, 1, i3.transform.tileZoom), u_pixel_coord_upper: [h2 >> 16, d2 >> 16], u_pixel_coord_lower: [65535 & h2, 65535 & d2] };
          }(r3, n2, o2, a2), { u_matrix: e2, u_opacity: i2 }), Ui2 = { fillExtrusion: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_lightpos: new t.Uniform3f(e2, i2.u_lightpos), u_lightintensity: new t.Uniform1f(e2, i2.u_lightintensity), u_lightcolor: new t.Uniform3f(e2, i2.u_lightcolor), u_vertical_gradient: new t.Uniform1f(e2, i2.u_vertical_gradient), u_opacity: new t.Uniform1f(e2, i2.u_opacity) }), fillExtrusionPattern: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_lightpos: new t.Uniform3f(e2, i2.u_lightpos), u_lightintensity: new t.Uniform1f(e2, i2.u_lightintensity), u_lightcolor: new t.Uniform3f(e2, i2.u_lightcolor), u_vertical_gradient: new t.Uniform1f(e2, i2.u_vertical_gradient), u_height_factor: new t.Uniform1f(e2, i2.u_height_factor), u_image: new t.Uniform1i(e2, i2.u_image), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_scale: new t.Uniform3f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade), u_opacity: new t.Uniform1f(e2, i2.u_opacity) }), fill: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) }), fillPattern: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_image: new t.Uniform1i(e2, i2.u_image), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_scale: new t.Uniform3f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade) }), fillOutline: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_world: new t.Uniform2f(e2, i2.u_world) }), fillOutlinePattern: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_world: new t.Uniform2f(e2, i2.u_world), u_image: new t.Uniform1i(e2, i2.u_image), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_scale: new t.Uniform3f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade) }), circle: (e2, i2) => ({ u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_extrude_scale: new t.Uniform2f(e2, i2.u_extrude_scale), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) }), collisionBox: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_extrude_scale: new t.Uniform2f(e2, i2.u_extrude_scale) }), collisionCircle: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_inv_matrix: new t.UniformMatrix4f(e2, i2.u_inv_matrix), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_viewport_size: new t.Uniform2f(e2, i2.u_viewport_size) }), debug: (e2, i2) => ({ u_color: new t.UniformColor(e2, i2.u_color), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_overlay: new t.Uniform1i(e2, i2.u_overlay), u_overlay_scale: new t.Uniform1f(e2, i2.u_overlay_scale) }), clippingMask: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) }), heatmap: (e2, i2) => ({ u_extrude_scale: new t.Uniform1f(e2, i2.u_extrude_scale), u_intensity: new t.Uniform1f(e2, i2.u_intensity), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) }), heatmapTexture: (e2, i2) => ({ u_image: new t.Uniform1i(e2, i2.u_image), u_color_ramp: new t.Uniform1i(e2, i2.u_color_ramp), u_opacity: new t.Uniform1f(e2, i2.u_opacity) }), hillshade: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_image: new t.Uniform1i(e2, i2.u_image), u_latrange: new t.Uniform2f(e2, i2.u_latrange), u_light: new t.Uniform2f(e2, i2.u_light), u_shadow: new t.UniformColor(e2, i2.u_shadow), u_highlight: new t.UniformColor(e2, i2.u_highlight), u_accent: new t.UniformColor(e2, i2.u_accent) }), hillshadePrepare: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_image: new t.Uniform1i(e2, i2.u_image), u_dimension: new t.Uniform2f(e2, i2.u_dimension), u_zoom: new t.Uniform1f(e2, i2.u_zoom), u_unpack: new t.Uniform4f(e2, i2.u_unpack) }), line: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels) }), lineGradient: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels), u_image: new t.Uniform1i(e2, i2.u_image), u_image_height: new t.Uniform1f(e2, i2.u_image_height) }), linePattern: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_image: new t.Uniform1i(e2, i2.u_image), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels), u_scale: new t.Uniform3f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade) }), lineSDF: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels), u_image: new t.Uniform1i(e2, i2.u_image), u_scale: new t.Uniform3f(e2, i2.u_scale), u_mix: new t.Uniform1f(e2, i2.u_mix) }), raster: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_tl_parent: new t.Uniform2f(e2, i2.u_tl_parent), u_scale_parent: new t.Uniform1f(e2, i2.u_scale_parent), u_buffer_scale: new t.Uniform1f(e2, i2.u_buffer_scale), u_fade_t: new t.Uniform1f(e2, i2.u_fade_t), u_opacity: new t.Uniform1f(e2, i2.u_opacity), u_image0: new t.Uniform1i(e2, i2.u_image0), u_image1: new t.Uniform1i(e2, i2.u_image1), u_brightness_low: new t.Uniform1f(e2, i2.u_brightness_low), u_brightness_high: new t.Uniform1f(e2, i2.u_brightness_high), u_saturation_factor: new t.Uniform1f(e2, i2.u_saturation_factor), u_contrast_factor: new t.Uniform1f(e2, i2.u_contrast_factor), u_spin_weights: new t.Uniform3f(e2, i2.u_spin_weights) }), symbolIcon: (e2, i2) => ({ u_is_size_zoom_constant: new t.Uniform1i(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e2, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e2, i2.u_size_t), u_size: new t.Uniform1f(e2, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e2, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e2, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e2, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e2, i2.u_coord_matrix), u_is_text: new t.Uniform1i(e2, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e2, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_texture: new t.Uniform1i(e2, i2.u_texture) }), symbolSDF: (e2, i2) => ({ u_is_size_zoom_constant: new t.Uniform1i(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e2, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e2, i2.u_size_t), u_size: new t.Uniform1f(e2, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e2, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e2, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e2, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e2, i2.u_coord_matrix), u_is_text: new t.Uniform1i(e2, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e2, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_texture: new t.Uniform1i(e2, i2.u_texture), u_gamma_scale: new t.Uniform1f(e2, i2.u_gamma_scale), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_is_halo: new t.Uniform1i(e2, i2.u_is_halo) }), symbolTextAndIcon: (e2, i2) => ({ u_is_size_zoom_constant: new t.Uniform1i(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e2, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e2, i2.u_size_t), u_size: new t.Uniform1f(e2, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e2, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e2, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e2, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e2, i2.u_coord_matrix), u_is_text: new t.Uniform1i(e2, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e2, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_texsize_icon: new t.Uniform2f(e2, i2.u_texsize_icon), u_texture: new t.Uniform1i(e2, i2.u_texture), u_texture_icon: new t.Uniform1i(e2, i2.u_texture_icon), u_gamma_scale: new t.Uniform1f(e2, i2.u_gamma_scale), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_is_halo: new t.Uniform1i(e2, i2.u_is_halo) }), background: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_opacity: new t.Uniform1f(e2, i2.u_opacity), u_color: new t.UniformColor(e2, i2.u_color) }), backgroundPattern: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_opacity: new t.Uniform1f(e2, i2.u_opacity), u_image: new t.Uniform1i(e2, i2.u_image), u_pattern_tl_a: new t.Uniform2f(e2, i2.u_pattern_tl_a), u_pattern_br_a: new t.Uniform2f(e2, i2.u_pattern_br_a), u_pattern_tl_b: new t.Uniform2f(e2, i2.u_pattern_tl_b), u_pattern_br_b: new t.Uniform2f(e2, i2.u_pattern_br_b), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_mix: new t.Uniform1f(e2, i2.u_mix), u_pattern_size_a: new t.Uniform2f(e2, i2.u_pattern_size_a), u_pattern_size_b: new t.Uniform2f(e2, i2.u_pattern_size_b), u_scale_a: new t.Uniform1f(e2, i2.u_scale_a), u_scale_b: new t.Uniform1f(e2, i2.u_scale_b), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_tile_units_to_pixels: new t.Uniform1f(e2, i2.u_tile_units_to_pixels) }), terrainRaster: ii2, terrainDepth: ii2, skybox: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_sun_direction: new t.Uniform3f(e2, i2.u_sun_direction), u_cubemap: new t.Uniform1i(e2, i2.u_cubemap), u_opacity: new t.Uniform1f(e2, i2.u_opacity), u_temporal_offset: new t.Uniform1f(e2, i2.u_temporal_offset) }), skyboxGradient: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_color_ramp: new t.Uniform1i(e2, i2.u_color_ramp), u_center_direction: new t.Uniform3f(e2, i2.u_center_direction), u_radius: new t.Uniform1f(e2, i2.u_radius), u_opacity: new t.Uniform1f(e2, i2.u_opacity), u_temporal_offset: new t.Uniform1f(e2, i2.u_temporal_offset) }), skyboxCapture: (e2, i2) => ({ u_matrix_3f: new t.UniformMatrix3f(e2, i2.u_matrix_3f), u_sun_direction: new t.Uniform3f(e2, i2.u_sun_direction), u_sun_intensity: new t.Uniform1f(e2, i2.u_sun_intensity), u_color_tint_r: new t.Uniform4f(e2, i2.u_color_tint_r), u_color_tint_m: new t.Uniform4f(e2, i2.u_color_tint_m), u_luminance: new t.Uniform1f(e2, i2.u_luminance) }) };
          let Ni2;
          function Gi2(e2, i2, o2, r3, a2, n2, s2) {
            const l2 = e2.context, c2 = l2.gl, h2 = e2.useProgram("collisionBox"), d2 = [];
            let u2 = 0, _2 = 0;
            for (let p3 = 0; p3 < r3.length; p3++) {
              const m3 = r3[p3], f3 = i2.getTile(m3), g3 = f3.getBucket(o2);
              if (!g3)
                continue;
              let v3 = m3.projMatrix;
              a2[0] === 0 && a2[1] === 0 || (v3 = e2.translatePosMatrix(m3.projMatrix, f3, a2, n2));
              const x4 = s2 ? g3.textCollisionBox : g3.iconCollisionBox, y2 = g3.collisionCircleArray;
              if (y2.length > 0) {
                const i3 = t.create$1(), o3 = v3;
                t.mul$1(i3, g3.placementInvProjMatrix, e2.transform.glCoordMatrix), t.mul$1(i3, i3, g3.placementViewportMatrix), d2.push({ circleArray: y2, circleOffset: _2, transform: o3, invTransform: i3 }), u2 += y2.length / 4, _2 = u2;
              }
              x4 && (e2.terrain && e2.terrain.setupElevationDraw(f3, h2), h2.draw(l2, c2.LINES, t.DepthMode.disabled, t.StencilMode.disabled, e2.colorModeForRenderPass(), t.CullFaceMode.disabled, Ti2(v3, e2.transform, f3), o2.id, x4.layoutVertexBuffer, x4.indexBuffer, x4.segments, null, e2.transform.zoom, null, x4.collisionVertexBuffer, x4.collisionVertexBufferExt));
            }
            if (!s2 || !d2.length)
              return;
            const p2 = e2.useProgram("collisionCircle"), m2 = new t.StructArrayLayout2f1f2i16();
            m2.resize(4 * u2), m2._trim();
            let f2 = 0;
            for (const t2 of d2)
              for (let e3 = 0; e3 < t2.circleArray.length / 4; e3++) {
                const i3 = 4 * e3, o3 = t2.circleArray[i3 + 0], r4 = t2.circleArray[i3 + 1], a3 = t2.circleArray[i3 + 2], n3 = t2.circleArray[i3 + 3];
                m2.emplace(f2++, o3, r4, a3, n3, 0), m2.emplace(f2++, o3, r4, a3, n3, 1), m2.emplace(f2++, o3, r4, a3, n3, 2), m2.emplace(f2++, o3, r4, a3, n3, 3);
              }
            (!Ni2 || Ni2.length < 2 * u2) && (Ni2 = function(e3) {
              const i3 = 2 * e3, o3 = new t.StructArrayLayout3ui6();
              o3.resize(i3), o3._trim();
              for (let t2 = 0; t2 < i3; t2++) {
                const e4 = 6 * t2;
                o3.uint16[e4 + 0] = 4 * t2 + 0, o3.uint16[e4 + 1] = 4 * t2 + 1, o3.uint16[e4 + 2] = 4 * t2 + 2, o3.uint16[e4 + 3] = 4 * t2 + 2, o3.uint16[e4 + 4] = 4 * t2 + 3, o3.uint16[e4 + 5] = 4 * t2 + 0;
              }
              return o3;
            }(u2));
            const g2 = l2.createIndexBuffer(Ni2, true), v2 = l2.createVertexBuffer(m2, t.collisionCircleLayout.members, true);
            for (const i3 of d2) {
              const r4 = { u_matrix: i3.transform, u_inv_matrix: i3.invTransform, u_camera_to_center_distance: (x3 = e2.transform).cameraToCenterDistance, u_viewport_size: [x3.width, x3.height] };
              p2.draw(l2, c2.TRIANGLES, t.DepthMode.disabled, t.StencilMode.disabled, e2.colorModeForRenderPass(), t.CullFaceMode.disabled, r4, o2.id, v2, g2, t.SegmentVector.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, e2.transform.zoom, null, null, null);
            }
            var x3;
            v2.destroy(), g2.destroy();
          }
          const Zi2 = t.identity(new Float32Array(16));
          function Vi2(e2, i2, o2, r3, a2, n2) {
            const { horizontalAlign: s2, verticalAlign: l2 } = t.getAnchorAlignment(e2), c2 = -(s2 - 0.5) * i2, h2 = -(l2 - 0.5) * o2, d2 = t.evaluateVariableOffset(e2, r3);
            return new t.pointGeometry((c2 / a2 + d2[0]) * n2, (h2 / a2 + d2[1]) * n2);
          }
          function ji2(e2, i2, o2, r3, a2, n2, s2, l2, c2, h2, d2, u2) {
            const _2 = e2.text.placedSymbolArray, p2 = e2.text.dynamicLayoutVertexArray, m2 = e2.icon.dynamicLayoutVertexArray, f2 = {};
            p2.clear();
            for (let m3 = 0; m3 < _2.length; m3++) {
              const g2 = _2.get(m3), v2 = e2.allowVerticalPlacement && !g2.placedOrientation, x3 = g2.hidden || !g2.crossTileID || v2 ? null : r3[g2.crossTileID];
              if (x3) {
                const r4 = new t.pointGeometry(g2.anchorX, g2.anchorY), _3 = u2(r4), m4 = Yt(r4, o2 ? l2 : s2, _3), v3 = Qt2(n2.cameraToCenterDistance, m4.signedDistanceFromCamera);
                let y2 = a2.evaluateSizeForFeature(e2.textSizeData, h2, g2) * v3 / t.ONE_EM;
                o2 && (y2 *= e2.tilePixelRatio / c2);
                const { width: b2, height: w3, anchor: T2, textOffset: E2, textScale: C2 } = x3, S2 = Vi2(T2, b2, w3, E2, C2, y2), I3 = o2 ? Yt(r4.add(S2), s2, _3).point : m4.point.add(i2 ? S2.rotate(-n2.angle) : S2), M3 = e2.allowVerticalPlacement && g2.placedOrientation === t.WritingMode.vertical ? Math.PI / 2 : 0;
                for (let e3 = 0; e3 < g2.numGlyphs; e3++)
                  t.addDynamicAttributes(p2, I3, M3);
                d2 && g2.associatedIconIndex >= 0 && (f2[g2.associatedIconIndex] = { shiftedAnchor: I3, angle: M3 });
              } else
                se2(g2.numGlyphs, p2);
            }
            if (d2) {
              m2.clear();
              const i3 = e2.icon.placedSymbolArray;
              for (let e3 = 0; e3 < i3.length; e3++) {
                const o3 = i3.get(e3);
                if (o3.hidden)
                  se2(o3.numGlyphs, m2);
                else {
                  const i4 = f2[e3];
                  if (i4)
                    for (let e4 = 0; e4 < o3.numGlyphs; e4++)
                      t.addDynamicAttributes(m2, i4.shiftedAnchor, i4.angle);
                  else
                    se2(o3.numGlyphs, m2);
                }
              }
              e2.icon.dynamicLayoutVertexBuffer.updateData(m2);
            }
            e2.text.dynamicLayoutVertexBuffer.updateData(p2);
          }
          function qi2(t2, e2, i2) {
            return i2.iconsInText && e2 ? "symbolTextAndIcon" : t2 ? "symbolSDF" : "symbolIcon";
          }
          function Wi2(e2, i2, o2, r3, a2, n2, s2, l2, c2, h2, d2, u2) {
            const _2 = e2.context, p2 = _2.gl, m2 = e2.transform, f2 = l2 === "map", g2 = c2 === "map", v2 = f2 && o2.layout.get("symbol-placement") !== "point", x3 = f2 && !g2 && !v2, y2 = o2.layout.get("symbol-sort-key").constantOr(1) !== void 0;
            let b2 = false;
            const w3 = e2.depthModeForSublayer(0, t.DepthMode.ReadOnly), T2 = o2.layout.get("text-variable-anchor"), E2 = [], C2 = e2.terrain && g2 ? ["PITCH_WITH_MAP_TERRAIN"] : null;
            for (const l3 of r3) {
              const r4 = i2.getTile(l3), c3 = r4.getBucket(o2);
              if (!c3)
                continue;
              const d3 = a2 ? c3.text : c3.icon;
              if (!d3 || !d3.segments.get().length)
                continue;
              const u3 = d3.programConfigurations.get(o2.id), _3 = a2 || c3.sdfIcons, w4 = a2 ? c3.textSizeData : c3.iconSizeData, S2 = g2 || m2.pitch !== 0, I3 = e2.useProgram(qi2(_3, a2, c3), u3, C2), M3 = t.evaluateSizeForZoom(w4, m2.zoom);
              let D2, A2, P2, L3, R2 = [0, 0], k3 = null;
              if (a2) {
                if (A2 = r4.glyphAtlasTexture, P2 = p2.LINEAR, D2 = r4.glyphAtlasTexture.size, c3.iconsInText) {
                  R2 = r4.imageAtlasTexture.size, k3 = r4.imageAtlasTexture;
                  const t2 = w4.kind === "composite" || w4.kind === "camera";
                  L3 = S2 || e2.options.rotating || e2.options.zooming || t2 ? p2.LINEAR : p2.NEAREST;
                }
              } else {
                const t2 = o2.layout.get("icon-size").constantOr(0) !== 1 || c3.iconsNeedLinear;
                A2 = r4.imageAtlasTexture, P2 = _3 || e2.options.rotating || e2.options.zooming || t2 || S2 ? p2.LINEAR : p2.NEAREST, D2 = r4.imageAtlasTexture.size;
              }
              const F3 = z(r4, 1, e2.transform.zoom), B2 = Ht(l3.projMatrix, g2, f2, e2.transform, F3), O2 = e2.terrain && g2 && v2 ? t.invert(new Float32Array(16), B2) : Zi2, U3 = Kt2(l3.projMatrix, g2, f2, e2.transform, F3), N2 = T2 && c3.hasTextData(), G3 = o2.layout.get("icon-text-fit") !== "none" && N2 && c3.hasIconData();
              if (v2) {
                const t2 = m2.elevation;
                te2(c3, l3.projMatrix, e2, a2, B2, U3, g2, h2, t2 ? (e3) => t2.getAtTileOffset(l3, e3.x, e3.y) : null);
              }
              const Z3 = e2.translatePosMatrix(l3.projMatrix, r4, n2, s2), V2 = v2 || a2 && T2 || G3 ? Zi2 : B2, j3 = e2.translatePosMatrix(U3, r4, n2, s2, true), q2 = _3 && o2.paint.get(a2 ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
              let W2;
              W2 = _3 ? c3.iconsInText ? Fi2(w4.kind, M3, x3, g2, e2, Z3, V2, j3, D2, R2) : ki2(w4.kind, M3, x3, g2, e2, Z3, V2, j3, a2, D2, true) : Ri(w4.kind, M3, x3, g2, e2, Z3, V2, j3, a2, D2);
              const $3 = { program: I3, buffers: d3, uniformValues: W2, atlasTexture: A2, atlasTextureIcon: k3, atlasInterpolation: P2, atlasInterpolationIcon: L3, isSDF: _3, hasHalo: q2, tile: r4, labelPlaneMatrixInv: O2 };
              if (y2 && c3.canOverlap) {
                b2 = true;
                const e3 = d3.segments.get();
                for (const i3 of e3)
                  E2.push({ segments: new t.SegmentVector([i3]), sortKey: i3.sortKey, state: $3 });
              } else
                E2.push({ segments: d3.segments, sortKey: 0, state: $3 });
            }
            b2 && E2.sort((t2, e3) => t2.sortKey - e3.sortKey);
            for (const t2 of E2) {
              const i3 = t2.state;
              if (e2.terrain && e2.terrain.setupElevationDraw(i3.tile, i3.program, { useDepthForOcclusion: true, labelPlaneMatrixInv: i3.labelPlaneMatrixInv }), _2.activeTexture.set(p2.TEXTURE0), i3.atlasTexture.bind(i3.atlasInterpolation, p2.CLAMP_TO_EDGE), i3.atlasTextureIcon && (_2.activeTexture.set(p2.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, p2.CLAMP_TO_EDGE)), i3.isSDF) {
                const r4 = i3.uniformValues;
                i3.hasHalo && (r4.u_is_halo = 1, $i2(i3.buffers, t2.segments, o2, e2, i3.program, w3, d2, u2, r4)), r4.u_is_halo = 0;
              }
              $i2(i3.buffers, t2.segments, o2, e2, i3.program, w3, d2, u2, i3.uniformValues);
            }
          }
          function $i2(e2, i2, o2, r3, a2, n2, s2, l2, c2) {
            const h2 = r3.context;
            a2.draw(h2, h2.gl.TRIANGLES, n2, s2, l2, t.CullFaceMode.disabled, c2, o2.id, e2.layoutVertexBuffer, e2.indexBuffer, i2, o2.paint, r3.transform.zoom, e2.programConfigurations.get(o2.id), e2.dynamicLayoutVertexBuffer, e2.opacityVertexBuffer);
          }
          function Xi2(e2, i2, o2, r3, a2, n2, s2) {
            const l2 = e2.context.gl, c2 = o2.paint.get("fill-pattern"), h2 = c2 && c2.constantOr(1), d2 = o2.getCrossfadeParameters();
            let u2, _2, p2, m2, f2;
            s2 ? (_2 = h2 && !o2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", u2 = l2.LINES) : (_2 = h2 ? "fillPattern" : "fill", u2 = l2.TRIANGLES);
            for (const g2 of r3) {
              const r4 = i2.getTile(g2);
              if (h2 && !r4.patternsLoaded())
                continue;
              const v2 = r4.getBucket(o2);
              if (!v2)
                continue;
              e2.prepareDrawTile(g2);
              const x3 = v2.programConfigurations.get(o2.id), y2 = e2.useProgram(_2, x3);
              h2 && (e2.context.activeTexture.set(l2.TEXTURE0), r4.imageAtlasTexture.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), x3.updatePaintBuffers(d2));
              const b2 = c2.constantOr(null);
              if (b2 && r4.imageAtlas) {
                const t2 = r4.imageAtlas, e3 = t2.patternPositions[b2.to.toString()], i3 = t2.patternPositions[b2.from.toString()];
                e3 && i3 && x3.setConstantPatternPositions(e3, i3);
              }
              const w3 = e2.translatePosMatrix(g2.projMatrix, r4, o2.paint.get("fill-translate"), o2.paint.get("fill-translate-anchor"));
              if (s2) {
                m2 = v2.indexBuffer2, f2 = v2.segments2;
                const t2 = e2.terrain && e2.terrain.renderingToTexture ? e2.terrain.drapeBufferSize : [l2.drawingBufferWidth, l2.drawingBufferHeight];
                p2 = _2 === "fillOutlinePattern" && h2 ? yi2(w3, e2, d2, r4, t2) : xi2(w3, t2);
              } else
                m2 = v2.indexBuffer, f2 = v2.segments, p2 = h2 ? vi2(w3, e2, d2, r4) : gi(w3);
              e2.prepareDrawProgram(e2.context, y2, g2.toUnwrapped()), y2.draw(e2.context, u2, a2, e2.stencilModeForClipping(g2), n2, t.CullFaceMode.disabled, p2, o2.id, v2.layoutVertexBuffer, m2, f2, o2.paint, e2.transform.zoom, x3);
            }
          }
          function Hi2(e2, i2, o2, r3, a2, n2, s2) {
            const l2 = e2.context, c2 = l2.gl, h2 = o2.paint.get("fill-extrusion-pattern"), d2 = h2.constantOr(1), u2 = o2.getCrossfadeParameters(), _2 = o2.paint.get("fill-extrusion-opacity");
            for (const p2 of r3) {
              const r4 = i2.getTile(p2), m2 = r4.getBucket(o2);
              if (!m2)
                continue;
              const f2 = m2.programConfigurations.get(o2.id), g2 = e2.useProgram(d2 ? "fillExtrusionPattern" : "fillExtrusion", f2);
              if (e2.terrain) {
                const t2 = e2.terrain;
                if (!m2.enableTerrain)
                  continue;
                if (t2.setupElevationDraw(r4, g2, { useMeterToDem: true }), Ki2(l2, i2, p2, m2, o2, t2), !m2.centroidVertexBuffer) {
                  const t3 = g2.attributes.a_centroid_pos;
                  t3 !== void 0 && c2.vertexAttrib2f(t3, 0, 0);
                }
              }
              d2 && (e2.context.activeTexture.set(c2.TEXTURE0), r4.imageAtlasTexture.bind(c2.LINEAR, c2.CLAMP_TO_EDGE), f2.updatePaintBuffers(u2));
              const v2 = h2.constantOr(null);
              if (v2 && r4.imageAtlas) {
                const t2 = r4.imageAtlas, e3 = t2.patternPositions[v2.to.toString()], i3 = t2.patternPositions[v2.from.toString()];
                e3 && i3 && f2.setConstantPatternPositions(e3, i3);
              }
              const x3 = e2.translatePosMatrix(p2.projMatrix, r4, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), y2 = o2.paint.get("fill-extrusion-vertical-gradient"), b2 = d2 ? fi(x3, e2, y2, _2, p2, u2, r4) : mi(x3, e2, y2, _2);
              e2.prepareDrawProgram(l2, g2, p2.toUnwrapped()), g2.draw(l2, l2.gl.TRIANGLES, a2, n2, s2, t.CullFaceMode.backCCW, b2, o2.id, m2.layoutVertexBuffer, m2.indexBuffer, m2.segments, o2.paint, e2.transform.zoom, f2, e2.terrain ? m2.centroidVertexBuffer : null);
            }
          }
          function Ki2(e2, i2, o2, r3, a2, n2) {
            const s2 = [(e3) => {
              let i3 = e3.canonical.x - 1, o3 = e3.wrap;
              return i3 < 0 && (i3 = (1 << e3.canonical.z) - 1, o3--), new t.OverscaledTileID(e3.overscaledZ, o3, e3.canonical.z, i3, e3.canonical.y);
            }, (e3) => {
              let i3 = e3.canonical.x + 1, o3 = e3.wrap;
              return i3 === 1 << e3.canonical.z && (i3 = 0, o3++), new t.OverscaledTileID(e3.overscaledZ, o3, e3.canonical.z, i3, e3.canonical.y);
            }, (e3) => new t.OverscaledTileID(e3.overscaledZ, e3.wrap, e3.canonical.z, e3.canonical.x, (e3.canonical.y === 0 ? 1 << e3.canonical.z : e3.canonical.y) - 1), (e3) => new t.OverscaledTileID(e3.overscaledZ, e3.wrap, e3.canonical.z, e3.canonical.x, e3.canonical.y === (1 << e3.canonical.z) - 1 ? 0 : e3.canonical.y + 1)], l2 = (t2) => {
              const e3 = i2.getSource().maxzoom, o3 = (t3) => {
                const e4 = i2.getTileByID(t3);
                if (e4 && e4.hasData())
                  return e4.getBucket(a2);
              };
              let r4, n3, s3;
              return (t2.overscaledZ === t2.canonical.z || t2.overscaledZ >= e3) && (r4 = o3(t2.key)), t2.overscaledZ >= e3 && (n3 = o3(t2.calculateScaledKey(t2.overscaledZ + 1))), t2.overscaledZ > e3 && (s3 = o3(t2.calculateScaledKey(t2.overscaledZ - 1))), r4 || n3 || s3;
            }, c2 = [0, 0, 0], h2 = (e3, i3) => (c2[0] = Math.min(e3.min.y, i3.min.y), c2[1] = Math.max(e3.max.y, i3.max.y), c2[2] = t.EXTENT - i3.min.x > e3.max.x ? i3.min.x - t.EXTENT : e3.max.x, c2), d2 = (e3, i3) => (c2[0] = Math.min(e3.min.x, i3.min.x), c2[1] = Math.max(e3.max.x, i3.max.x), c2[2] = t.EXTENT - i3.min.y > e3.max.y ? i3.min.y - t.EXTENT : e3.max.y, c2), u2 = [(t2, e3) => h2(t2, e3), (t2, e3) => h2(e3, t2), (t2, e3) => d2(t2, e3), (t2, e3) => d2(e3, t2)], _2 = new t.pointGeometry(0, 0);
            let p2, m2, f2;
            const g2 = (e3, i3, r4, a3, s3) => {
              const l3 = [[a3 ? r4 : e3, a3 ? e3 : r4, 0], [a3 ? r4 : i3, a3 ? i3 : r4, 0]], c3 = s3 < 0 ? t.EXTENT + s3 : s3, h3 = [a3 ? c3 : (e3 + i3) / 2, a3 ? (e3 + i3) / 2 : c3, 0];
              return r4 === 0 && s3 < 0 || r4 !== 0 && s3 > 0 ? n2.getForTilePoints(f2, [h3], true, m2) : l3.push(h3), n2.getForTilePoints(o2, l3, true, p2), Math.max(l3[0][2], l3[1][2], h3[2]) / n2.exaggeration();
            };
            for (let e3 = 0; e3 < 4; e3++) {
              const i3 = r3.borders[e3];
              if (i3.length === 0 && (r3.borderDone[e3] = true), r3.borderDone[e3])
                continue;
              const a3 = f2 = s2[e3](o2), c3 = l2(a3);
              if (!c3 || !c3.enableTerrain)
                continue;
              if (m2 = n2.findDEMTileFor(a3), !m2 || !m2.dem)
                continue;
              if (!p2) {
                const t2 = n2.findDEMTileFor(o2);
                if (!t2 || !t2.dem)
                  return;
                p2 = t2;
              }
              const h3 = (e3 < 2 ? 1 : 5) - e3, d3 = c3.borders[h3];
              let v2 = 0;
              for (let o3 = 0; o3 < i3.length; o3++) {
                const a4 = r3.featuresOnBorder[i3[o3]], n3 = a4.borders[e3];
                let s3;
                for (; v2 < d3.length && (s3 = c3.featuresOnBorder[d3[v2]], !(s3.borders[h3][1] > n3[0] + 3)); )
                  c3.borderDone[h3] || c3.encodeCentroid(void 0, s3, false), v2++;
                if (s3 && v2 < d3.length) {
                  const i4 = v2;
                  let o4 = 0;
                  for (; !(s3.borders[h3][0] > n3[1] - 3) && (o4++, ++v2 !== d3.length); )
                    s3 = c3.featuresOnBorder[d3[v2]];
                  if (s3 = c3.featuresOnBorder[d3[i4]], a4.intersectsCount() > 1 || s3.intersectsCount() > 1 || o4 !== 1) {
                    o4 !== 1 && (v2 = i4), r3.encodeCentroid(void 0, a4, false), c3.borderDone[h3] || c3.encodeCentroid(void 0, s3, false);
                    continue;
                  }
                  const l3 = u2[e3](a4, s3), p3 = e3 % 2 ? t.EXTENT - 1 : 0;
                  _2.x = g2(l3[0], Math.min(t.EXTENT - 1, l3[1]), p3, e3 < 2, l3[2]), _2.y = 0, r3.encodeCentroid(_2, a4, false), c3.borderDone[h3] || c3.encodeCentroid(_2, s3, false);
                } else
                  r3.encodeCentroid(void 0, a4, false);
              }
              r3.borderDone[e3] = r3.needsCentroidUpdate = true, c3.borderDone[h3] || (c3.borderDone[h3] = c3.needsCentroidUpdate = true);
            }
            (r3.needsCentroidUpdate || !r3.centroidVertexBuffer && r3.centroidVertexArray.length !== 0) && r3.uploadCentroid(e2);
          }
          const Yi2 = new t.Color(1, 0, 0, 1), Qi2 = new t.Color(0, 1, 0, 1), Ji2 = new t.Color(0, 0, 1, 1), to2 = new t.Color(1, 0, 1, 1), eo2 = new t.Color(0, 1, 1, 1);
          function io2(t2, e2, i2, o2) {
            ro2(t2, 0, e2 + i2 / 2, t2.transform.width, i2, o2);
          }
          function oo2(t2, e2, i2, o2) {
            ro2(t2, e2 - i2 / 2, 0, i2, t2.transform.height, o2);
          }
          function ro2(e2, i2, o2, r3, a2, n2) {
            const s2 = e2.context, l2 = s2.gl;
            l2.enable(l2.SCISSOR_TEST), l2.scissor(i2 * t.exported.devicePixelRatio, o2 * t.exported.devicePixelRatio, r3 * t.exported.devicePixelRatio, a2 * t.exported.devicePixelRatio), s2.clear({ color: n2 }), l2.disable(l2.SCISSOR_TEST);
          }
          function ao2(e2, i2, o2) {
            const r3 = e2.context, a2 = r3.gl, n2 = o2.projMatrix, s2 = e2.useProgram("debug"), l2 = i2.getTileByID(o2.key);
            e2.terrain && e2.terrain.setupElevationDraw(l2, s2);
            const c2 = t.DepthMode.disabled, h2 = t.StencilMode.disabled, d2 = e2.colorModeForRenderPass(), u2 = "$debug";
            r3.activeTexture.set(a2.TEXTURE0), e2.emptyTexture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE), s2.draw(r3, a2.LINE_STRIP, c2, h2, d2, t.CullFaceMode.disabled, Ei2(n2, t.Color.red), u2, e2.debugBuffer, e2.tileBorderIndexBuffer, e2.debugSegments);
            const _2 = l2.latestRawTileData, p2 = Math.floor((_2 && _2.byteLength || 0) / 1024), m2 = i2.getTile(o2).tileSize, f2 = 512 / Math.min(m2, 512) * (o2.overscaledZ / e2.transform.zoom) * 0.5;
            let g2 = o2.canonical.toString();
            o2.overscaledZ !== o2.canonical.z && (g2 += ` => ${o2.overscaledZ}`), function(t2, e3) {
              t2.initDebugOverlayCanvas();
              const i3 = t2.debugOverlayCanvas, o3 = t2.context.gl, r4 = t2.debugOverlayCanvas.getContext("2d");
              r4.clearRect(0, 0, i3.width, i3.height), r4.shadowColor = "white", r4.shadowBlur = 2, r4.lineWidth = 1.5, r4.strokeStyle = "white", r4.textBaseline = "top", r4.font = "bold 36px Open Sans, sans-serif", r4.fillText(e3, 5, 5), r4.strokeText(e3, 5, 5), t2.debugOverlayTexture.update(i3), t2.debugOverlayTexture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
            }(e2, `${g2} ${p2}kb`), s2.draw(r3, a2.TRIANGLES, c2, h2, t.ColorMode.alphaBlended, t.CullFaceMode.disabled, Ei2(n2, t.Color.transparent, f2), u2, e2.debugBuffer, e2.quadTriangleIndexBuffer, e2.debugSegments);
          }
          const no2 = t.createLayout([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: so2 } = no2;
          function lo2(t2, e2, i2, o2) {
            t2.emplaceBack(e2, i2, o2);
          }
          class co {
            constructor(e2) {
              this.vertexArray = new t.StructArrayLayout3f12(), this.indices = new t.StructArrayLayout3ui6(), lo2(this.vertexArray, -1, -1, 1), lo2(this.vertexArray, 1, -1, 1), lo2(this.vertexArray, -1, 1, 1), lo2(this.vertexArray, 1, 1, 1), lo2(this.vertexArray, -1, -1, -1), lo2(this.vertexArray, 1, -1, -1), lo2(this.vertexArray, -1, 1, -1), lo2(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = e2.createVertexBuffer(this.vertexArray, so2), this.indexBuffer = e2.createIndexBuffer(this.indices), this.segment = t.SegmentVector.simpleSegment(0, 0, 36, 12);
            }
          }
          function ho(e2, i2, o2, r3, a2, n2) {
            const s2 = e2.gl, l2 = i2.paint.get("sky-atmosphere-color"), c2 = i2.paint.get("sky-atmosphere-halo-color"), h2 = i2.paint.get("sky-atmosphere-sun-intensity"), d2 = ((t2, e3, i3, o3, r4) => ({ u_matrix_3f: t2, u_sun_direction: e3, u_sun_intensity: i3, u_color_tint_r: [o3.r, o3.g, o3.b, o3.a], u_color_tint_m: [r4.r, r4.g, r4.b, r4.a], u_luminance: 5e-5 }))(t.fromMat4([], r3), a2, h2, l2, c2);
            s2.framebufferTexture2D(s2.FRAMEBUFFER, s2.COLOR_ATTACHMENT0, s2.TEXTURE_CUBE_MAP_POSITIVE_X + n2, i2.skyboxTexture, 0), o2.draw(e2, s2.TRIANGLES, t.DepthMode.disabled, t.StencilMode.disabled, t.ColorMode.unblended, t.CullFaceMode.frontCW, d2, "skyboxCapture", i2.skyboxGeometry.vertexBuffer, i2.skyboxGeometry.indexBuffer, i2.skyboxGeometry.segment);
          }
          const uo = { symbol: function(e2, i2, o2, r3, a2) {
            if (e2.renderPass !== "translucent")
              return;
            const n2 = t.StencilMode.disabled, s2 = e2.colorModeForRenderPass();
            o2.layout.get("text-variable-anchor") && function(e3, i3, o3, r4, a3, n3, s3) {
              const l2 = i3.transform, c2 = a3 === "map", h2 = n3 === "map";
              for (const a4 of e3) {
                const e4 = r4.getTile(a4), n4 = e4.getBucket(o3);
                if (!n4 || !n4.text || !n4.text.segments.get().length)
                  continue;
                const d2 = t.evaluateSizeForZoom(n4.textSizeData, l2.zoom), u2 = z(e4, 1, i3.transform.zoom), _2 = Ht(a4.projMatrix, h2, c2, i3.transform, u2), p2 = o3.layout.get("icon-text-fit") !== "none" && n4.hasIconData();
                if (d2) {
                  const i4 = Math.pow(2, l2.zoom - e4.tileID.overscaledZ), o4 = l2.elevation;
                  ji2(n4, c2, h2, s3, t.symbolSize, l2, _2, a4.projMatrix, i4, d2, p2, o4 ? (t2) => o4.getAtTileOffset(a4, t2.x, t2.y) : (t2) => 0);
                }
              }
            }(r3, e2, o2, i2, o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), a2), o2.paint.get("icon-opacity").constantOr(1) !== 0 && Wi2(e2, i2, o2, r3, false, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), o2.layout.get("icon-rotation-alignment"), o2.layout.get("icon-pitch-alignment"), o2.layout.get("icon-keep-upright"), n2, s2), o2.paint.get("text-opacity").constantOr(1) !== 0 && Wi2(e2, i2, o2, r3, true, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), o2.layout.get("text-keep-upright"), n2, s2), i2.map.showCollisionBoxes && (Gi2(e2, i2, o2, r3, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), true), Gi2(e2, i2, o2, r3, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), false));
          }, circle: function(e2, i2, o2, r3) {
            if (e2.renderPass !== "translucent")
              return;
            const a2 = o2.paint.get("circle-opacity"), n2 = o2.paint.get("circle-stroke-width"), s2 = o2.paint.get("circle-stroke-opacity"), l2 = o2.layout.get("circle-sort-key").constantOr(1) !== void 0;
            if (a2.constantOr(1) === 0 && (n2.constantOr(1) === 0 || s2.constantOr(1) === 0))
              return;
            const c2 = e2.context, h2 = c2.gl, d2 = e2.depthModeForSublayer(0, t.DepthMode.ReadOnly), u2 = t.StencilMode.disabled, _2 = e2.colorModeForRenderPass(), p2 = [];
            for (let a3 = 0; a3 < r3.length; a3++) {
              const n3 = r3[a3], s3 = i2.getTile(n3), c3 = s3.getBucket(o2);
              if (!c3)
                continue;
              const h3 = c3.programConfigurations.get(o2.id), d3 = wi2(o2), u3 = { programConfiguration: h3, program: e2.useProgram("circle", h3, d3), layoutVertexBuffer: c3.layoutVertexBuffer, indexBuffer: c3.indexBuffer, uniformValues: bi2(e2, n3, s3, o2), tile: s3 };
              if (l2) {
                const e3 = c3.segments.get();
                for (const i3 of e3)
                  p2.push({ segments: new t.SegmentVector([i3]), sortKey: i3.sortKey, state: u3 });
              } else
                p2.push({ segments: c3.segments, sortKey: 0, state: u3 });
            }
            l2 && p2.sort((t2, e3) => t2.sortKey - e3.sortKey);
            for (const i3 of p2) {
              const { programConfiguration: r4, program: a3, layoutVertexBuffer: n3, indexBuffer: s3, uniformValues: l3, tile: p3 } = i3.state, m2 = i3.segments;
              e2.terrain && e2.terrain.setupElevationDraw(p3, a3, { useDepthForOcclusion: true }), e2.prepareDrawProgram(c2, a3, p3.tileID.toUnwrapped()), a3.draw(c2, h2.TRIANGLES, d2, u2, _2, t.CullFaceMode.disabled, l3, o2.id, n3, s3, m2, o2.paint, e2.transform.zoom, r4);
            }
          }, heatmap: function(e2, i2, o2, r3) {
            if (o2.paint.get("heatmap-opacity") !== 0)
              if (e2.renderPass === "offscreen") {
                const a2 = e2.context, n2 = a2.gl, s2 = t.StencilMode.disabled, l2 = new t.ColorMode([n2.ONE, n2.ONE], t.Color.transparent, [true, true, true, true]);
                !function(t2, e3, i3) {
                  const o3 = t2.gl;
                  t2.activeTexture.set(o3.TEXTURE1), t2.viewport.set([0, 0, e3.width / 4, e3.height / 4]);
                  let r4 = i3.heatmapFbo;
                  if (r4)
                    o3.bindTexture(o3.TEXTURE_2D, r4.colorAttachment.get()), t2.bindFramebuffer.set(r4.framebuffer);
                  else {
                    const a3 = o3.createTexture();
                    o3.bindTexture(o3.TEXTURE_2D, a3), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_S, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_T, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MIN_FILTER, o3.LINEAR), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MAG_FILTER, o3.LINEAR), r4 = i3.heatmapFbo = t2.createFramebuffer(e3.width / 4, e3.height / 4, false), function(t3, e4, i4, o4) {
                      const r5 = t3.gl;
                      r5.texImage2D(r5.TEXTURE_2D, 0, r5.RGBA, e4.width / 4, e4.height / 4, 0, r5.RGBA, t3.extRenderToTextureHalfFloat ? t3.extTextureHalfFloat.HALF_FLOAT_OES : r5.UNSIGNED_BYTE, null), o4.colorAttachment.set(i4);
                    }(t2, e3, a3, r4);
                  }
                }(a2, e2, o2), a2.clear({ color: t.Color.transparent });
                for (let c2 = 0; c2 < r3.length; c2++) {
                  const h2 = r3[c2];
                  if (i2.hasRenderableParent(h2))
                    continue;
                  const d2 = i2.getTile(h2), u2 = d2.getBucket(o2);
                  if (!u2)
                    continue;
                  const _2 = u2.programConfigurations.get(o2.id), p2 = e2.useProgram("heatmap", _2), { zoom: m2 } = e2.transform;
                  e2.terrain && e2.terrain.setupElevationDraw(d2, p2), e2.prepareDrawProgram(a2, p2, h2.toUnwrapped()), p2.draw(a2, n2.TRIANGLES, t.DepthMode.disabled, s2, l2, t.CullFaceMode.disabled, Ci2(h2.projMatrix, d2, m2, o2.paint.get("heatmap-intensity")), o2.id, u2.layoutVertexBuffer, u2.indexBuffer, u2.segments, o2.paint, e2.transform.zoom, _2);
                }
                a2.viewport.set([0, 0, e2.width, e2.height]);
              } else
                e2.renderPass === "translucent" && (e2.context.setColorMode(e2.colorModeForRenderPass()), function(e3, i3) {
                  const o3 = e3.context, r4 = o3.gl, a2 = i3.heatmapFbo;
                  if (!a2)
                    return;
                  o3.activeTexture.set(r4.TEXTURE0), r4.bindTexture(r4.TEXTURE_2D, a2.colorAttachment.get()), o3.activeTexture.set(r4.TEXTURE1);
                  let n2 = i3.colorRampTexture;
                  n2 || (n2 = i3.colorRampTexture = new t.Texture(o3, i3.colorRamp, r4.RGBA)), n2.bind(r4.LINEAR, r4.CLAMP_TO_EDGE), e3.useProgram("heatmapTexture").draw(o3, r4.TRIANGLES, t.DepthMode.disabled, t.StencilMode.disabled, e3.colorModeForRenderPass(), t.CullFaceMode.disabled, ((t2, e4, i4, o4) => ({ u_image: 0, u_color_ramp: 1, u_opacity: e4.paint.get("heatmap-opacity") }))(0, i3), i3.id, e3.viewportBuffer, e3.quadTriangleIndexBuffer, e3.viewportSegments, i3.paint, e3.transform.zoom);
                }(e2, o2));
          }, line: function(e2, i2, o2, r3) {
            if (e2.renderPass !== "translucent")
              return;
            const a2 = o2.paint.get("line-opacity"), n2 = o2.paint.get("line-width");
            if (a2.constantOr(1) === 0 || n2.constantOr(1) === 0)
              return;
            const s2 = e2.depthModeForSublayer(0, t.DepthMode.ReadOnly), l2 = e2.colorModeForRenderPass(), c2 = o2.paint.get("line-dasharray"), h2 = c2.constantOr(1), d2 = o2.layout.get("line-cap"), u2 = o2.paint.get("line-pattern"), _2 = u2.constantOr(1), p2 = o2.paint.get("line-gradient"), m2 = o2.getCrossfadeParameters(), f2 = _2 ? "linePattern" : h2 ? "lineSDF" : p2 ? "lineGradient" : "line", g2 = e2.context, v2 = g2.gl;
            for (const a3 of r3) {
              const r4 = i2.getTile(a3);
              if (_2 && !r4.patternsLoaded())
                continue;
              const n3 = r4.getBucket(o2);
              if (!n3)
                continue;
              e2.prepareDrawTile(a3);
              const x3 = n3.programConfigurations.get(o2.id), y2 = e2.useProgram(f2, x3), b2 = u2.constantOr(null);
              if (b2 && r4.imageAtlas) {
                const t2 = r4.imageAtlas, e3 = t2.patternPositions[b2.to.toString()], i3 = t2.patternPositions[b2.from.toString()];
                e3 && i3 && x3.setConstantPatternPositions(e3, i3);
              }
              const w3 = c2.constantOr(null), T2 = d2.constantOr(null);
              if (!_2 && w3 && T2 && r4.lineAtlas) {
                const t2 = r4.lineAtlas, e3 = t2.getDash(w3.to, T2), i3 = t2.getDash(w3.from, T2);
                e3 && i3 && x3.setConstantPatternPositions(e3, i3);
              }
              const E2 = e2.terrain ? a3.projMatrix : null, C2 = _2 ? Mi2(e2, r4, o2, m2, E2) : h2 ? zi2(e2, r4, o2, m2, E2) : p2 ? Ii2(e2, r4, o2, E2, n3.lineClipsArray.length) : Si2(e2, r4, o2, E2);
              if (_2)
                g2.activeTexture.set(v2.TEXTURE0), r4.imageAtlasTexture.bind(v2.LINEAR, v2.CLAMP_TO_EDGE), x3.updatePaintBuffers(m2);
              else if (h2)
                g2.activeTexture.set(v2.TEXTURE0), r4.lineAtlasTexture.bind(v2.LINEAR, v2.REPEAT), x3.updatePaintBuffers(m2);
              else if (p2) {
                const r5 = n3.gradients[o2.id];
                let s3 = r5.texture;
                if (o2.gradientVersion !== r5.version) {
                  let l3 = 256;
                  if (o2.stepInterpolant) {
                    const o3 = i2.getSource().maxzoom, r6 = a3.canonical.z === o3 ? Math.ceil(1 << e2.transform.maxZoom - a3.canonical.z) : 1;
                    l3 = t.clamp(t.nextPowerOfTwo(n3.maxLineLength / t.EXTENT * 1024 * r6), 256, g2.maxTextureSize);
                  }
                  r5.gradient = t.renderColorRamp({ expression: o2.gradientExpression(), evaluationKey: "lineProgress", resolution: l3, image: r5.gradient || void 0, clips: n3.lineClipsArray }), r5.texture ? r5.texture.update(r5.gradient) : r5.texture = new t.Texture(g2, r5.gradient, v2.RGBA), r5.version = o2.gradientVersion, s3 = r5.texture;
                }
                g2.activeTexture.set(v2.TEXTURE0), s3.bind(o2.stepInterpolant ? v2.NEAREST : v2.LINEAR, v2.CLAMP_TO_EDGE);
              }
              e2.prepareDrawProgram(g2, y2, a3.toUnwrapped()), y2.draw(g2, v2.TRIANGLES, s2, e2.stencilModeForClipping(a3), l2, t.CullFaceMode.disabled, C2, o2.id, n3.layoutVertexBuffer, n3.indexBuffer, n3.segments, o2.paint, e2.transform.zoom, x3, n3.layoutVertexBuffer2);
            }
          }, fill: function(e2, i2, o2, r3) {
            const a2 = o2.paint.get("fill-color"), n2 = o2.paint.get("fill-opacity");
            if (n2.constantOr(1) === 0)
              return;
            const s2 = e2.colorModeForRenderPass(), l2 = o2.paint.get("fill-pattern"), c2 = e2.opaquePassEnabledForLayer() && !l2.constantOr(1) && a2.constantOr(t.Color.transparent).a === 1 && n2.constantOr(0) === 1 ? "opaque" : "translucent";
            if (e2.renderPass === c2) {
              const a3 = e2.depthModeForSublayer(1, e2.renderPass === "opaque" ? t.DepthMode.ReadWrite : t.DepthMode.ReadOnly);
              Xi2(e2, i2, o2, r3, a3, s2, false);
            }
            if (e2.renderPass === "translucent" && o2.paint.get("fill-antialias")) {
              const a3 = e2.depthModeForSublayer(o2.getPaintProperty("fill-outline-color") ? 2 : 0, t.DepthMode.ReadOnly);
              Xi2(e2, i2, o2, r3, a3, s2, true);
            }
          }, "fill-extrusion": function(e2, i2, o2, r3) {
            const a2 = o2.paint.get("fill-extrusion-opacity");
            if (a2 !== 0 && e2.renderPass === "translucent") {
              const n2 = new t.DepthMode(e2.context.gl.LEQUAL, t.DepthMode.ReadWrite, e2.depthRangeFor3D);
              if (a2 !== 1 || o2.paint.get("fill-extrusion-pattern").constantOr(1))
                Hi2(e2, i2, o2, r3, n2, t.StencilMode.disabled, t.ColorMode.disabled), Hi2(e2, i2, o2, r3, n2, e2.stencilModeFor3D(), e2.colorModeForRenderPass());
              else {
                const a3 = e2.colorModeForRenderPass();
                Hi2(e2, i2, o2, r3, n2, t.StencilMode.disabled, a3);
              }
            }
          }, hillshade: function(e2, i2, o2, r3) {
            if (e2.renderPass !== "offscreen" && e2.renderPass !== "translucent")
              return;
            const a2 = e2.context, n2 = e2.depthModeForSublayer(0, t.DepthMode.ReadOnly), s2 = e2.colorModeForRenderPass(), l2 = e2.terrain && e2.terrain.renderingToTexture, [c2, h2] = e2.renderPass !== "translucent" || l2 ? [{}, r3] : e2.stencilConfigForOverlap(r3);
            for (const r4 of h2) {
              const a3 = i2.getTile(r4);
              if (a3.needsHillshadePrepare && e2.renderPass === "offscreen")
                ei2(e2, a3, o2, n2, t.StencilMode.disabled, s2);
              else if (e2.renderPass === "translucent") {
                const t2 = l2 && e2.terrain ? e2.terrain.stencilModeForRTTOverlap(r4) : c2[r4.overscaledZ];
                Je2(e2, r4, a3, o2, n2, t2, s2);
              }
            }
            a2.viewport.set([0, 0, e2.width, e2.height]);
          }, raster: function(e2, i2, o2, r3, a2, n2) {
            if (e2.renderPass !== "translucent")
              return;
            if (o2.paint.get("raster-opacity") === 0)
              return;
            if (!r3.length)
              return;
            const s2 = e2.context, l2 = s2.gl, c2 = i2.getSource(), h2 = e2.useProgram("raster"), d2 = e2.colorModeForRenderPass(), u2 = e2.terrain && e2.terrain.renderingToTexture, [_2, p2] = c2 instanceof Et2 || u2 ? [{}, r3] : e2.stencilConfigForOverlap(r3), m2 = p2[p2.length - 1].overscaledZ, f2 = !e2.options.moving;
            for (const r4 of p2) {
              const a3 = u2 ? t.DepthMode.disabled : e2.depthModeForSublayer(r4.overscaledZ - m2, o2.paint.get("raster-opacity") === 1 ? t.DepthMode.ReadWrite : t.DepthMode.ReadOnly, l2.LESS), p3 = r4.toUnwrapped(), g2 = i2.getTile(r4);
              if (u2 && (!g2 || !g2.hasData()))
                continue;
              const v2 = u2 ? r4.projMatrix : e2.transform.calculateProjMatrix(p3, f2), x3 = e2.terrain && u2 ? e2.terrain.stencilModeForRTTOverlap(r4) : _2[r4.overscaledZ], y2 = n2 ? 0 : o2.paint.get("raster-fade-duration");
              g2.registerFadeDuration(y2);
              const b2 = i2.findLoadedParent(r4, 0), w3 = li2(g2, b2, i2, e2.transform, y2);
              let T2, E2;
              e2.terrain && e2.terrain.prepareDrawTile(r4);
              const C2 = o2.paint.get("raster-resampling") === "nearest" ? l2.NEAREST : l2.LINEAR;
              s2.activeTexture.set(l2.TEXTURE0), g2.texture.bind(C2, l2.CLAMP_TO_EDGE, l2.LINEAR_MIPMAP_NEAREST), s2.activeTexture.set(l2.TEXTURE1), b2 ? (b2.texture.bind(C2, l2.CLAMP_TO_EDGE, l2.LINEAR_MIPMAP_NEAREST), T2 = Math.pow(2, b2.tileID.overscaledZ - g2.tileID.overscaledZ), E2 = [g2.tileID.canonical.x * T2 % 1, g2.tileID.canonical.y * T2 % 1]) : g2.texture.bind(C2, l2.CLAMP_TO_EDGE, l2.LINEAR_MIPMAP_NEAREST);
              const S2 = Pi2(v2, E2 || [0, 0], T2 || 1, w3, o2);
              e2.prepareDrawProgram(s2, h2, p3), c2 instanceof Et2 ? h2.draw(s2, l2.TRIANGLES, a3, t.StencilMode.disabled, d2, t.CullFaceMode.disabled, S2, o2.id, c2.boundsBuffer, e2.quadTriangleIndexBuffer, c2.boundsSegments) : h2.draw(s2, l2.TRIANGLES, a3, x3, d2, t.CullFaceMode.disabled, S2, o2.id, e2.rasterBoundsBuffer, e2.quadTriangleIndexBuffer, e2.rasterBoundsSegments);
            }
          }, background: function(e2, i2, o2, r3) {
            const a2 = o2.paint.get("background-color"), n2 = o2.paint.get("background-opacity");
            if (n2 === 0)
              return;
            const s2 = e2.context, l2 = s2.gl, c2 = e2.transform, h2 = c2.tileSize, d2 = o2.paint.get("background-pattern");
            if (e2.isPatternMissing(d2))
              return;
            const u2 = !d2 && a2.a === 1 && n2 === 1 && e2.opaquePassEnabledForLayer() ? "opaque" : "translucent";
            if (e2.renderPass !== u2)
              return;
            const _2 = t.StencilMode.disabled, p2 = e2.depthModeForSublayer(0, u2 === "opaque" ? t.DepthMode.ReadWrite : t.DepthMode.ReadOnly), m2 = e2.colorModeForRenderPass(), f2 = e2.useProgram(d2 ? "backgroundPattern" : "background"), g2 = r3 || c2.coveringTiles({ tileSize: h2 });
            d2 && (s2.activeTexture.set(l2.TEXTURE0), e2.imageManager.bind(e2.context));
            const v2 = o2.getCrossfadeParameters();
            for (const i3 of g2) {
              const c3 = i3.toUnwrapped(), u3 = r3 ? i3.projMatrix : e2.transform.calculateProjMatrix(c3);
              e2.prepareDrawTile(i3);
              const g3 = d2 ? Oi2(u3, n2, e2, d2, { tileID: i3, tileSize: h2 }, v2) : Bi2(u3, n2, a2);
              e2.prepareDrawProgram(s2, f2, c3), f2.draw(s2, l2.TRIANGLES, p2, _2, m2, t.CullFaceMode.disabled, g3, o2.id, e2.tileExtentBuffer, e2.quadTriangleIndexBuffer, e2.tileExtentSegments);
            }
          }, sky: function(e2, i2, o2) {
            const r3 = o2.paint.get("sky-opacity");
            if (r3 === 0)
              return;
            const a2 = e2.context, n2 = o2.paint.get("sky-type"), s2 = new t.DepthMode(a2.gl.LEQUAL, t.DepthMode.ReadOnly, [0, 1]), l2 = e2.frameCounter / 1e3 % 1;
            n2 === "atmosphere" ? e2.renderPass === "offscreen" ? o2.needsSkyboxCapture(e2) && (function(e3, i3, o3, r4) {
              const a3 = e3.context, n3 = a3.gl;
              let s3 = i3.skyboxFbo;
              if (!s3) {
                s3 = i3.skyboxFbo = a3.createFramebuffer(32, 32, false), i3.skyboxGeometry = new co(a3), i3.skyboxTexture = a3.gl.createTexture(), n3.bindTexture(n3.TEXTURE_CUBE_MAP, i3.skyboxTexture), n3.texParameteri(n3.TEXTURE_CUBE_MAP, n3.TEXTURE_WRAP_S, n3.CLAMP_TO_EDGE), n3.texParameteri(n3.TEXTURE_CUBE_MAP, n3.TEXTURE_WRAP_T, n3.CLAMP_TO_EDGE), n3.texParameteri(n3.TEXTURE_CUBE_MAP, n3.TEXTURE_MIN_FILTER, n3.LINEAR), n3.texParameteri(n3.TEXTURE_CUBE_MAP, n3.TEXTURE_MAG_FILTER, n3.LINEAR);
                for (let t2 = 0; t2 < 6; ++t2)
                  n3.texImage2D(n3.TEXTURE_CUBE_MAP_POSITIVE_X + t2, 0, n3.RGBA, 32, 32, 0, n3.RGBA, n3.UNSIGNED_BYTE, null);
              }
              a3.bindFramebuffer.set(s3.framebuffer), a3.viewport.set([0, 0, 32, 32]);
              const l3 = i3.getCenter(e3, true), c2 = e3.useProgram("skyboxCapture"), h2 = new Float64Array(16);
              t.identity(h2), t.rotateY(h2, h2, 0.5 * -Math.PI), ho(a3, i3, c2, h2, l3, 0), t.identity(h2), t.rotateY(h2, h2, 0.5 * Math.PI), ho(a3, i3, c2, h2, l3, 1), t.identity(h2), t.rotateX(h2, h2, 0.5 * -Math.PI), ho(a3, i3, c2, h2, l3, 2), t.identity(h2), t.rotateX(h2, h2, 0.5 * Math.PI), ho(a3, i3, c2, h2, l3, 3), t.identity(h2), ho(a3, i3, c2, h2, l3, 4), t.identity(h2), t.rotateY(h2, h2, Math.PI), ho(a3, i3, c2, h2, l3, 5), a3.viewport.set([0, 0, e3.width, e3.height]);
            }(e2, o2), o2.markSkyboxValid(e2)) : e2.renderPass === "sky" && function(e3, i3, o3, r4, a3) {
              const n3 = e3.context, s3 = n3.gl, l3 = e3.transform, c2 = e3.useProgram("skybox");
              n3.activeTexture.set(s3.TEXTURE0), s3.bindTexture(s3.TEXTURE_CUBE_MAP, i3.skyboxTexture);
              const h2 = ((t2, e4, i4, o4, r5) => ({ u_matrix: t2, u_sun_direction: e4, u_cubemap: 0, u_opacity: o4, u_temporal_offset: r5 }))(l3.skyboxMatrix, i3.getCenter(e3, false), 0, r4, a3);
              e3.prepareDrawProgram(n3, c2), c2.draw(n3, s3.TRIANGLES, o3, t.StencilMode.disabled, e3.colorModeForRenderPass(), t.CullFaceMode.backCW, h2, "skybox", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
            }(e2, o2, s2, r3, l2) : n2 === "gradient" && e2.renderPass === "sky" && function(e3, i3, o3, r4, a3) {
              const n3 = e3.context, s3 = n3.gl, l3 = e3.transform, c2 = e3.useProgram("skyboxGradient");
              i3.skyboxGeometry || (i3.skyboxGeometry = new co(n3)), n3.activeTexture.set(s3.TEXTURE0);
              let h2 = i3.colorRampTexture;
              h2 || (h2 = i3.colorRampTexture = new t.Texture(n3, i3.colorRamp, s3.RGBA)), h2.bind(s3.LINEAR, s3.CLAMP_TO_EDGE);
              const d2 = ((e4, i4, o4, r5, a4) => ({ u_matrix: e4, u_color_ramp: 0, u_center_direction: i4, u_radius: t.degToRad(o4), u_opacity: r5, u_temporal_offset: a4 }))(l3.skyboxMatrix, i3.getCenter(e3, false), i3.paint.get("sky-gradient-radius"), r4, a3);
              e3.prepareDrawProgram(n3, c2), c2.draw(n3, s3.TRIANGLES, o3, t.StencilMode.disabled, e3.colorModeForRenderPass(), t.CullFaceMode.backCW, d2, "skyboxGradient", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
            }(e2, o2, s2, r3, l2);
          }, debug: function(t2, e2, i2) {
            for (let o2 = 0; o2 < i2.length; o2++)
              ao2(t2, e2, i2[o2]);
          }, custom: function(e2, i2, o2) {
            const r3 = e2.context, a2 = o2.implementation;
            if (e2.renderPass === "offscreen") {
              const t2 = a2.prerender;
              t2 && (e2.setCustomLayerDefaults(), r3.setColorMode(e2.colorModeForRenderPass()), t2.call(a2, r3.gl, e2.transform.customLayerMatrix()), r3.setDirty(), e2.setBaseState());
            } else if (e2.renderPass === "translucent") {
              e2.setCustomLayerDefaults(), r3.setColorMode(e2.colorModeForRenderPass()), r3.setStencilMode(t.StencilMode.disabled);
              const i3 = a2.renderingMode === "3d" ? new t.DepthMode(e2.context.gl.LEQUAL, t.DepthMode.ReadWrite, e2.depthRangeFor3D) : e2.depthModeForSublayer(0, t.DepthMode.ReadOnly);
              r3.setDepthMode(i3), a2.render(r3.gl, e2.transform.customLayerMatrix()), r3.setDirty(), e2.setBaseState(), r3.bindFramebuffer.set(null);
            }
          } };
          class _o2 {
            constructor(e2, i2) {
              this.context = new yt2(e2), this.transform = i2, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.setup(), this.numSublayers = t.SourceCache.maxUnderzooming + t.SourceCache.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Fe(), this.gpuTimers = {}, this.frameCounter = 0;
            }
            updateTerrain(t2, e2) {
              const i2 = !!t2 && !!t2.terrain;
              if (!(i2 || this._terrain && this._terrain.enabled))
                return;
              this._terrain || (this._terrain = new di(this, t2));
              const o2 = this._terrain;
              this.transform.elevation = i2 ? o2 : null, o2.update(t2, this.transform, e2);
            }
            _updateFog(t2) {
              const e2 = t2.fog;
              if (!e2 || e2.getOpacity(this.transform.pitch) < 1 || e2.properties.get("horizon-blend") < 0.03)
                return void (this.transform.fogCullDistSq = null);
              const [i2, o2] = e2.getFovAdjustedRange(this.transform._fov);
              if (i2 > o2)
                return void (this.transform.fogCullDistSq = null);
              const r3 = i2 + 0.78 * (o2 - i2);
              this.transform.fogCullDistSq = r3 * r3;
            }
            get terrain() {
              return this._terrain && this._terrain.enabled ? this._terrain : null;
            }
            resize(e2, i2) {
              if (this.width = e2 * t.exported.devicePixelRatio, this.height = i2 * t.exported.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
                for (const t2 of this.style.order)
                  this.style._layers[t2].resize();
            }
            setup() {
              const e2 = this.context, i2 = new t.StructArrayLayout2i4();
              i2.emplaceBack(0, 0), i2.emplaceBack(t.EXTENT, 0), i2.emplaceBack(0, t.EXTENT), i2.emplaceBack(t.EXTENT, t.EXTENT), this.tileExtentBuffer = e2.createVertexBuffer(i2, t.posAttributes.members), this.tileExtentSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
              const o2 = new t.StructArrayLayout2i4();
              o2.emplaceBack(0, 0), o2.emplaceBack(t.EXTENT, 0), o2.emplaceBack(0, t.EXTENT), o2.emplaceBack(t.EXTENT, t.EXTENT), this.debugBuffer = e2.createVertexBuffer(o2, t.posAttributes.members), this.debugSegments = t.SegmentVector.simpleSegment(0, 0, 4, 5);
              const r3 = new t.StructArrayLayout4i8();
              r3.emplaceBack(0, 0, 0, 0), r3.emplaceBack(t.EXTENT, 0, t.EXTENT, 0), r3.emplaceBack(0, t.EXTENT, 0, t.EXTENT), r3.emplaceBack(t.EXTENT, t.EXTENT, t.EXTENT, t.EXTENT), this.rasterBoundsBuffer = e2.createVertexBuffer(r3, Tt2.members), this.rasterBoundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
              const a2 = new t.StructArrayLayout2i4();
              a2.emplaceBack(-1, -1), a2.emplaceBack(1, -1), a2.emplaceBack(-1, 1), a2.emplaceBack(1, 1), this.viewportBuffer = e2.createVertexBuffer(a2, t.posAttributes.members), this.viewportSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
              const n2 = new t.StructArrayLayout1ui2();
              n2.emplaceBack(0), n2.emplaceBack(1), n2.emplaceBack(3), n2.emplaceBack(2), n2.emplaceBack(0), this.tileBorderIndexBuffer = e2.createIndexBuffer(n2);
              const s2 = new t.StructArrayLayout3ui6();
              s2.emplaceBack(0, 1, 2), s2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e2.createIndexBuffer(s2), this.emptyTexture = new t.Texture(e2, { width: 1, height: 1, data: new Uint8Array([0, 0, 0, 0]) }, e2.gl.RGBA), this.identityMat = t.create$1();
              const l2 = this.context.gl;
              this.stencilClearMode = new t.StencilMode({ func: l2.ALWAYS, mask: 0 }, 0, 255, l2.ZERO, l2.ZERO, l2.ZERO), this.loadTimeStamps.push(t.window.performance.now());
            }
            clearStencil() {
              const e2 = this.context, i2 = e2.gl;
              this.nextStencilID = 1, this.currentStencilSource = void 0, this.useProgram("clippingMask").draw(e2, i2.TRIANGLES, t.DepthMode.disabled, this.stencilClearMode, t.ColorMode.disabled, t.CullFaceMode.disabled, si(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
            }
            _renderTileClippingMasks(e2, i2, o2) {
              if (!(i2 && this.currentStencilSource !== i2.id && e2.isTileClipped() && o2 && o2.length))
                return;
              this.currentStencilSource = i2.id;
              const r3 = this.context, a2 = r3.gl;
              this.nextStencilID + o2.length > 256 && this.clearStencil(), r3.setColorMode(t.ColorMode.disabled), r3.setDepthMode(t.DepthMode.disabled);
              const n2 = this.useProgram("clippingMask");
              this._tileClippingMaskIDs = {};
              for (const e3 of o2) {
                const i3 = this._tileClippingMaskIDs[e3.key] = this.nextStencilID++;
                n2.draw(r3, a2.TRIANGLES, t.DepthMode.disabled, new t.StencilMode({ func: a2.ALWAYS, mask: 0 }, i3, 255, a2.KEEP, a2.KEEP, a2.REPLACE), t.ColorMode.disabled, t.CullFaceMode.disabled, si(e3.projMatrix), "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
              }
            }
            stencilModeFor3D() {
              this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
              const e2 = this.nextStencilID++, i2 = this.context.gl;
              return new t.StencilMode({ func: i2.NOTEQUAL, mask: 255 }, e2, 255, i2.KEEP, i2.KEEP, i2.REPLACE);
            }
            stencilModeForClipping(e2) {
              if (this.terrain)
                return this.terrain.stencilModeForRTTOverlap(e2);
              const i2 = this.context.gl;
              return new t.StencilMode({ func: i2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e2.key], 0, i2.KEEP, i2.KEEP, i2.REPLACE);
            }
            stencilConfigForOverlap(e2) {
              const i2 = this.context.gl, o2 = e2.sort((t2, e3) => e3.overscaledZ - t2.overscaledZ), r3 = o2[o2.length - 1].overscaledZ, a2 = o2[0].overscaledZ - r3 + 1;
              if (a2 > 1) {
                this.currentStencilSource = void 0, this.nextStencilID + a2 > 256 && this.clearStencil();
                const e3 = {};
                for (let o3 = 0; o3 < a2; o3++)
                  e3[o3 + r3] = new t.StencilMode({ func: i2.GEQUAL, mask: 255 }, o3 + this.nextStencilID, 255, i2.KEEP, i2.KEEP, i2.REPLACE);
                return this.nextStencilID += a2, [e3, o2];
              }
              return [{ [r3]: t.StencilMode.disabled }, o2];
            }
            colorModeForRenderPass() {
              const e2 = this.context.gl;
              if (this._showOverdrawInspector) {
                const i2 = 1 / 8;
                return new t.ColorMode([e2.CONSTANT_COLOR, e2.ONE], new t.Color(i2, i2, i2, 0), [true, true, true, true]);
              }
              return this.renderPass === "opaque" ? t.ColorMode.unblended : t.ColorMode.alphaBlended;
            }
            depthModeForSublayer(e2, i2, o2) {
              if (!this.opaquePassEnabledForLayer())
                return t.DepthMode.disabled;
              const r3 = 1 - ((1 + this.currentLayer) * this.numSublayers + e2) * this.depthEpsilon;
              return new t.DepthMode(o2 || this.context.gl.LEQUAL, i2, [r3, r3]);
            }
            opaquePassEnabledForLayer() {
              return this.currentLayer < this.opaquePassCutoff;
            }
            render(e2, i2) {
              this.style = e2, this.options = i2, this.lineAtlas = e2.lineAtlas, this.imageManager = e2.imageManager, this.glyphManager = e2.glyphManager, this.symbolFadeChange = e2.placement.symbolFadeChange(t.exported.now()), this.imageManager.beginFrame();
              const o2 = this.style.order, r3 = this.style._sourceCaches;
              for (const t2 in r3) {
                const e3 = r3[t2];
                e3.used && e3.prepare(this.context);
              }
              const a2 = {}, n2 = {}, s2 = {};
              for (const t2 in r3) {
                const e3 = r3[t2];
                a2[t2] = e3.getVisibleCoordinates(), n2[t2] = a2[t2].slice().reverse(), s2[t2] = e3.getVisibleCoordinates(true).reverse();
              }
              this.opaquePassCutoff = 1 / 0;
              for (let t2 = 0; t2 < o2.length; t2++)
                if (this.style._layers[o2[t2]].is3D()) {
                  this.opaquePassCutoff = t2;
                  break;
                }
              if (this.terrain && (this.terrain.updateTileBinding(s2), this.opaquePassCutoff = 0), !t.isMapAuthenticated(this.context.gl))
                return;
              this.renderPass = "offscreen";
              for (const t2 of o2) {
                const i3 = this.style._layers[t2], o3 = e2._getLayerSourceCache(i3);
                if (!i3.hasOffscreenPass() || i3.isHidden(this.transform.zoom))
                  continue;
                const r4 = o3 ? n2[o3.id] : void 0;
                (i3.type === "custom" || i3.isSky() || r4 && r4.length) && this.renderLayer(this, o3, i3, r4);
              }
              this.depthRangeFor3D = [0, 1 - (e2.order.length + 2) * this.numSublayers * this.depthEpsilon], this.terrain && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && this.terrain.drawDepth(), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);
              let l2 = t.Color.transparent;
              if (this.style.fog && (l2 = this.style.fog.properties.get("color")), this.context.clear({ color: i2.showOverdrawInspector ? t.Color.black : l2, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i2.showOverdrawInspector, this.renderPass = "opaque", !this.terrain)
                for (this.currentLayer = o2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                  const t2 = this.style._layers[o2[this.currentLayer]], i3 = e2._getLayerSourceCache(t2);
                  if (t2.isSky())
                    continue;
                  const r4 = i3 ? n2[i3.id] : void 0;
                  this._renderTileClippingMasks(t2, i3, r4), this.renderLayer(this, i3, t2, r4);
                }
              if (this.renderPass = "sky", this.transform.isHorizonVisible())
                for (this.currentLayer = 0; this.currentLayer < o2.length; this.currentLayer++) {
                  const t2 = this.style._layers[o2[this.currentLayer]], i3 = e2._getLayerSourceCache(t2);
                  t2.isSky() && this.renderLayer(this, i3, t2, i3 ? n2[i3.id] : void 0);
                }
              for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < o2.length; ) {
                const t2 = this.style._layers[o2[this.currentLayer]], i3 = e2._getLayerSourceCache(t2);
                if (t2.isSky()) {
                  ++this.currentLayer;
                  continue;
                }
                if (this.terrain && this.style.isLayerDraped(t2)) {
                  if (t2.isHidden(this.transform.zoom)) {
                    ++this.currentLayer;
                    continue;
                  }
                  this.currentLayer = this.terrain.renderBatch(this.currentLayer);
                  continue;
                }
                const r4 = i3 ? (t2.type === "symbol" ? s2 : n2)[i3.id] : void 0;
                this._renderTileClippingMasks(t2, i3, i3 ? a2[i3.id] : void 0), this.renderLayer(this, i3, t2, r4), ++this.currentLayer;
              }
              if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry) {
                let i3 = null;
                t.values(this.style._layers).forEach((t2) => {
                  const o3 = e2._getLayerSourceCache(t2);
                  o3 && !t2.isHidden(this.transform.zoom) && (!i3 || i3.getSource().maxzoom < o3.getSource().maxzoom) && (i3 = o3);
                }), i3 && this.options.showTileBoundaries && uo.debug(this, i3, i3.getVisibleCoordinates());
              }
              this.options.showPadding && function(t2) {
                const e3 = t2.transform.padding;
                io2(t2, t2.transform.height - (e3.top || 0), 3, Yi2), io2(t2, e3.bottom || 0, 3, Qi2), oo2(t2, e3.left || 0, 3, Ji2), oo2(t2, t2.transform.width - (e3.right || 0), 3, to2);
                const i3 = t2.transform.centerPoint;
                !function(t3, e4, i4, o3) {
                  ro2(t3, e4 - 1, i4 - 10, 2, 20, o3), ro2(t3, e4 - 10, i4 - 1, 20, 2, o3);
                }(t2, i3.x, t2.transform.height - i3.y, eo2);
              }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % t.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(t.window.performance.now()), this.saveCanvasCopy());
            }
            renderLayer(t2, e2, i2, o2) {
              i2.isHidden(this.transform.zoom) || (i2.type === "background" || i2.type === "sky" || i2.type === "custom" || o2 && o2.length) && (this.id = i2.id, this.gpuTimingStart(i2), uo[i2.type](t2, e2, i2, o2, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
            }
            gpuTimingStart(t2) {
              if (!this.options.gpuTiming)
                return;
              const e2 = this.context.extTimerQuery;
              let i2 = this.gpuTimers[t2.id];
              i2 || (i2 = this.gpuTimers[t2.id] = { calls: 0, cpuTime: 0, query: e2.createQueryEXT() }), i2.calls++, e2.beginQueryEXT(e2.TIME_ELAPSED_EXT, i2.query);
            }
            gpuTimingEnd() {
              if (!this.options.gpuTiming)
                return;
              const t2 = this.context.extTimerQuery;
              t2.endQueryEXT(t2.TIME_ELAPSED_EXT);
            }
            collectGpuTimers() {
              const t2 = this.gpuTimers;
              return this.gpuTimers = {}, t2;
            }
            queryGpuTimers(t2) {
              const e2 = {};
              for (const i2 in t2) {
                const o2 = t2[i2], r3 = this.context.extTimerQuery, a2 = r3.getQueryObjectEXT(o2.query, r3.QUERY_RESULT_EXT) / 1e6;
                r3.deleteQueryEXT(o2.query), e2[i2] = a2;
              }
              return e2;
            }
            translatePosMatrix(e2, i2, o2, r3, a2) {
              if (!o2[0] && !o2[1])
                return e2;
              const n2 = a2 ? r3 === "map" ? this.transform.angle : 0 : r3 === "viewport" ? -this.transform.angle : 0;
              if (n2) {
                const t2 = Math.sin(n2), e3 = Math.cos(n2);
                o2 = [o2[0] * e3 - o2[1] * t2, o2[0] * t2 + o2[1] * e3];
              }
              const s2 = [a2 ? o2[0] : z(i2, o2[0], this.transform.zoom), a2 ? o2[1] : z(i2, o2[1], this.transform.zoom), 0], l2 = new Float32Array(16);
              return t.translate(l2, e2, s2), l2;
            }
            saveTileTexture(t2) {
              const e2 = this._tileTextures[t2.size[0]];
              e2 ? e2.push(t2) : this._tileTextures[t2.size[0]] = [t2];
            }
            getTileTexture(t2) {
              const e2 = this._tileTextures[t2];
              return e2 && e2.length > 0 ? e2.pop() : null;
            }
            isPatternMissing(t2) {
              if (!t2)
                return false;
              if (!t2.from || !t2.to)
                return true;
              const e2 = this.imageManager.getPattern(t2.from.toString()), i2 = this.imageManager.getPattern(t2.to.toString());
              return !e2 || !i2;
            }
            currentGlobalDefines() {
              const t2 = this.terrain && this.terrain.renderingToTexture, e2 = this.style && this.style.fog, i2 = [];
              return this.terrain && !this.terrain.renderingToTexture && i2.push("TERRAIN"), e2 && !t2 && e2.getOpacity(this.transform.pitch) !== 0 && i2.push("FOG"), t2 && i2.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && i2.push("OVERDRAW_INSPECTOR"), i2;
            }
            useProgram(t2, e2, i2) {
              this.cache = this.cache || {};
              const o2 = i2 || [], r3 = this.currentGlobalDefines().concat(o2), a2 = _i.cacheKey(t2, r3, e2);
              return this.cache[a2] || (this.cache[a2] = new _i(this.context, t2, He[t2], e2, Ui2[t2], r3)), this.cache[a2];
            }
            setCustomLayerDefaults() {
              this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
            }
            setBaseState() {
              const t2 = this.context.gl;
              this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t2.FUNC_ADD);
            }
            initDebugOverlayCanvas() {
              this.debugOverlayCanvas == null && (this.debugOverlayCanvas = t.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new t.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
            }
            destroy() {
              this._terrain && this._terrain.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy();
            }
            prepareDrawTile(t2) {
              this.terrain && this.terrain.prepareDrawTile(t2);
            }
            prepareDrawProgram(t2, e2, i2) {
              if (this.terrain && this.terrain.renderingToTexture)
                return;
              const o2 = this.style.fog;
              if (o2) {
                const r3 = o2.getOpacity(this.transform.pitch);
                r3 !== 0 && e2.setFogUniformValues(t2, ((t3, e3, i3, o3) => {
                  const r4 = e3.properties.get("color"), a2 = t3.frameCounter / 1e3 % 1, n2 = [r4.r / r4.a, r4.g / r4.a, r4.b / r4.a, o3];
                  return { u_fog_matrix: i3 ? t3.transform.calculateFogTileMatrix(i3) : t3.identityMat, u_fog_range: e3.getFovAdjustedRange(t3.transform._fov), u_fog_color: n2, u_fog_horizon_blend: e3.properties.get("horizon-blend"), u_fog_temporal_offset: a2 };
                })(this, o2, i2, r3));
              }
            }
            setTileLoadedFlag(t2) {
              this.tileLoaded = t2;
            }
            saveCanvasCopy() {
              this.frameCopies.push(this.canvasCopy()), this.tileLoaded = false;
            }
            canvasCopy() {
              const t2 = this.context.gl, e2 = t2.createTexture();
              return t2.bindTexture(t2.TEXTURE_2D, e2), t2.copyTexImage2D(t2.TEXTURE_2D, 0, t2.RGBA, 0, 0, t2.drawingBufferWidth, t2.drawingBufferHeight, 0), e2;
            }
            getCanvasCopiesAndTimestamps() {
              return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
            }
            averageElevationNeedsEasing() {
              if (!this.transform._elevation)
                return false;
              const t2 = this.style && this.style.fog;
              return !!t2 && t2.getOpacity(this.transform.pitch) !== 0;
            }
          }
          class po2 {
            constructor(t2 = 0, e2 = 0, i2 = 0, o2 = 0) {
              if (isNaN(t2) || t2 < 0 || isNaN(e2) || e2 < 0 || isNaN(i2) || i2 < 0 || isNaN(o2) || o2 < 0)
                throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
              this.top = t2, this.bottom = e2, this.left = i2, this.right = o2;
            }
            interpolate(e2, i2, o2) {
              return i2.top != null && e2.top != null && (this.top = t.number(e2.top, i2.top, o2)), i2.bottom != null && e2.bottom != null && (this.bottom = t.number(e2.bottom, i2.bottom, o2)), i2.left != null && e2.left != null && (this.left = t.number(e2.left, i2.left, o2)), i2.right != null && e2.right != null && (this.right = t.number(e2.right, i2.right, o2)), this;
            }
            getCenter(e2, i2) {
              const o2 = t.clamp((this.left + e2 - this.right) / 2, 0, e2), r3 = t.clamp((this.top + i2 - this.bottom) / 2, 0, i2);
              return new t.pointGeometry(o2, r3);
            }
            equals(t2) {
              return this.top === t2.top && this.bottom === t2.bottom && this.left === t2.left && this.right === t2.right;
            }
            clone() {
              return new po2(this.top, this.bottom, this.left, this.right);
            }
            toJSON() {
              return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
            }
          }
          function mo2(t2, e2) {
            return [t2[4 * e2], t2[4 * e2 + 1], t2[4 * e2 + 2], t2[4 * e2 + 3]];
          }
          function fo(t2, e2, i2) {
            t2[4 * e2 + 0] = i2[0], t2[4 * e2 + 1] = i2[1], t2[4 * e2 + 2] = i2[2], t2[4 * e2 + 3] = i2[3];
          }
          function go2(e2, i2) {
            const o2 = mo2(e2, 3);
            t.fromQuat(e2, i2), fo(e2, 3, o2);
          }
          function vo2(t2, e2) {
            fo(t2, 3, [e2[0], e2[1], e2[2], 1]);
          }
          function xo2(e2, i2) {
            const o2 = t.identity$1([]);
            return t.rotateZ$1(o2, o2, -i2), t.rotateX$1(o2, o2, -e2), o2;
          }
          function yo2(e2, i2) {
            const o2 = [e2[0], e2[1], 0], r3 = [i2[0], i2[1], 0];
            if (t.length(o2) >= 1e-15) {
              const e3 = t.normalize([], o2);
              t.scale(r3, e3, t.dot(r3, e3)), i2[0] = r3[0], i2[1] = r3[1];
            }
            const a2 = t.cross([], i2, e2);
            if (t.len(a2) < 1e-15)
              return null;
            const n2 = Math.atan2(-a2[1], a2[0]);
            return xo2(Math.atan2(Math.sqrt(e2[0] * e2[0] + e2[1] * e2[1]), -e2[2]), n2);
          }
          class bo2 {
            constructor(t2, e2) {
              this.position = t2, this.orientation = e2;
            }
            get position() {
              return this._position;
            }
            set position(e2) {
              this._position = this._renderWorldCopies ? function(e3) {
                if (!e3)
                  return;
                const i2 = Array.isArray(e3) ? new t.MercatorCoordinate(e3[0], e3[1], e3[2]) : e3;
                return i2.x = t.wrap(i2.x, 0, 1), i2;
              }(e2) : e2;
            }
            lookAtPoint(e2, i2) {
              if (this.orientation = null, !this.position)
                return;
              const o2 = this._elevation ? this._elevation.getAtPointOrZero(t.MercatorCoordinate.fromLngLat(e2)) : 0, r3 = this.position, a2 = t.MercatorCoordinate.fromLngLat(e2, o2), n2 = [a2.x - r3.x, a2.y - r3.y, a2.z - r3.z];
              i2 || (i2 = [0, 0, 1]), i2[2] = Math.abs(i2[2]), this.orientation = yo2(n2, i2);
            }
            setPitchBearing(e2, i2) {
              this.orientation = xo2(t.degToRad(e2), t.degToRad(-i2));
            }
          }
          class wo2 {
            constructor(e2, i2) {
              this._transform = t.identity([]), this._orientation = t.identity$1([]), i2 && (this._orientation = i2, go2(this._transform, this._orientation)), e2 && vo2(this._transform, e2);
            }
            get mercatorPosition() {
              const e2 = this.position;
              return new t.MercatorCoordinate(e2[0], e2[1], e2[2]);
            }
            get position() {
              const t2 = mo2(this._transform, 3);
              return [t2[0], t2[1], t2[2]];
            }
            set position(t2) {
              vo2(this._transform, t2);
            }
            get orientation() {
              return this._orientation;
            }
            set orientation(t2) {
              this._orientation = t2, go2(this._transform, this._orientation);
            }
            getPitchBearing() {
              const t2 = this.forward(), e2 = this.right();
              return { bearing: Math.atan2(-e2[1], e2[0]), pitch: Math.atan2(Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]), -t2[2]) };
            }
            setPitchBearing(t2, e2) {
              this._orientation = xo2(t2, e2), go2(this._transform, this._orientation);
            }
            forward() {
              const t2 = mo2(this._transform, 2);
              return [-t2[0], -t2[1], -t2[2]];
            }
            up() {
              const t2 = mo2(this._transform, 1);
              return [-t2[0], -t2[1], -t2[2]];
            }
            right() {
              const t2 = mo2(this._transform, 0);
              return [t2[0], t2[1], t2[2]];
            }
            getCameraToWorld(e2, i2) {
              const o2 = new Float64Array(16);
              return t.invert(o2, this.getWorldToCamera(e2, i2)), o2;
            }
            getWorldToCameraPosition(e2, i2, o2) {
              const r3 = this.position;
              t.scale(r3, r3, -e2);
              const a2 = new Float64Array(16);
              return t.fromScaling(a2, [o2, o2, o2]), t.translate(a2, a2, r3), a2[10] *= i2, a2;
            }
            getWorldToCamera(e2, i2) {
              const o2 = new Float64Array(16), r3 = new Float64Array(4), a2 = this.position;
              return t.conjugate(r3, this._orientation), t.scale(a2, a2, -e2), t.fromQuat(o2, r3), t.translate(o2, o2, a2), o2[1] *= -1, o2[5] *= -1, o2[9] *= -1, o2[13] *= -1, o2[8] *= i2, o2[9] *= i2, o2[10] *= i2, o2[11] *= i2, o2;
            }
            getCameraToClipPerspective(e2, i2, o2, r3) {
              const a2 = new Float64Array(16);
              return t.perspective(a2, e2, i2, o2, r3), a2;
            }
            getDistanceToElevation(e2) {
              const i2 = e2 === 0 ? 0 : t.mercatorZfromAltitude(e2, this.position[1]), o2 = this.forward();
              return (i2 - this.position[2]) / o2[2];
            }
            clone() {
              return new wo2([...this.position], [...this.orientation]);
            }
          }
          class To2 {
            constructor(e2, i2, o2, r3, a2) {
              this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = a2 === void 0 || a2, this._minZoom = e2 || 0, this._maxZoom = i2 || 22, this._minPitch = o2 == null ? 0 : o2, this._maxPitch = r3 == null ? 60 : r3, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new t.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = true, this._edgeInsets = new po2(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._camera = new wo2(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._horizonShift = 0.1;
            }
            clone() {
              const t2 = new To2(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
              return t2._elevation = this._elevation, t2._centerAltitude = this._centerAltitude, t2.tileSize = this.tileSize, t2.latRange = this.latRange, t2.width = this.width, t2.height = this.height, t2.cameraElevationReference = this.cameraElevationReference, t2._center = this._center, t2._setZoom(this.zoom), t2._cameraZoom = this._cameraZoom, t2.angle = this.angle, t2._fov = this._fov, t2._pitch = this._pitch, t2._averageElevation = this._averageElevation, t2._unmodified = this._unmodified, t2._edgeInsets = this._edgeInsets.clone(), t2._camera = this._camera.clone(), t2._calcMatrices(), t2.freezeTileCoverage = this.freezeTileCoverage, t2;
            }
            get elevation() {
              return this._elevation;
            }
            set elevation(t2) {
              this._elevation !== t2 && (this._elevation = t2, t2 ? this._updateCenterElevation() && this._updateCameraOnTerrain() : (this._cameraZoom = null, this._centerAltitude = 0), this._calcMatrices());
            }
            updateElevation(t2) {
              this._terrainEnabled() && this._cameraZoom == null && this._updateCenterElevation() && this._updateCameraOnTerrain(), t2 && this._constrainCameraAltitude(), this._calcMatrices();
            }
            get minZoom() {
              return this._minZoom;
            }
            set minZoom(t2) {
              this._minZoom !== t2 && (this._minZoom = t2, this.zoom = Math.max(this.zoom, t2));
            }
            get maxZoom() {
              return this._maxZoom;
            }
            set maxZoom(t2) {
              this._maxZoom !== t2 && (this._maxZoom = t2, this.zoom = Math.min(this.zoom, t2));
            }
            get minPitch() {
              return this._minPitch;
            }
            set minPitch(t2) {
              this._minPitch !== t2 && (this._minPitch = t2, this.pitch = Math.max(this.pitch, t2));
            }
            get maxPitch() {
              return this._maxPitch;
            }
            set maxPitch(t2) {
              this._maxPitch !== t2 && (this._maxPitch = t2, this.pitch = Math.min(this.pitch, t2));
            }
            get renderWorldCopies() {
              return this._renderWorldCopies;
            }
            set renderWorldCopies(t2) {
              t2 === void 0 ? t2 = true : t2 === null && (t2 = false), this._renderWorldCopies = t2;
            }
            get worldSize() {
              return this.tileSize * this.scale;
            }
            get cameraWorldSize() {
              const t2 = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
              return this._worldSizeFromZoom(this._zoomFromMercatorZ(t2));
            }
            get pixelsPerMeter() {
              return t.mercatorZfromAltitude(1, this.center.lat) * this.worldSize;
            }
            get cameraPixelsPerMeter() {
              return t.mercatorZfromAltitude(1, this.center.lat) * this.cameraWorldSize;
            }
            get centerOffset() {
              return this.centerPoint._sub(this.size._div(2));
            }
            get size() {
              return new t.pointGeometry(this.width, this.height);
            }
            get bearing() {
              return -this.angle / Math.PI * 180;
            }
            set bearing(e2) {
              const i2 = -t.wrap(e2, -180, 180) * Math.PI / 180;
              var o2;
              this.angle !== i2 && (this._unmodified = false, this.angle = i2, this._calcMatrices(), this.rotationMatrix = (o2 = new t.ARRAY_TYPE(4), t.ARRAY_TYPE != Float32Array && (o2[1] = 0, o2[2] = 0), o2[0] = 1, o2[3] = 1, o2), function(t2, e3, i3) {
                var o3 = e3[0], r3 = e3[1], a2 = e3[2], n2 = e3[3], s2 = Math.sin(i3), l2 = Math.cos(i3);
                t2[0] = o3 * l2 + a2 * s2, t2[1] = r3 * l2 + n2 * s2, t2[2] = o3 * -s2 + a2 * l2, t2[3] = r3 * -s2 + n2 * l2;
              }(this.rotationMatrix, this.rotationMatrix, this.angle));
            }
            get pitch() {
              return this._pitch / Math.PI * 180;
            }
            set pitch(e2) {
              const i2 = t.clamp(e2, this.minPitch, this.maxPitch) / 180 * Math.PI;
              this._pitch !== i2 && (this._unmodified = false, this._pitch = i2, this._calcMatrices());
            }
            get fov() {
              return this._fov / Math.PI * 180;
            }
            set fov(t2) {
              t2 = Math.max(0.01, Math.min(60, t2)), this._fov !== t2 && (this._unmodified = false, this._fov = t2 / 180 * Math.PI, this._calcMatrices());
            }
            get averageElevation() {
              return this._averageElevation;
            }
            set averageElevation(t2) {
              this._averageElevation = t2, this._calcFogMatrices();
            }
            get zoom() {
              return this._zoom;
            }
            set zoom(t2) {
              const e2 = Math.min(Math.max(t2, this.minZoom), this.maxZoom);
              this._zoom !== e2 && (this._unmodified = false, this._setZoom(e2), this._terrainEnabled() && this._updateCameraOnTerrain(), this._constrain(), this._calcMatrices());
            }
            _setZoom(t2) {
              this._zoom = t2, this.scale = this.zoomScale(t2), this.tileZoom = Math.floor(t2), this.zoomFraction = t2 - this.tileZoom;
            }
            _updateCenterElevation() {
              if (!this._elevation)
                return false;
              const e2 = this._elevation.getAtPointOrZero(t.MercatorCoordinate.fromLngLat(this.center), -1);
              return e2 === -1 ? (this._cameraZoom = null, false) : (this._centerAltitude = e2, true);
            }
            _updateCameraOnTerrain() {
              const e2 = this.cameraToCenterDistance / this.worldSize, i2 = t.mercatorZfromAltitude(this._centerAltitude, this.center.lat);
              this._cameraZoom = this._zoomFromMercatorZ(i2 + e2);
            }
            sampleAverageElevation() {
              if (!this._elevation)
                return 0;
              const e2 = this._elevation, i2 = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], o2 = this.horizonLineFromTop();
              let r3 = 0, a2 = 0;
              for (let n2 = 0; n2 < i2.length; n2++) {
                const s2 = new t.pointGeometry(i2[n2][0] * this.width, o2 + i2[n2][1] * (this.height - o2)), l2 = e2.pointCoordinate(s2);
                if (!l2)
                  continue;
                const c2 = 1 / Math.hypot(l2[0] - this._camera.position[0], l2[1] - this._camera.position[1]);
                r3 += l2[3] * c2, a2 += c2;
              }
              return a2 === 0 ? NaN : r3 / a2;
            }
            get center() {
              return this._center;
            }
            set center(t2) {
              t2.lat === this._center.lat && t2.lng === this._center.lng || (this._unmodified = false, this._center = t2, this._terrainEnabled() && (this.cameraElevationReference === "ground" ? this._updateCenterElevation() ? this._updateCameraOnTerrain() : this._cameraZoom = null : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
            }
            _updateZoomFromElevation() {
              if (this._cameraZoom == null || !this._elevation)
                return;
              const e2 = this._cameraZoom, i2 = this._elevation.getAtPointOrZero(t.MercatorCoordinate.fromLngLat(this.center)), o2 = t.mercatorZfromAltitude(i2, this.center.lat), r3 = this._mercatorZfromZoom(e2), a2 = this._mercatorZfromZoom(this._maxZoom), n2 = Math.max(r3 - o2, a2);
              this._setZoom(this._zoomFromMercatorZ(n2));
            }
            get padding() {
              return this._edgeInsets.toJSON();
            }
            set padding(t2) {
              this._edgeInsets.equals(t2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, t2, 1), this._calcMatrices());
            }
            computeZoomRelativeTo(e2) {
              const i2 = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, e2.toAltitude()));
              let o2;
              o2 = e2.z < this._camera.position[2] ? [i2.x, i2.y, i2.z] : [e2.x, e2.y, e2.z];
              const r3 = t.length(t.sub([], this._camera.position, o2));
              return t.clamp(this._zoomFromMercatorZ(r3), this._minZoom, this._maxZoom);
            }
            setFreeCameraOptions(e2) {
              if (!this.height)
                return;
              if (!e2.position && !e2.orientation)
                return;
              this._updateCameraState();
              let i2 = false;
              if (e2.orientation && !t.exactEquals(e2.orientation, this._camera.orientation) && (i2 = this._setCameraOrientation(e2.orientation)), e2.position) {
                const o2 = [e2.position.x, e2.position.y, e2.position.z];
                t.exactEquals$1(o2, this._camera.position) || (this._setCameraPosition(o2), i2 = true);
              }
              i2 && (this._updateStateFromCamera(), this.recenterOnTerrain());
            }
            getFreeCameraOptions() {
              this._updateCameraState();
              const e2 = this._camera.position, i2 = new bo2();
              return i2.position = new t.MercatorCoordinate(e2[0], e2[1], e2[2]), i2.orientation = this._camera.orientation, i2._elevation = this.elevation, i2._renderWorldCopies = this._renderWorldCopies, i2;
            }
            _setCameraOrientation(e2) {
              if (!t.length$1(e2))
                return false;
              t.normalize$1(e2, e2);
              const i2 = t.transformQuat([], [0, 0, -1], e2), o2 = t.transformQuat([], [0, -1, 0], e2);
              if (o2[2] < 0)
                return false;
              const r3 = yo2(i2, o2);
              return !!r3 && (this._camera.orientation = r3, true);
            }
            _setCameraPosition(e2) {
              const i2 = this.zoomScale(this.minZoom) * this.tileSize, o2 = this.zoomScale(this.maxZoom) * this.tileSize, r3 = this.cameraToCenterDistance;
              e2[2] = t.clamp(e2[2], r3 / o2, r3 / i2), this._camera.position = e2;
            }
            get centerPoint() {
              return this._edgeInsets.getCenter(this.width, this.height);
            }
            get fovAboveCenter() {
              return this._fov * (0.5 + this.centerOffset.y / this.height);
            }
            isPaddingEqual(t2) {
              return this._edgeInsets.equals(t2);
            }
            interpolatePadding(t2, e2, i2) {
              this._unmodified = false, this._edgeInsets.interpolate(t2, e2, i2), this._constrain(), this._calcMatrices();
            }
            coveringZoomLevel(t2) {
              const e2 = (t2.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t2.tileSize));
              return Math.max(0, e2);
            }
            getVisibleUnwrappedCoordinates(e2) {
              const i2 = [new t.UnwrappedTileID(0, e2)];
              if (this._renderWorldCopies) {
                const o2 = this.pointCoordinate(new t.pointGeometry(0, 0)), r3 = this.pointCoordinate(new t.pointGeometry(this.width, 0)), a2 = this.pointCoordinate(new t.pointGeometry(this.width, this.height)), n2 = this.pointCoordinate(new t.pointGeometry(0, this.height)), s2 = Math.floor(Math.min(o2.x, r3.x, a2.x, n2.x)), l2 = Math.floor(Math.max(o2.x, r3.x, a2.x, n2.x)), c2 = 1;
                for (let o3 = s2 - c2; o3 <= l2 + c2; o3++)
                  o3 !== 0 && i2.push(new t.UnwrappedTileID(o3, e2));
              }
              return i2;
            }
            coveringTiles(e2) {
              let i2 = this.coveringZoomLevel(e2);
              const o2 = i2, r3 = this.elevation && !e2.isTerrainDEM;
              if (e2.minzoom !== void 0 && i2 < e2.minzoom)
                return [];
              e2.maxzoom !== void 0 && i2 > e2.maxzoom && (i2 = e2.maxzoom);
              const a2 = t.MercatorCoordinate.fromLngLat(this.center), n2 = 1 << i2, s2 = [n2 * a2.x, n2 * a2.y, 0], l2 = _.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i2), c2 = this.pointCoordinate(this.getCameraPoint()), h2 = n2 * t.mercatorZfromAltitude(1, this.center.lat), d2 = this._camera.position[2] / t.mercatorZfromAltitude(1, this.center.lat), u2 = [n2 * c2.x, n2 * c2.y, d2], m2 = this.cameraToCenterDistance / e2.tileSize * (e2.roundZoom ? 1 : 0.502), f2 = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation ? i2 : 0, g2 = e2.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude, v2 = e2.isTerrainDEM ? -g2 : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, x3 = (t2) => ({ aabb: new p([t2 * n2, 0, v2], [(t2 + 1) * n2, n2, g2]), zoom: 0, x: 0, y: 0, wrap: t2, fullyVisible: false }), y2 = [], b2 = [], w3 = i2, T2 = e2.reparseOverscaled ? o2 : i2, E2 = (t2) => {
                if (!this._elevation || !t2.tileID)
                  return;
                const e3 = this._elevation.getMinMaxForTile(t2.tileID), i3 = t2.aabb;
                e3 ? (i3.min[2] = e3.min, i3.max[2] = e3.max, i3.center[2] = (i3.min[2] + i3.max[2]) / 2) : (t2.shouldSplit = I3(t2), t2.shouldSplit || (i3.min[2] = i3.max[2] = i3.center[2] = this._centerAltitude));
              }, C2 = (t2) => t2 * t2, S2 = C2((d2 - this._centerAltitude) * h2), I3 = (t2) => {
                if (t2.zoom < f2)
                  return true;
                if (t2.zoom === w3)
                  return false;
                if (t2.shouldSplit != null)
                  return t2.shouldSplit;
                const e3 = t2.aabb.distanceX(u2), i3 = t2.aabb.distanceY(u2);
                let o3 = S2;
                r3 && (o3 = C2(t2.aabb.distanceZ(u2) * h2));
                const a3 = e3 * e3 + i3 * i3 + o3;
                return a3 < C2((1 << w3 - t2.zoom) * m2 * ((t3, e4) => {
                  if (e4 * C2(0.707) < t3)
                    return 1;
                  const i4 = Math.sqrt(e4 / t3);
                  return i4 / (1.4144271570014144 + (Math.pow(1.1, i4 - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
                })(Math.max(o3, S2), a3));
              };
              if (this._renderWorldCopies)
                for (let t2 = 1; t2 <= 3; t2++)
                  y2.push(x3(-t2)), y2.push(x3(t2));
              for (y2.push(x3(0)); y2.length > 0; ) {
                const o3 = y2.pop(), a3 = o3.x, n3 = o3.y;
                let c3 = o3.fullyVisible;
                if (!c3) {
                  const t2 = o3.aabb.intersects(l2);
                  if (t2 === 0)
                    continue;
                  c3 = t2 === 2;
                }
                if (o3.zoom !== w3 && I3(o3))
                  for (let e3 = 0; e3 < 4; e3++) {
                    const i3 = (a3 << 1) + e3 % 2, s3 = (n3 << 1) + (e3 >> 1), l3 = { aabb: o3.aabb.quadrant(e3), zoom: o3.zoom + 1, x: i3, y: s3, wrap: o3.wrap, fullyVisible: c3, tileID: void 0, shouldSplit: void 0 };
                    r3 && (l3.tileID = new t.OverscaledTileID(o3.zoom + 1 === w3 ? T2 : o3.zoom + 1, o3.wrap, o3.zoom + 1, i3, s3), E2(l3)), y2.push(l3);
                  }
                else {
                  const r4 = o3.zoom === w3 ? T2 : o3.zoom;
                  if (e2.minzoom && e2.minzoom > r4)
                    continue;
                  const l3 = s2[0] - (0.5 + a3 + (o3.wrap << o3.zoom)) * (1 << i2 - o3.zoom), c4 = s2[1] - 0.5 - n3, h3 = o3.tileID ? o3.tileID : new t.OverscaledTileID(r4, o3.wrap, o3.zoom, a3, n3);
                  b2.push({ tileID: h3, distanceSq: l3 * l3 + c4 * c4 });
                }
              }
              if (this.fogCullDistSq) {
                const e3 = this.fogCullDistSq;
                b2.splice(0, b2.length, ...b2.filter((i3) => {
                  const o3 = [0, 0, 0, 1], a3 = [t.EXTENT, t.EXTENT, 0, 1], n3 = this.calculateFogTileMatrix(i3.tileID.toUnwrapped());
                  t.transformMat4(o3, o3, n3), t.transformMat4(a3, a3, n3);
                  const s3 = t.getAABBPointSquareDist(o3, a3);
                  if (s3 === 0)
                    return true;
                  let l3 = false;
                  const c3 = this.horizonLineFromTop();
                  if (s3 > e3 && c3 !== 0) {
                    const e4 = this.calculateProjMatrix(i3.tileID.toUnwrapped());
                    let o4;
                    r3 && this._elevation && (o4 = this._elevation.getMinMaxForTile(i3.tileID)), o4 || (o4 = { min: v2, max: g2 });
                    const a4 = t.furthestTileCorner(this.bearing), n4 = [a4[0] * t.EXTENT, a4[1] * t.EXTENT, o4.max];
                    t.transformMat4$1(n4, n4, e4), l3 = (1 - n4[1]) * this.height * 0.5 < c3;
                  }
                  return s3 < e3 || l3;
                }));
              }
              return b2.sort((t2, e3) => t2.distanceSq - e3.distanceSq).map((t2) => t2.tileID);
            }
            resize(t2, e2) {
              this.width = t2, this.height = e2, this.pixelsToGLUnits = [2 / t2, -2 / e2], this._constrain(), this._calcMatrices();
            }
            get unmodified() {
              return this._unmodified;
            }
            zoomScale(t2) {
              return Math.pow(2, t2);
            }
            scaleZoom(t2) {
              return Math.log(t2) / Math.LN2;
            }
            project(e2) {
              const i2 = t.clamp(e2.lat, -this.maxValidLatitude, this.maxValidLatitude);
              return new t.pointGeometry(t.mercatorXfromLng(e2.lng) * this.worldSize, t.mercatorYfromLat(i2) * this.worldSize);
            }
            unproject(e2) {
              return new t.MercatorCoordinate(e2.x / this.worldSize, e2.y / this.worldSize).toLngLat();
            }
            get point() {
              return this.project(this.center);
            }
            setLocationAtPoint(e2, i2) {
              const o2 = this.pointCoordinate(i2), r3 = this.pointCoordinate(this.centerPoint), a2 = this.locationCoordinate(e2), n2 = new t.MercatorCoordinate(a2.x - (o2.x - r3.x), a2.y - (o2.y - r3.y));
              this.center = this.coordinateLocation(n2), this._renderWorldCopies && (this.center = this.center.wrap());
            }
            setLocation(t2) {
              this.center = this.coordinateLocation(t2), this._renderWorldCopies && (this.center = this.center.wrap());
            }
            locationPoint(t2) {
              return this._coordinatePoint(this.locationCoordinate(t2), false);
            }
            locationPoint3D(t2) {
              return this._coordinatePoint(this.locationCoordinate(t2), true);
            }
            pointLocation(t2) {
              return this.coordinateLocation(this.pointCoordinate(t2));
            }
            pointLocation3D(t2) {
              return this.coordinateLocation(this.pointCoordinate3D(t2));
            }
            locationCoordinate(e2) {
              return t.MercatorCoordinate.fromLngLat(e2);
            }
            coordinateLocation(t2) {
              return t2.toLngLat();
            }
            pointRayIntersection(e2, i2) {
              const o2 = i2 != null ? i2 : this._centerAltitude, r3 = [e2.x, e2.y, 0, 1], a2 = [e2.x, e2.y, 1, 1];
              t.transformMat4(r3, r3, this.pixelMatrixInverse), t.transformMat4(a2, a2, this.pixelMatrixInverse);
              const n2 = a2[3];
              t.scale$2(r3, r3, 1 / r3[3]), t.scale$2(a2, a2, 1 / n2);
              const s2 = r3[2], l2 = a2[2];
              return { p0: r3, p1: a2, t: s2 === l2 ? 0 : (o2 - s2) / (l2 - s2) };
            }
            screenPointToMercatorRay(e2) {
              const i2 = [e2.x, e2.y, 0, 1], o2 = [e2.x, e2.y, 1, 1];
              return t.transformMat4(i2, i2, this.pixelMatrixInverse), t.transformMat4(o2, o2, this.pixelMatrixInverse), t.scale$2(i2, i2, 1 / i2[3]), t.scale$2(o2, o2, 1 / o2[3]), i2[2] = t.mercatorZfromAltitude(i2[2], this._center.lat) * this.worldSize, o2[2] = t.mercatorZfromAltitude(o2[2], this._center.lat) * this.worldSize, t.scale$2(i2, i2, 1 / this.worldSize), t.scale$2(o2, o2, 1 / this.worldSize), new u([i2[0], i2[1], i2[2]], t.normalize([], t.sub([], o2, i2)));
            }
            rayIntersectionCoordinate(e2) {
              const { p0: i2, p1: o2, t: r3 } = e2, a2 = t.mercatorZfromAltitude(i2[2], this._center.lat), n2 = t.mercatorZfromAltitude(o2[2], this._center.lat);
              return new t.MercatorCoordinate(t.number(i2[0], o2[0], r3) / this.worldSize, t.number(i2[1], o2[1], r3) / this.worldSize, t.number(a2, n2, r3));
            }
            pointCoordinate(e2) {
              const i2 = this.horizonLineFromTop(false), o2 = new t.pointGeometry(e2.x, Math.max(i2, e2.y));
              return this.rayIntersectionCoordinate(this.pointRayIntersection(o2));
            }
            pointCoordinate3D(e2) {
              if (!this.elevation)
                return this.pointCoordinate(e2);
              const i2 = this.elevation;
              let o2 = this.elevation.pointCoordinate(e2);
              if (o2)
                return new t.MercatorCoordinate(o2[0], o2[1], o2[2]);
              let r3 = 0, a2 = this.horizonLineFromTop();
              if (e2.y > a2)
                return this.pointCoordinate(e2);
              const n2 = 0.02 * a2, s2 = e2.clone();
              for (let e3 = 0; e3 < 10 && a2 - r3 > n2; e3++) {
                s2.y = t.number(r3, a2, 0.66);
                const e4 = i2.pointCoordinate(s2);
                e4 ? (a2 = s2.y, o2 = e4) : r3 = s2.y;
              }
              return o2 ? new t.MercatorCoordinate(o2[0], o2[1], o2[2]) : this.pointCoordinate(e2);
            }
            isPointAboveHorizon(t2) {
              if (this.elevation)
                return !this.elevation.pointCoordinate(t2);
              {
                const e2 = this.horizonLineFromTop();
                return t2.y < e2;
              }
            }
            _coordinatePoint(e2, i2) {
              const o2 = i2 && this.elevation ? this.elevation.getAtPointOrZero(e2, this._centerAltitude) : this._centerAltitude, r3 = [e2.x * this.worldSize, e2.y * this.worldSize, o2 + e2.toAltitude(), 1];
              return t.transformMat4(r3, r3, this.pixelMatrix), r3[3] > 0 ? new t.pointGeometry(r3[0] / r3[3], r3[1] / r3[3]) : new t.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE);
            }
            getBounds() {
              return this._terrainEnabled() ? this._getBounds3D() : new t.LngLatBounds().extend(this.pointLocation(new t.pointGeometry(this._edgeInsets.left, this._edgeInsets.top))).extend(this.pointLocation(new t.pointGeometry(this.width - this._edgeInsets.right, this._edgeInsets.top))).extend(this.pointLocation(new t.pointGeometry(this.width - this._edgeInsets.right, this.height - this._edgeInsets.bottom))).extend(this.pointLocation(new t.pointGeometry(this._edgeInsets.left, this.height - this._edgeInsets.bottom)));
            }
            _getBounds3D() {
              const e2 = this.elevation, i2 = e2.visibleDemTiles.reduce((t2, e3) => {
                if (e3.dem) {
                  const i3 = e3.dem.tree;
                  t2.min = Math.min(t2.min, i3.minimums[0]), t2.max = Math.max(t2.max, i3.maximums[0]);
                }
                return t2;
              }, { min: Number.MAX_VALUE, max: 0 });
              i2.min *= e2.exaggeration(), i2.max *= e2.exaggeration();
              const o2 = this.horizonLineFromTop();
              return [new t.pointGeometry(0, o2), new t.pointGeometry(this.width, o2), new t.pointGeometry(this.width, this.height), new t.pointGeometry(0, this.height)].reduce((t2, e3) => t2.extend(this.coordinateLocation(this.rayIntersectionCoordinate(this.pointRayIntersection(e3, i2.min)))).extend(this.coordinateLocation(this.rayIntersectionCoordinate(this.pointRayIntersection(e3, i2.max)))), new t.LngLatBounds());
            }
            horizonLineFromTop(t2 = true) {
              const e2 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) + this.centerOffset.y, i2 = this.height / 2 - 0.97 * e2;
              return t2 ? Math.max(0, i2) : i2;
            }
            getMaxBounds() {
              return this.latRange && this.latRange.length === 2 && this.lngRange && this.lngRange.length === 2 ? new t.LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
            }
            setMaxBounds(t2) {
              t2 ? (this.lngRange = [t2.getWest(), t2.getEast()], this.latRange = [t2.getSouth(), t2.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);
            }
            calculatePosMatrix(e2, i2) {
              const o2 = e2.canonical, r3 = i2 / this.zoomScale(o2.z), a2 = o2.x + Math.pow(2, o2.z) * e2.wrap, n2 = t.identity(new Float64Array(16));
              return t.translate(n2, n2, [a2 * r3, o2.y * r3, 0]), t.scale$1(n2, n2, [r3 / t.EXTENT, r3 / t.EXTENT, 1]), n2;
            }
            calculateFogTileMatrix(e2) {
              const i2 = e2.key, o2 = this._fogTileMatrixCache;
              if (o2[i2])
                return o2[i2];
              const r3 = this.calculatePosMatrix(e2, this.cameraWorldSize);
              return t.multiply(r3, this.worldToFogMatrix, r3), o2[i2] = new Float32Array(r3), o2[i2];
            }
            calculateProjMatrix(e2, i2 = false) {
              const o2 = e2.key, r3 = i2 ? this._alignedProjMatrixCache : this._projMatrixCache;
              if (r3[o2])
                return r3[o2];
              const a2 = this.calculatePosMatrix(e2, this.worldSize);
              return t.multiply(a2, i2 ? this.alignedProjMatrix : this.projMatrix, a2), r3[o2] = new Float32Array(a2), r3[o2];
            }
            customLayerMatrix() {
              return this.mercatorMatrix.slice();
            }
            recenterOnTerrain() {
              if (!this._elevation)
                return;
              const e2 = this._elevation;
              this._updateCameraState();
              const i2 = this._camera.position, o2 = this._camera.forward();
              if (i2[2] <= 0 || o2[2] >= 0)
                return;
              const r3 = t.mercatorZfromAltitude(1, this._center.lat);
              i2[2] /= r3, o2[2] /= r3, t.normalize(o2, o2);
              const a2 = e2.raycast(i2, o2, e2.exaggeration());
              if (a2) {
                const e3 = t.scaleAndAdd([], i2, o2, a2), r4 = new t.MercatorCoordinate(e3[0], e3[1], t.mercatorZfromAltitude(e3[2], t.latFromMercatorY(e3[1]))), n2 = this._camera.position, s2 = r4.z + t.length([r4.x - n2[0], r4.y - n2[1], r4.z - n2[2]]);
                this._cameraZoom = this._zoomFromMercatorZ(s2), this._centerAltitude = r4.toAltitude(), this._center = r4.toLngLat(), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
              }
            }
            _constrainCameraAltitude() {
              if (!this._elevation)
                return;
              const e2 = this._elevation;
              this._updateCameraState();
              const i2 = e2.getAtPointOrZero(this._camera.mercatorPosition), o2 = this._minimumHeightOverTerrain() * Math.cos(t.degToRad(this._maxPitch)), r3 = t.mercatorZfromAltitude(i2, this._center.lat), a2 = this._camera.position[2] - r3;
              if (a2 < o2) {
                const e3 = t.MercatorCoordinate.fromLngLat(this._center, this._centerAltitude), i3 = this._camera.mercatorPosition, r4 = [e3.x - i3.x, e3.y - i3.y, e3.z - i3.z], n2 = t.length(r4);
                r4[2] -= o2 - a2;
                const s2 = t.length(r4);
                if (s2 === 0)
                  return;
                t.scale(r4, r4, n2 / s2), this._camera.position = [e3.x - r4[0], e3.y - r4[1], e3.z - r4[2]], this._camera.orientation = yo2(r4, this._camera.up()), this._updateStateFromCamera();
              }
            }
            _constrain() {
              if (!this.center || !this.width || !this.height || this._constraining)
                return;
              this._constraining = true;
              let e2, i2, o2, r3, a2 = -90, n2 = 90, s2 = -180, l2 = 180;
              const c2 = this.size, h2 = this._unmodified;
              if (this.latRange) {
                const i3 = this.latRange;
                a2 = t.mercatorYfromLat(i3[1]) * this.worldSize, n2 = t.mercatorYfromLat(i3[0]) * this.worldSize, e2 = n2 - a2 < c2.y ? c2.y / (n2 - a2) : 0;
              }
              if (this.lngRange) {
                const e3 = this.lngRange;
                s2 = t.mercatorXfromLng(e3[0]) * this.worldSize, l2 = t.mercatorXfromLng(e3[1]) * this.worldSize, i2 = l2 - s2 < c2.x ? c2.x / (l2 - s2) : 0;
              }
              const d2 = this.point, u2 = Math.max(i2 || 0, e2 || 0);
              if (u2)
                return this.center = this.unproject(new t.pointGeometry(i2 ? (l2 + s2) / 2 : d2.x, e2 ? (n2 + a2) / 2 : d2.y)), this.zoom += this.scaleZoom(u2), this._unmodified = h2, void (this._constraining = false);
              if (this.latRange) {
                const t2 = d2.y, e3 = c2.y / 2;
                t2 - e3 < a2 && (r3 = a2 + e3), t2 + e3 > n2 && (r3 = n2 - e3);
              }
              if (this.lngRange) {
                const t2 = d2.x, e3 = c2.x / 2;
                t2 - e3 < s2 && (o2 = s2 + e3), t2 + e3 > l2 && (o2 = l2 - e3);
              }
              o2 === void 0 && r3 === void 0 || (this.center = this.unproject(new t.pointGeometry(o2 !== void 0 ? o2 : d2.x, r3 !== void 0 ? r3 : d2.y))), this._constrainCameraAltitude(), this._unmodified = h2, this._constraining = false;
            }
            _minZoomForBounds() {
              const e2 = (t2, e3) => Math.log2(t2 / (this.tileSize * Math.abs(e3[1] - e3[0])));
              let i2 = 0;
              if (this.latRange) {
                const o3 = this.latRange;
                i2 = e2(this.height, [t.mercatorYfromLat(o3[0]), t.mercatorYfromLat(o3[1])]);
              }
              let o2 = 0;
              if (this.lngRange) {
                const i3 = this.lngRange;
                o2 = e2(this.width, [t.mercatorXfromLng(i3[0]), t.mercatorXfromLng(i3[1])]);
              }
              return Math.max(i2, o2);
            }
            _maxCameraBoundsDistance() {
              return this._mercatorZfromZoom(this._minZoomForBounds());
            }
            _calcMatrices() {
              if (!this.height)
                return;
              const e2 = this.centerOffset;
              this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height;
              const i2 = this.pixelsPerMeter;
              this._updateCameraState();
              const o2 = Math.PI / 2 + this._pitch, r3 = this.fovAboveCenter, a2 = this.elevation ? this.elevation.getMinElevationBelowMSL() * i2 : 0, n2 = (this._camera.position[2] * this.worldSize - a2) / Math.cos(this._pitch), s2 = Math.sin(r3) * n2 / Math.sin(t.clamp(Math.PI - o2 - r3, 0.01, Math.PI - 0.01)), l2 = this.point, c2 = l2.x, h2 = l2.y, d2 = Math.cos(Math.PI / 2 - this._pitch) * s2 + n2, u2 = Math.min(1.01 * d2, n2 * (1 / this._horizonShift)), _2 = this.height / 50, p2 = this._camera.getWorldToCamera(this.worldSize, i2), m2 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, _2, u2);
              m2[8] = 2 * -e2.x / this.width, m2[9] = 2 * e2.y / this.height;
              let f2 = t.mul$1([], m2, p2);
              this.mercatorMatrix = t.scale$1([], f2, [this.worldSize, this.worldSize, this.worldSize / i2]), this.projMatrix = f2, this.invProjMatrix = t.invert(new Float64Array(16), this.projMatrix);
              const g2 = new Float32Array(16);
              t.identity(g2), t.scale$1(g2, g2, [1, -1, 1]), t.rotateX(g2, g2, this._pitch), t.rotateZ(g2, g2, this.angle);
              const v2 = t.perspective(new Float32Array(16), this._fov, this.width / this.height, _2, u2), x3 = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
              v2[8] = 2 * -e2.x / this.width, v2[9] = 2 * (e2.y + x3) / this.height, this.skyboxMatrix = t.multiply(g2, v2, g2);
              const y2 = this.width % 2 / 2, b2 = this.height % 2 / 2, w3 = Math.cos(this.angle), T2 = Math.sin(this.angle), E2 = c2 - Math.round(c2) + w3 * y2 + T2 * b2, C2 = h2 - Math.round(h2) + w3 * b2 + T2 * y2, S2 = new Float64Array(f2);
              if (t.translate(S2, S2, [E2 > 0.5 ? E2 - 1 : E2, C2 > 0.5 ? C2 - 1 : C2, 0]), this.alignedProjMatrix = S2, f2 = t.create$1(), t.scale$1(f2, f2, [this.width / 2, -this.height / 2, 1]), t.translate(f2, f2, [1, -1, 0]), this.labelPlaneMatrix = f2, f2 = t.create$1(), t.scale$1(f2, f2, [1, -1, 1]), t.translate(f2, f2, [-1, -1, 0]), t.scale$1(f2, f2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = f2, this.pixelMatrix = t.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), this._calcFogMatrices(), f2 = t.invert(new Float64Array(16), this.pixelMatrix), !f2)
                throw new Error("failed to invert matrix");
              this.pixelMatrixInverse = f2, this._projMatrixCache = {}, this._alignedProjMatrixCache = {};
            }
            _calcFogMatrices() {
              this._fogTileMatrixCache = {};
              const e2 = this.cameraWorldSize, i2 = this.cameraPixelsPerMeter, o2 = this._camera.position, r3 = 1 / this.height, a2 = [e2, e2, i2];
              t.scale(a2, a2, r3), t.scale(o2, o2, -1), t.multiply$1(o2, o2, a2);
              const n2 = t.create$1();
              t.translate(n2, n2, o2), t.scale$1(n2, n2, a2), this.mercatorFogMatrix = n2, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(e2, i2, r3);
            }
            _updateCameraState() {
              if (!this.height)
                return;
              this._camera.setPitchBearing(this._pitch, this.angle);
              const e2 = this._camera.forward(), i2 = this.cameraToCenterDistance, o2 = this.point, r3 = this._mercatorZfromZoom(this._cameraZoom ? this._cameraZoom : this._zoom) - t.mercatorZfromAltitude(this._centerAltitude, this.center.lat), a2 = this.cameraToCenterDistance / r3;
              this._camera.position = [o2.x / this.worldSize - e2[0] * i2 / a2, o2.y / this.worldSize - e2[1] * i2 / a2, t.mercatorZfromAltitude(this._centerAltitude, this._center.lat) + -e2[2] * i2 / a2];
            }
            _translateCameraConstrained(e2) {
              const i2 = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o2 = e2[2];
              let r3 = 1;
              o2 > 0 && (r3 = Math.min((i2 - this._camera.position[2]) / o2, 1)), this._camera.position = t.scaleAndAdd([], this._camera.position, e2, r3), this._updateStateFromCamera();
            }
            _updateStateFromCamera() {
              const e2 = this._camera.position, i2 = this._camera.forward(), { pitch: o2, bearing: r3 } = this._camera.getPitchBearing(), a2 = t.mercatorZfromAltitude(this._centerAltitude, this.center.lat), n2 = this._mercatorZfromZoom(this._maxZoom) * Math.cos(t.degToRad(this._maxPitch)), s2 = Math.max((e2[2] - a2) / Math.cos(o2), n2), l2 = this._zoomFromMercatorZ(s2);
              t.scaleAndAdd(e2, e2, i2, s2), this._pitch = t.clamp(o2, t.degToRad(this.minPitch), t.degToRad(this.maxPitch)), this.angle = t.wrap(r3, -Math.PI, Math.PI), this._setZoom(t.clamp(l2, this._minZoom, this._maxZoom)), this._terrainEnabled() && this._updateCameraOnTerrain(), this._center = new t.MercatorCoordinate(e2[0], e2[1], e2[2]).toLngLat(), this._unmodified = false, this._constrain(), this._calcMatrices();
            }
            _worldSizeFromZoom(t2) {
              return Math.pow(2, t2) * this.tileSize;
            }
            _mercatorZfromZoom(t2) {
              return this.cameraToCenterDistance / this._worldSizeFromZoom(t2);
            }
            _minimumHeightOverTerrain() {
              const t2 = Math.min((this._cameraZoom != null ? this._cameraZoom : this._zoom) + 2, this._maxZoom);
              return this._mercatorZfromZoom(t2);
            }
            _zoomFromMercatorZ(t2) {
              return this.scaleZoom(this.cameraToCenterDistance / (t2 * this.tileSize));
            }
            _terrainEnabled() {
              return !!this._elevation;
            }
            isHorizonVisibleForPoints(e2, i2) {
              const o2 = Math.min(e2.x, i2.x), r3 = Math.max(e2.x, i2.x), a2 = Math.min(e2.y, i2.y), n2 = Math.max(e2.y, i2.y), s2 = [new t.pointGeometry(o2, a2), new t.pointGeometry(r3, n2), new t.pointGeometry(o2, n2), new t.pointGeometry(r3, a2)], l2 = this._renderWorldCopies ? -3 : 0, c2 = this._renderWorldCopies ? 4 : 1;
              for (const t2 of s2) {
                const e3 = this.pointRayIntersection(t2);
                if (e3.t < 0)
                  return true;
                const i3 = this.rayIntersectionCoordinate(e3);
                if (i3.x < l2 || i3.y < 0 || i3.x > c2 || i3.y > 1)
                  return true;
              }
              return false;
            }
            isHorizonVisible() {
              return this.pitch + t.radToDeg(this.fovAboveCenter) > 88 || this.isHorizonVisibleForPoints(new t.pointGeometry(0, 0), new t.pointGeometry(this.width, this.height));
            }
            zoomDeltaToMovement(e2, i2) {
              const o2 = t.length(t.sub([], this._camera.position, e2)), r3 = this._zoomFromMercatorZ(o2) + i2;
              return o2 - this._mercatorZfromZoom(r3);
            }
            getCameraPoint() {
              const e2 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
              return this.centerPoint.add(new t.pointGeometry(0, e2));
            }
          }
          function Eo2(t2, e2) {
            let i2 = false, o2 = null;
            const r3 = () => {
              o2 = null, i2 && (t2(), o2 = setTimeout(r3, e2), i2 = false);
            };
            return () => (i2 = true, o2 || r3(), o2);
          }
          class Co2 {
            constructor(e2) {
              this._hashName = e2 && encodeURIComponent(e2), t.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = Eo2(this._updateHashUnthrottled.bind(this), 300);
            }
            addTo(e2) {
              return this._map = e2, t.window.addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
            }
            remove() {
              return t.window.removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
            }
            getHashString(e2) {
              const i2 = this._map.getCenter(), o2 = Math.round(100 * this._map.getZoom()) / 100, r3 = Math.ceil((o2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), a2 = Math.pow(10, r3), n2 = Math.round(i2.lng * a2) / a2, s2 = Math.round(i2.lat * a2) / a2, l2 = this._map.getBearing(), c2 = this._map.getPitch();
              let h2 = "";
              if (h2 += e2 ? `/${n2}/${s2}/${o2}` : `${o2}/${s2}/${n2}`, (l2 || c2) && (h2 += "/" + Math.round(10 * l2) / 10), c2 && (h2 += `/${Math.round(c2)}`), this._hashName) {
                const e3 = this._hashName;
                let i3 = false;
                const o3 = t.window.location.hash.slice(1).split("&").map((t2) => {
                  const o4 = t2.split("=")[0];
                  return o4 === e3 ? (i3 = true, `${o4}=${h2}`) : t2;
                }).filter((t2) => t2);
                return i3 || o3.push(`${e3}=${h2}`), `#${o3.join("&")}`;
              }
              return `#${h2}`;
            }
            _getCurrentHash() {
              const e2 = t.window.location.hash.replace("#", "");
              if (this._hashName) {
                let t2;
                return e2.split("&").map((t3) => t3.split("=")).forEach((e3) => {
                  e3[0] === this._hashName && (t2 = e3);
                }), (t2 && t2[1] || "").split("/");
              }
              return e2.split("/");
            }
            _onHashChange() {
              const t2 = this._getCurrentHash();
              if (t2.length >= 3 && !t2.some((t3) => isNaN(t3))) {
                const e2 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t2[3] || 0) : this._map.getBearing();
                return this._map.jumpTo({ center: [+t2[2], +t2[1]], zoom: +t2[0], bearing: e2, pitch: +(t2[4] || 0) }), true;
              }
              return false;
            }
            _updateHashUnthrottled() {
              const e2 = t.window.location.href.replace(/(#.+)?$/, this.getHashString());
              t.window.history.replaceState(t.window.history.state, null, e2);
            }
          }
          const So2 = { linearity: 0.3, easing: t.bezier(0, 0, 0.3, 1) }, Io2 = t.extend({ deceleration: 2500, maxSpeed: 1400 }, So2), Mo2 = t.extend({ deceleration: 20, maxSpeed: 1400 }, So2), zo2 = t.extend({ deceleration: 1e3, maxSpeed: 360 }, So2), Do2 = t.extend({ deceleration: 1e3, maxSpeed: 90 }, So2);
          class Ao2 {
            constructor(t2) {
              this._map = t2, this.clear();
            }
            clear() {
              this._inertiaBuffer = [];
            }
            record(e2) {
              this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: t.exported.now(), settings: e2 });
            }
            _drainInertiaBuffer() {
              const e2 = this._inertiaBuffer, i2 = t.exported.now();
              for (; e2.length > 0 && i2 - e2[0].time > 160; )
                e2.shift();
            }
            _onMoveEnd(e2) {
              if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
                return;
              const i2 = { zoom: 0, bearing: 0, pitch: 0, pan: new t.pointGeometry(0, 0), pinchAround: void 0, around: void 0 };
              for (const { settings: t2 } of this._inertiaBuffer)
                i2.zoom += t2.zoomDelta || 0, i2.bearing += t2.bearingDelta || 0, i2.pitch += t2.pitchDelta || 0, t2.panDelta && i2.pan._add(t2.panDelta), t2.around && (i2.around = t2.around), t2.pinchAround && (i2.pinchAround = t2.pinchAround);
              const o2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r3 = {};
              if (i2.pan.mag()) {
                const a2 = Lo2(i2.pan.mag(), o2, t.extend({}, Io2, e2 || {}));
                r3.offset = i2.pan.mult(a2.amount / i2.pan.mag()), r3.center = this._map.transform.center, Po2(r3, a2);
              }
              if (i2.zoom) {
                const t2 = Lo2(i2.zoom, o2, Mo2);
                r3.zoom = this._map.transform.zoom + t2.amount, Po2(r3, t2);
              }
              if (i2.bearing) {
                const e3 = Lo2(i2.bearing, o2, zo2);
                r3.bearing = this._map.transform.bearing + t.clamp(e3.amount, -179, 179), Po2(r3, e3);
              }
              if (i2.pitch) {
                const t2 = Lo2(i2.pitch, o2, Do2);
                r3.pitch = this._map.transform.pitch + t2.amount, Po2(r3, t2);
              }
              if (r3.zoom || r3.bearing) {
                const t2 = i2.pinchAround === void 0 ? i2.around : i2.pinchAround;
                r3.around = t2 ? this._map.unproject(t2) : this._map.getCenter();
              }
              return this.clear(), t.extend(r3, { noMoveStart: true });
            }
          }
          function Po2(t2, e2) {
            (!t2.duration || t2.duration < e2.duration) && (t2.duration = e2.duration, t2.easing = e2.easing);
          }
          function Lo2(e2, i2, o2) {
            const { maxSpeed: r3, linearity: a2, deceleration: n2 } = o2, s2 = t.clamp(e2 * a2 / (i2 / 1e3), -r3, r3), l2 = Math.abs(s2) / (n2 * a2);
            return { easing: o2.easing, duration: 1e3 * l2, amount: s2 * (l2 / 2) };
          }
          class Ro2 extends t.Event {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(e2, i2, o2, r3 = {}) {
              const n2 = a.mousePos(i2.getCanvasContainer(), o2), s2 = i2.unproject(n2);
              super(e2, t.extend({ point: n2, lngLat: s2, originalEvent: o2 }, r3)), this._defaultPrevented = false, this.target = i2;
            }
          }
          class ko2 extends t.Event {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(e2, i2, o2) {
              const r3 = e2 === "touchend" ? o2.changedTouches : o2.touches, n2 = a.touchPos(i2.getCanvasContainer(), r3), s2 = n2.map((t2) => i2.unproject(t2)), l2 = n2.reduce((t2, e3, i3, o3) => t2.add(e3.div(o3.length)), new t.pointGeometry(0, 0));
              super(e2, { points: n2, point: l2, lngLats: s2, lngLat: i2.unproject(l2), originalEvent: o2 }), this._defaultPrevented = false;
            }
          }
          class Fo2 extends t.Event {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(t2, e2, i2) {
              super(t2, { originalEvent: i2 }), this._defaultPrevented = false;
            }
          }
          class Bo2 {
            constructor(t2, e2) {
              this._map = t2, this._clickTolerance = e2.clickTolerance;
            }
            reset() {
              delete this._mousedownPos;
            }
            wheel(t2) {
              return this._firePreventable(new Fo2(t2.type, this._map, t2));
            }
            mousedown(t2, e2) {
              return this._mousedownPos = e2, this._firePreventable(new Ro2(t2.type, this._map, t2));
            }
            mouseup(t2) {
              this._map.fire(new Ro2(t2.type, this._map, t2));
            }
            click(t2, e2) {
              this._mousedownPos && this._mousedownPos.dist(e2) >= this._clickTolerance || this._map.fire(new Ro2(t2.type, this._map, t2));
            }
            dblclick(t2) {
              return this._firePreventable(new Ro2(t2.type, this._map, t2));
            }
            mouseover(t2) {
              this._map.fire(new Ro2(t2.type, this._map, t2));
            }
            mouseout(t2) {
              this._map.fire(new Ro2(t2.type, this._map, t2));
            }
            touchstart(t2) {
              return this._firePreventable(new ko2(t2.type, this._map, t2));
            }
            touchmove(t2) {
              this._map.fire(new ko2(t2.type, this._map, t2));
            }
            touchend(t2) {
              this._map.fire(new ko2(t2.type, this._map, t2));
            }
            touchcancel(t2) {
              this._map.fire(new ko2(t2.type, this._map, t2));
            }
            _firePreventable(t2) {
              if (this._map.fire(t2), t2.defaultPrevented)
                return {};
            }
            isEnabled() {
              return true;
            }
            isActive() {
              return false;
            }
            enable() {
            }
            disable() {
            }
          }
          class Oo2 {
            constructor(t2) {
              this._map = t2;
            }
            reset() {
              this._delayContextMenu = false, delete this._contextMenuEvent;
            }
            mousemove(t2) {
              this._map.fire(new Ro2(t2.type, this._map, t2));
            }
            mousedown() {
              this._delayContextMenu = true;
            }
            mouseup() {
              this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new Ro2("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
            }
            contextmenu(t2) {
              this._delayContextMenu ? this._contextMenuEvent = t2 : this._map.fire(new Ro2(t2.type, this._map, t2)), this._map.listens("contextmenu") && t2.preventDefault();
            }
            isEnabled() {
              return true;
            }
            isActive() {
              return false;
            }
            enable() {
            }
            disable() {
            }
          }
          class Uo2 {
            constructor(t2, e2) {
              this._map = t2, this._el = t2.getCanvasContainer(), this._container = t2.getContainer(), this._clickTolerance = e2.clickTolerance || 1;
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return !!this._active;
            }
            enable() {
              this.isEnabled() || (this._enabled = true);
            }
            disable() {
              this.isEnabled() && (this._enabled = false);
            }
            mousedown(t2, e2) {
              this.isEnabled() && t2.shiftKey && t2.button === 0 && (a.disableDrag(), this._startPos = this._lastPos = e2, this._active = true);
            }
            mousemoveWindow(t2, e2) {
              if (!this._active)
                return;
              const i2 = e2;
              if (this._lastPos.equals(i2) || !this._box && i2.dist(this._startPos) < this._clickTolerance)
                return;
              const o2 = this._startPos;
              this._lastPos = i2, this._box || (this._box = a.create("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", t2));
              const r3 = Math.min(o2.x, i2.x), n2 = Math.max(o2.x, i2.x), s2 = Math.min(o2.y, i2.y), l2 = Math.max(o2.y, i2.y);
              this._map._requestDomTask(() => {
                this._box && (a.setTransform(this._box, `translate(${r3}px,${s2}px)`), this._box.style.width = n2 - r3 + "px", this._box.style.height = l2 - s2 + "px");
              });
            }
            mouseupWindow(e2, i2) {
              if (!this._active)
                return;
              if (e2.button !== 0)
                return;
              const o2 = this._startPos, r3 = i2;
              if (this.reset(), a.suppressClick(), o2.x !== r3.x || o2.y !== r3.y)
                return this._map.fire(new t.Event("boxzoomend", { originalEvent: e2 })), { cameraAnimation: (t2) => t2.fitScreenCoordinates(o2, r3, this._map.getBearing(), { linear: false }) };
              this._fireEvent("boxzoomcancel", e2);
            }
            keydown(t2) {
              this._active && t2.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", t2));
            }
            reset() {
              this._active = false, this._container.classList.remove("mapboxgl-crosshair"), this._box && (a.remove(this._box), this._box = null), a.enableDrag(), delete this._startPos, delete this._lastPos;
            }
            _fireEvent(e2, i2) {
              return this._map.fire(new t.Event(e2, { originalEvent: i2 }));
            }
          }
          function No2(t2, e2) {
            const i2 = {};
            for (let o2 = 0; o2 < t2.length; o2++)
              i2[t2[o2].identifier] = e2[o2];
            return i2;
          }
          class Go2 {
            constructor(t2) {
              this.reset(), this.numTouches = t2.numTouches;
            }
            reset() {
              delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
            }
            touchstart(e2, i2, o2) {
              (this.centroid || o2.length > this.numTouches) && (this.aborted = true), this.aborted || (this.startTime === void 0 && (this.startTime = e2.timeStamp), o2.length === this.numTouches && (this.centroid = function(e3) {
                const i3 = new t.pointGeometry(0, 0);
                for (const t2 of e3)
                  i3._add(t2);
                return i3.div(e3.length);
              }(i2), this.touches = No2(o2, i2)));
            }
            touchmove(t2, e2, i2) {
              if (this.aborted || !this.centroid)
                return;
              const o2 = No2(i2, e2);
              for (const t3 in this.touches) {
                const e3 = this.touches[t3], i3 = o2[t3];
                (!i3 || i3.dist(e3) > 30) && (this.aborted = true);
              }
            }
            touchend(t2, e2, i2) {
              if ((!this.centroid || t2.timeStamp - this.startTime > 500) && (this.aborted = true), i2.length === 0) {
                const t3 = !this.aborted && this.centroid;
                if (this.reset(), t3)
                  return t3;
              }
            }
          }
          class Zo2 {
            constructor(t2) {
              this.singleTap = new Go2(t2), this.numTaps = t2.numTaps, this.reset();
            }
            reset() {
              this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
            }
            touchstart(t2, e2, i2) {
              this.singleTap.touchstart(t2, e2, i2);
            }
            touchmove(t2, e2, i2) {
              this.singleTap.touchmove(t2, e2, i2);
            }
            touchend(t2, e2, i2) {
              const o2 = this.singleTap.touchend(t2, e2, i2);
              if (o2) {
                const e3 = t2.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(o2) < 30;
                if (e3 && i3 || this.reset(), this.count++, this.lastTime = t2.timeStamp, this.lastTap = o2, this.count === this.numTaps)
                  return this.reset(), o2;
              }
            }
          }
          class Vo2 {
            constructor() {
              this._zoomIn = new Zo2({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Zo2({ numTouches: 2, numTaps: 1 }), this.reset();
            }
            reset() {
              this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
            }
            touchstart(t2, e2, i2) {
              this._zoomIn.touchstart(t2, e2, i2), this._zoomOut.touchstart(t2, e2, i2);
            }
            touchmove(t2, e2, i2) {
              this._zoomIn.touchmove(t2, e2, i2), this._zoomOut.touchmove(t2, e2, i2);
            }
            touchend(t2, e2, i2) {
              const o2 = this._zoomIn.touchend(t2, e2, i2), r3 = this._zoomOut.touchend(t2, e2, i2);
              return o2 ? (this._active = true, t2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e3) => e3.easeTo({ duration: 300, zoom: e3.getZoom() + 1, around: e3.unproject(o2) }, { originalEvent: t2 }) }) : r3 ? (this._active = true, t2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e3) => e3.easeTo({ duration: 300, zoom: e3.getZoom() - 1, around: e3.unproject(r3) }, { originalEvent: t2 }) }) : void 0;
            }
            touchcancel() {
              this.reset();
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          const jo2 = { 0: 1, 2: 2 };
          class qo2 {
            constructor(t2) {
              this.reset(), this._clickTolerance = t2.clickTolerance || 1;
            }
            reset() {
              this._active = false, this._moved = false, delete this._lastPoint, delete this._eventButton;
            }
            _correctButton(t2, e2) {
              return false;
            }
            _move(t2, e2) {
              return {};
            }
            mousedown(t2, e2) {
              if (this._lastPoint)
                return;
              const i2 = a.mouseButton(t2);
              this._correctButton(t2, i2) && (this._lastPoint = e2, this._eventButton = i2);
            }
            mousemoveWindow(t2, e2) {
              const i2 = this._lastPoint;
              if (i2) {
                if (t2.preventDefault(), function(t3, e3) {
                  const i3 = jo2[e3];
                  return t3.buttons === void 0 || (t3.buttons & i3) !== i3;
                }(t2, this._eventButton))
                  this.reset();
                else if (this._moved || !(e2.dist(i2) < this._clickTolerance))
                  return this._moved = true, this._lastPoint = e2, this._move(i2, e2);
              }
            }
            mouseupWindow(t2) {
              this._lastPoint && a.mouseButton(t2) === this._eventButton && (this._moved && a.suppressClick(), this.reset());
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class Wo2 extends qo2 {
            mousedown(t2, e2) {
              super.mousedown(t2, e2), this._lastPoint && (this._active = true);
            }
            _correctButton(t2, e2) {
              return e2 === 0 && !t2.ctrlKey;
            }
            _move(t2, e2) {
              return { around: e2, panDelta: e2.sub(t2) };
            }
          }
          class $o2 extends qo2 {
            _correctButton(t2, e2) {
              return e2 === 0 && t2.ctrlKey || e2 === 2;
            }
            _move(t2, e2) {
              const i2 = 0.8 * (e2.x - t2.x);
              if (i2)
                return this._active = true, { bearingDelta: i2 };
            }
            contextmenu(t2) {
              t2.preventDefault();
            }
          }
          class Xo2 extends qo2 {
            _correctButton(t2, e2) {
              return e2 === 0 && t2.ctrlKey || e2 === 2;
            }
            _move(t2, e2) {
              const i2 = -0.5 * (e2.y - t2.y);
              if (i2)
                return this._active = true, { pitchDelta: i2 };
            }
            contextmenu(t2) {
              t2.preventDefault();
            }
          }
          class Ho2 {
            constructor(t2) {
              this._minTouches = 1, this._clickTolerance = t2.clickTolerance || 1, this.reset();
            }
            reset() {
              this._active = false, this._touches = {}, this._sum = new t.pointGeometry(0, 0);
            }
            touchstart(t2, e2, i2) {
              return this._calculateTransform(t2, e2, i2);
            }
            touchmove(t2, e2, i2) {
              if (this._active && !(i2.length < this._minTouches))
                return t2.preventDefault(), this._calculateTransform(t2, e2, i2);
            }
            touchend(t2, e2, i2) {
              this._calculateTransform(t2, e2, i2), this._active && i2.length < this._minTouches && this.reset();
            }
            touchcancel() {
              this.reset();
            }
            _calculateTransform(e2, i2, o2) {
              o2.length > 0 && (this._active = true);
              const r3 = No2(o2, i2), a2 = new t.pointGeometry(0, 0), n2 = new t.pointGeometry(0, 0);
              let s2 = 0;
              for (const t2 in r3) {
                const e3 = r3[t2], i3 = this._touches[t2];
                i3 && (a2._add(e3), n2._add(e3.sub(i3)), s2++, r3[t2] = e3);
              }
              if (this._touches = r3, s2 < this._minTouches || !n2.mag())
                return;
              const l2 = n2.div(s2);
              return this._sum._add(l2), this._sum.mag() < this._clickTolerance ? void 0 : { around: a2.div(s2), panDelta: l2 };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class Ko2 {
            constructor() {
              this.reset();
            }
            reset() {
              this._active = false, delete this._firstTwoTouches;
            }
            _start(t2) {
            }
            _move(t2, e2, i2) {
              return {};
            }
            touchstart(t2, e2, i2) {
              this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([e2[0], e2[1]]));
            }
            touchmove(t2, e2, i2) {
              if (!this._firstTwoTouches)
                return;
              t2.preventDefault();
              const [o2, r3] = this._firstTwoTouches, a2 = Yo2(i2, e2, o2), n2 = Yo2(i2, e2, r3);
              if (!a2 || !n2)
                return;
              const s2 = this._aroundCenter ? null : a2.add(n2).div(2);
              return this._move([a2, n2], s2, t2);
            }
            touchend(t2, e2, i2) {
              if (!this._firstTwoTouches)
                return;
              const [o2, r3] = this._firstTwoTouches, n2 = Yo2(i2, e2, o2), s2 = Yo2(i2, e2, r3);
              n2 && s2 || (this._active && a.suppressClick(), this.reset());
            }
            touchcancel() {
              this.reset();
            }
            enable(t2) {
              this._enabled = true, this._aroundCenter = !!t2 && t2.around === "center";
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          function Yo2(t2, e2, i2) {
            for (let o2 = 0; o2 < t2.length; o2++)
              if (t2[o2].identifier === i2)
                return e2[o2];
          }
          function Qo2(t2, e2) {
            return Math.log(t2 / e2) / Math.LN2;
          }
          class Jo2 extends Ko2 {
            reset() {
              super.reset(), delete this._distance, delete this._startDistance;
            }
            _start(t2) {
              this._startDistance = this._distance = t2[0].dist(t2[1]);
            }
            _move(t2, e2) {
              const i2 = this._distance;
              if (this._distance = t2[0].dist(t2[1]), this._active || !(Math.abs(Qo2(this._distance, this._startDistance)) < 0.1))
                return this._active = true, { zoomDelta: Qo2(this._distance, i2), pinchAround: e2 };
            }
          }
          function tr2(t2, e2) {
            return 180 * t2.angleWith(e2) / Math.PI;
          }
          class er2 extends Ko2 {
            reset() {
              super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
            }
            _start(t2) {
              this._startVector = this._vector = t2[0].sub(t2[1]), this._minDiameter = t2[0].dist(t2[1]);
            }
            _move(t2, e2) {
              const i2 = this._vector;
              if (this._vector = t2[0].sub(t2[1]), this._active || !this._isBelowThreshold(this._vector))
                return this._active = true, { bearingDelta: tr2(this._vector, i2), pinchAround: e2 };
            }
            _isBelowThreshold(t2) {
              this._minDiameter = Math.min(this._minDiameter, t2.mag());
              const e2 = 25 / (Math.PI * this._minDiameter) * 360, i2 = tr2(t2, this._startVector);
              return Math.abs(i2) < e2;
            }
          }
          function ir2(t2) {
            return Math.abs(t2.y) > Math.abs(t2.x);
          }
          class or2 extends Ko2 {
            reset() {
              super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
            }
            _start(t2) {
              this._lastPoints = t2, ir2(t2[0].sub(t2[1])) && (this._valid = false);
            }
            _move(t2, e2, i2) {
              const o2 = t2[0].sub(this._lastPoints[0]), r3 = t2[1].sub(this._lastPoints[1]);
              if (this._valid = this.gestureBeginsVertically(o2, r3, i2.timeStamp), this._valid)
                return this._lastPoints = t2, this._active = true, { pitchDelta: (o2.y + r3.y) / 2 * -0.5 };
            }
            gestureBeginsVertically(t2, e2, i2) {
              if (this._valid !== void 0)
                return this._valid;
              const o2 = t2.mag() >= 2, r3 = e2.mag() >= 2;
              if (!o2 && !r3)
                return;
              if (!o2 || !r3)
                return this._firstMove === void 0 && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
              const a2 = t2.y > 0 == e2.y > 0;
              return ir2(t2) && ir2(e2) && a2;
            }
          }
          const rr2 = { panStep: 100, bearingStep: 15, pitchStep: 10 };
          class ar2 {
            constructor() {
              const t2 = rr2;
              this._panStep = t2.panStep, this._bearingStep = t2.bearingStep, this._pitchStep = t2.pitchStep, this._rotationDisabled = false;
            }
            reset() {
              this._active = false;
            }
            keydown(t2) {
              if (t2.altKey || t2.ctrlKey || t2.metaKey)
                return;
              let e2 = 0, i2 = 0, o2 = 0, r3 = 0, a2 = 0;
              switch (t2.keyCode) {
                case 61:
                case 107:
                case 171:
                case 187:
                  e2 = 1;
                  break;
                case 189:
                case 109:
                case 173:
                  e2 = -1;
                  break;
                case 37:
                  t2.shiftKey ? i2 = -1 : (t2.preventDefault(), r3 = -1);
                  break;
                case 39:
                  t2.shiftKey ? i2 = 1 : (t2.preventDefault(), r3 = 1);
                  break;
                case 38:
                  t2.shiftKey ? o2 = 1 : (t2.preventDefault(), a2 = -1);
                  break;
                case 40:
                  t2.shiftKey ? o2 = -1 : (t2.preventDefault(), a2 = 1);
                  break;
                default:
                  return;
              }
              return this._rotationDisabled && (i2 = 0, o2 = 0), { cameraAnimation: (n2) => {
                const s2 = n2.getZoom();
                n2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: nr2, zoom: e2 ? Math.round(s2) + e2 * (t2.shiftKey ? 2 : 1) : s2, bearing: n2.getBearing() + i2 * this._bearingStep, pitch: n2.getPitch() + o2 * this._pitchStep, offset: [-r3 * this._panStep, -a2 * this._panStep], center: n2.getCenter() }, { originalEvent: t2 });
              } };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
            disableRotation() {
              this._rotationDisabled = true;
            }
            enableRotation() {
              this._rotationDisabled = false;
            }
          }
          function nr2(t2) {
            return t2 * (2 - t2);
          }
          const sr2 = 4.000244140625;
          class lr {
            constructor(e2, i2) {
              this._map = e2, this._el = e2.getCanvasContainer(), this._handler = i2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222, t.bindAll(["_onTimeout"], this);
            }
            setZoomRate(t2) {
              this._defaultZoomRate = t2;
            }
            setWheelZoomRate(t2) {
              this._wheelZoomRate = t2;
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return !!this._active || this._finishTimeout !== void 0;
            }
            isZooming() {
              return !!this._zooming;
            }
            enable(t2) {
              this.isEnabled() || (this._enabled = true, this._aroundCenter = t2 && t2.around === "center");
            }
            disable() {
              this.isEnabled() && (this._enabled = false);
            }
            wheel(e2) {
              if (!this.isEnabled())
                return;
              let i2 = e2.deltaMode === t.window.WheelEvent.DOM_DELTA_LINE ? 40 * e2.deltaY : e2.deltaY;
              const o2 = t.exported.now(), r3 = o2 - (this._lastWheelEventTime || 0);
              this._lastWheelEventTime = o2, i2 !== 0 && i2 % sr2 == 0 ? this._type = "wheel" : i2 !== 0 && Math.abs(i2) < 4 ? this._type = "trackpad" : r3 > 400 ? (this._type = null, this._lastValue = i2, this._timeout = setTimeout(this._onTimeout, 40, e2)) : this._type || (this._type = Math.abs(r3 * i2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i2 += this._lastValue)), e2.shiftKey && i2 && (i2 /= 4), this._type && (this._lastWheelEvent = e2, this._delta -= i2, this._active || this._start(e2)), e2.preventDefault();
            }
            _onTimeout(t2) {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t2);
            }
            _start(t2) {
              if (!this._delta)
                return;
              this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
              const e2 = a.mousePos(this._el, t2);
              this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : e2, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
            }
            renderFrame() {
              if (!this._frameId)
                return;
              if (this._frameId = null, !this.isActive())
                return;
              const e2 = this._map.transform, i2 = () => e2._terrainEnabled() ? e2.computeZoomRelativeTo(this._aroundCoord) : e2.zoom;
              if (this._delta !== 0) {
                const t2 = this._type === "wheel" && Math.abs(this._delta) > sr2 ? this._wheelZoomRate : this._defaultZoomRate;
                let o3 = 2 / (1 + Math.exp(-Math.abs(this._delta * t2)));
                this._delta < 0 && o3 !== 0 && (o3 = 1 / o3);
                const r4 = i2(), a3 = Math.pow(2, r4), n3 = typeof this._targetZoom == "number" ? e2.zoomScale(this._targetZoom) : a3;
                this._targetZoom = Math.min(e2.maxZoom, Math.max(e2.minZoom, e2.scaleZoom(n3 * o3))), this._type === "wheel" && (this._startZoom = i2(), this._easing = this._smoothOutEasing(200)), this._delta = 0;
              }
              const o2 = typeof this._targetZoom == "number" ? this._targetZoom : i2(), r3 = this._startZoom, a2 = this._easing;
              let n2, s2 = false;
              if (this._type === "wheel" && r3 && a2) {
                const e3 = Math.min((t.exported.now() - this._lastWheelEventTime) / 200, 1), i3 = a2(e3);
                n2 = t.number(r3, o2, i3), e3 < 1 ? this._frameId || (this._frameId = true) : s2 = true;
              } else
                n2 = o2, s2 = true;
              return this._active = true, s2 && (this._active = false, this._finishTimeout = setTimeout(() => {
                this._zooming = false, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
              }, 200)), { noInertia: true, needsRenderFrame: !s2, zoomDelta: n2 - i2(), around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
            }
            _smoothOutEasing(e2) {
              let i2 = t.ease;
              if (this._prevEase) {
                const e3 = this._prevEase, o2 = (t.exported.now() - e3.start) / e3.duration, r3 = e3.easing(o2 + 0.01) - e3.easing(o2), a2 = 0.27 / Math.sqrt(r3 * r3 + 1e-4) * 0.01, n2 = Math.sqrt(0.0729 - a2 * a2);
                i2 = t.bezier(a2, n2, 0.25, 1);
              }
              return this._prevEase = { start: t.exported.now(), duration: e2, easing: i2 }, i2;
            }
            reset() {
              this._active = false;
            }
          }
          class cr {
            constructor(t2, e2) {
              this._clickZoom = t2, this._tapZoom = e2;
            }
            enable() {
              this._clickZoom.enable(), this._tapZoom.enable();
            }
            disable() {
              this._clickZoom.disable(), this._tapZoom.disable();
            }
            isEnabled() {
              return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
            }
            isActive() {
              return this._clickZoom.isActive() || this._tapZoom.isActive();
            }
          }
          class hr2 {
            constructor() {
              this.reset();
            }
            reset() {
              this._active = false;
            }
            dblclick(t2, e2) {
              return t2.preventDefault(), { cameraAnimation: (i2) => {
                i2.easeTo({ duration: 300, zoom: i2.getZoom() + (t2.shiftKey ? -1 : 1), around: i2.unproject(e2) }, { originalEvent: t2 });
              } };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class dr2 {
            constructor() {
              this._tap = new Zo2({ numTouches: 1, numTaps: 1 }), this.reset();
            }
            reset() {
              this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset();
            }
            touchstart(t2, e2, i2) {
              this._swipePoint || (this._tapTime && t2.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i2.length > 0 && (this._swipePoint = e2[0], this._swipeTouch = i2[0].identifier) : this._tap.touchstart(t2, e2, i2));
            }
            touchmove(t2, e2, i2) {
              if (this._tapTime) {
                if (this._swipePoint) {
                  if (i2[0].identifier !== this._swipeTouch)
                    return;
                  const o2 = e2[0], r3 = o2.y - this._swipePoint.y;
                  return this._swipePoint = o2, t2.preventDefault(), this._active = true, { zoomDelta: r3 / 128 };
                }
              } else
                this._tap.touchmove(t2, e2, i2);
            }
            touchend(t2, e2, i2) {
              this._tapTime ? this._swipePoint && i2.length === 0 && this.reset() : this._tap.touchend(t2, e2, i2) && (this._tapTime = t2.timeStamp);
            }
            touchcancel() {
              this.reset();
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class ur2 {
            constructor(t2, e2, i2) {
              this._el = t2, this._mousePan = e2, this._touchPan = i2;
            }
            enable(t2) {
              this._inertiaOptions = t2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
            }
            disable() {
              this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
            }
            isEnabled() {
              return this._mousePan.isEnabled() && this._touchPan.isEnabled();
            }
            isActive() {
              return this._mousePan.isActive() || this._touchPan.isActive();
            }
          }
          class _r2 {
            constructor(t2, e2, i2) {
              this._pitchWithRotate = t2.pitchWithRotate, this._mouseRotate = e2, this._mousePitch = i2;
            }
            enable() {
              this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
            }
            disable() {
              this._mouseRotate.disable(), this._mousePitch.disable();
            }
            isEnabled() {
              return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
            }
            isActive() {
              return this._mouseRotate.isActive() || this._mousePitch.isActive();
            }
          }
          class pr2 {
            constructor(t2, e2, i2, o2) {
              this._el = t2, this._touchZoom = e2, this._touchRotate = i2, this._tapDragZoom = o2, this._rotationDisabled = false, this._enabled = true;
            }
            enable(t2) {
              this._touchZoom.enable(t2), this._rotationDisabled || this._touchRotate.enable(t2), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
            }
            disable() {
              this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
            }
            isEnabled() {
              return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
            }
            isActive() {
              return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
            }
            disableRotation() {
              this._rotationDisabled = true, this._touchRotate.disable();
            }
            enableRotation() {
              this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
            }
          }
          const mr2 = (t2) => t2.zoom || t2.drag || t2.pitch || t2.rotate;
          class fr2 extends t.Event {
          }
          class gr2 {
            constructor() {
              this.constants = [1, 1, 0.01], this.radius = 0;
            }
            setup(e2, i2) {
              const o2 = t.sub([], i2, e2);
              this.radius = t.length(o2[2] < 0 ? t.div([], o2, this.constants) : [o2[0], o2[1], 0]);
            }
            projectRay(e2) {
              t.div(e2, e2, this.constants), t.normalize(e2, e2), t.mul$2(e2, e2, this.constants);
              const i2 = t.scale([], e2, this.radius);
              if (i2[2] > 0) {
                const e3 = t.scale([], [0, 0, 1], t.dot(i2, [0, 0, 1])), o2 = t.scale([], t.normalize([], [i2[0], i2[1], 0]), this.radius), r3 = t.add([], i2, t.scale([], t.sub([], t.add([], o2, e3), i2), 2));
                i2[0] = r3[0], i2[1] = r3[1];
              }
              return i2;
            }
          }
          function vr2(t2) {
            return t2.panDelta && t2.panDelta.mag() || t2.zoomDelta || t2.bearingDelta || t2.pitchDelta;
          }
          class xr2 {
            constructor(e2, i2) {
              this._map = e2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Ao2(e2), this._bearingSnap = i2.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new gr2(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i2), t.bindAll(["handleEvent", "handleWindowEvent"], this);
              const o2 = this._el;
              this._listeners = [[o2, "touchstart", { passive: true }], [o2, "touchmove", { passive: false }], [o2, "touchend", void 0], [o2, "touchcancel", void 0], [o2, "mousedown", void 0], [o2, "mousemove", void 0], [o2, "mouseup", void 0], [t.window.document, "mousemove", { capture: true }], [t.window.document, "mouseup", void 0], [o2, "mouseover", void 0], [o2, "mouseout", void 0], [o2, "dblclick", void 0], [o2, "click", void 0], [o2, "keydown", { capture: false }], [o2, "keyup", void 0], [o2, "wheel", { passive: false }], [o2, "contextmenu", void 0], [t.window, "blur", void 0]];
              for (const [e3, i3, o3] of this._listeners)
                a.addEventListener(e3, i3, e3 === t.window.document ? this.handleWindowEvent : this.handleEvent, o3);
            }
            destroy() {
              for (const [e2, i2, o2] of this._listeners)
                a.removeEventListener(e2, i2, e2 === t.window.document ? this.handleWindowEvent : this.handleEvent, o2);
            }
            _addDefaultHandlers(t2) {
              const e2 = this._map, i2 = e2.getCanvasContainer();
              this._add("mapEvent", new Bo2(e2, t2));
              const o2 = e2.boxZoom = new Uo2(e2, t2);
              this._add("boxZoom", o2);
              const r3 = new Vo2(), a2 = new hr2();
              e2.doubleClickZoom = new cr(a2, r3), this._add("tapZoom", r3), this._add("clickZoom", a2);
              const n2 = new dr2();
              this._add("tapDragZoom", n2);
              const s2 = e2.touchPitch = new or2();
              this._add("touchPitch", s2);
              const l2 = new $o2(t2), c2 = new Xo2(t2);
              e2.dragRotate = new _r2(t2, l2, c2), this._add("mouseRotate", l2, ["mousePitch"]), this._add("mousePitch", c2, ["mouseRotate"]);
              const h2 = new Wo2(t2), d2 = new Ho2(t2);
              e2.dragPan = new ur2(i2, h2, d2), this._add("mousePan", h2), this._add("touchPan", d2, ["touchZoom", "touchRotate"]);
              const u2 = new er2(), _2 = new Jo2();
              e2.touchZoomRotate = new pr2(i2, _2, u2, n2), this._add("touchRotate", u2, ["touchPan", "touchZoom"]), this._add("touchZoom", _2, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new Oo2(e2));
              const p2 = e2.scrollZoom = new lr(e2, this);
              this._add("scrollZoom", p2, ["mousePan"]);
              const m2 = e2.keyboard = new ar2();
              this._add("keyboard", m2);
              for (const i3 of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
                t2.interactive && t2[i3] && e2[i3].enable(t2[i3]);
            }
            _add(t2, e2, i2) {
              this._handlers.push({ handlerName: t2, handler: e2, allowed: i2 }), this._handlersById[t2] = e2;
            }
            stop(t2) {
              if (!this._updatingCamera) {
                for (const { handler: t3 } of this._handlers)
                  t3.reset();
                this._inertia.clear(), this._fireEvents({}, {}, t2), this._changes = [];
              }
            }
            isActive() {
              for (const { handler: t2 } of this._handlers)
                if (t2.isActive())
                  return true;
              return false;
            }
            isZooming() {
              return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
            }
            isRotating() {
              return !!this._eventsInProgress.rotate;
            }
            isMoving() {
              return Boolean(mr2(this._eventsInProgress)) || this.isZooming();
            }
            _blockedByActive(t2, e2, i2) {
              for (const o2 in t2)
                if (o2 !== i2 && (!e2 || e2.indexOf(o2) < 0))
                  return true;
              return false;
            }
            handleWindowEvent(t2) {
              this.handleEvent(t2, `${t2.type}Window`);
            }
            _getMapTouches(t2) {
              const e2 = [];
              for (const i2 of t2)
                this._el.contains(i2.target) && e2.push(i2);
              return e2;
            }
            handleEvent(t2, e2) {
              if (t2.type === "blur")
                return void this.stop(true);
              this._updatingCamera = true;
              const i2 = t2.type === "renderFrame", o2 = i2 ? void 0 : t2, r3 = { needsRenderFrame: false }, n2 = {}, s2 = {}, l2 = t2.touches ? this._getMapTouches(t2.touches) : void 0, c2 = l2 ? a.touchPos(this._el, l2) : i2 ? void 0 : a.mousePos(this._el, t2);
              for (const { handlerName: i3, handler: a2, allowed: h3 } of this._handlers) {
                if (!a2.isEnabled())
                  continue;
                let d3;
                this._blockedByActive(s2, h3, i3) ? a2.reset() : a2[e2 || t2.type] && (d3 = a2[e2 || t2.type](t2, c2, l2), this.mergeHandlerResult(r3, n2, d3, i3, o2), d3 && d3.needsRenderFrame && this._triggerRenderFrame()), (d3 || a2.isActive()) && (s2[i3] = a2);
              }
              const h2 = {};
              for (const t3 in this._previousActiveHandlers)
                s2[t3] || (h2[t3] = o2);
              this._previousActiveHandlers = s2, (Object.keys(h2).length || vr2(r3)) && (this._changes.push([r3, n2, h2]), this._triggerRenderFrame()), (Object.keys(s2).length || vr2(r3)) && this._map._stop(true), this._updatingCamera = false;
              const { cameraAnimation: d2 } = r3;
              d2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], d2(this._map));
            }
            mergeHandlerResult(e2, i2, o2, r3, a2) {
              if (!o2)
                return;
              t.extend(e2, o2);
              const n2 = { handlerName: r3, originalEvent: o2.originalEvent || a2 };
              o2.zoomDelta !== void 0 && (i2.zoom = n2), o2.panDelta !== void 0 && (i2.drag = n2), o2.pitchDelta !== void 0 && (i2.pitch = n2), o2.bearingDelta !== void 0 && (i2.rotate = n2);
            }
            _applyChanges() {
              const e2 = {}, i2 = {}, o2 = {};
              for (const [r3, a2, n2] of this._changes)
                r3.panDelta && (e2.panDelta = (e2.panDelta || new t.pointGeometry(0, 0))._add(r3.panDelta)), r3.zoomDelta && (e2.zoomDelta = (e2.zoomDelta || 0) + r3.zoomDelta), r3.bearingDelta && (e2.bearingDelta = (e2.bearingDelta || 0) + r3.bearingDelta), r3.pitchDelta && (e2.pitchDelta = (e2.pitchDelta || 0) + r3.pitchDelta), r3.around !== void 0 && (e2.around = r3.around), r3.aroundCoord !== void 0 && (e2.aroundCoord = r3.aroundCoord), r3.pinchAround !== void 0 && (e2.pinchAround = r3.pinchAround), r3.noInertia && (e2.noInertia = r3.noInertia), t.extend(i2, a2), t.extend(o2, n2);
              this._updateMapTransform(e2, i2, o2), this._changes = [];
            }
            _updateMapTransform(e2, i2, o2) {
              const r3 = this._map, a2 = r3.transform, n2 = (t2) => [t2.x, t2.y, t2.z];
              if (((t2) => {
                const e3 = this._eventsInProgress.drag;
                return e3 && !this._handlersById[e3.handlerName].isActive();
              })() && !vr2(e2)) {
                const t2 = a2.zoom;
                a2.cameraElevationReference = "sea", a2.recenterOnTerrain(), a2.cameraElevationReference = "ground", t2 !== a2.zoom && this._map._update(true);
              }
              if (!vr2(e2))
                return this._fireEvents(i2, o2, true);
              let { panDelta: s2, zoomDelta: l2, bearingDelta: c2, pitchDelta: h2, around: d2, aroundCoord: u2, pinchAround: _2 } = e2;
              _2 !== void 0 && (d2 = _2), ((t2) => i2.drag && !this._eventsInProgress.drag)() && d2 && (this._dragOrigin = n2(a2.pointCoordinate3D(d2)), this._trackingEllipsoid.setup(a2._camera.position, this._dragOrigin)), a2.cameraElevationReference = "sea", r3._stop(true), d2 = d2 || r3.transform.centerPoint, c2 && (a2.bearing += c2), h2 && (a2.pitch += h2), a2._updateCameraState();
              const p2 = [0, 0, 0];
              if (s2) {
                const t2 = a2.screenPointToMercatorRay(d2), e3 = a2.screenPointToMercatorRay(d2.sub(s2)), i3 = this._trackingEllipsoid.projectRay(t2.dir), o3 = this._trackingEllipsoid.projectRay(e3.dir);
                p2[0] = o3[0] - i3[0], p2[1] = o3[1] - i3[1];
              }
              const m2 = a2.zoom, f2 = [0, 0, 0];
              if (l2) {
                const e3 = n2(u2 || a2.pointCoordinate3D(d2)), i3 = { dir: t.normalize([], t.sub([], e3, a2._camera.position)) }, o3 = a2.screenPointToMercatorRay(a2.centerPoint);
                if (i3.dir[2] < 0) {
                  const r4 = t.altitudeFromMercatorZ(e3[2], e3[1]), s3 = a2.rayIntersectionCoordinate(a2.pointRayIntersection(a2.centerPoint, r4)), c3 = a2.zoomDeltaToMovement(n2(s3), l2) * (o3.dir[2] / i3.dir[2]);
                  t.scale(f2, i3.dir, c3);
                } else if (a2._terrainEnabled()) {
                  const o4 = a2.zoomDeltaToMovement(e3, l2);
                  t.scale(f2, i3.dir, o4);
                }
              }
              const g2 = t.add(p2, p2, f2);
              a2._translateCameraConstrained(g2), l2 && Math.abs(a2.zoom - m2) > 1e-4 && a2.recenterOnTerrain(), a2.cameraElevationReference = "ground", this._map._update(), e2.noInertia || this._inertia.record(e2), this._fireEvents(i2, o2, true);
            }
            _fireEvents(e2, i2, o2) {
              const r3 = mr2(this._eventsInProgress), a2 = mr2(e2), n2 = {};
              for (const t2 in e2) {
                const { originalEvent: i3 } = e2[t2];
                this._eventsInProgress[t2] || (n2[`${t2}start`] = i3), this._eventsInProgress[t2] = e2[t2];
              }
              !r3 && a2 && this._fireEvent("movestart", a2.originalEvent);
              for (const t2 in n2)
                this._fireEvent(t2, n2[t2]);
              a2 && this._fireEvent("move", a2.originalEvent);
              for (const t2 in e2) {
                const { originalEvent: i3 } = e2[t2];
                this._fireEvent(t2, i3);
              }
              const s2 = {};
              let l2;
              for (const t2 in this._eventsInProgress) {
                const { handlerName: e3, originalEvent: o3 } = this._eventsInProgress[t2];
                this._handlersById[e3].isActive() || (delete this._eventsInProgress[t2], l2 = i2[e3] || o3, s2[`${t2}end`] = l2);
              }
              for (const t2 in s2)
                this._fireEvent(t2, s2[t2]);
              const c2 = mr2(this._eventsInProgress);
              if (o2 && (r3 || a2) && !c2) {
                this._updatingCamera = true;
                const e3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (t2) => t2 !== 0 && -this._bearingSnap < t2 && t2 < this._bearingSnap;
                e3 ? (i3(e3.bearing || this._map.getBearing()) && (e3.bearing = 0), this._map.easeTo(e3, { originalEvent: l2 })) : (this._map.fire(new t.Event("moveend", { originalEvent: l2 })), i3(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
              }
            }
            _fireEvent(e2, i2) {
              this._map.fire(new t.Event(e2, i2 ? { originalEvent: i2 } : {}));
            }
            _requestFrame() {
              return this._map.triggerRepaint(), this._map._renderTaskQueue.add((t2) => {
                delete this._frameId, this.handleEvent(new fr2("renderFrame", { timeStamp: t2 })), this._applyChanges();
              });
            }
            _triggerRenderFrame() {
              this._frameId === void 0 && (this._frameId = this._requestFrame());
            }
          }
          class yr2 extends t.Evented {
            constructor(e2, i2) {
              super(), this._moving = false, this._zooming = false, this.transform = e2, this._bearingSnap = i2.bearingSnap, t.bindAll(["_renderFrameCallback"], this);
            }
            getCenter() {
              return new t.LngLat(this.transform.center.lng, this.transform.center.lat);
            }
            setCenter(t2, e2) {
              return this.jumpTo({ center: t2 }, e2);
            }
            panBy(e2, i2, o2) {
              return e2 = t.pointGeometry.convert(e2).mult(-1), this.panTo(this.transform.center, t.extend({ offset: e2 }, i2), o2);
            }
            panTo(e2, i2, o2) {
              return this.easeTo(t.extend({ center: e2 }, i2), o2);
            }
            getZoom() {
              return this.transform.zoom;
            }
            setZoom(t2, e2) {
              return this.jumpTo({ zoom: t2 }, e2), this;
            }
            zoomTo(e2, i2, o2) {
              return this.easeTo(t.extend({ zoom: e2 }, i2), o2);
            }
            zoomIn(t2, e2) {
              return this.zoomTo(this.getZoom() + 1, t2, e2), this;
            }
            zoomOut(t2, e2) {
              return this.zoomTo(this.getZoom() - 1, t2, e2), this;
            }
            getBearing() {
              return this.transform.bearing;
            }
            setBearing(t2, e2) {
              return this.jumpTo({ bearing: t2 }, e2), this;
            }
            getPadding() {
              return this.transform.padding;
            }
            setPadding(t2, e2) {
              return this.jumpTo({ padding: t2 }, e2), this;
            }
            rotateTo(e2, i2, o2) {
              return this.easeTo(t.extend({ bearing: e2 }, i2), o2);
            }
            resetNorth(e2, i2) {
              return this.rotateTo(0, t.extend({ duration: 1e3 }, e2), i2), this;
            }
            resetNorthPitch(e2, i2) {
              return this.easeTo(t.extend({ bearing: 0, pitch: 0, duration: 1e3 }, e2), i2), this;
            }
            snapToNorth(t2, e2) {
              return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t2, e2) : this;
            }
            getPitch() {
              return this.transform.pitch;
            }
            setPitch(t2, e2) {
              return this.jumpTo({ pitch: t2 }, e2), this;
            }
            cameraForBounds(e2, i2) {
              e2 = t.LngLatBounds.convert(e2);
              const o2 = i2 && i2.bearing || 0;
              return this._cameraForBoxAndBearing(e2.getNorthWest(), e2.getSouthEast(), o2, i2);
            }
            _extendCameraOptions(e2) {
              const i2 = { top: 0, bottom: 0, right: 0, left: 0 };
              if (typeof (e2 = t.extend({ padding: i2, offset: [0, 0], maxZoom: this.transform.maxZoom }, e2)).padding == "number") {
                const t2 = e2.padding;
                e2.padding = { top: t2, bottom: t2, right: t2, left: t2 };
              }
              return e2.padding = t.extend(i2, e2.padding), e2;
            }
            _cameraForBoxAndBearing(e2, i2, o2, r3) {
              const a2 = this._extendCameraOptions(r3), n2 = this.transform, s2 = n2.padding, l2 = n2.project(t.LngLat.convert(e2)), c2 = n2.project(t.LngLat.convert(i2)), h2 = l2.rotate(-t.degToRad(o2)), d2 = c2.rotate(-t.degToRad(o2)), u2 = new t.pointGeometry(Math.max(h2.x, d2.x), Math.max(h2.y, d2.y)), _2 = new t.pointGeometry(Math.min(h2.x, d2.x), Math.min(h2.y, d2.y)), p2 = u2.sub(_2), m2 = (n2.width - (s2.left + s2.right + a2.padding.left + a2.padding.right)) / p2.x, f2 = (n2.height - (s2.top + s2.bottom + a2.padding.top + a2.padding.bottom)) / p2.y;
              if (f2 < 0 || m2 < 0)
                return void t.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
              const g2 = Math.min(n2.scaleZoom(n2.scale * Math.min(m2, f2)), a2.maxZoom), v2 = typeof a2.offset.x == "number" ? new t.pointGeometry(a2.offset.x, a2.offset.y) : t.pointGeometry.convert(a2.offset), x3 = new t.pointGeometry((a2.padding.left - a2.padding.right) / 2, (a2.padding.top - a2.padding.bottom) / 2).rotate(o2 * Math.PI / 180), y2 = v2.add(x3).mult(n2.scale / n2.zoomScale(g2));
              return { center: n2.unproject(l2.add(c2).div(2).sub(y2)), zoom: g2, bearing: o2 };
            }
            _cameraForBox(e2, i2, o2, r3, a2) {
              const n2 = this._extendCameraOptions(a2);
              o2 = o2 || 0, r3 = r3 || 0, e2 = t.LngLat.convert(e2), i2 = t.LngLat.convert(i2);
              const s2 = this.transform.clone();
              s2.padding = n2.padding;
              const l2 = this.getFreeCameraOptions(), c2 = new t.LngLat(0.5 * (e2.lng + i2.lng), 0.5 * (e2.lat + i2.lat)), h2 = 0.5 * (o2 + r3);
              if (s2._camera.position[2] < t.mercatorZfromAltitude(h2, c2.lat))
                return void t.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
              l2.lookAtPoint(c2), s2.setFreeCameraOptions(l2);
              const d2 = t.MercatorCoordinate.fromLngLat(e2), u2 = t.MercatorCoordinate.fromLngLat(i2), m2 = s2.pointRayIntersection(s2.centerPoint, h2), f2 = [(g2 = s2.rayIntersectionCoordinate(m2)).x, g2.y, g2.z];
              var g2;
              const v2 = s2.screenPointToMercatorRay(s2.centerPoint);
              let x3, y2 = 0;
              do {
                const e3 = Math.floor(s2.zoom), i3 = 1 << e3, a3 = Math.min(i3 * d2.x, i3 * u2.x), n3 = Math.min(i3 * d2.y, i3 * u2.y), l3 = Math.max(i3 * d2.x, i3 * u2.x), c3 = Math.max(i3 * d2.y, i3 * u2.y), h3 = new p([a3, n3, o2], [l3, c3, r3]), m3 = _.fromInvProjectionMatrix(s2.invProjMatrix, s2.worldSize, e3);
                if (h3.intersects(m3) !== 2) {
                  x3 && (s2._camera.position = t.scaleAndAdd([], s2._camera.position, v2.dir, -x3), s2._updateStateFromCamera());
                  break;
                }
                const g3 = t.sub([], s2._camera.position, f2);
                x3 = 0.5 * t.length(g3), s2._camera.position = t.scaleAndAdd([], s2._camera.position, v2.dir, x3);
                try {
                  s2._updateStateFromCamera();
                } catch (e4) {
                  return void t.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
                }
              } while (++y2 < 10);
              return { center: s2.center, zoom: s2.zoom, bearing: s2.bearing, pitch: s2.pitch };
            }
            fitBounds(t2, e2, i2) {
              return this._fitInternal(this.cameraForBounds(t2, e2), e2, i2);
            }
            _raycastElevationBox(e2, i2) {
              const o2 = this.transform.elevation;
              if (!o2)
                return;
              const r3 = new t.pointGeometry(e2.x, i2.y), a2 = new t.pointGeometry(i2.x, e2.y), n2 = o2.pointCoordinate(e2);
              if (!n2)
                return;
              const s2 = o2.pointCoordinate(i2);
              if (!s2)
                return;
              const l2 = o2.pointCoordinate(r3);
              if (!l2)
                return;
              const c2 = o2.pointCoordinate(a2);
              if (!c2)
                return;
              const h2 = new t.MercatorCoordinate(n2[0], n2[1]).toLngLat(), d2 = new t.MercatorCoordinate(s2[0], s2[1]).toLngLat(), u2 = new t.MercatorCoordinate(l2[0], l2[1]).toLngLat(), _2 = new t.MercatorCoordinate(c2[0], c2[1]).toLngLat(), p2 = Math.min(h2.lng, Math.min(d2.lng, Math.min(u2.lng, _2.lng))), m2 = Math.min(h2.lat, Math.min(d2.lat, Math.min(u2.lat, _2.lat))), f2 = Math.max(h2.lng, Math.max(d2.lng, Math.max(u2.lng, _2.lng))), g2 = Math.max(h2.lat, Math.max(d2.lat, Math.max(u2.lat, _2.lat))), v2 = Math.min(n2[3], Math.min(s2[3], Math.min(l2[3], c2[3]))), x3 = Math.max(n2[3], Math.max(s2[3], Math.max(l2[3], c2[3])));
              return { minLngLat: new t.LngLat(p2, m2), maxLngLat: new t.LngLat(f2, g2), minAltitude: v2, maxAltitude: x3 };
            }
            fitScreenCoordinates(e2, i2, o2, r3, a2) {
              let n2, s2, l2, c2;
              const h2 = t.pointGeometry.convert(e2), d2 = t.pointGeometry.convert(i2), u2 = this._raycastElevationBox(h2, d2);
              if (u2)
                n2 = u2.minLngLat, s2 = u2.maxLngLat, l2 = u2.minAltitude, c2 = u2.maxAltitude;
              else {
                if (this.transform.isHorizonVisibleForPoints(h2, d2))
                  return this;
                n2 = this.transform.pointLocation(h2), s2 = this.transform.pointLocation(d2);
              }
              return this._fitInternal(this.transform.pitch === 0 ? this._cameraForBoxAndBearing(this.transform.pointLocation(t.pointGeometry.convert(e2)), this.transform.pointLocation(t.pointGeometry.convert(i2)), o2, r3) : this._cameraForBox(n2, s2, l2, c2, r3), r3, a2);
            }
            _fitInternal(e2, i2, o2) {
              return e2 ? (delete (i2 = t.extend(e2, i2)).padding, i2.linear ? this.easeTo(i2, o2) : this.flyTo(i2, o2)) : this;
            }
            jumpTo(e2, i2) {
              this.stop();
              const o2 = this.transform;
              let r3 = false, a2 = false, n2 = false;
              return "zoom" in e2 && o2.zoom !== +e2.zoom && (r3 = true, o2.zoom = +e2.zoom), e2.center !== void 0 && (o2.center = t.LngLat.convert(e2.center)), "bearing" in e2 && o2.bearing !== +e2.bearing && (a2 = true, o2.bearing = +e2.bearing), "pitch" in e2 && o2.pitch !== +e2.pitch && (n2 = true, o2.pitch = +e2.pitch), e2.padding == null || o2.isPaddingEqual(e2.padding) || (o2.padding = e2.padding), this.fire(new t.Event("movestart", i2)).fire(new t.Event("move", i2)), r3 && this.fire(new t.Event("zoomstart", i2)).fire(new t.Event("zoom", i2)).fire(new t.Event("zoomend", i2)), a2 && this.fire(new t.Event("rotatestart", i2)).fire(new t.Event("rotate", i2)).fire(new t.Event("rotateend", i2)), n2 && this.fire(new t.Event("pitchstart", i2)).fire(new t.Event("pitch", i2)).fire(new t.Event("pitchend", i2)), this.fire(new t.Event("moveend", i2));
            }
            getFreeCameraOptions() {
              return this.transform.getFreeCameraOptions();
            }
            setFreeCameraOptions(e2, i2) {
              this.stop();
              const o2 = this.transform, r3 = o2.zoom, a2 = o2.pitch, n2 = o2.bearing;
              o2.setFreeCameraOptions(e2);
              const s2 = r3 !== o2.zoom, l2 = a2 !== o2.pitch, c2 = n2 !== o2.bearing;
              return this.fire(new t.Event("movestart", i2)).fire(new t.Event("move", i2)), s2 && this.fire(new t.Event("zoomstart", i2)).fire(new t.Event("zoom", i2)).fire(new t.Event("zoomend", i2)), c2 && this.fire(new t.Event("rotatestart", i2)).fire(new t.Event("rotate", i2)).fire(new t.Event("rotateend", i2)), l2 && this.fire(new t.Event("pitchstart", i2)).fire(new t.Event("pitch", i2)).fire(new t.Event("pitchend", i2)), this.fire(new t.Event("moveend", i2)), this;
            }
            easeTo(e2, i2) {
              this._stop(false, e2.easeId), ((e2 = t.extend({ offset: [0, 0], duration: 500, easing: t.ease }, e2)).animate === false || !e2.essential && t.exported.prefersReducedMotion) && (e2.duration = 0);
              const o2 = this.transform, r3 = this.getZoom(), a2 = this.getBearing(), n2 = this.getPitch(), s2 = this.getPadding(), l2 = "zoom" in e2 ? +e2.zoom : r3, c2 = "bearing" in e2 ? this._normalizeBearing(e2.bearing, a2) : a2, h2 = "pitch" in e2 ? +e2.pitch : n2, d2 = "padding" in e2 ? e2.padding : o2.padding, u2 = t.pointGeometry.convert(e2.offset);
              let _2 = o2.centerPoint.add(u2);
              const p2 = o2.pointLocation(_2), m2 = t.LngLat.convert(e2.center || p2);
              this._normalizeCenter(m2);
              const f2 = o2.project(p2), g2 = o2.project(m2).sub(f2), v2 = o2.zoomScale(l2 - r3);
              let x3, y2;
              e2.around && (x3 = t.LngLat.convert(e2.around), y2 = o2.locationPoint(x3));
              const b2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
              return this._zooming = this._zooming || l2 !== r3, this._rotating = this._rotating || a2 !== c2, this._pitching = this._pitching || h2 !== n2, this._padding = !o2.isPaddingEqual(d2), this._easeId = e2.easeId, this._prepareEase(i2, e2.noMoveStart, b2), this._ease((e3) => {
                if (this._zooming && (o2.zoom = t.number(r3, l2, e3)), this._rotating && (o2.bearing = t.number(a2, c2, e3)), this._pitching && (o2.pitch = t.number(n2, h2, e3)), this._padding && (o2.interpolatePadding(s2, d2, e3), _2 = o2.centerPoint.add(u2)), x3)
                  o2.setLocationAtPoint(x3, y2);
                else {
                  const t2 = o2.zoomScale(o2.zoom - r3), i3 = l2 > r3 ? Math.min(2, v2) : Math.max(0.5, v2), a3 = Math.pow(i3, 1 - e3), n3 = o2.unproject(f2.add(g2.mult(e3 * a3)).mult(t2));
                  o2.setLocationAtPoint(o2.renderWorldCopies ? n3.wrap() : n3, _2);
                }
                this._fireMoveEvents(i2);
              }, (t2) => {
                o2.recenterOnTerrain(), this._afterEase(i2, t2);
              }, e2), this;
            }
            _prepareEase(e2, i2, o2 = {}) {
              this._moving = true, this.transform.cameraElevationReference = "sea", i2 || o2.moving || this.fire(new t.Event("movestart", e2)), this._zooming && !o2.zooming && this.fire(new t.Event("zoomstart", e2)), this._rotating && !o2.rotating && this.fire(new t.Event("rotatestart", e2)), this._pitching && !o2.pitching && this.fire(new t.Event("pitchstart", e2));
            }
            _fireMoveEvents(e2) {
              this.fire(new t.Event("move", e2)), this._zooming && this.fire(new t.Event("zoom", e2)), this._rotating && this.fire(new t.Event("rotate", e2)), this._pitching && this.fire(new t.Event("pitch", e2));
            }
            _afterEase(e2, i2) {
              if (this._easeId && i2 && this._easeId === i2)
                return;
              delete this._easeId, this.transform.cameraElevationReference = "ground";
              const o2 = this._zooming, r3 = this._rotating, a2 = this._pitching;
              this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, o2 && this.fire(new t.Event("zoomend", e2)), r3 && this.fire(new t.Event("rotateend", e2)), a2 && this.fire(new t.Event("pitchend", e2)), this.fire(new t.Event("moveend", e2));
            }
            flyTo(e2, i2) {
              if (!e2.essential && t.exported.prefersReducedMotion) {
                const o3 = t.pick(e2, ["center", "zoom", "bearing", "pitch", "around"]);
                return this.jumpTo(o3, i2);
              }
              this.stop(), e2 = t.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t.ease }, e2);
              const o2 = this.transform, r3 = this.getZoom(), a2 = this.getBearing(), n2 = this.getPitch(), s2 = this.getPadding(), l2 = "zoom" in e2 ? t.clamp(+e2.zoom, o2.minZoom, o2.maxZoom) : r3, c2 = "bearing" in e2 ? this._normalizeBearing(e2.bearing, a2) : a2, h2 = "pitch" in e2 ? +e2.pitch : n2, d2 = "padding" in e2 ? e2.padding : o2.padding, u2 = o2.zoomScale(l2 - r3), _2 = t.pointGeometry.convert(e2.offset);
              let p2 = o2.centerPoint.add(_2);
              const m2 = o2.pointLocation(p2), f2 = t.LngLat.convert(e2.center || m2);
              this._normalizeCenter(f2);
              const g2 = o2.project(m2), v2 = o2.project(f2).sub(g2);
              let x3 = e2.curve;
              const y2 = Math.max(o2.width, o2.height), b2 = y2 / u2, w3 = v2.mag();
              if ("minZoom" in e2) {
                const i3 = t.clamp(Math.min(e2.minZoom, r3, l2), o2.minZoom, o2.maxZoom), a3 = y2 / o2.zoomScale(i3 - r3);
                x3 = Math.sqrt(a3 / w3 * 2);
              }
              const T2 = x3 * x3;
              function E2(t2) {
                const e3 = (b2 * b2 - y2 * y2 + (t2 ? -1 : 1) * T2 * T2 * w3 * w3) / (2 * (t2 ? b2 : y2) * T2 * w3);
                return Math.log(Math.sqrt(e3 * e3 + 1) - e3);
              }
              function C2(t2) {
                return (Math.exp(t2) - Math.exp(-t2)) / 2;
              }
              function S2(t2) {
                return (Math.exp(t2) + Math.exp(-t2)) / 2;
              }
              const I3 = E2(0);
              let M3 = function(t2) {
                return S2(I3) / S2(I3 + x3 * t2);
              }, z2 = function(t2) {
                return y2 * ((S2(I3) * (C2(e3 = I3 + x3 * t2) / S2(e3)) - C2(I3)) / T2) / w3;
                var e3;
              }, D2 = (E2(1) - I3) / x3;
              if (Math.abs(w3) < 1e-6 || !isFinite(D2)) {
                if (Math.abs(y2 - b2) < 1e-6)
                  return this.easeTo(e2, i2);
                const t2 = b2 < y2 ? -1 : 1;
                D2 = Math.abs(Math.log(b2 / y2)) / x3, z2 = function() {
                  return 0;
                }, M3 = function(e3) {
                  return Math.exp(t2 * x3 * e3);
                };
              }
              return e2.duration = "duration" in e2 ? +e2.duration : 1e3 * D2 / ("screenSpeed" in e2 ? +e2.screenSpeed / x3 : +e2.speed), e2.maxDuration && e2.duration > e2.maxDuration && (e2.duration = 0), this._zooming = true, this._rotating = a2 !== c2, this._pitching = h2 !== n2, this._padding = !o2.isPaddingEqual(d2), this._prepareEase(i2, false), this._ease((e3) => {
                const u3 = e3 * D2, m3 = 1 / M3(u3);
                o2.zoom = e3 === 1 ? l2 : r3 + o2.scaleZoom(m3), this._rotating && (o2.bearing = t.number(a2, c2, e3)), this._pitching && (o2.pitch = t.number(n2, h2, e3)), this._padding && (o2.interpolatePadding(s2, d2, e3), p2 = o2.centerPoint.add(_2));
                const x4 = e3 === 1 ? f2 : o2.unproject(g2.add(v2.mult(z2(u3))).mult(m3));
                o2.setLocationAtPoint(o2.renderWorldCopies ? x4.wrap() : x4, p2), o2._updateCenterElevation(), this._fireMoveEvents(i2);
              }, () => this._afterEase(i2), e2), this;
            }
            isEasing() {
              return !!this._easeFrameId;
            }
            stop() {
              return this._stop();
            }
            _stop(t2, e2) {
              if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
                const t3 = this._onEaseEnd;
                delete this._onEaseEnd, t3.call(this, e2);
              }
              if (!t2) {
                const t3 = this.handlers;
                t3 && t3.stop(false);
              }
              return this;
            }
            _ease(e2, i2, o2) {
              o2.animate === false || o2.duration === 0 ? (e2(1), i2()) : (this._easeStart = t.exported.now(), this._easeOptions = o2, this._onEaseFrame = e2, this._onEaseEnd = i2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
            }
            _renderFrameCallback() {
              const e2 = Math.min((t.exported.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(e2)), e2 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }
            _normalizeBearing(e2, i2) {
              e2 = t.wrap(e2, -180, 180);
              const o2 = Math.abs(e2 - i2);
              return Math.abs(e2 - 360 - i2) < o2 && (e2 -= 360), Math.abs(e2 + 360 - i2) < o2 && (e2 += 360), e2;
            }
            _normalizeCenter(t2) {
              const e2 = this.transform;
              if (!e2.renderWorldCopies || e2.lngRange)
                return;
              const i2 = t2.lng - e2.center.lng;
              t2.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
            }
          }
          class br2 {
            constructor(e2 = {}) {
              this.options = e2, t.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
            }
            getDefaultPosition() {
              return "bottom-right";
            }
            onAdd(t2) {
              const e2 = this.options && this.options.compact;
              return this._map = t2, this._container = a.create("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = a.create("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = a.create("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), e2 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), e2 === void 0 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
            }
            onRemove() {
              a.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
            }
            _setElementTitle(t2, e2) {
              const i2 = this._map._getUIString(`AttributionControl.${e2}`);
              t2.title = i2, t2.setAttribute("aria-label", i2);
            }
            _toggleAttribution() {
              this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "true"));
            }
            _updateEditLink() {
              let e2 = this._editLink;
              e2 || (e2 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
              const i2 = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || t.config.ACCESS_TOKEN }];
              if (e2) {
                const o2 = i2.reduce((t2, e3, o3) => (e3.value && (t2 += `${e3.key}=${e3.value}${o3 < i2.length - 1 ? "&" : ""}`), t2), "?");
                e2.href = `${t.config.FEEDBACK_URL}/${o2}${this._map._hash ? this._map._hash.getHashString(true) : ""}`, e2.rel = "noopener nofollow", this._setElementTitle(e2, "MapFeedback");
              }
            }
            _updateData(t2) {
              !t2 || t2.sourceDataType !== "metadata" && t2.sourceDataType !== "visibility" && t2.dataType !== "style" || (this._updateAttributions(), this._updateEditLink());
            }
            _updateAttributions() {
              if (!this._map.style)
                return;
              let t2 = [];
              if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t2 = t2.concat(this.options.customAttribution.map((t3) => typeof t3 != "string" ? "" : t3)) : typeof this.options.customAttribution == "string" && t2.push(this.options.customAttribution)), this._map.style.stylesheet) {
                const t3 = this._map.style.stylesheet;
                this.styleOwner = t3.owner, this.styleId = t3.id;
              }
              const e2 = this._map.style._sourceCaches;
              for (const i3 in e2) {
                const o2 = e2[i3];
                if (o2.used) {
                  const e3 = o2.getSource();
                  e3.attribution && t2.indexOf(e3.attribution) < 0 && t2.push(e3.attribution);
                }
              }
              t2.sort((t3, e3) => t3.length - e3.length), t2 = t2.filter((e3, i3) => {
                for (let o2 = i3 + 1; o2 < t2.length; o2++)
                  if (t2[o2].indexOf(e3) >= 0)
                    return false;
                return true;
              });
              const i2 = t2.join(" | ");
              i2 !== this._attribHTML && (this._attribHTML = i2, t2.length ? (this._innerContainer.innerHTML = i2, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
            }
            _updateCompact() {
              this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
            }
          }
          class wr2 {
            constructor() {
              t.bindAll(["_updateLogo"], this), t.bindAll(["_updateCompact"], this);
            }
            onAdd(t2) {
              this._map = t2, this._container = a.create("div", "mapboxgl-ctrl");
              const e2 = a.create("a", "mapboxgl-ctrl-logo");
              return e2.target = "_blank", e2.rel = "noopener nofollow", e2.href = "https://www.mapbox.com/", e2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e2), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
            }
            onRemove() {
              a.remove(this._container), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
            }
            getDefaultPosition() {
              return "bottom-left";
            }
            _updateLogo(t2) {
              t2 && t2.sourceDataType !== "metadata" || (this._container.style.display = this._logoRequired() ? "block" : "none");
            }
            _logoRequired() {
              if (!this._map.style)
                return true;
              const t2 = this._map.style._sourceCaches;
              if (Object.entries(t2).length === 0)
                return true;
              for (const e2 in t2) {
                const i2 = t2[e2].getSource();
                if (i2.hasOwnProperty("mapbox_logo") && !i2.mapbox_logo)
                  return false;
              }
              return true;
            }
            _updateCompact() {
              const t2 = this._container.children;
              if (t2.length) {
                const e2 = t2[0];
                this._map.getCanvasContainer().offsetWidth < 250 ? e2.classList.add("mapboxgl-compact") : e2.classList.remove("mapboxgl-compact");
              }
            }
          }
          class Tr2 {
            constructor() {
              this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
            }
            add(t2) {
              const e2 = ++this._id;
              return this._queue.push({ callback: t2, id: e2, cancelled: false }), e2;
            }
            remove(t2) {
              const e2 = this._currentlyRunning, i2 = e2 ? this._queue.concat(e2) : this._queue;
              for (const e3 of i2)
                if (e3.id === t2)
                  return void (e3.cancelled = true);
            }
            run(t2 = 0) {
              const e2 = this._currentlyRunning = this._queue;
              this._queue = [];
              for (const i2 of e2)
                if (!i2.cancelled && (i2.callback(t2), this._cleared))
                  break;
              this._cleared = false, this._currentlyRunning = false;
            }
            clear() {
              this._currentlyRunning && (this._cleared = true), this._queue = [];
            }
          }
          function Er2(e2, i2, o2) {
            if (e2 = new t.LngLat(e2.lng, e2.lat), i2) {
              const r3 = new t.LngLat(e2.lng - 360, e2.lat), a2 = new t.LngLat(e2.lng + 360, e2.lat), n2 = 360 * Math.ceil(Math.abs(e2.lng - o2.center.lng) / 360), s2 = o2.locationPoint(e2).distSqr(i2), l2 = i2.x < 0 || i2.y < 0 || i2.x > o2.width || i2.y > o2.height;
              o2.locationPoint(r3).distSqr(i2) < s2 && (l2 || Math.abs(r3.lng - o2.center.lng) < n2) ? e2 = r3 : o2.locationPoint(a2).distSqr(i2) < s2 && (l2 || Math.abs(a2.lng - o2.center.lng) < n2) && (e2 = a2);
            }
            for (; Math.abs(e2.lng - o2.center.lng) > 180; ) {
              const t2 = o2.locationPoint(e2);
              if (t2.x >= 0 && t2.y >= 0 && t2.x <= o2.width && t2.y <= o2.height)
                break;
              e2.lng > o2.center.lng ? e2.lng -= 360 : e2.lng += 360;
            }
            return e2;
          }
          const Cr2 = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
          function Sr2(t2, e2, i2) {
            const o2 = t2.classList;
            for (const t3 in Cr2)
              o2.remove(`mapboxgl-${i2}-anchor-${t3}`);
            o2.add(`mapboxgl-${i2}-anchor-${e2}`);
          }
          class Ir2 extends t.Evented {
            constructor(e2, i2) {
              if (super(), (e2 instanceof t.window.HTMLElement || i2) && (e2 = t.extend({ element: e2 }, i2)), t.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = e2 && e2.anchor || "center", this._color = e2 && e2.color || "#3FB1CE", this._scale = e2 && e2.scale || 1, this._draggable = e2 && e2.draggable || false, this._clickTolerance = e2 && e2.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = e2 && e2.rotation || 0, this._rotationAlignment = e2 && e2.rotationAlignment || "auto", this._pitchAlignment = e2 && e2.pitchAlignment && e2.pitchAlignment !== "auto" ? e2.pitchAlignment : this._rotationAlignment, e2 && e2.element)
                this._element = e2.element, this._offset = t.pointGeometry.convert(e2 && e2.offset || [0, 0]);
              else {
                this._defaultMarker = true, this._element = a.create("div"), this._element.setAttribute("aria-label", "Map marker");
                const i3 = a.createNS("http://www.w3.org/2000/svg", "svg"), o2 = 41, r3 = 27;
                i3.setAttributeNS(null, "display", "block"), i3.setAttributeNS(null, "height", `${o2}px`), i3.setAttributeNS(null, "width", `${r3}px`), i3.setAttributeNS(null, "viewBox", `0 0 ${r3} ${o2}`);
                const n2 = a.createNS("http://www.w3.org/2000/svg", "g");
                n2.setAttributeNS(null, "stroke", "none"), n2.setAttributeNS(null, "stroke-width", "1"), n2.setAttributeNS(null, "fill", "none"), n2.setAttributeNS(null, "fill-rule", "evenodd");
                const s2 = a.createNS("http://www.w3.org/2000/svg", "g");
                s2.setAttributeNS(null, "fill-rule", "nonzero");
                const l2 = a.createNS("http://www.w3.org/2000/svg", "g");
                l2.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l2.setAttributeNS(null, "fill", "#000000");
                const c2 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
                for (const t2 of c2) {
                  const e3 = a.createNS("http://www.w3.org/2000/svg", "ellipse");
                  e3.setAttributeNS(null, "opacity", "0.04"), e3.setAttributeNS(null, "cx", "10.5"), e3.setAttributeNS(null, "cy", "5.80029008"), e3.setAttributeNS(null, "rx", t2.rx), e3.setAttributeNS(null, "ry", t2.ry), l2.appendChild(e3);
                }
                const h2 = a.createNS("http://www.w3.org/2000/svg", "g");
                h2.setAttributeNS(null, "fill", this._color);
                const d2 = a.createNS("http://www.w3.org/2000/svg", "path");
                d2.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), h2.appendChild(d2);
                const u2 = a.createNS("http://www.w3.org/2000/svg", "g");
                u2.setAttributeNS(null, "opacity", "0.25"), u2.setAttributeNS(null, "fill", "#000000");
                const _2 = a.createNS("http://www.w3.org/2000/svg", "path");
                _2.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), u2.appendChild(_2);
                const p2 = a.createNS("http://www.w3.org/2000/svg", "g");
                p2.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), p2.setAttributeNS(null, "fill", "#FFFFFF");
                const m2 = a.createNS("http://www.w3.org/2000/svg", "g");
                m2.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
                const f2 = a.createNS("http://www.w3.org/2000/svg", "circle");
                f2.setAttributeNS(null, "fill", "#000000"), f2.setAttributeNS(null, "opacity", "0.25"), f2.setAttributeNS(null, "cx", "5.5"), f2.setAttributeNS(null, "cy", "5.5"), f2.setAttributeNS(null, "r", "5.4999962");
                const g2 = a.createNS("http://www.w3.org/2000/svg", "circle");
                g2.setAttributeNS(null, "fill", "#FFFFFF"), g2.setAttributeNS(null, "cx", "5.5"), g2.setAttributeNS(null, "cy", "5.5"), g2.setAttributeNS(null, "r", "5.4999962"), m2.appendChild(f2), m2.appendChild(g2), s2.appendChild(l2), s2.appendChild(h2), s2.appendChild(u2), s2.appendChild(p2), s2.appendChild(m2), i3.appendChild(s2), i3.setAttributeNS(null, "height", o2 * this._scale + "px"), i3.setAttributeNS(null, "width", r3 * this._scale + "px"), this._element.appendChild(i3), this._offset = t.pointGeometry.convert(e2 && e2.offset || [0, -14]);
              }
              this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (t2) => {
                t2.preventDefault();
              }), this._element.addEventListener("mousedown", (t2) => {
                t2.preventDefault();
              }), Sr2(this._element, this._anchor, "marker"), this._popup = null;
            }
            addTo(t2) {
              return this.remove(), this._map = t2, t2.getCanvasContainer().appendChild(this._element), t2.on("move", this._update), t2.on("moveend", this._update), t2.on("remove", this._clearFadeTimer), t2._addMarker(this), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
            }
            remove() {
              return this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._map.off("remove", this._clearFadeTimer), this._map._removeMarker(this), delete this._map), this._clearFadeTimer(), a.remove(this._element), this._popup && this._popup.remove(), this;
            }
            getLngLat() {
              return this._lngLat;
            }
            setLngLat(e2) {
              return this._lngLat = t.LngLat.convert(e2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
            }
            getElement() {
              return this._element;
            }
            setPopup(t2) {
              if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t2) {
                if (!("offset" in t2.options)) {
                  const e2 = 38.1, i2 = 13.5, o2 = Math.sqrt(Math.pow(i2, 2) / 2);
                  t2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -e2], "bottom-left": [o2, -1 * (e2 - i2 + o2)], "bottom-right": [-o2, -1 * (e2 - i2 + o2)], left: [i2, -1 * (e2 - i2)], right: [-i2, -1 * (e2 - i2)] } : this._offset;
                }
                this._popup = t2, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
              }
              return this;
            }
            _onKeyPress(t2) {
              const e2 = t2.code, i2 = t2.charCode || t2.keyCode;
              e2 !== "Space" && e2 !== "Enter" && i2 !== 32 && i2 !== 13 || this.togglePopup();
            }
            _onMapClick(t2) {
              const e2 = t2.originalEvent.target, i2 = this._element;
              this._popup && (e2 === i2 || i2.contains(e2)) && this.togglePopup();
            }
            getPopup() {
              return this._popup;
            }
            togglePopup() {
              const t2 = this._popup;
              return t2 ? (t2.isOpen() ? t2.remove() : t2.addTo(this._map), this) : this;
            }
            _evaluateOpacity() {
              const t2 = this._pos ? this._pos.sub(this._transformedOffset()) : null;
              if (!this._withinScreenBounds(t2))
                return void this._clearFadeTimer();
              const e2 = this._map.unproject(t2);
              let i2 = false;
              if (this._map.getTerrain()) {
                const t3 = this._map.getFreeCameraOptions();
                if (t3.position) {
                  const o3 = t3.position.toLngLat();
                  i2 = o3.distanceTo(e2) < 0.9 * o3.distanceTo(this._lngLat);
                }
              }
              const o2 = (1 - this._map._queryFogOpacity(e2)) * (i2 ? 0.2 : 1);
              this._element.style.opacity = `${o2}`, this._popup && this._popup._setOpacity(`${o2}`), this._fadeTimer = null;
            }
            _clearFadeTimer() {
              this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
            }
            _withinScreenBounds(t2) {
              const e2 = this._map.transform;
              return !!t2 && t2.x >= 0 && t2.x < e2.width && t2.y >= 0 && t2.y < e2.height;
            }
            _update(t2) {
              if (!this._map)
                return;
              this._map.transform.renderWorldCopies && (this._lngLat = Er2(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._transformedOffset());
              let e2 = "";
              this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? e2 = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (e2 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let i2 = "";
              this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? i2 = "rotateX(0deg)" : this._pitchAlignment === "map" && (i2 = `rotateX(${this._map.getPitch()}deg)`), t2 && t2.type !== "moveend" || (this._pos = this._pos.round()), this._map._requestDomTask(() => {
                this._map && (this._element && this._pos && this._anchor && a.setTransform(this._element, `${Cr2[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${i2} ${e2}`), !this._map.getTerrain() && !this._map.getFog() || this._fadeTimer || (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
              });
            }
            _transformedOffset() {
              if (!this._defaultMarker)
                return this._offset;
              const t2 = this._map.transform, e2 = this._offset.mult(this._scale);
              return this._rotationAlignment === "map" && e2._rotate(t2.angle), this._pitchAlignment === "map" && (e2.y *= Math.cos(t2._pitch)), e2;
            }
            getOffset() {
              return this._offset;
            }
            setOffset(e2) {
              return this._offset = t.pointGeometry.convert(e2), this._update(), this;
            }
            _onMove(e2) {
              if (!this._isDragging) {
                const t2 = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = e2.point.dist(this._pointerdownPos) >= t2;
              }
              this._isDragging && (this._pos = e2.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new t.Event("dragstart"))), this.fire(new t.Event("drag")));
            }
            _onUp() {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new t.Event("dragend")), this._state = "inactive";
            }
            _addDragHandler(t2) {
              this._element.contains(t2.originalEvent.target) && (t2.preventDefault(), this._positionDelta = t2.point.sub(this._pos).add(this._transformedOffset()), this._pointerdownPos = t2.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }
            setDraggable(t2) {
              return this._draggable = !!t2, this._map && (t2 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
            }
            isDraggable() {
              return this._draggable;
            }
            setRotation(t2) {
              return this._rotation = t2 || 0, this._update(), this;
            }
            getRotation() {
              return this._rotation;
            }
            setRotationAlignment(t2) {
              return this._rotationAlignment = t2 || "auto", this._update(), this;
            }
            getRotationAlignment() {
              return this._rotationAlignment;
            }
            setPitchAlignment(t2) {
              return this._pitchAlignment = t2 && t2 !== "auto" ? t2 : this._rotationAlignment, this._update(), this;
            }
            getPitchAlignment() {
              return this._pitchAlignment;
            }
          }
          class Mr2 {
            constructor(t2) {
              this.jumpTo(t2);
            }
            getValue(e2) {
              if (e2 <= this._startTime)
                return this._start;
              if (e2 >= this._endTime)
                return this._end;
              const i2 = t.easeCubicInOut((e2 - this._startTime) / (this._endTime - this._startTime));
              return this._start * (1 - i2) + this._end * i2;
            }
            isEasing(t2) {
              return t2 >= this._startTime && t2 <= this._endTime;
            }
            jumpTo(t2) {
              this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = t2, this._end = t2;
            }
            easeTo(t2, e2, i2) {
              this._start = this.getValue(e2), this._end = t2, this._startTime = e2, this._endTime = e2 + i2;
            }
          }
          const zr = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm" }, { HTMLImageElement: Dr, HTMLElement: Ar2, ImageBitmap: Pr2 } = t.window, Lr2 = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, optimizeForTerrain: true, renderWorldCopies: true, refreshExpiredTiles: true, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, crossSourceCollisions: true };
          function Rr2(t2) {
            t2.parentNode && t2.parentNode.removeChild(t2);
          }
          const kr2 = { showCompass: true, showZoom: true, visualizePitch: false };
          class Fr2 {
            constructor(e2, i2, o2 = false) {
              this._clickTolerance = 10, this.element = i2, this.mouseRotate = new $o2({ clickTolerance: e2.dragRotate._mouseRotate._clickTolerance }), this.map = e2, o2 && (this.mousePitch = new Xo2({ clickTolerance: e2.dragRotate._mousePitch._clickTolerance })), t.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), a.addEventListener(i2, "mousedown", this.mousedown), a.addEventListener(i2, "touchstart", this.touchstart, { passive: false }), a.addEventListener(i2, "touchmove", this.touchmove), a.addEventListener(i2, "touchend", this.touchend), a.addEventListener(i2, "touchcancel", this.reset);
            }
            down(t2, e2) {
              this.mouseRotate.mousedown(t2, e2), this.mousePitch && this.mousePitch.mousedown(t2, e2), a.disableDrag();
            }
            move(t2, e2) {
              const i2 = this.map, o2 = this.mouseRotate.mousemoveWindow(t2, e2);
              if (o2 && o2.bearingDelta && i2.setBearing(i2.getBearing() + o2.bearingDelta), this.mousePitch) {
                const o3 = this.mousePitch.mousemoveWindow(t2, e2);
                o3 && o3.pitchDelta && i2.setPitch(i2.getPitch() + o3.pitchDelta);
              }
            }
            off() {
              const t2 = this.element;
              a.removeEventListener(t2, "mousedown", this.mousedown), a.removeEventListener(t2, "touchstart", this.touchstart, { passive: false }), a.removeEventListener(t2, "touchmove", this.touchmove), a.removeEventListener(t2, "touchend", this.touchend), a.removeEventListener(t2, "touchcancel", this.reset), this.offTemp();
            }
            offTemp() {
              a.enableDrag(), a.removeEventListener(t.window, "mousemove", this.mousemove), a.removeEventListener(t.window, "mouseup", this.mouseup);
            }
            mousedown(e2) {
              this.down(t.extend({}, e2, { ctrlKey: true, preventDefault: () => e2.preventDefault() }), a.mousePos(this.element, e2)), a.addEventListener(t.window, "mousemove", this.mousemove), a.addEventListener(t.window, "mouseup", this.mouseup);
            }
            mousemove(t2) {
              this.move(t2, a.mousePos(this.element, t2));
            }
            mouseup(t2) {
              this.mouseRotate.mouseupWindow(t2), this.mousePitch && this.mousePitch.mouseupWindow(t2), this.offTemp();
            }
            touchstart(t2) {
              t2.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = a.touchPos(this.element, t2.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: () => t2.preventDefault() }, this._startPos));
            }
            touchmove(t2) {
              t2.targetTouches.length !== 1 ? this.reset() : (this._lastPos = a.touchPos(this.element, t2.targetTouches)[0], this.move({ preventDefault: () => t2.preventDefault() }, this._lastPos));
            }
            touchend(t2) {
              t2.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
            }
            reset() {
              this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }
          }
          const Br2 = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true, showUserHeading: false };
          let Or2, Ur2 = 0, Nr2 = false;
          const Gr = { maxWidth: 100, unit: "metric" };
          function Zr2(t2, e2, i2) {
            const o2 = i2 && i2.maxWidth || 100, r3 = t2._container.clientHeight / 2, a2 = t2.unproject([0, r3]), n2 = t2.unproject([o2, r3]), s2 = a2.distanceTo(n2);
            if (i2 && i2.unit === "imperial") {
              const i3 = 3.2808 * s2;
              i3 > 5280 ? Vr(e2, o2, i3 / 5280, t2._getUIString("ScaleControl.Miles"), t2) : Vr(e2, o2, i3, t2._getUIString("ScaleControl.Feet"), t2);
            } else
              i2 && i2.unit === "nautical" ? Vr(e2, o2, s2 / 1852, t2._getUIString("ScaleControl.NauticalMiles"), t2) : s2 >= 1e3 ? Vr(e2, o2, s2 / 1e3, t2._getUIString("ScaleControl.Kilometers"), t2) : Vr(e2, o2, s2, t2._getUIString("ScaleControl.Meters"), t2);
          }
          function Vr(t2, e2, i2, o2, r3) {
            const a2 = function(t3) {
              const e3 = Math.pow(10, `${Math.floor(t3)}`.length - 1);
              let i3 = t3 / e3;
              return i3 = i3 >= 10 ? 10 : i3 >= 5 ? 5 : i3 >= 3 ? 3 : i3 >= 2 ? 2 : i3 >= 1 ? 1 : function(t4) {
                const e4 = Math.pow(10, Math.ceil(-Math.log(t4) / Math.LN10));
                return Math.round(t4 * e4) / e4;
              }(i3), e3 * i3;
            }(i2), n2 = a2 / i2;
            r3._requestDomTask(() => {
              t2.style.width = e2 * n2 + "px", t2.innerHTML = `${a2}&nbsp;${o2}`;
            });
          }
          const jr2 = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, qr2 = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
          function Wr2(e2) {
            if (e2) {
              if (typeof e2 == "number") {
                const i2 = Math.round(Math.sqrt(0.5 * Math.pow(e2, 2)));
                return { center: new t.pointGeometry(0, 0), top: new t.pointGeometry(0, e2), "top-left": new t.pointGeometry(i2, i2), "top-right": new t.pointGeometry(-i2, i2), bottom: new t.pointGeometry(0, -e2), "bottom-left": new t.pointGeometry(i2, -i2), "bottom-right": new t.pointGeometry(-i2, -i2), left: new t.pointGeometry(e2, 0), right: new t.pointGeometry(-e2, 0) };
              }
              if (e2 instanceof t.pointGeometry || Array.isArray(e2)) {
                const i2 = t.pointGeometry.convert(e2);
                return { center: i2, top: i2, "top-left": i2, "top-right": i2, bottom: i2, "bottom-left": i2, "bottom-right": i2, left: i2, right: i2 };
              }
              return { center: t.pointGeometry.convert(e2.center || [0, 0]), top: t.pointGeometry.convert(e2.top || [0, 0]), "top-left": t.pointGeometry.convert(e2["top-left"] || [0, 0]), "top-right": t.pointGeometry.convert(e2["top-right"] || [0, 0]), bottom: t.pointGeometry.convert(e2.bottom || [0, 0]), "bottom-left": t.pointGeometry.convert(e2["bottom-left"] || [0, 0]), "bottom-right": t.pointGeometry.convert(e2["bottom-right"] || [0, 0]), left: t.pointGeometry.convert(e2.left || [0, 0]), right: t.pointGeometry.convert(e2.right || [0, 0]) };
            }
            return Wr2(new t.pointGeometry(0, 0));
          }
          const $r2 = { version: t.version, supported: e, setRTLTextPlugin: t.setRTLTextPlugin, getRTLTextPluginStatus: t.getRTLTextPluginStatus, Map: class extends yr2 {
            constructor(e2) {
              if ((e2 = t.extend({}, Lr2, e2)).minZoom != null && e2.maxZoom != null && e2.minZoom > e2.maxZoom)
                throw new Error("maxZoom must be greater than or equal to minZoom");
              if (e2.minPitch != null && e2.maxPitch != null && e2.minPitch > e2.maxPitch)
                throw new Error("maxPitch must be greater than or equal to minPitch");
              if (e2.minPitch != null && e2.minPitch < 0)
                throw new Error("minPitch must be greater than or equal to 0");
              if (e2.maxPitch != null && e2.maxPitch > 85)
                throw new Error("maxPitch must be less than or equal to 85");
              if (super(new To2(e2.minZoom, e2.maxZoom, e2.minPitch, e2.maxPitch, e2.renderWorldCopies), e2), this._interactive = e2.interactive, this._maxTileCacheSize = e2.maxTileCacheSize, this._failIfMajorPerformanceCaveat = e2.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e2.preserveDrawingBuffer, this._antialias = e2.antialias, this._trackResize = e2.trackResize, this._bearingSnap = e2.bearingSnap, this._refreshExpiredTiles = e2.refreshExpiredTiles, this._fadeDuration = e2.fadeDuration, this._isInitialLoad = true, this._crossSourceCollisions = e2.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = e2.collectResourceTiming, this._optimizeForTerrain = e2.optimizeForTerrain, this._renderTaskQueue = new Tr2(), this._domRenderTaskQueue = new Tr2(), this._controls = [], this._markers = [], this._mapId = t.uniqueId(), this._locale = t.extend({}, zr, e2.locale), this._clickTolerance = e2.clickTolerance, this._averageElevationLastSampledAt = -1 / 0, this._averageElevation = new Mr2(0), this._requestManager = new t.RequestManager(e2.transformRequest, e2.accessToken, e2.testMode), this._silenceAuthErrors = !!e2.testMode, typeof e2.container == "string") {
                if (this._container = t.window.document.getElementById(e2.container), !this._container)
                  throw new Error(`Container '${e2.container}' not found.`);
              } else {
                if (!(e2.container instanceof Ar2))
                  throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                this._container = e2.container;
              }
              if (e2.maxBounds && this.setMaxBounds(e2.maxBounds), t.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), this.painter === void 0)
                throw new Error("Failed to initialize WebGL.");
              this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), t.window !== void 0 && (t.window.addEventListener("online", this._onWindowOnline, false), t.window.addEventListener("resize", this._onWindowResize, false), t.window.addEventListener("orientationchange", this._onWindowResize, false), t.window.addEventListener("webkitfullscreenchange", this._onWindowResize, false)), this.handlers = new xr2(this, e2), this._hash = e2.hash && new Co2(typeof e2.hash == "string" && e2.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: e2.center, zoom: e2.zoom, bearing: e2.bearing, pitch: e2.pitch }), e2.bounds && (this.resize(), this.fitBounds(e2.bounds, t.extend({}, e2.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localFontFamily = e2.localFontFamily, this._localIdeographFontFamily = e2.localIdeographFontFamily, e2.style && this.setStyle(e2.style, { localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), e2.attributionControl && this.addControl(new br2({ customAttribution: e2.customAttribution })), this._logoControl = new wr2(), this.addControl(this._logoControl, e2.logoPosition), this.on("style.load", () => {
                this.transform.unmodified && this.jumpTo(this.style.stylesheet);
              }), this.on("data", (e3) => {
                this._update(e3.dataType === "style"), this.fire(new t.Event(`${e3.dataType}data`, e3));
              }), this.on("dataloading", (e3) => {
                this.fire(new t.Event(`${e3.dataType}dataloading`, e3));
              });
            }
            _getMapId() {
              return this._mapId;
            }
            addControl(e2, i2) {
              if (i2 === void 0 && (i2 = e2.getDefaultPosition ? e2.getDefaultPosition() : "top-right"), !e2 || !e2.onAdd)
                return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
              const o2 = e2.onAdd(this);
              this._controls.push(e2);
              const r3 = this._controlPositions[i2];
              return i2.indexOf("bottom") !== -1 ? r3.insertBefore(o2, r3.firstChild) : r3.appendChild(o2), this;
            }
            removeControl(e2) {
              if (!e2 || !e2.onRemove)
                return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
              const i2 = this._controls.indexOf(e2);
              return i2 > -1 && this._controls.splice(i2, 1), e2.onRemove(this), this;
            }
            hasControl(t2) {
              return this._controls.indexOf(t2) > -1;
            }
            getContainer() {
              return this._container;
            }
            getCanvasContainer() {
              return this._canvasContainer;
            }
            getCanvas() {
              return this._canvas;
            }
            resize(e2) {
              const i2 = this._containerDimensions(), o2 = i2[0], r3 = i2[1];
              this._resizeCanvas(o2, r3), this.transform.resize(o2, r3), this.painter.resize(o2, r3);
              const a2 = !this._moving;
              return a2 && (this.stop(), this.fire(new t.Event("movestart", e2)).fire(new t.Event("move", e2))), this.fire(new t.Event("resize", e2)), a2 && this.fire(new t.Event("moveend", e2)), this;
            }
            getBounds() {
              return this.transform.getBounds();
            }
            getMaxBounds() {
              return this.transform.getMaxBounds();
            }
            setMaxBounds(e2) {
              return this.transform.setMaxBounds(t.LngLatBounds.convert(e2)), this._update();
            }
            setMinZoom(t2) {
              if ((t2 = t2 == null ? -2 : t2) >= -2 && t2 <= this.transform.maxZoom)
                return this.transform.minZoom = t2, this._update(), this.getZoom() < t2 && this.setZoom(t2), this;
              throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
            }
            getMinZoom() {
              return this.transform.minZoom;
            }
            setMaxZoom(t2) {
              if ((t2 = t2 == null ? 22 : t2) >= this.transform.minZoom)
                return this.transform.maxZoom = t2, this._update(), this.getZoom() > t2 && this.setZoom(t2), this;
              throw new Error("maxZoom must be greater than the current minZoom");
            }
            getMaxZoom() {
              return this.transform.maxZoom;
            }
            setMinPitch(t2) {
              if ((t2 = t2 == null ? 0 : t2) < 0)
                throw new Error("minPitch must be greater than or equal to 0");
              if (t2 >= 0 && t2 <= this.transform.maxPitch)
                return this.transform.minPitch = t2, this._update(), this.getPitch() < t2 && this.setPitch(t2), this;
              throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
            }
            getMinPitch() {
              return this.transform.minPitch;
            }
            setMaxPitch(t2) {
              if ((t2 = t2 == null ? 85 : t2) > 85)
                throw new Error("maxPitch must be less than or equal to 85");
              if (t2 >= this.transform.minPitch)
                return this.transform.maxPitch = t2, this._update(), this.getPitch() > t2 && this.setPitch(t2), this;
              throw new Error("maxPitch must be greater than the current minPitch");
            }
            getMaxPitch() {
              return this.transform.maxPitch;
            }
            getRenderWorldCopies() {
              return this.transform.renderWorldCopies;
            }
            setRenderWorldCopies(t2) {
              return this.transform.renderWorldCopies = t2, this._update();
            }
            project(e2) {
              return this.transform.locationPoint3D(t.LngLat.convert(e2));
            }
            unproject(e2) {
              return this.transform.pointLocation3D(t.pointGeometry.convert(e2));
            }
            isMoving() {
              return this._moving || this.handlers && this.handlers.isMoving();
            }
            isZooming() {
              return this._zooming || this.handlers && this.handlers.isZooming();
            }
            isRotating() {
              return this._rotating || this.handlers && this.handlers.isRotating();
            }
            _createDelegatedListener(t2, e2, i2) {
              if (t2 === "mouseenter" || t2 === "mouseover") {
                let o2 = false;
                const r3 = (r4) => {
                  const a2 = this.getLayer(e2) ? this.queryRenderedFeatures(r4.point, { layers: [e2] }) : [];
                  a2.length ? o2 || (o2 = true, i2.call(this, new Ro2(t2, this, r4.originalEvent, { features: a2 }))) : o2 = false;
                };
                return { layer: e2, listener: i2, delegates: { mousemove: r3, mouseout: () => {
                  o2 = false;
                } } };
              }
              if (t2 === "mouseleave" || t2 === "mouseout") {
                let o2 = false;
                const r3 = (r4) => {
                  (this.getLayer(e2) ? this.queryRenderedFeatures(r4.point, { layers: [e2] }) : []).length ? o2 = true : o2 && (o2 = false, i2.call(this, new Ro2(t2, this, r4.originalEvent)));
                }, a2 = (e3) => {
                  o2 && (o2 = false, i2.call(this, new Ro2(t2, this, e3.originalEvent)));
                };
                return { layer: e2, listener: i2, delegates: { mousemove: r3, mouseout: a2 } };
              }
              {
                const o2 = (t3) => {
                  const o3 = this.getLayer(e2) ? this.queryRenderedFeatures(t3.point, { layers: [e2] }) : [];
                  o3.length && (t3.features = o3, i2.call(this, t3), delete t3.features);
                };
                return { layer: e2, listener: i2, delegates: { [t2]: o2 } };
              }
            }
            on(t2, e2, i2) {
              if (i2 === void 0)
                return super.on(t2, e2);
              const o2 = this._createDelegatedListener(t2, e2, i2);
              this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t2] = this._delegatedListeners[t2] || [], this._delegatedListeners[t2].push(o2);
              for (const t3 in o2.delegates)
                this.on(t3, o2.delegates[t3]);
              return this;
            }
            once(t2, e2, i2) {
              if (i2 === void 0)
                return super.once(t2, e2);
              const o2 = this._createDelegatedListener(t2, e2, i2);
              for (const t3 in o2.delegates)
                this.once(t3, o2.delegates[t3]);
              return this;
            }
            off(t2, e2, i2) {
              return i2 === void 0 ? super.off(t2, e2) : (this._delegatedListeners && this._delegatedListeners[t2] && ((o2) => {
                const r3 = this._delegatedListeners[t2];
                for (let t3 = 0; t3 < r3.length; t3++) {
                  const o3 = r3[t3];
                  if (o3.layer === e2 && o3.listener === i2) {
                    for (const t4 in o3.delegates)
                      this.off(t4, o3.delegates[t4]);
                    return r3.splice(t3, 1), this;
                  }
                }
              })(), this);
            }
            queryRenderedFeatures(e2, i2) {
              return this.style ? (i2 !== void 0 || e2 === void 0 || e2 instanceof t.pointGeometry || Array.isArray(e2) || (i2 = e2, e2 = void 0), this.style.queryRenderedFeatures(e2 = e2 || [[0, 0], [this.transform.width, this.transform.height]], i2 = i2 || {}, this.transform)) : [];
            }
            querySourceFeatures(t2, e2) {
              return this.style.querySourceFeatures(t2, e2);
            }
            queryTerrainElevation(e2, i2) {
              const o2 = this.transform.elevation;
              return o2 ? (i2 = t.extend({}, { exaggerated: true }, i2), o2.getAtPoint(t.MercatorCoordinate.fromLngLat(e2), null, i2.exaggerated)) : null;
            }
            setStyle(e2, i2) {
              return (i2 = t.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, i2)).diff !== false && i2.localIdeographFontFamily === this._localIdeographFontFamily && i2.localFontFamily === this._localFontFamily && this.style && e2 ? (this._diffStyle(e2, i2), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._localFontFamily = i2.localFontFamily, this._updateStyle(e2, i2));
            }
            _getUIString(t2) {
              const e2 = this._locale[t2];
              if (e2 == null)
                throw new Error(`Missing UI string '${t2}'`);
              return e2;
            }
            _updateStyle(t2, e2) {
              return this.style && (this.style.setEventedParent(null), this.style._remove(), delete this.style), t2 && (this.style = new Ze2(this, e2 || {}), this.style.setEventedParent(this, { style: this.style }), typeof t2 == "string" ? this.style.loadURL(t2) : this.style.loadJSON(t2)), this._updateTerrain(), this;
            }
            _lazyInitEmptyStyle() {
              this.style || (this.style = new Ze2(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
            }
            _diffStyle(e2, i2) {
              if (typeof e2 == "string") {
                const o2 = this._requestManager.normalizeStyleURL(e2), r3 = this._requestManager.transformRequest(o2, t.ResourceType.Style);
                t.getJSON(r3, (e3, o3) => {
                  e3 ? this.fire(new t.ErrorEvent(e3)) : o3 && this._updateDiff(o3, i2);
                });
              } else
                typeof e2 == "object" && this._updateDiff(e2, i2);
            }
            _updateDiff(e2, i2) {
              try {
                this.style.setState(e2) && this._update(true);
              } catch (o2) {
                t.warnOnce(`Unable to perform style diff: ${o2.message || o2.error || o2}.  Rebuilding the style from scratch.`), this._updateStyle(e2, i2);
              }
            }
            getStyle() {
              if (this.style)
                return this.style.serialize();
            }
            isStyleLoaded() {
              return this.style ? this.style.loaded() : t.warnOnce("There is no style added to the map.");
            }
            addSource(t2, e2) {
              return this._lazyInitEmptyStyle(), this.style.addSource(t2, e2), this._update(true);
            }
            isSourceLoaded(e2) {
              const i2 = this.style && this.style._getSourceCaches(e2);
              if (i2.length !== 0)
                return i2.every((t2) => t2.loaded());
              this.fire(new t.ErrorEvent(new Error(`There is no source with ID '${e2}'`)));
            }
            areTilesLoaded() {
              const t2 = this.style && this.style._sourceCaches;
              for (const e2 in t2) {
                const i2 = t2[e2]._tiles;
                for (const t3 in i2) {
                  const e3 = i2[t3];
                  if (e3.state !== "loaded" && e3.state !== "errored")
                    return false;
                }
              }
              return true;
            }
            addSourceType(t2, e2, i2) {
              return this._lazyInitEmptyStyle(), this.style.addSourceType(t2, e2, i2);
            }
            removeSource(t2) {
              return this.style.removeSource(t2), this._updateTerrain(), this._update(true);
            }
            getSource(t2) {
              return this.style.getSource(t2);
            }
            addImage(e2, i2, { pixelRatio: o2 = 1, sdf: r3 = false, stretchX: a2, stretchY: n2, content: s2 } = {}) {
              if (this._lazyInitEmptyStyle(), i2 instanceof Dr || Pr2 && i2 instanceof Pr2) {
                const { width: l2, height: c2, data: h2 } = t.exported.getImageData(i2);
                this.style.addImage(e2, { data: new t.RGBAImage({ width: l2, height: c2 }, h2), pixelRatio: o2, stretchX: a2, stretchY: n2, content: s2, sdf: r3, version: 0 });
              } else {
                if (i2.width === void 0 || i2.height === void 0)
                  return this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                {
                  const { width: l2, height: c2, data: h2 } = i2, d2 = i2;
                  this.style.addImage(e2, { data: new t.RGBAImage({ width: l2, height: c2 }, new Uint8Array(h2)), pixelRatio: o2, stretchX: a2, stretchY: n2, content: s2, sdf: r3, version: 0, userImage: d2 }), d2.onAdd && d2.onAdd(this, e2);
                }
              }
            }
            updateImage(e2, i2) {
              const o2 = this.style.getImage(e2);
              if (!o2)
                return this.fire(new t.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
              const r3 = i2 instanceof Dr || Pr2 && i2 instanceof Pr2 ? t.exported.getImageData(i2) : i2, { width: a2, height: n2, data: s2 } = r3;
              return a2 === void 0 || n2 === void 0 ? this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))) : a2 !== o2.data.width || n2 !== o2.data.height ? this.fire(new t.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image"))) : (o2.data.replace(s2, !(i2 instanceof Dr || Pr2 && i2 instanceof Pr2)), void this.style.updateImage(e2, o2));
            }
            hasImage(e2) {
              return e2 ? !!this.style.getImage(e2) : (this.fire(new t.ErrorEvent(new Error("Missing required image id"))), false);
            }
            removeImage(t2) {
              this.style.removeImage(t2);
            }
            loadImage(e2, i2) {
              t.getImage(this._requestManager.transformRequest(e2, t.ResourceType.Image), (e3, o2) => {
                i2(e3, o2 instanceof Dr ? t.exported.getImageData(o2) : o2);
              });
            }
            listImages() {
              return this.style.listImages();
            }
            addLayer(t2, e2) {
              return this._lazyInitEmptyStyle(), this.style.addLayer(t2, e2), this._update(true);
            }
            moveLayer(t2, e2) {
              return this.style.moveLayer(t2, e2), this._update(true);
            }
            removeLayer(t2) {
              return this.style.removeLayer(t2), this._update(true);
            }
            getLayer(t2) {
              return this.style.getLayer(t2);
            }
            setLayerZoomRange(t2, e2, i2) {
              return this.style.setLayerZoomRange(t2, e2, i2), this._update(true);
            }
            setFilter(t2, e2, i2 = {}) {
              return this.style.setFilter(t2, e2, i2), this._update(true);
            }
            getFilter(t2) {
              return this.style.getFilter(t2);
            }
            setPaintProperty(t2, e2, i2, o2 = {}) {
              return this.style.setPaintProperty(t2, e2, i2, o2), this._update(true);
            }
            getPaintProperty(t2, e2) {
              return this.style.getPaintProperty(t2, e2);
            }
            setLayoutProperty(t2, e2, i2, o2 = {}) {
              return this.style.setLayoutProperty(t2, e2, i2, o2), this._update(true);
            }
            getLayoutProperty(t2, e2) {
              return this.style.getLayoutProperty(t2, e2);
            }
            setLight(t2, e2 = {}) {
              return this._lazyInitEmptyStyle(), this.style.setLight(t2, e2), this._update(true);
            }
            getLight() {
              return this.style.getLight();
            }
            setTerrain(t2) {
              return this._lazyInitEmptyStyle(), this.style.setTerrain(t2), this._averageElevationLastSampledAt = -1 / 0, this._update(true);
            }
            getTerrain() {
              return this.style ? this.style.getTerrain() : null;
            }
            setFog(t2) {
              return this._lazyInitEmptyStyle(), this.style.setFog(t2), this._update(true);
            }
            getFog() {
              return this.style ? this.style.getFog() : null;
            }
            _queryFogOpacity(e2) {
              return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(t.LngLat.convert(e2), this.transform) : 0;
            }
            setFeatureState(t2, e2) {
              return this.style.setFeatureState(t2, e2), this._update();
            }
            removeFeatureState(t2, e2) {
              return this.style.removeFeatureState(t2, e2), this._update();
            }
            getFeatureState(t2) {
              return this.style.getFeatureState(t2);
            }
            _containerDimensions() {
              let t2 = 0, e2 = 0;
              return this._container && (t2 = this._container.clientWidth || 400, e2 = this._container.clientHeight || 300), [t2, e2];
            }
            _detectMissingCSS() {
              t.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") !== "rgb(250, 128, 114)" && t.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
            }
            _setupContainer() {
              const t2 = this._container;
              t2.classList.add("mapboxgl-map"), (this._missingCSSCanary = a.create("div", "mapboxgl-canary", t2)).style.visibility = "hidden", this._detectMissingCSS();
              const e2 = this._canvasContainer = a.create("div", "mapboxgl-canvas-container", t2);
              this._interactive && e2.classList.add("mapboxgl-interactive"), this._canvas = a.create("canvas", "mapboxgl-canvas", e2), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
              const i2 = this._containerDimensions();
              this._resizeCanvas(i2[0], i2[1]);
              const o2 = this._controlContainer = a.create("div", "mapboxgl-control-container", t2), r3 = this._controlPositions = {};
              ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((t3) => {
                r3[t3] = a.create("div", `mapboxgl-ctrl-${t3}`, o2);
              }), this._container.addEventListener("scroll", this._onMapScroll, false);
            }
            _resizeCanvas(e2, i2) {
              const o2 = t.exported.devicePixelRatio || 1;
              this._canvas.width = o2 * e2, this._canvas.height = o2 * i2, this._canvas.style.width = `${e2}px`, this._canvas.style.height = `${i2}px`;
            }
            _addMarker(t2) {
              this._markers.push(t2);
            }
            _removeMarker(t2) {
              const e2 = this._markers.indexOf(t2);
              e2 !== -1 && this._markers.splice(e2, 1);
            }
            _setupPainter() {
              const i2 = t.extend({}, e.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), o2 = this._canvas.getContext("webgl", i2) || this._canvas.getContext("experimental-webgl", i2);
              o2 ? (t.storeAuthState(o2, true), this.painter = new _o2(o2, this.transform), this.on("data", (t2) => {
                t2.dataType === "source" && this.painter.setTileLoadedFlag(true);
              }), t.exported$1.testSupport(o2)) : this.fire(new t.ErrorEvent(new Error("Failed to initialize WebGL")));
            }
            _contextLost(e2) {
              e2.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new t.Event("webglcontextlost", { originalEvent: e2 }));
            }
            _contextRestored(e2) {
              this._setupPainter(), this.resize(), this._update(), this.fire(new t.Event("webglcontextrestored", { originalEvent: e2 }));
            }
            _onMapScroll(t2) {
              if (t2.target === this._container)
                return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
            }
            loaded() {
              return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
            }
            _update(t2) {
              return this.style ? (this._styleDirty = this._styleDirty || t2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
            }
            _requestRenderFrame(t2) {
              return this._update(), this._renderTaskQueue.add(t2);
            }
            _cancelRenderFrame(t2) {
              this._renderTaskQueue.remove(t2);
            }
            _requestDomTask(t2) {
              !this.isMoving() && this.loaded() ? t2() : this._domRenderTaskQueue.add(t2);
            }
            _render(e2) {
              let i2;
              const o2 = this.painter.context.extTimerQuery, r3 = t.exported.now();
              this.listens("gpu-timing-frame") && (i2 = o2.createQueryEXT(), o2.beginQueryEXT(o2.TIME_ELAPSED_EXT, i2));
              let a2 = this._updateAverageElevation(r3);
              if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e2), this._domRenderTaskQueue.run(e2), this._removed)
                return;
              let n2 = false;
              const s2 = this._isInitialLoad ? 0 : this._fadeDuration;
              if (this.style && this._styleDirty) {
                this._styleDirty = false;
                const e3 = this.transform.zoom, i3 = t.exported.now();
                this.style.zoomHistory.update(e3, i3);
                const o3 = new t.EvaluationParameters(e3, { now: i3, fadeDuration: s2, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), r4 = o3.crossFadingFactor();
                r4 === 1 && r4 === this._crossFadingFactor || (n2 = true, this._crossFadingFactor = r4), this.style.update(o3);
              }
              if (this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = true, this._sourcesDirty = true), this.style && this._sourcesDirty && (this._sourcesDirty = false, this.painter._updateFog(this.style), this._updateTerrain(), this.style._updateSources(this.transform)), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, s2, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showTerrainWireframe: this.showTerrainWireframe, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: s2, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), speedIndexTiming: this.speedIndexTiming }), this.fire(new t.Event("render")), this.loaded() && !this._loaded && (this._loaded = true, this.fire(new t.Event("load"))), this.style && (this.style.hasTransitions() || n2) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) {
                const e3 = t.exported.now() - r3;
                o2.endQueryEXT(o2.TIME_ELAPSED_EXT, i2), setTimeout(() => {
                  const r4 = o2.getQueryObjectEXT(i2, o2.QUERY_RESULT_EXT) / 1e6;
                  o2.deleteQueryEXT(i2), this.fire(new t.Event("gpu-timing-frame", { cpuTime: e3, gpuTime: r4 }));
                }, 50);
              }
              if (this.listens("gpu-timing-layer")) {
                const e3 = this.painter.collectGpuTimers();
                setTimeout(() => {
                  const i3 = this.painter.queryGpuTimers(e3);
                  this.fire(new t.Event("gpu-timing-layer", { layerTimes: i3 }));
                }, 50);
              }
              const l2 = this._sourcesDirty || this._styleDirty || this._placementDirty || a2;
              if (l2 || this._repaint)
                this.triggerRepaint();
              else {
                const e3 = !this.isMoving() && this.loaded();
                if (e3 && (a2 = this._updateAverageElevation(r3, true)), a2)
                  this.triggerRepaint();
                else if (this._triggerFrame(false), e3 && (this.fire(new t.Event("idle")), this._isInitialLoad = false, this.speedIndexTiming)) {
                  const e4 = this._calculateSpeedIndex();
                  this.fire(new t.Event("speedindexcompleted", { speedIndex: e4 })), this.speedIndexTiming = false;
                }
              }
              return !this._loaded || this._fullyLoaded || l2 || (this._fullyLoaded = true, this._authenticate()), this;
            }
            _updateAverageElevation(t2, e2 = false) {
              const i2 = (t3) => (this.transform.averageElevation = t3, this._update(false), true);
              if (!this.painter.averageElevationNeedsEasing())
                return this.transform.averageElevation !== 0 && i2(0);
              if ((e2 || t2 - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(t2)) {
                const e3 = this.transform.averageElevation;
                let o2 = this.transform.sampleAverageElevation();
                isNaN(o2) ? o2 = 0 : this._averageElevationLastSampledAt = t2;
                const r3 = Math.abs(e3 - o2);
                if (r3 > 1) {
                  if (this._isInitialLoad)
                    return this._averageElevation.jumpTo(o2), i2(o2);
                  this._averageElevation.easeTo(o2, t2, 300);
                } else if (r3 > 1e-4)
                  return this._averageElevation.jumpTo(o2), i2(o2);
              }
              return !!this._averageElevation.isEasing(t2) && i2(this._averageElevation.getValue(t2));
            }
            _authenticate() {
              t.getMapSessionAPI(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (e2) => {
                if (e2 && (e2.message === t.AUTH_ERR_MSG || e2.status === 401)) {
                  const e3 = this.painter.context.gl;
                  t.storeAuthState(e3, false), this._logoControl instanceof wr2 && this._logoControl._updateLogo(), e3 && e3.clear(e3.DEPTH_BUFFER_BIT | e3.COLOR_BUFFER_BIT | e3.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new t.ErrorEvent(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
                }
              }), t.postMapLoadEvent(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
              });
            }
            _updateTerrain() {
              this.painter.updateTerrain(this.style, this.isMoving() || this.isRotating() || this.isZooming());
            }
            _calculateSpeedIndex() {
              const t2 = this.painter.canvasCopy(), e2 = this.painter.getCanvasCopiesAndTimestamps();
              e2.timeStamps.push(performance.now());
              const i2 = this.painter.context.gl, o2 = i2.createFramebuffer();
              function r3(t3) {
                i2.framebufferTexture2D(i2.FRAMEBUFFER, i2.COLOR_ATTACHMENT0, i2.TEXTURE_2D, t3, 0);
                const e3 = new Uint8Array(i2.drawingBufferWidth * i2.drawingBufferHeight * 4);
                return i2.readPixels(0, 0, i2.drawingBufferWidth, i2.drawingBufferHeight, i2.RGBA, i2.UNSIGNED_BYTE, e3), e3;
              }
              return i2.bindFramebuffer(i2.FRAMEBUFFER, o2), this._canvasPixelComparison(r3(t2), e2.canvasCopies.map(r3), e2.timeStamps);
            }
            _canvasPixelComparison(t2, e2, i2) {
              let o2 = i2[1] - i2[0];
              const r3 = t2.length / 4;
              for (let a2 = 0; a2 < e2.length; a2++) {
                const n2 = e2[a2];
                let s2 = 0;
                for (let e3 = 0; e3 < n2.length; e3 += 4)
                  n2[e3] === t2[e3] && n2[e3 + 1] === t2[e3 + 1] && n2[e3 + 2] === t2[e3 + 2] && n2[e3 + 3] === t2[e3 + 3] && (s2 += 1);
                o2 += (i2[a2 + 2] - i2[a2 + 1]) * (1 - s2 / r3);
              }
              return o2;
            }
            remove() {
              this._hash && this._hash.remove();
              for (const t2 of this._controls)
                t2.onRemove(this);
              this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), t.window !== void 0 && (t.window.removeEventListener("resize", this._onWindowResize, false), t.window.removeEventListener("orientationchange", this._onWindowResize, false), t.window.removeEventListener("webkitfullscreenchange", this._onWindowResize, false), t.window.removeEventListener("online", this._onWindowOnline, false));
              const e2 = this.painter.context.gl.getExtension("WEBGL_lose_context");
              e2 && e2.loseContext(), Rr2(this._canvasContainer), Rr2(this._controlContainer), Rr2(this._missingCSSCanary), this._container.classList.remove("mapboxgl-map"), t.removeAuthState(this.painter.context.gl), this._removed = true, this.fire(new t.Event("remove"));
            }
            triggerRepaint() {
              this._triggerFrame(true);
            }
            _triggerFrame(e2) {
              this._renderNextFrame = this._renderNextFrame || e2, this.style && !this._frame && (this._frame = t.exported.frame((t2) => {
                const e3 = !!this._renderNextFrame;
                this._frame = null, this._renderNextFrame = null, e3 && this._render(t2);
              }));
            }
            _onWindowOnline() {
              this._update();
            }
            _onWindowResize(t2) {
              this._trackResize && this.resize({ originalEvent: t2 })._update();
            }
            get showTileBoundaries() {
              return !!this._showTileBoundaries;
            }
            set showTileBoundaries(t2) {
              this._showTileBoundaries !== t2 && (this._showTileBoundaries = t2, this._update());
            }
            get showTerrainWireframe() {
              return !!this._showTerrainWireframe;
            }
            set showTerrainWireframe(t2) {
              this._showTerrainWireframe !== t2 && (this._showTerrainWireframe = t2, this._update());
            }
            get speedIndexTiming() {
              return !!this._speedIndexTiming;
            }
            set speedIndexTiming(t2) {
              this._speedIndexTiming !== t2 && (this._speedIndexTiming = t2, this._update());
            }
            get showPadding() {
              return !!this._showPadding;
            }
            set showPadding(t2) {
              this._showPadding !== t2 && (this._showPadding = t2, this._update());
            }
            get showCollisionBoxes() {
              return !!this._showCollisionBoxes;
            }
            set showCollisionBoxes(t2) {
              this._showCollisionBoxes !== t2 && (this._showCollisionBoxes = t2, t2 ? this.style._generateCollisionBoxes() : this._update());
            }
            get showOverdrawInspector() {
              return !!this._showOverdrawInspector;
            }
            set showOverdrawInspector(t2) {
              this._showOverdrawInspector !== t2 && (this._showOverdrawInspector = t2, this._update());
            }
            get repaint() {
              return !!this._repaint;
            }
            set repaint(t2) {
              this._repaint !== t2 && (this._repaint = t2, this.triggerRepaint());
            }
            get vertices() {
              return !!this._vertices;
            }
            set vertices(t2) {
              this._vertices = t2, this._update();
            }
            _setCacheLimits(e2, i2) {
              t.setCacheLimits(e2, i2);
            }
            get version() {
              return t.version;
            }
          }, NavigationControl: class {
            constructor(e2) {
              this.options = t.extend({}, kr2, e2), this._container = a.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (t2) => t2.preventDefault()), this.options.showZoom && (t.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (t2) => this._map.zoomIn({}, { originalEvent: t2 })), a.create("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", true), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (t2) => this._map.zoomOut({}, { originalEvent: t2 })), a.create("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", true)), this.options.showCompass && (t.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (t2) => {
                this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t2 }) : this._map.resetNorth({}, { originalEvent: t2 });
              }), this._compassIcon = a.create("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", true));
            }
            _updateZoomButtons() {
              const t2 = this._map.getZoom(), e2 = t2 === this._map.getMaxZoom(), i2 = t2 === this._map.getMinZoom();
              this._zoomInButton.disabled = e2, this._zoomOutButton.disabled = i2, this._zoomInButton.setAttribute("aria-disabled", e2.toString()), this._zoomOutButton.setAttribute("aria-disabled", i2.toString());
            }
            _rotateCompassArrow() {
              const t2 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
              this._map._requestDomTask(() => {
                this._compassIcon && (this._compassIcon.style.transform = t2);
              });
            }
            onAdd(t2) {
              return this._map = t2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Fr2(this._map, this._compass, this.options.visualizePitch)), this._container;
            }
            onRemove() {
              a.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
            }
            _createButton(t2, e2) {
              const i2 = a.create("button", t2, this._container);
              return i2.type = "button", i2.addEventListener("click", e2), i2;
            }
            _setButtonTitle(t2, e2) {
              const i2 = this._map._getUIString(`NavigationControl.${e2}`);
              t2.title = i2, t2.setAttribute("aria-label", i2);
            }
          }, GeolocateControl: class extends t.Evented {
            constructor(e2) {
              super(), this.options = t.extend({}, Br2, e2), t.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation"], this), this._onDeviceOrientationListener = this._onDeviceOrientation.bind(this), this._updateMarkerRotationThrottled = Eo2(this._updateMarkerRotation, 20);
            }
            onAdd(e2) {
              var i2;
              return this._map = e2, this._container = a.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), i2 = this._setupUI, Or2 !== void 0 ? i2(Or2) : t.window.navigator.permissions !== void 0 ? t.window.navigator.permissions.query({ name: "geolocation" }).then((t2) => {
                Or2 = t2.state !== "denied", i2(Or2);
              }) : (Or2 = !!t.window.navigator.geolocation, i2(Or2)), this._container;
            }
            onRemove() {
              this._geolocationWatchID !== void 0 && (t.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), a.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Ur2 = 0, Nr2 = false;
            }
            _isOutOfMapMaxBounds(t2) {
              const e2 = this._map.getMaxBounds(), i2 = t2.coords;
              return e2 && (i2.longitude < e2.getWest() || i2.longitude > e2.getEast() || i2.latitude < e2.getSouth() || i2.latitude > e2.getNorth());
            }
            _setErrorState() {
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                  break;
                case "ACTIVE_LOCK":
                  this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                  break;
                case "BACKGROUND":
                  this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
              }
            }
            _onSuccess(e2) {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e2))
                  return this._setErrorState(), this.fire(new t.Event("outofmaxbounds", e2)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation)
                  switch (this._lastKnownPosition = e2, this._watchState) {
                    case "WAITING_ACTIVE":
                    case "ACTIVE_LOCK":
                    case "ACTIVE_ERROR":
                      this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                      break;
                    case "BACKGROUND":
                    case "BACKGROUND_ERROR":
                      this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                  }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e2), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e2), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new t.Event("geolocate", e2)), this._finish();
              }
            }
            _updateCamera(e2) {
              const i2 = new t.LngLat(e2.coords.longitude, e2.coords.latitude), o2 = e2.coords.accuracy, r3 = this._map.getBearing(), a2 = t.extend({ bearing: r3 }, this.options.fitBoundsOptions);
              this._map.fitBounds(i2.toBounds(o2), a2, { geolocateSource: true });
            }
            _updateMarker(e2) {
              if (e2) {
                const i2 = new t.LngLat(e2.coords.longitude, e2.coords.latitude);
                this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = e2.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              } else
                this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }
            _updateCircleRadius() {
              const t2 = this._map._container.clientHeight / 2, e2 = this._map.unproject([0, t2]), i2 = this._map.unproject([100, t2]), o2 = e2.distanceTo(i2) / 100, r3 = Math.ceil(2 * this._accuracy / o2);
              this._circleElement.style.width = `${r3}px`, this._circleElement.style.height = `${r3}px`;
            }
            _onZoom() {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            }
            _updateMarkerRotation() {
              this._userLocationDotMarker && typeof this._heading == "number" ? (this._userLocationDotMarker.setRotation(this._heading), this._dotElement.classList.add("mapboxgl-user-location-show-heading")) : (this._dotElement.classList.remove("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
            }
            _onError(e2) {
              if (this._map) {
                if (this.options.trackUserLocation)
                  if (e2.code === 1) {
                    this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                    const t2 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                    this._geolocateButton.title = t2, this._geolocateButton.setAttribute("aria-label", t2), this._geolocationWatchID !== void 0 && this._clearWatch();
                  } else {
                    if (e2.code === 3 && Nr2)
                      return;
                    this._setErrorState();
                  }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new t.Event("error", e2)), this._finish();
              }
            }
            _finish() {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }
            _setupUI(e2) {
              if (this._container.addEventListener("contextmenu", (t2) => t2.preventDefault()), this._geolocateButton = a.create("button", "mapboxgl-ctrl-geolocate", this._container), a.create("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", true), this._geolocateButton.type = "button", e2 === false) {
                t.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
                const e3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = true, this._geolocateButton.title = e3, this._geolocateButton.setAttribute("aria-label", e3);
              } else {
                const t2 = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.title = t2, this._geolocateButton.setAttribute("aria-label", t2);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = a.create("div", "mapboxgl-user-location"), this._dotElement.appendChild(a.create("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(a.create("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new Ir2({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = a.create("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Ir2({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (e3) => {
                e3.geolocateSource || this._watchState !== "ACTIVE_LOCK" || e3.originalEvent && e3.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new t.Event("trackuserlocationend")));
              });
            }
            _onDeviceOrientation(t2) {
              this._userLocationDotMarker && (t2.webkitCompassHeading ? this._heading = t2.webkitCompassHeading : t2.absolute === true && (this._heading = -1 * t2.alpha), this._updateMarkerRotationThrottled());
            }
            trigger() {
              if (!this._setup)
                return t.warnOnce("Geolocate control triggered before added to a map"), false;
              if (this.options.trackUserLocation) {
                switch (this._watchState) {
                  case "OFF":
                    this._watchState = "WAITING_ACTIVE", this.fire(new t.Event("trackuserlocationstart"));
                    break;
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                  case "BACKGROUND_ERROR":
                    Ur2--, Nr2 = false, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new t.Event("trackuserlocationend"));
                    break;
                  case "BACKGROUND":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.Event("trackuserlocationstart"));
                }
                switch (this._watchState) {
                  case "WAITING_ACTIVE":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                    break;
                  case "ACTIVE_LOCK":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                    break;
                  case "ACTIVE_ERROR":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                    break;
                  case "BACKGROUND":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                    break;
                  case "BACKGROUND_ERROR":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
                }
                if (this._watchState === "OFF" && this._geolocationWatchID !== void 0)
                  this._clearWatch();
                else if (this._geolocationWatchID === void 0) {
                  let e2;
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Ur2++, Ur2 > 1 ? (e2 = { maximumAge: 6e5, timeout: 0 }, Nr2 = true) : (e2 = this.options.positionOptions, Nr2 = false), this._geolocationWatchID = t.window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e2), this.options.showUserHeading && this._addDeviceOrientationListener();
                }
              } else
                t.window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
              return true;
            }
            _addDeviceOrientationListener() {
              const e2 = () => {
                t.window.addEventListener("ondeviceorientationabsolute" in t.window ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientationListener);
              };
              t.window.DeviceMotionEvent !== void 0 && typeof t.window.DeviceMotionEvent.requestPermission == "function" ? DeviceOrientationEvent.requestPermission().then((t2) => {
                t2 === "granted" && e2();
              }).catch(console.error) : e2();
            }
            _clearWatch() {
              t.window.navigator.geolocation.clearWatch(this._geolocationWatchID), t.window.removeEventListener("deviceorientation", this._onDeviceOrientationListener), t.window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientationListener), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
            }
          }, AttributionControl: br2, ScaleControl: class {
            constructor(e2) {
              this.options = t.extend({}, Gr, e2), t.bindAll(["_onMove", "setUnit"], this);
            }
            getDefaultPosition() {
              return "bottom-left";
            }
            _onMove() {
              Zr2(this._map, this._container, this.options);
            }
            onAdd(t2) {
              return this._map = t2, this._container = a.create("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", t2.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
            }
            onRemove() {
              a.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
            }
            setUnit(t2) {
              this.options.unit = t2, Zr2(this._map, this._container, this.options);
            }
          }, FullscreenControl: class {
            constructor(e2) {
              this._fullscreen = false, e2 && e2.container && (e2.container instanceof t.window.HTMLElement ? this._container = e2.container : t.warnOnce("Full screen control 'container' must be a DOM element.")), t.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in t.window.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in t.window.document && (this._fullscreenchange = "webkitfullscreenchange");
            }
            onAdd(e2) {
              return this._map = e2, this._container || (this._container = this._map.getContainer()), this._controlContainer = a.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", t.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
            }
            onRemove() {
              a.remove(this._controlContainer), this._map = null, t.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
            }
            _checkFullscreenSupport() {
              return !(!t.window.document.fullscreenEnabled && !t.window.document.webkitFullscreenEnabled);
            }
            _setupUI() {
              const e2 = this._fullscreenButton = a.create("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
              a.create("span", "mapboxgl-ctrl-icon", e2).setAttribute("aria-hidden", true), e2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), t.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
            }
            _updateTitle() {
              const t2 = this._getTitle();
              this._fullscreenButton.setAttribute("aria-label", t2), this._fullscreenButton.title = t2;
            }
            _getTitle() {
              return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
            }
            _isFullscreen() {
              return this._fullscreen;
            }
            _changeIcon() {
              (t.window.document.fullscreenElement || t.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
            }
            _onClickFullscreen() {
              this._isFullscreen() ? t.window.document.exitFullscreen ? t.window.document.exitFullscreen() : t.window.document.webkitCancelFullScreen && t.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
            }
          }, Popup: class extends t.Evented {
            constructor(e2) {
              super(), this.options = t.extend(Object.create(jr2), e2), t.bindAll(["_update", "_onClose", "remove", "_onMouseMove", "_onMouseUp", "_onDrag"], this);
            }
            addTo(e2) {
              return this._map && this.remove(), this._map = e2, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.Event("open")), this;
            }
            isOpen() {
              return !!this._map;
            }
            remove() {
              return this._content && a.remove(this._content), this._container && (a.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new t.Event("close")), this;
            }
            getLngLat() {
              return this._lngLat;
            }
            setLngLat(e2) {
              return this._lngLat = t.LngLat.convert(e2), this._pos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
            }
            trackPointer() {
              return this._trackPointer = true, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
            }
            getElement() {
              return this._container;
            }
            setText(e2) {
              return this.setDOMContent(t.window.document.createTextNode(e2));
            }
            setHTML(e2) {
              const i2 = t.window.document.createDocumentFragment(), o2 = t.window.document.createElement("body");
              let r3;
              for (o2.innerHTML = e2; r3 = o2.firstChild, r3; )
                i2.appendChild(r3);
              return this.setDOMContent(i2);
            }
            getMaxWidth() {
              return this._container && this._container.style.maxWidth;
            }
            setMaxWidth(t2) {
              return this.options.maxWidth = t2, this._update(), this;
            }
            setDOMContent(t2) {
              if (this._content)
                for (; this._content.hasChildNodes(); )
                  this._content.firstChild && this._content.removeChild(this._content.firstChild);
              else
                this._content = a.create("div", "mapboxgl-popup-content", this._container);
              return this._content.appendChild(t2), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
            }
            addClassName(t2) {
              this._container && this._container.classList.add(t2);
            }
            removeClassName(t2) {
              this._container && this._container.classList.remove(t2);
            }
            setOffset(t2) {
              return this.options.offset = t2, this._update(), this;
            }
            toggleClassName(t2) {
              if (this._container)
                return this._container.classList.toggle(t2);
            }
            _createCloseButton() {
              this.options.closeButton && (this._closeButton = a.create("button", "mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
            }
            _onMouseUp(t2) {
              this._update(t2.point);
            }
            _onMouseMove(t2) {
              this._update(t2.point);
            }
            _onDrag(t2) {
              this._update(t2.point);
            }
            _update(t2) {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content)
                return;
              if (this._container || (this._container = a.create("div", "mapboxgl-popup", this._map.getContainer()), this._tip = a.create("div", "mapboxgl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className && this.options.className.split(" ").forEach((t3) => this._container.classList.add(t3)), this._trackPointer && this._container.classList.add("mapboxgl-popup-track-pointer")), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Er2(this._lngLat, this._pos, this._map.transform)), this._trackPointer && !t2)
                return;
              const e2 = this._pos = this._trackPointer && t2 ? t2 : this._map.project(this._lngLat);
              let i2 = this.options.anchor;
              const o2 = Wr2(this.options.offset);
              if (!i2) {
                const t3 = this._container.offsetWidth, r4 = this._container.offsetHeight;
                let a2;
                a2 = e2.y + o2.bottom.y < r4 ? ["top"] : e2.y > this._map.transform.height - r4 ? ["bottom"] : [], e2.x < t3 / 2 ? a2.push("left") : e2.x > this._map.transform.width - t3 / 2 && a2.push("right"), i2 = a2.length === 0 ? "bottom" : a2.join("-");
              }
              const r3 = e2.add(o2[i2]).round();
              this._map._requestDomTask(() => {
                this._container && i2 && (a.setTransform(this._container, `${Cr2[i2]} translate(${r3.x}px,${r3.y}px)`), Sr2(this._container, i2, "popup"));
              });
            }
            _focusFirstElement() {
              if (!this.options.focusAfterOpen || !this._container)
                return;
              const t2 = this._container.querySelector(qr2);
              t2 && t2.focus();
            }
            _onClose() {
              this.remove();
            }
            _setOpacity(t2) {
              this._content && (this._content.style.opacity = t2), this._tip && (this._tip.style.opacity = t2);
            }
          }, Marker: Ir2, Style: Ze2, LngLat: t.LngLat, LngLatBounds: t.LngLatBounds, Point: t.pointGeometry, MercatorCoordinate: t.MercatorCoordinate, FreeCameraOptions: bo2, Evented: t.Evented, config: t.config, prewarm: function() {
            kt2().acquire(Pt2);
          }, clearPrewarmedResources: function() {
            const t2 = Rt;
            t2 && (t2.isPreloaded() && t2.numActive() === 1 ? (t2.release(Pt2), Rt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
          }, get accessToken() {
            return t.config.ACCESS_TOKEN;
          }, set accessToken(e2) {
            t.config.ACCESS_TOKEN = e2;
          }, get baseApiUrl() {
            return t.config.API_URL;
          }, set baseApiUrl(e2) {
            t.config.API_URL = e2;
          }, get workerCount() {
            return Lt.workerCount;
          }, set workerCount(t2) {
            Lt.workerCount = t2;
          }, get maxParallelImageRequests() {
            return t.config.MAX_PARALLEL_IMAGE_REQUESTS;
          }, set maxParallelImageRequests(e2) {
            t.config.MAX_PARALLEL_IMAGE_REQUESTS = e2;
          }, clearStorage(e2) {
            t.clearTileCache(e2);
          }, workerUrl: "", workerClass: null, setNow: t.exported.setNow, restoreNow: t.exported.restoreNow };
          return $r2;
        });
        var mapboxgl$1 = mapboxgl2;
        return mapboxgl$1;
      });
    }
  });

  // node_modules/@metoceanapi/wxtiles-gl/dist/es/bundle.js
  var J_ = Object.create;
  var Hs = Object.defineProperty;
  var $_ = Object.defineProperties;
  var ex = Object.getOwnPropertyDescriptor;
  var tx = Object.getOwnPropertyDescriptors;
  var rx = Object.getOwnPropertyNames;
  var Vu = Object.getOwnPropertySymbols;
  var nx = Object.getPrototypeOf;
  var Gu = Object.prototype.hasOwnProperty;
  var ix = Object.prototype.propertyIsEnumerable;
  var zu = (r2, e, t) => e in r2 ? Hs(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
  var x = (r2, e) => {
    for (var t in e || (e = {}))
      Gu.call(e, t) && zu(r2, t, e[t]);
    if (Vu)
      for (var t of Vu(e))
        ix.call(e, t) && zu(r2, t, e[t]);
    return r2;
  };
  var L = (r2, e) => $_(r2, tx(e));
  var sx = (r2) => Hs(r2, "__esModule", { value: true });
  var pt = (r2, e) => () => (e || r2((e = { exports: {} }).exports, e), e.exports);
  var ox = (r2, e, t) => {
    if (e && typeof e == "object" || typeof e == "function")
      for (let n of rx(e))
        !Gu.call(r2, n) && n !== "default" && Hs(r2, n, { get: () => e[n], enumerable: !(t = ex(e, n)) || t.enumerable });
    return r2;
  };
  var Mt = (r2) => ox(sx(Hs(r2 != null ? J_(nx(r2)) : {}, "default", r2 && r2.__esModule && "default" in r2 ? { get: () => r2.default, enumerable: true } : { value: r2, enumerable: true })), r2);
  var gn = pt((hM, Ri) => {
    function wy(r2) {
      return r2 && r2.__esModule ? r2 : { default: r2 };
    }
    Ri.exports = wy;
    Ri.exports.default = Ri.exports, Ri.exports.__esModule = true;
  });
  var Mi = pt((dM, We) => {
    function co(r2) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? (We.exports = co = function(t) {
        return typeof t;
      }, We.exports.default = We.exports, We.exports.__esModule = true) : (We.exports = co = function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
      }, We.exports.default = We.exports, We.exports.__esModule = true), co(r2);
    }
    We.exports = co;
    We.exports.default = We.exports, We.exports.__esModule = true;
  });
  var _l = pt((ke) => {
    "use strict";
    var Py = gn();
    Object.defineProperty(ke, "__esModule", { value: true });
    ke.console = ke.process = ke.document = ke.global = ke.window = ke.self = void 0;
    var Ly = Py(Mi()), _t = { self: typeof self != "undefined" && self, window: typeof window != "undefined" && window, global: typeof global != "undefined" && global, document: typeof document != "undefined" && document, process: (typeof process == "undefined" ? "undefined" : (0, Ly.default)(process)) === "object" && process }, Cy = _t.self || _t.window || _t.global;
    ke.self = Cy;
    var Ry = _t.window || _t.self || _t.global;
    ke.window = Ry;
    var My = _t.global || _t.self || _t.window;
    ke.global = My;
    var Iy = _t.document || {};
    ke.document = Iy;
    var Oy = _t.process || {};
    ke.process = Oy;
    var Ny = console;
    ke.console = Ny;
  });
  var lo = pt((yl) => {
    "use strict";
    var Fy = gn();
    Object.defineProperty(yl, "__esModule", { value: true });
    yl.default = Dy;
    var xl = Fy(Mi());
    function Dy(r2) {
      if (typeof window != "undefined" && (0, xl.default)(window.process) === "object" && window.process.type === "renderer" || typeof process != "undefined" && (0, xl.default)(process.versions) === "object" && Boolean(process.versions.electron))
        return true;
      var e = (typeof navigator == "undefined" ? "undefined" : (0, xl.default)(navigator)) === "object" && typeof navigator.userAgent == "string" && navigator.userAgent, t = r2 || e;
      return !!(t && t.indexOf("Electron") >= 0);
    }
  });
  var El = pt((fo) => {
    "use strict";
    var Gh = gn();
    Object.defineProperty(fo, "__esModule", { value: true });
    fo.default = zh;
    fo.isBrowserMainThread = ky;
    var By = Gh(Mi()), Uy = Gh(lo());
    function zh() {
      var r2 = (typeof process == "undefined" ? "undefined" : (0, By.default)(process)) === "object" && String(process) === "[object process]" && !process.browser;
      return !r2 || (0, Uy.default)();
    }
    function ky() {
      return zh() && typeof document != "undefined";
    }
  });
  var Wh = pt((ho) => {
    "use strict";
    var jh = gn();
    Object.defineProperty(ho, "__esModule", { value: true });
    ho.isMobile = zy;
    ho.default = jy;
    var uo = _l(), Vy = jh(El()), Gy = jh(lo());
    function zy() {
      return typeof uo.window.orientation != "undefined";
    }
    function jy(r2) {
      if (!r2 && !(0, Vy.default)())
        return "Node";
      if ((0, Gy.default)(r2))
        return "Electron";
      var e = typeof navigator != "undefined" ? navigator : {}, t = r2 || e.userAgent || "";
      if (t.indexOf("Edge") > -1)
        return "Edge";
      var n = t.indexOf("MSIE ") !== -1, i = t.indexOf("Trident/") !== -1;
      return n || i ? "IE" : uo.window.chrome ? "Chrome" : uo.window.safari ? "Safari" : uo.window.mozInnerScreenX ? "Firefox" : "Unknown";
    }
  });
  var Zh = pt((He) => {
    "use strict";
    var Wy = gn(), Hy = Mi();
    Object.defineProperty(He, "__esModule", { value: true });
    Object.defineProperty(He, "self", { enumerable: true, get: function() {
      return _n.self;
    } });
    Object.defineProperty(He, "window", { enumerable: true, get: function() {
      return _n.window;
    } });
    Object.defineProperty(He, "global", { enumerable: true, get: function() {
      return _n.global;
    } });
    Object.defineProperty(He, "document", { enumerable: true, get: function() {
      return _n.document;
    } });
    Object.defineProperty(He, "process", { enumerable: true, get: function() {
      return _n.process;
    } });
    Object.defineProperty(He, "console", { enumerable: true, get: function() {
      return _n.console;
    } });
    Object.defineProperty(He, "isBrowser", { enumerable: true, get: function() {
      return Hh.default;
    } });
    Object.defineProperty(He, "isBrowserMainThread", { enumerable: true, get: function() {
      return Hh.isBrowserMainThread;
    } });
    Object.defineProperty(He, "getBrowser", { enumerable: true, get: function() {
      return Xh.default;
    } });
    Object.defineProperty(He, "isMobile", { enumerable: true, get: function() {
      return Xh.isMobile;
    } });
    Object.defineProperty(He, "isElectron", { enumerable: true, get: function() {
      return Xy.default;
    } });
    var _n = _l(), Hh = qh(El()), Xh = qh(Wh()), Xy = Wy(lo());
    function Yh(r2) {
      if (typeof WeakMap != "function")
        return null;
      var e = new WeakMap(), t = new WeakMap();
      return (Yh = function(i) {
        return i ? t : e;
      })(r2);
    }
    function qh(r2, e) {
      if (!e && r2 && r2.__esModule)
        return r2;
      if (r2 === null || Hy(r2) !== "object" && typeof r2 != "function")
        return { default: r2 };
      var t = Yh(e);
      if (t && t.has(r2))
        return t.get(r2);
      var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var s in r2)
        if (s !== "default" && Object.prototype.hasOwnProperty.call(r2, s)) {
          var o = i ? Object.getOwnPropertyDescriptor(r2, s) : null;
          o && (o.get || o.set) ? Object.defineProperty(n, s, o) : n[s] = r2[s];
        }
      return n.default = r2, t && t.set(r2, n), n;
    }
  });
  var dr = pt((yM, Kh) => {
    Kh.exports = Zh();
  });
  var Mm = pt((d5, va) => {
    (function(r2, e, t, n) {
      "use strict";
      var i = ["", "webkit", "Moz", "MS", "ms", "o"], s = e.createElement("div"), o = "function", a = Math.round, c = Math.abs, l = Date.now;
      function f(p, g, y) {
        return setTimeout(T(p, y), g);
      }
      function u(p, g, y) {
        return Array.isArray(p) ? (h(p, y[g], y), true) : false;
      }
      function h(p, g, y) {
        var A;
        if (!!p)
          if (p.forEach)
            p.forEach(g, y);
          else if (p.length !== n)
            for (A = 0; A < p.length; )
              g.call(y, p[A], A, p), A++;
          else
            for (A in p)
              p.hasOwnProperty(A) && g.call(y, p[A], A, p);
      }
      function d(p, g, y) {
        var A = "DEPRECATED METHOD: " + g + `
` + y + ` AT 
`;
        return function() {
          var P = new Error("get-stack-trace"), O = P && P.stack ? P.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace", X = r2.console && (r2.console.warn || r2.console.log);
          return X && X.call(r2.console, A, O), p.apply(this, arguments);
        };
      }
      var m;
      typeof Object.assign != "function" ? m = function(g) {
        if (g === n || g === null)
          throw new TypeError("Cannot convert undefined or null to object");
        for (var y = Object(g), A = 1; A < arguments.length; A++) {
          var P = arguments[A];
          if (P !== n && P !== null)
            for (var O in P)
              P.hasOwnProperty(O) && (y[O] = P[O]);
        }
        return y;
      } : m = Object.assign;
      var _ = d(function(g, y, A) {
        for (var P = Object.keys(y), O = 0; O < P.length; )
          (!A || A && g[P[O]] === n) && (g[P[O]] = y[P[O]]), O++;
        return g;
      }, "extend", "Use `assign`."), E = d(function(g, y) {
        return _(g, y, true);
      }, "merge", "Use `assign`.");
      function b(p, g, y) {
        var A = g.prototype, P;
        P = p.prototype = Object.create(A), P.constructor = p, P._super = A, y && m(P, y);
      }
      function T(p, g) {
        return function() {
          return p.apply(g, arguments);
        };
      }
      function v(p, g) {
        return typeof p == o ? p.apply(g && g[0] || n, g) : p;
      }
      function C(p, g) {
        return p === n ? g : p;
      }
      function S(p, g, y) {
        h(N(g), function(A) {
          p.addEventListener(A, y, false);
        });
      }
      function R(p, g, y) {
        h(N(g), function(A) {
          p.removeEventListener(A, y, false);
        });
      }
      function D(p, g) {
        for (; p; ) {
          if (p == g)
            return true;
          p = p.parentNode;
        }
        return false;
      }
      function B(p, g) {
        return p.indexOf(g) > -1;
      }
      function N(p) {
        return p.trim().split(/\s+/g);
      }
      function W(p, g, y) {
        if (p.indexOf && !y)
          return p.indexOf(g);
        for (var A = 0; A < p.length; ) {
          if (y && p[A][y] == g || !y && p[A] === g)
            return A;
          A++;
        }
        return -1;
      }
      function q(p) {
        return Array.prototype.slice.call(p, 0);
      }
      function z(p, g, y) {
        for (var A = [], P = [], O = 0; O < p.length; ) {
          var X = g ? p[O][g] : p[O];
          W(P, X) < 0 && A.push(p[O]), P[O] = X, O++;
        }
        return y && (g ? A = A.sort(function(Te, Fe) {
          return Te[g] > Fe[g];
        }) : A = A.sort()), A;
      }
      function V(p, g) {
        for (var y, A, P = g[0].toUpperCase() + g.slice(1), O = 0; O < i.length; ) {
          if (y = i[O], A = y ? y + P : g, A in p)
            return A;
          O++;
        }
        return n;
      }
      var Y = 1;
      function Se() {
        return Y++;
      }
      function jt(p) {
        var g = p.ownerDocument || p;
        return g.defaultView || g.parentWindow || r2;
      }
      var cr = /mobile|tablet|ip(ad|hone|od)|android/i, Wt = "ontouchstart" in r2, Ac = V(r2, "PointerEvent") !== n, Sc = Wt && cr.test(navigator.userAgent), fi = "touch", T_ = "pen", wc = "mouse", v_ = "kinect", A_ = 25, Ne = 1, Vr = 2, pe = 4, Ue = 8, Fs = 1, ui = 2, hi = 4, di = 8, pi = 16, Lt = ui | hi, Gr = di | pi, bu = Lt | Gr, Tu = ["x", "y"], Ds = ["clientX", "clientY"];
      function tt(p, g) {
        var y = this;
        this.manager = p, this.callback = g, this.element = p.element, this.target = p.options.inputTarget, this.domHandler = function(A) {
          v(p.options.enable, [p]) && y.handler(A);
        }, this.init();
      }
      tt.prototype = { handler: function() {
      }, init: function() {
        this.evEl && S(this.element, this.evEl, this.domHandler), this.evTarget && S(this.target, this.evTarget, this.domHandler), this.evWin && S(jt(this.element), this.evWin, this.domHandler);
      }, destroy: function() {
        this.evEl && R(this.element, this.evEl, this.domHandler), this.evTarget && R(this.target, this.evTarget, this.domHandler), this.evWin && R(jt(this.element), this.evWin, this.domHandler);
      } };
      function S_(p) {
        var g, y = p.options.inputClass;
        return y ? g = y : Ac ? g = Lc : Sc ? g = ks : Wt ? g = Cc : g = Us, new g(p, w_);
      }
      function w_(p, g, y) {
        var A = y.pointers.length, P = y.changedPointers.length, O = g & Ne && A - P == 0, X = g & (pe | Ue) && A - P == 0;
        y.isFirst = !!O, y.isFinal = !!X, O && (p.session = {}), y.eventType = g, P_(p, y), p.emit("hammer.input", y), p.recognize(y), p.session.prevInput = y;
      }
      function P_(p, g) {
        var y = p.session, A = g.pointers, P = A.length;
        y.firstInput || (y.firstInput = vu(g)), P > 1 && !y.firstMultiple ? y.firstMultiple = vu(g) : P === 1 && (y.firstMultiple = false);
        var O = y.firstInput, X = y.firstMultiple, Ee = X ? X.center : O.center, Te = g.center = Au(A);
        g.timeStamp = l(), g.deltaTime = g.timeStamp - O.timeStamp, g.angle = Pc(Ee, Te), g.distance = Bs(Ee, Te), L_(y, g), g.offsetDirection = wu(g.deltaX, g.deltaY);
        var Fe = Su(g.deltaTime, g.deltaX, g.deltaY);
        g.overallVelocityX = Fe.x, g.overallVelocityY = Fe.y, g.overallVelocity = c(Fe.x) > c(Fe.y) ? Fe.x : Fe.y, g.scale = X ? M_(X.pointers, A) : 1, g.rotation = X ? R_(X.pointers, A) : 0, g.maxPointers = y.prevInput ? g.pointers.length > y.prevInput.maxPointers ? g.pointers.length : y.prevInput.maxPointers : g.pointers.length, C_(y, g);
        var Rt = p.element;
        D(g.srcEvent.target, Rt) && (Rt = g.srcEvent.target), g.target = Rt;
      }
      function L_(p, g) {
        var y = g.center, A = p.offsetDelta || {}, P = p.prevDelta || {}, O = p.prevInput || {};
        (g.eventType === Ne || O.eventType === pe) && (P = p.prevDelta = { x: O.deltaX || 0, y: O.deltaY || 0 }, A = p.offsetDelta = { x: y.x, y: y.y }), g.deltaX = P.x + (y.x - A.x), g.deltaY = P.y + (y.y - A.y);
      }
      function C_(p, g) {
        var y = p.lastInterval || g, A = g.timeStamp - y.timeStamp, P, O, X, Ee;
        if (g.eventType != Ue && (A > A_ || y.velocity === n)) {
          var Te = g.deltaX - y.deltaX, Fe = g.deltaY - y.deltaY, Rt = Su(A, Te, Fe);
          O = Rt.x, X = Rt.y, P = c(Rt.x) > c(Rt.y) ? Rt.x : Rt.y, Ee = wu(Te, Fe), p.lastInterval = g;
        } else
          P = y.velocity, O = y.velocityX, X = y.velocityY, Ee = y.direction;
        g.velocity = P, g.velocityX = O, g.velocityY = X, g.direction = Ee;
      }
      function vu(p) {
        for (var g = [], y = 0; y < p.pointers.length; )
          g[y] = { clientX: a(p.pointers[y].clientX), clientY: a(p.pointers[y].clientY) }, y++;
        return { timeStamp: l(), pointers: g, center: Au(g), deltaX: p.deltaX, deltaY: p.deltaY };
      }
      function Au(p) {
        var g = p.length;
        if (g === 1)
          return { x: a(p[0].clientX), y: a(p[0].clientY) };
        for (var y = 0, A = 0, P = 0; P < g; )
          y += p[P].clientX, A += p[P].clientY, P++;
        return { x: a(y / g), y: a(A / g) };
      }
      function Su(p, g, y) {
        return { x: g / p || 0, y: y / p || 0 };
      }
      function wu(p, g) {
        return p === g ? Fs : c(p) >= c(g) ? p < 0 ? ui : hi : g < 0 ? di : pi;
      }
      function Bs(p, g, y) {
        y || (y = Tu);
        var A = g[y[0]] - p[y[0]], P = g[y[1]] - p[y[1]];
        return Math.sqrt(A * A + P * P);
      }
      function Pc(p, g, y) {
        y || (y = Tu);
        var A = g[y[0]] - p[y[0]], P = g[y[1]] - p[y[1]];
        return Math.atan2(P, A) * 180 / Math.PI;
      }
      function R_(p, g) {
        return Pc(g[1], g[0], Ds) + Pc(p[1], p[0], Ds);
      }
      function M_(p, g) {
        return Bs(g[0], g[1], Ds) / Bs(p[0], p[1], Ds);
      }
      var I_ = { mousedown: Ne, mousemove: Vr, mouseup: pe }, O_ = "mousedown", N_ = "mousemove mouseup";
      function Us() {
        this.evEl = O_, this.evWin = N_, this.pressed = false, tt.apply(this, arguments);
      }
      b(Us, tt, { handler: function(g) {
        var y = I_[g.type];
        y & Ne && g.button === 0 && (this.pressed = true), y & Vr && g.which !== 1 && (y = pe), !!this.pressed && (y & pe && (this.pressed = false), this.callback(this.manager, y, { pointers: [g], changedPointers: [g], pointerType: wc, srcEvent: g }));
      } });
      var F_ = { pointerdown: Ne, pointermove: Vr, pointerup: pe, pointercancel: Ue, pointerout: Ue }, D_ = { 2: fi, 3: T_, 4: wc, 5: v_ }, Pu = "pointerdown", Lu = "pointermove pointerup pointercancel";
      r2.MSPointerEvent && !r2.PointerEvent && (Pu = "MSPointerDown", Lu = "MSPointerMove MSPointerUp MSPointerCancel");
      function Lc() {
        this.evEl = Pu, this.evWin = Lu, tt.apply(this, arguments), this.store = this.manager.session.pointerEvents = [];
      }
      b(Lc, tt, { handler: function(g) {
        var y = this.store, A = false, P = g.type.toLowerCase().replace("ms", ""), O = F_[P], X = D_[g.pointerType] || g.pointerType, Ee = X == fi, Te = W(y, g.pointerId, "pointerId");
        O & Ne && (g.button === 0 || Ee) ? Te < 0 && (y.push(g), Te = y.length - 1) : O & (pe | Ue) && (A = true), !(Te < 0) && (y[Te] = g, this.callback(this.manager, O, { pointers: y, changedPointers: [g], pointerType: X, srcEvent: g }), A && y.splice(Te, 1));
      } });
      var B_ = { touchstart: Ne, touchmove: Vr, touchend: pe, touchcancel: Ue }, U_ = "touchstart", k_ = "touchstart touchmove touchend touchcancel";
      function Cu() {
        this.evTarget = U_, this.evWin = k_, this.started = false, tt.apply(this, arguments);
      }
      b(Cu, tt, { handler: function(g) {
        var y = B_[g.type];
        if (y === Ne && (this.started = true), !!this.started) {
          var A = V_.call(this, g, y);
          y & (pe | Ue) && A[0].length - A[1].length == 0 && (this.started = false), this.callback(this.manager, y, { pointers: A[0], changedPointers: A[1], pointerType: fi, srcEvent: g });
        }
      } });
      function V_(p, g) {
        var y = q(p.touches), A = q(p.changedTouches);
        return g & (pe | Ue) && (y = z(y.concat(A), "identifier", true)), [y, A];
      }
      var G_ = { touchstart: Ne, touchmove: Vr, touchend: pe, touchcancel: Ue }, z_ = "touchstart touchmove touchend touchcancel";
      function ks() {
        this.evTarget = z_, this.targetIds = {}, tt.apply(this, arguments);
      }
      b(ks, tt, { handler: function(g) {
        var y = G_[g.type], A = j_.call(this, g, y);
        !A || this.callback(this.manager, y, { pointers: A[0], changedPointers: A[1], pointerType: fi, srcEvent: g });
      } });
      function j_(p, g) {
        var y = q(p.touches), A = this.targetIds;
        if (g & (Ne | Vr) && y.length === 1)
          return A[y[0].identifier] = true, [y, y];
        var P, O, X = q(p.changedTouches), Ee = [], Te = this.target;
        if (O = y.filter(function(Fe) {
          return D(Fe.target, Te);
        }), g === Ne)
          for (P = 0; P < O.length; )
            A[O[P].identifier] = true, P++;
        for (P = 0; P < X.length; )
          A[X[P].identifier] && Ee.push(X[P]), g & (pe | Ue) && delete A[X[P].identifier], P++;
        if (!!Ee.length)
          return [z(O.concat(Ee), "identifier", true), Ee];
      }
      var W_ = 2500, Ru = 25;
      function Cc() {
        tt.apply(this, arguments);
        var p = T(this.handler, this);
        this.touch = new ks(this.manager, p), this.mouse = new Us(this.manager, p), this.primaryTouch = null, this.lastTouches = [];
      }
      b(Cc, tt, { handler: function(g, y, A) {
        var P = A.pointerType == fi, O = A.pointerType == wc;
        if (!(O && A.sourceCapabilities && A.sourceCapabilities.firesTouchEvents)) {
          if (P)
            H_.call(this, y, A);
          else if (O && X_.call(this, A))
            return;
          this.callback(g, y, A);
        }
      }, destroy: function() {
        this.touch.destroy(), this.mouse.destroy();
      } });
      function H_(p, g) {
        p & Ne ? (this.primaryTouch = g.changedPointers[0].identifier, Mu.call(this, g)) : p & (pe | Ue) && Mu.call(this, g);
      }
      function Mu(p) {
        var g = p.changedPointers[0];
        if (g.identifier === this.primaryTouch) {
          var y = { x: g.clientX, y: g.clientY };
          this.lastTouches.push(y);
          var A = this.lastTouches, P = function() {
            var O = A.indexOf(y);
            O > -1 && A.splice(O, 1);
          };
          setTimeout(P, W_);
        }
      }
      function X_(p) {
        for (var g = p.srcEvent.clientX, y = p.srcEvent.clientY, A = 0; A < this.lastTouches.length; A++) {
          var P = this.lastTouches[A], O = Math.abs(g - P.x), X = Math.abs(y - P.y);
          if (O <= Ru && X <= Ru)
            return true;
        }
        return false;
      }
      var Iu = V(s.style, "touchAction"), Ou = Iu !== n, Nu = "compute", Fu = "auto", Rc = "manipulation", zr = "none", mi = "pan-x", gi = "pan-y", Vs = q_();
      function Mc(p, g) {
        this.manager = p, this.set(g);
      }
      Mc.prototype = { set: function(p) {
        p == Nu && (p = this.compute()), Ou && this.manager.element.style && Vs[p] && (this.manager.element.style[Iu] = p), this.actions = p.toLowerCase().trim();
      }, update: function() {
        this.set(this.manager.options.touchAction);
      }, compute: function() {
        var p = [];
        return h(this.manager.recognizers, function(g) {
          v(g.options.enable, [g]) && (p = p.concat(g.getTouchAction()));
        }), Y_(p.join(" "));
      }, preventDefaults: function(p) {
        var g = p.srcEvent, y = p.offsetDirection;
        if (this.manager.session.prevented) {
          g.preventDefault();
          return;
        }
        var A = this.actions, P = B(A, zr) && !Vs[zr], O = B(A, gi) && !Vs[gi], X = B(A, mi) && !Vs[mi];
        if (P) {
          var Ee = p.pointers.length === 1, Te = p.distance < 2, Fe = p.deltaTime < 250;
          if (Ee && Te && Fe)
            return;
        }
        if (!(X && O) && (P || O && y & Lt || X && y & Gr))
          return this.preventSrc(g);
      }, preventSrc: function(p) {
        this.manager.session.prevented = true, p.preventDefault();
      } };
      function Y_(p) {
        if (B(p, zr))
          return zr;
        var g = B(p, mi), y = B(p, gi);
        return g && y ? zr : g || y ? g ? mi : gi : B(p, Rc) ? Rc : Fu;
      }
      function q_() {
        if (!Ou)
          return false;
        var p = {}, g = r2.CSS && r2.CSS.supports;
        return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(y) {
          p[y] = g ? r2.CSS.supports("touch-action", y) : true;
        }), p;
      }
      var Gs = 1, rt = 2, un = 4, lr = 8, Ht = lr, _i = 16, Ct = 32;
      function Xt(p) {
        this.options = m({}, this.defaults, p || {}), this.id = Se(), this.manager = null, this.options.enable = C(this.options.enable, true), this.state = Gs, this.simultaneous = {}, this.requireFail = [];
      }
      Xt.prototype = { defaults: {}, set: function(p) {
        return m(this.options, p), this.manager && this.manager.touchAction.update(), this;
      }, recognizeWith: function(p) {
        if (u(p, "recognizeWith", this))
          return this;
        var g = this.simultaneous;
        return p = zs(p, this), g[p.id] || (g[p.id] = p, p.recognizeWith(this)), this;
      }, dropRecognizeWith: function(p) {
        return u(p, "dropRecognizeWith", this) ? this : (p = zs(p, this), delete this.simultaneous[p.id], this);
      }, requireFailure: function(p) {
        if (u(p, "requireFailure", this))
          return this;
        var g = this.requireFail;
        return p = zs(p, this), W(g, p) === -1 && (g.push(p), p.requireFailure(this)), this;
      }, dropRequireFailure: function(p) {
        if (u(p, "dropRequireFailure", this))
          return this;
        p = zs(p, this);
        var g = W(this.requireFail, p);
        return g > -1 && this.requireFail.splice(g, 1), this;
      }, hasRequireFailures: function() {
        return this.requireFail.length > 0;
      }, canRecognizeWith: function(p) {
        return !!this.simultaneous[p.id];
      }, emit: function(p) {
        var g = this, y = this.state;
        function A(P) {
          g.manager.emit(P, p);
        }
        y < lr && A(g.options.event + Du(y)), A(g.options.event), p.additionalEvent && A(p.additionalEvent), y >= lr && A(g.options.event + Du(y));
      }, tryEmit: function(p) {
        if (this.canEmit())
          return this.emit(p);
        this.state = Ct;
      }, canEmit: function() {
        for (var p = 0; p < this.requireFail.length; ) {
          if (!(this.requireFail[p].state & (Ct | Gs)))
            return false;
          p++;
        }
        return true;
      }, recognize: function(p) {
        var g = m({}, p);
        if (!v(this.options.enable, [this, g])) {
          this.reset(), this.state = Ct;
          return;
        }
        this.state & (Ht | _i | Ct) && (this.state = Gs), this.state = this.process(g), this.state & (rt | un | lr | _i) && this.tryEmit(g);
      }, process: function(p) {
      }, getTouchAction: function() {
      }, reset: function() {
      } };
      function Du(p) {
        return p & _i ? "cancel" : p & lr ? "end" : p & un ? "move" : p & rt ? "start" : "";
      }
      function Bu(p) {
        return p == pi ? "down" : p == di ? "up" : p == ui ? "left" : p == hi ? "right" : "";
      }
      function zs(p, g) {
        var y = g.manager;
        return y ? y.get(p) : p;
      }
      function dt() {
        Xt.apply(this, arguments);
      }
      b(dt, Xt, { defaults: { pointers: 1 }, attrTest: function(p) {
        var g = this.options.pointers;
        return g === 0 || p.pointers.length === g;
      }, process: function(p) {
        var g = this.state, y = p.eventType, A = g & (rt | un), P = this.attrTest(p);
        return A && (y & Ue || !P) ? g | _i : A || P ? y & pe ? g | lr : g & rt ? g | un : rt : Ct;
      } });
      function js() {
        dt.apply(this, arguments), this.pX = null, this.pY = null;
      }
      b(js, dt, { defaults: { event: "pan", threshold: 10, pointers: 1, direction: bu }, getTouchAction: function() {
        var p = this.options.direction, g = [];
        return p & Lt && g.push(gi), p & Gr && g.push(mi), g;
      }, directionTest: function(p) {
        var g = this.options, y = true, A = p.distance, P = p.direction, O = p.deltaX, X = p.deltaY;
        return P & g.direction || (g.direction & Lt ? (P = O === 0 ? Fs : O < 0 ? ui : hi, y = O != this.pX, A = Math.abs(p.deltaX)) : (P = X === 0 ? Fs : X < 0 ? di : pi, y = X != this.pY, A = Math.abs(p.deltaY))), p.direction = P, y && A > g.threshold && P & g.direction;
      }, attrTest: function(p) {
        return dt.prototype.attrTest.call(this, p) && (this.state & rt || !(this.state & rt) && this.directionTest(p));
      }, emit: function(p) {
        this.pX = p.deltaX, this.pY = p.deltaY;
        var g = Bu(p.direction);
        g && (p.additionalEvent = this.options.event + g), this._super.emit.call(this, p);
      } });
      function Ic() {
        dt.apply(this, arguments);
      }
      b(Ic, dt, { defaults: { event: "pinch", threshold: 0, pointers: 2 }, getTouchAction: function() {
        return [zr];
      }, attrTest: function(p) {
        return this._super.attrTest.call(this, p) && (Math.abs(p.scale - 1) > this.options.threshold || this.state & rt);
      }, emit: function(p) {
        if (p.scale !== 1) {
          var g = p.scale < 1 ? "in" : "out";
          p.additionalEvent = this.options.event + g;
        }
        this._super.emit.call(this, p);
      } });
      function Oc() {
        Xt.apply(this, arguments), this._timer = null, this._input = null;
      }
      b(Oc, Xt, { defaults: { event: "press", pointers: 1, time: 251, threshold: 9 }, getTouchAction: function() {
        return [Fu];
      }, process: function(p) {
        var g = this.options, y = p.pointers.length === g.pointers, A = p.distance < g.threshold, P = p.deltaTime > g.time;
        if (this._input = p, !A || !y || p.eventType & (pe | Ue) && !P)
          this.reset();
        else if (p.eventType & Ne)
          this.reset(), this._timer = f(function() {
            this.state = Ht, this.tryEmit();
          }, g.time, this);
        else if (p.eventType & pe)
          return Ht;
        return Ct;
      }, reset: function() {
        clearTimeout(this._timer);
      }, emit: function(p) {
        this.state === Ht && (p && p.eventType & pe ? this.manager.emit(this.options.event + "up", p) : (this._input.timeStamp = l(), this.manager.emit(this.options.event, this._input)));
      } });
      function Nc() {
        dt.apply(this, arguments);
      }
      b(Nc, dt, { defaults: { event: "rotate", threshold: 0, pointers: 2 }, getTouchAction: function() {
        return [zr];
      }, attrTest: function(p) {
        return this._super.attrTest.call(this, p) && (Math.abs(p.rotation) > this.options.threshold || this.state & rt);
      } });
      function Fc() {
        dt.apply(this, arguments);
      }
      b(Fc, dt, { defaults: { event: "swipe", threshold: 10, velocity: 0.3, direction: Lt | Gr, pointers: 1 }, getTouchAction: function() {
        return js.prototype.getTouchAction.call(this);
      }, attrTest: function(p) {
        var g = this.options.direction, y;
        return g & (Lt | Gr) ? y = p.overallVelocity : g & Lt ? y = p.overallVelocityX : g & Gr && (y = p.overallVelocityY), this._super.attrTest.call(this, p) && g & p.offsetDirection && p.distance > this.options.threshold && p.maxPointers == this.options.pointers && c(y) > this.options.velocity && p.eventType & pe;
      }, emit: function(p) {
        var g = Bu(p.offsetDirection);
        g && this.manager.emit(this.options.event + g, p), this.manager.emit(this.options.event, p);
      } });
      function Ws() {
        Xt.apply(this, arguments), this.pTime = false, this.pCenter = false, this._timer = null, this._input = null, this.count = 0;
      }
      b(Ws, Xt, { defaults: { event: "tap", pointers: 1, taps: 1, interval: 300, time: 250, threshold: 9, posThreshold: 10 }, getTouchAction: function() {
        return [Rc];
      }, process: function(p) {
        var g = this.options, y = p.pointers.length === g.pointers, A = p.distance < g.threshold, P = p.deltaTime < g.time;
        if (this.reset(), p.eventType & Ne && this.count === 0)
          return this.failTimeout();
        if (A && P && y) {
          if (p.eventType != pe)
            return this.failTimeout();
          var O = this.pTime ? p.timeStamp - this.pTime < g.interval : true, X = !this.pCenter || Bs(this.pCenter, p.center) < g.posThreshold;
          this.pTime = p.timeStamp, this.pCenter = p.center, !X || !O ? this.count = 1 : this.count += 1, this._input = p;
          var Ee = this.count % g.taps;
          if (Ee === 0)
            return this.hasRequireFailures() ? (this._timer = f(function() {
              this.state = Ht, this.tryEmit();
            }, g.interval, this), rt) : Ht;
        }
        return Ct;
      }, failTimeout: function() {
        return this._timer = f(function() {
          this.state = Ct;
        }, this.options.interval, this), Ct;
      }, reset: function() {
        clearTimeout(this._timer);
      }, emit: function() {
        this.state == Ht && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));
      } });
      function Yt(p, g) {
        return g = g || {}, g.recognizers = C(g.recognizers, Yt.defaults.preset), new Dc(p, g);
      }
      Yt.VERSION = "2.0.7", Yt.defaults = { domEvents: false, touchAction: Nu, enable: true, inputTarget: null, inputClass: null, preset: [[Nc, { enable: false }], [Ic, { enable: false }, ["rotate"]], [Fc, { direction: Lt }], [js, { direction: Lt }, ["swipe"]], [Ws], [Ws, { event: "doubletap", taps: 2 }, ["tap"]], [Oc]], cssProps: { userSelect: "none", touchSelect: "none", touchCallout: "none", contentZooming: "none", userDrag: "none", tapHighlightColor: "rgba(0,0,0,0)" } };
      var Z_ = 1, Uu = 2;
      function Dc(p, g) {
        this.options = m({}, Yt.defaults, g || {}), this.options.inputTarget = this.options.inputTarget || p, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = p, this.input = S_(this), this.touchAction = new Mc(this, this.options.touchAction), ku(this, true), h(this.options.recognizers, function(y) {
          var A = this.add(new y[0](y[1]));
          y[2] && A.recognizeWith(y[2]), y[3] && A.requireFailure(y[3]);
        }, this);
      }
      Dc.prototype = { set: function(p) {
        return m(this.options, p), p.touchAction && this.touchAction.update(), p.inputTarget && (this.input.destroy(), this.input.target = p.inputTarget, this.input.init()), this;
      }, stop: function(p) {
        this.session.stopped = p ? Uu : Z_;
      }, recognize: function(p) {
        var g = this.session;
        if (!g.stopped) {
          this.touchAction.preventDefaults(p);
          var y, A = this.recognizers, P = g.curRecognizer;
          (!P || P && P.state & Ht) && (P = g.curRecognizer = null);
          for (var O = 0; O < A.length; )
            y = A[O], g.stopped !== Uu && (!P || y == P || y.canRecognizeWith(P)) ? y.recognize(p) : y.reset(), !P && y.state & (rt | un | lr) && (P = g.curRecognizer = y), O++;
        }
      }, get: function(p) {
        if (p instanceof Xt)
          return p;
        for (var g = this.recognizers, y = 0; y < g.length; y++)
          if (g[y].options.event == p)
            return g[y];
        return null;
      }, add: function(p) {
        if (u(p, "add", this))
          return this;
        var g = this.get(p.options.event);
        return g && this.remove(g), this.recognizers.push(p), p.manager = this, this.touchAction.update(), p;
      }, remove: function(p) {
        if (u(p, "remove", this))
          return this;
        if (p = this.get(p), p) {
          var g = this.recognizers, y = W(g, p);
          y !== -1 && (g.splice(y, 1), this.touchAction.update());
        }
        return this;
      }, on: function(p, g) {
        if (p !== n && g !== n) {
          var y = this.handlers;
          return h(N(p), function(A) {
            y[A] = y[A] || [], y[A].push(g);
          }), this;
        }
      }, off: function(p, g) {
        if (p !== n) {
          var y = this.handlers;
          return h(N(p), function(A) {
            g ? y[A] && y[A].splice(W(y[A], g), 1) : delete y[A];
          }), this;
        }
      }, emit: function(p, g) {
        this.options.domEvents && K_(p, g);
        var y = this.handlers[p] && this.handlers[p].slice();
        if (!(!y || !y.length)) {
          g.type = p, g.preventDefault = function() {
            g.srcEvent.preventDefault();
          };
          for (var A = 0; A < y.length; )
            y[A](g), A++;
        }
      }, destroy: function() {
        this.element && ku(this, false), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
      } };
      function ku(p, g) {
        var y = p.element;
        if (!!y.style) {
          var A;
          h(p.options.cssProps, function(P, O) {
            A = V(y.style, O), g ? (p.oldCssProps[A] = y.style[A], y.style[A] = P) : y.style[A] = p.oldCssProps[A] || "";
          }), g || (p.oldCssProps = {});
        }
      }
      function K_(p, g) {
        var y = e.createEvent("Event");
        y.initEvent(p, true, true), y.gesture = g, g.target.dispatchEvent(y);
      }
      m(Yt, { INPUT_START: Ne, INPUT_MOVE: Vr, INPUT_END: pe, INPUT_CANCEL: Ue, STATE_POSSIBLE: Gs, STATE_BEGAN: rt, STATE_CHANGED: un, STATE_ENDED: lr, STATE_RECOGNIZED: Ht, STATE_CANCELLED: _i, STATE_FAILED: Ct, DIRECTION_NONE: Fs, DIRECTION_LEFT: ui, DIRECTION_RIGHT: hi, DIRECTION_UP: di, DIRECTION_DOWN: pi, DIRECTION_HORIZONTAL: Lt, DIRECTION_VERTICAL: Gr, DIRECTION_ALL: bu, Manager: Dc, Input: tt, TouchAction: Mc, TouchInput: ks, MouseInput: Us, PointerEventInput: Lc, TouchMouseInput: Cc, SingleTouchInput: Cu, Recognizer: Xt, AttrRecognizer: dt, Tap: Ws, Pan: js, Swipe: Fc, Pinch: Ic, Rotate: Nc, Press: Oc, on: S, off: R, each: h, merge: E, extend: _, assign: m, inherit: b, bindFn: T, prefixed: V });
      var Q_ = typeof r2 != "undefined" ? r2 : typeof self != "undefined" ? self : {};
      Q_.Hammer = Yt, typeof define == "function" && define.amd ? define(function() {
        return Yt;
      }) : typeof va != "undefined" && va.exports ? va.exports = Yt : r2[t] = Yt;
    })(window, document, "Hammer");
  });
  var Jg = pt((Cz, Jf) => {
    "use strict";
    Jf.exports = nc;
    Jf.exports.default = nc;
    function nc(r2, e, t) {
      t = t || 2;
      var n = e && e.length, i = n ? e[0] * t : r2.length, s = qg(r2, 0, i, t, true), o = [];
      if (!s || s.next === s.prev)
        return o;
      var a, c, l, f, u, h, d;
      if (n && (s = SS(r2, e, s, t)), r2.length > 80 * t) {
        a = l = r2[0], c = f = r2[1];
        for (var m = t; m < i; m += t)
          u = r2[m], h = r2[m + 1], u < a && (a = u), h < c && (c = h), u > l && (l = u), h > f && (f = h);
        d = Math.max(l - a, f - c), d = d !== 0 ? 1 / d : 0;
      }
      return As(s, o, t, a, c, d), o;
    }
    function qg(r2, e, t, n, i) {
      var s, o;
      if (i === Qf(r2, e, t, n) > 0)
        for (s = e; s < t; s += n)
          o = Qg(s, r2[s], r2[s + 1], o);
      else
        for (s = t - n; s >= e; s -= n)
          o = Qg(s, r2[s], r2[s + 1], o);
      return o && ic(o, o.next) && (ws(o), o = o.next), o;
    }
    function Dr(r2, e) {
      if (!r2)
        return r2;
      e || (e = r2);
      var t = r2, n;
      do
        if (n = false, !t.steiner && (ic(t, t.next) || ie(t.prev, t, t.next) === 0)) {
          if (ws(t), t = e = t.prev, t === t.next)
            break;
          n = true;
        } else
          t = t.next;
      while (n || t !== e);
      return e;
    }
    function As(r2, e, t, n, i, s, o) {
      if (!!r2) {
        !o && s && RS(r2, n, i, s);
        for (var a = r2, c, l; r2.prev !== r2.next; ) {
          if (c = r2.prev, l = r2.next, s ? TS(r2, n, i, s) : bS(r2)) {
            e.push(c.i / t), e.push(r2.i / t), e.push(l.i / t), ws(r2), r2 = l.next, a = l.next;
            continue;
          }
          if (r2 = l, r2 === a) {
            o ? o === 1 ? (r2 = vS(Dr(r2), e, t), As(r2, e, t, n, i, s, 2)) : o === 2 && AS(r2, e, t, n, i, s) : As(Dr(r2), e, t, n, i, s, 1);
            break;
          }
        }
      }
    }
    function bS(r2) {
      var e = r2.prev, t = r2, n = r2.next;
      if (ie(e, t, n) >= 0)
        return false;
      for (var i = r2.next.next; i !== r2.prev; ) {
        if (ri(e.x, e.y, t.x, t.y, n.x, n.y, i.x, i.y) && ie(i.prev, i, i.next) >= 0)
          return false;
        i = i.next;
      }
      return true;
    }
    function TS(r2, e, t, n) {
      var i = r2.prev, s = r2, o = r2.next;
      if (ie(i, s, o) >= 0)
        return false;
      for (var a = i.x < s.x ? i.x < o.x ? i.x : o.x : s.x < o.x ? s.x : o.x, c = i.y < s.y ? i.y < o.y ? i.y : o.y : s.y < o.y ? s.y : o.y, l = i.x > s.x ? i.x > o.x ? i.x : o.x : s.x > o.x ? s.x : o.x, f = i.y > s.y ? i.y > o.y ? i.y : o.y : s.y > o.y ? s.y : o.y, u = Zf(a, c, e, t, n), h = Zf(l, f, e, t, n), d = r2.prevZ, m = r2.nextZ; d && d.z >= u && m && m.z <= h; ) {
        if (d !== r2.prev && d !== r2.next && ri(i.x, i.y, s.x, s.y, o.x, o.y, d.x, d.y) && ie(d.prev, d, d.next) >= 0 || (d = d.prevZ, m !== r2.prev && m !== r2.next && ri(i.x, i.y, s.x, s.y, o.x, o.y, m.x, m.y) && ie(m.prev, m, m.next) >= 0))
          return false;
        m = m.nextZ;
      }
      for (; d && d.z >= u; ) {
        if (d !== r2.prev && d !== r2.next && ri(i.x, i.y, s.x, s.y, o.x, o.y, d.x, d.y) && ie(d.prev, d, d.next) >= 0)
          return false;
        d = d.prevZ;
      }
      for (; m && m.z <= h; ) {
        if (m !== r2.prev && m !== r2.next && ri(i.x, i.y, s.x, s.y, o.x, o.y, m.x, m.y) && ie(m.prev, m, m.next) >= 0)
          return false;
        m = m.nextZ;
      }
      return true;
    }
    function vS(r2, e, t) {
      var n = r2;
      do {
        var i = n.prev, s = n.next.next;
        !ic(i, s) && Zg(i, n, n.next, s) && Ss(i, s) && Ss(s, i) && (e.push(i.i / t), e.push(n.i / t), e.push(s.i / t), ws(n), ws(n.next), n = r2 = s), n = n.next;
      } while (n !== r2);
      return Dr(n);
    }
    function AS(r2, e, t, n, i, s) {
      var o = r2;
      do {
        for (var a = o.next.next; a !== o.prev; ) {
          if (o.i !== a.i && OS(o, a)) {
            var c = Kg(o, a);
            o = Dr(o, o.next), c = Dr(c, c.next), As(o, e, t, n, i, s), As(c, e, t, n, i, s);
            return;
          }
          a = a.next;
        }
        o = o.next;
      } while (o !== r2);
    }
    function SS(r2, e, t, n) {
      var i = [], s, o, a, c, l;
      for (s = 0, o = e.length; s < o; s++)
        a = e[s] * n, c = s < o - 1 ? e[s + 1] * n : r2.length, l = qg(r2, a, c, n, false), l === l.next && (l.steiner = true), i.push(IS(l));
      for (i.sort(wS), s = 0; s < i.length; s++)
        PS(i[s], t), t = Dr(t, t.next);
      return t;
    }
    function wS(r2, e) {
      return r2.x - e.x;
    }
    function PS(r2, e) {
      if (e = LS(r2, e), e) {
        var t = Kg(e, r2);
        Dr(e, e.next), Dr(t, t.next);
      }
    }
    function LS(r2, e) {
      var t = e, n = r2.x, i = r2.y, s = -1 / 0, o;
      do {
        if (i <= t.y && i >= t.next.y && t.next.y !== t.y) {
          var a = t.x + (i - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
          if (a <= n && a > s) {
            if (s = a, a === n) {
              if (i === t.y)
                return t;
              if (i === t.next.y)
                return t.next;
            }
            o = t.x < t.next.x ? t : t.next;
          }
        }
        t = t.next;
      } while (t !== e);
      if (!o)
        return null;
      if (n === s)
        return o;
      var c = o, l = o.x, f = o.y, u = 1 / 0, h;
      t = o;
      do
        n >= t.x && t.x >= l && n !== t.x && ri(i < f ? n : s, i, l, f, i < f ? s : n, i, t.x, t.y) && (h = Math.abs(i - t.y) / (n - t.x), Ss(t, r2) && (h < u || h === u && (t.x > o.x || t.x === o.x && CS(o, t))) && (o = t, u = h)), t = t.next;
      while (t !== c);
      return o;
    }
    function CS(r2, e) {
      return ie(r2.prev, r2, e.prev) < 0 && ie(e.next, r2, r2.next) < 0;
    }
    function RS(r2, e, t, n) {
      var i = r2;
      do
        i.z === null && (i.z = Zf(i.x, i.y, e, t, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
      while (i !== r2);
      i.prevZ.nextZ = null, i.prevZ = null, MS(i);
    }
    function MS(r2) {
      var e, t, n, i, s, o, a, c, l = 1;
      do {
        for (t = r2, r2 = null, s = null, o = 0; t; ) {
          for (o++, n = t, a = 0, e = 0; e < l && (a++, n = n.nextZ, !!n); e++)
            ;
          for (c = l; a > 0 || c > 0 && n; )
            a !== 0 && (c === 0 || !n || t.z <= n.z) ? (i = t, t = t.nextZ, a--) : (i = n, n = n.nextZ, c--), s ? s.nextZ = i : r2 = i, i.prevZ = s, s = i;
          t = n;
        }
        s.nextZ = null, l *= 2;
      } while (o > 1);
      return r2;
    }
    function Zf(r2, e, t, n, i) {
      return r2 = 32767 * (r2 - t) * i, e = 32767 * (e - n) * i, r2 = (r2 | r2 << 8) & 16711935, r2 = (r2 | r2 << 4) & 252645135, r2 = (r2 | r2 << 2) & 858993459, r2 = (r2 | r2 << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, r2 | e << 1;
    }
    function IS(r2) {
      var e = r2, t = r2;
      do
        (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
      while (e !== r2);
      return t;
    }
    function ri(r2, e, t, n, i, s, o, a) {
      return (i - o) * (e - a) - (r2 - o) * (s - a) >= 0 && (r2 - o) * (n - a) - (t - o) * (e - a) >= 0 && (t - o) * (s - a) - (i - o) * (n - a) >= 0;
    }
    function OS(r2, e) {
      return r2.next.i !== e.i && r2.prev.i !== e.i && !NS(r2, e) && (Ss(r2, e) && Ss(e, r2) && FS(r2, e) && (ie(r2.prev, r2, e.prev) || ie(r2, e.prev, e)) || ic(r2, e) && ie(r2.prev, r2, r2.next) > 0 && ie(e.prev, e, e.next) > 0);
    }
    function ie(r2, e, t) {
      return (e.y - r2.y) * (t.x - e.x) - (e.x - r2.x) * (t.y - e.y);
    }
    function ic(r2, e) {
      return r2.x === e.x && r2.y === e.y;
    }
    function Zg(r2, e, t, n) {
      var i = oc(ie(r2, e, t)), s = oc(ie(r2, e, n)), o = oc(ie(t, n, r2)), a = oc(ie(t, n, e));
      return !!(i !== s && o !== a || i === 0 && sc(r2, t, e) || s === 0 && sc(r2, n, e) || o === 0 && sc(t, r2, n) || a === 0 && sc(t, e, n));
    }
    function sc(r2, e, t) {
      return e.x <= Math.max(r2.x, t.x) && e.x >= Math.min(r2.x, t.x) && e.y <= Math.max(r2.y, t.y) && e.y >= Math.min(r2.y, t.y);
    }
    function oc(r2) {
      return r2 > 0 ? 1 : r2 < 0 ? -1 : 0;
    }
    function NS(r2, e) {
      var t = r2;
      do {
        if (t.i !== r2.i && t.next.i !== r2.i && t.i !== e.i && t.next.i !== e.i && Zg(t, t.next, r2, e))
          return true;
        t = t.next;
      } while (t !== r2);
      return false;
    }
    function Ss(r2, e) {
      return ie(r2.prev, r2, r2.next) < 0 ? ie(r2, e, r2.next) >= 0 && ie(r2, r2.prev, e) >= 0 : ie(r2, e, r2.prev) < 0 || ie(r2, r2.next, e) < 0;
    }
    function FS(r2, e) {
      var t = r2, n = false, i = (r2.x + e.x) / 2, s = (r2.y + e.y) / 2;
      do
        t.y > s != t.next.y > s && t.next.y !== t.y && i < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next;
      while (t !== r2);
      return n;
    }
    function Kg(r2, e) {
      var t = new Kf(r2.i, r2.x, r2.y), n = new Kf(e.i, e.x, e.y), i = r2.next, s = e.prev;
      return r2.next = e, e.prev = r2, t.next = i, i.prev = t, n.next = t, t.prev = n, s.next = n, n.prev = s, n;
    }
    function Qg(r2, e, t, n) {
      var i = new Kf(r2, e, t);
      return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
    }
    function ws(r2) {
      r2.next.prev = r2.prev, r2.prev.next = r2.next, r2.prevZ && (r2.prevZ.nextZ = r2.nextZ), r2.nextZ && (r2.nextZ.prevZ = r2.prevZ);
    }
    function Kf(r2, e, t) {
      this.i = r2, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
    }
    nc.deviation = function(r2, e, t, n) {
      var i = e && e.length, s = i ? e[0] * t : r2.length, o = Math.abs(Qf(r2, 0, s, t));
      if (i)
        for (var a = 0, c = e.length; a < c; a++) {
          var l = e[a] * t, f = a < c - 1 ? e[a + 1] * t : r2.length;
          o -= Math.abs(Qf(r2, l, f, t));
        }
      var u = 0;
      for (a = 0; a < n.length; a += 3) {
        var h = n[a] * t, d = n[a + 1] * t, m = n[a + 2] * t;
        u += Math.abs((r2[h] - r2[m]) * (r2[d + 1] - r2[h + 1]) - (r2[h] - r2[d]) * (r2[m + 1] - r2[h + 1]));
      }
      return o === 0 && u === 0 ? 0 : Math.abs((u - o) / o);
    };
    function Qf(r2, e, t, n) {
      for (var i = 0, s = e, o = t - n; s < t; s += n)
        i += (r2[o] - r2[s]) * (r2[s + 1] + r2[o + 1]), o = s;
      return i;
    }
    nc.flatten = function(r2) {
      for (var e = r2[0][0].length, t = { vertices: [], holes: [], dimensions: e }, n = 0, i = 0; i < r2.length; i++) {
        for (var s = 0; s < r2[i].length; s++)
          for (var o = 0; o < e; o++)
            t.vertices.push(r2[i][s][o]);
        i > 0 && (n += r2[i - 1].length, t.holes.push(n));
      }
      return t;
    };
  });
  var g0 = pt((rj, $f) => {
    "use strict";
    $f.exports = Ps;
    $f.exports.default = Ps;
    var si = 1e20;
    function Ps(r2, e, t, n, i, s) {
      this.fontSize = r2 || 24, this.buffer = e === void 0 ? 3 : e, this.cutoff = n || 0.25, this.fontFamily = i || "sans-serif", this.fontWeight = s || "normal", this.radius = t || 8;
      var o = this.size = this.fontSize + this.buffer * 2, a = o + this.buffer * 2;
      this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = o, this.ctx = this.canvas.getContext("2d"), this.ctx.font = this.fontWeight + " " + this.fontSize + "px " + this.fontFamily, this.ctx.textAlign = "left", this.ctx.fillStyle = "black", this.gridOuter = new Float64Array(a * a), this.gridInner = new Float64Array(a * a), this.f = new Float64Array(a), this.z = new Float64Array(a + 1), this.v = new Uint16Array(a), this.useMetrics = this.ctx.measureText("A").actualBoundingBoxLeft !== void 0, this.middle = Math.round(o / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1));
    }
    function jS(r2, e, t, n, i, s, o) {
      s.fill(si, 0, e * t), o.fill(0, 0, e * t);
      for (var a = (e - n) / 2, c = 0; c < i; c++)
        for (var l = 0; l < n; l++) {
          var f = (c + a) * e + l + a, u = r2.data[4 * (c * n + l) + 3] / 255;
          if (u === 1)
            s[f] = 0, o[f] = si;
          else if (u === 0)
            s[f] = si, o[f] = 0;
          else {
            var h = Math.max(0, 0.5 - u), d = Math.max(0, u - 0.5);
            s[f] = h * h, o[f] = d * d;
          }
        }
    }
    function WS(r2, e, t, n, i, s, o) {
      for (var a = 0; a < e * t; a++) {
        var c = Math.sqrt(n[a]) - Math.sqrt(i[a]);
        r2[a] = Math.round(255 - 255 * (c / s + o));
      }
    }
    Ps.prototype._draw = function(r2, e) {
      var t = this.ctx.measureText(r2), n = t.width, i = 2 * this.buffer, s, o, a, c, l, f, u, h;
      e && this.useMetrics ? (l = Math.floor(t.actualBoundingBoxAscent), h = this.buffer + Math.ceil(t.actualBoundingBoxAscent), f = this.buffer, u = this.buffer, o = Math.min(this.size, Math.ceil(t.actualBoundingBoxRight - t.actualBoundingBoxLeft)), c = Math.min(this.size - f, Math.ceil(t.actualBoundingBoxAscent + t.actualBoundingBoxDescent)), s = o + i, a = c + i, this.ctx.textBaseline = "alphabetic") : (s = o = this.size, a = c = this.size, l = 19 * this.fontSize / 24, f = u = 0, h = this.middle, this.ctx.textBaseline = "middle");
      var d;
      o && c && (this.ctx.clearRect(u, f, o, c), this.ctx.fillText(r2, this.buffer, h), d = this.ctx.getImageData(u, f, o, c));
      var m = new Uint8ClampedArray(s * a);
      return jS(d, s, a, o, c, this.gridOuter, this.gridInner), p0(this.gridOuter, s, a, this.f, this.v, this.z), p0(this.gridInner, s, a, this.f, this.v, this.z), WS(m, s, a, this.gridOuter, this.gridInner, this.radius, this.cutoff), { data: m, metrics: { width: o, height: c, sdfWidth: s, sdfHeight: a, top: l, left: 0, advance: n } };
    };
    Ps.prototype.draw = function(r2) {
      return this._draw(r2, false).data;
    };
    Ps.prototype.drawWithMetrics = function(r2) {
      return this._draw(r2, true);
    };
    function p0(r2, e, t, n, i, s) {
      for (var o = 0; o < e; o++)
        m0(r2, o, e, t, n, i, s);
      for (var a = 0; a < t; a++)
        m0(r2, a * e, 1, e, n, i, s);
    }
    function m0(r2, e, t, n, i, s, o) {
      var a, c, l, f;
      for (s[0] = 0, o[0] = -si, o[1] = si, a = 0; a < n; a++)
        i[a] = r2[e + a * t];
      for (a = 1, c = 0, l = 0; a < n; a++) {
        do
          f = s[c], l = (i[a] - i[f] + a * a - f * f) / (a - f) / 2;
        while (l <= o[c] && --c > -1);
        c++, s[c] = a, o[c] = l, o[c + 1] = si;
      }
      for (a = 0, c = 0; a < n; a++) {
        for (; o[c + 1] < a; )
          c++;
        f = s[c], r2[e + a * t] = i[f] + (a - f) * (a - f);
      }
    }
  });
  function Xs(r2, e) {
    if (!r2)
      throw new Error(e || "loader assertion failed.");
  }
  var It = { self: typeof self != "undefined" && self, window: typeof window != "undefined" && window, global: typeof global != "undefined" && global, document: typeof document != "undefined" && document };
  var ax = It.self || It.window || It.global || {};
  var cx = It.window || It.self || It.global || {};
  var xi = It.global || It.self || It.window || {};
  var lx = It.document || {};
  var Bc = typeof process != "object" || String(process) !== "[object process]" || process.browser;
  var fx = typeof importScripts == "function";
  var ju = typeof process != "undefined" && process.version && /v([0-9]*)/.exec(process.version);
  var ux = ju && parseFloat(ju[1]) || 0;
  var Wu = "3.0.8";
  function we(r2, e) {
    if (!r2)
      throw new Error(e || "loaders.gl assertion failed.");
  }
  var Ot = { self: typeof self != "undefined" && self, window: typeof window != "undefined" && window, global: typeof global != "undefined" && global, document: typeof document != "undefined" && document };
  var yL = Ot.self || Ot.window || Ot.global || {};
  var EL = Ot.window || Ot.self || Ot.global || {};
  var bL = Ot.global || Ot.self || Ot.window || {};
  var TL = Ot.document || {};
  var vL = typeof process != "object" || String(process) !== "[object process]" || process.browser;
  var AL = typeof importScripts == "function";
  var Hu = typeof window != "undefined" && typeof window.orientation != "undefined";
  var Xu = typeof process != "undefined" && process.version && /v([0-9]*)/.exec(process.version);
  var SL = Xu && parseFloat(Xu[1]) || 0;
  function G(r2, e, t) {
    return e in r2 ? Object.defineProperty(r2, e, { value: t, enumerable: true, configurable: true, writable: true }) : r2[e] = t, r2;
  }
  var Ys = class {
    constructor(e, t) {
      G(this, "name", void 0), G(this, "workerThread", void 0), G(this, "isRunning", void 0), G(this, "result", void 0), G(this, "_resolve", void 0), G(this, "_reject", void 0), this.name = e, this.workerThread = t, this.isRunning = true, this._resolve = () => {
      }, this._reject = () => {
      }, this.result = new Promise((n, i) => {
        this._resolve = n, this._reject = i;
      });
    }
    postMessage(e, t) {
      this.workerThread.postMessage({ source: "loaders.gl", type: e, payload: t });
    }
    done(e) {
      we(this.isRunning), this.isRunning = false, this._resolve(e);
    }
    error(e) {
      we(this.isRunning), this.isRunning = false, this._reject(e);
    }
  };
  var Uc = new Map();
  function Yu(r2) {
    we(r2.source && !r2.url || !r2.source && r2.url);
    let e = Uc.get(r2.source || r2.url);
    return e || (r2.url && (e = hx(r2.url), Uc.set(r2.url, e)), r2.source && (e = qu(r2.source), Uc.set(r2.source, e))), we(e), e;
  }
  function hx(r2) {
    if (!r2.startsWith("http"))
      return r2;
    let e = dx(r2);
    return qu(e);
  }
  function qu(r2) {
    let e = new Blob([r2], { type: "application/javascript" });
    return URL.createObjectURL(e);
  }
  function dx(r2) {
    return `try {
  importScripts('${r2}');
} catch (error) {
  console.error(error);
  throw error;
}`;
  }
  function kc(r2, e = true, t) {
    let n = t || new Set();
    if (r2) {
      if (Zu(r2))
        n.add(r2);
      else if (Zu(r2.buffer))
        n.add(r2.buffer);
      else if (!ArrayBuffer.isView(r2)) {
        if (e && typeof r2 == "object")
          for (let i in r2)
            kc(r2[i], e, n);
      }
    }
    return t === void 0 ? Array.from(n) : [];
  }
  function Zu(r2) {
    return r2 ? r2 instanceof ArrayBuffer || typeof MessagePort != "undefined" && r2 instanceof MessagePort || typeof ImageBitmap != "undefined" && r2 instanceof ImageBitmap || typeof OffscreenCanvas != "undefined" && r2 instanceof OffscreenCanvas : false;
  }
  var Vc = () => {
  };
  var hn = class {
    static isSupported() {
      return typeof Worker != "undefined";
    }
    constructor(e) {
      G(this, "name", void 0), G(this, "source", void 0), G(this, "url", void 0), G(this, "terminated", false), G(this, "worker", void 0), G(this, "onMessage", void 0), G(this, "onError", void 0), G(this, "_loadableURL", "");
      let { name: t, source: n, url: i } = e;
      we(n || i), this.name = t, this.source = n, this.url = i, this.onMessage = Vc, this.onError = (s) => console.log(s), this.worker = this._createBrowserWorker();
    }
    destroy() {
      this.onMessage = Vc, this.onError = Vc, this.worker.terminate(), this.terminated = true;
    }
    get isRunning() {
      return Boolean(this.onMessage);
    }
    postMessage(e, t) {
      t = t || kc(e), this.worker.postMessage(e, t);
    }
    _getErrorFromErrorEvent(e) {
      let t = "Failed to load ";
      return t += `worker ${this.name}. `, e.message && (t += `${e.message} in `), e.lineno && (t += `:${e.lineno}:${e.colno}`), new Error(t);
    }
    _createBrowserWorker() {
      this._loadableURL = Yu({ source: this.source, url: this.url });
      let e = new Worker(this._loadableURL, { name: this.name });
      return e.onmessage = (t) => {
        t.data ? this.onMessage(t.data) : this.onError(new Error("No data received"));
      }, e.onerror = (t) => {
        this.onError(this._getErrorFromErrorEvent(t)), this.terminated = true;
      }, e.onmessageerror = (t) => console.error(t), e;
    }
  };
  var qs = class {
    constructor(e) {
      G(this, "name", "unnamed"), G(this, "source", void 0), G(this, "url", void 0), G(this, "maxConcurrency", 1), G(this, "maxMobileConcurrency", 1), G(this, "onDebug", () => {
      }), G(this, "reuseWorkers", true), G(this, "props", {}), G(this, "jobQueue", []), G(this, "idleQueue", []), G(this, "count", 0), G(this, "isDestroyed", false), this.source = e.source, this.url = e.url, this.setProps(e);
    }
    destroy() {
      this.idleQueue.forEach((e) => e.destroy()), this.isDestroyed = true;
    }
    setProps(e) {
      this.props = x(x({}, this.props), e), e.name !== void 0 && (this.name = e.name), e.maxConcurrency !== void 0 && (this.maxConcurrency = e.maxConcurrency), e.maxMobileConcurrency !== void 0 && (this.maxMobileConcurrency = e.maxMobileConcurrency), e.reuseWorkers !== void 0 && (this.reuseWorkers = e.reuseWorkers), e.onDebug !== void 0 && (this.onDebug = e.onDebug);
    }
    async startJob(e, t = (i, s, o) => i.done(o), n = (i, s) => i.error(s)) {
      let i = new Promise((s) => (this.jobQueue.push({ name: e, onMessage: t, onError: n, onStart: s }), this));
      return this._startQueuedJob(), await i;
    }
    async _startQueuedJob() {
      if (!this.jobQueue.length)
        return;
      let e = this._getAvailableWorker();
      if (!e)
        return;
      let t = this.jobQueue.shift();
      if (t) {
        this.onDebug({ message: "Starting job", name: t.name, workerThread: e, backlog: this.jobQueue.length });
        let n = new Ys(t.name, e);
        e.onMessage = (i) => t.onMessage(n, i.type, i.payload), e.onError = (i) => t.onError(n, i), t.onStart(n);
        try {
          await n.result;
        } finally {
          this.returnWorkerToQueue(e);
        }
      }
    }
    returnWorkerToQueue(e) {
      this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency() ? (e.destroy(), this.count--) : this.idleQueue.push(e), this.isDestroyed || this._startQueuedJob();
    }
    _getAvailableWorker() {
      if (this.idleQueue.length > 0)
        return this.idleQueue.shift() || null;
      if (this.count < this._getMaxConcurrency()) {
        this.count++;
        let e = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
        return new hn({ name: e, source: this.source, url: this.url });
      }
      return null;
    }
    _getMaxConcurrency() {
      return Hu ? this.maxMobileConcurrency : this.maxConcurrency;
    }
  };
  var px = { maxConcurrency: 3, maxMobileConcurrency: 1, onDebug: () => {
  }, reuseWorkers: true };
  var je = class {
    static isSupported() {
      return hn.isSupported();
    }
    static getWorkerFarm(e = {}) {
      return je._workerFarm = je._workerFarm || new je({}), je._workerFarm.setProps(e), je._workerFarm;
    }
    constructor(e) {
      G(this, "props", void 0), G(this, "workerPools", new Map()), this.props = x({}, px), this.setProps(e), this.workerPools = new Map();
    }
    destroy() {
      for (let e of this.workerPools.values())
        e.destroy();
    }
    setProps(e) {
      this.props = x(x({}, this.props), e);
      for (let t of this.workerPools.values())
        t.setProps(this._getWorkerPoolProps());
    }
    getWorkerPool(e) {
      let { name: t, source: n, url: i } = e, s = this.workerPools.get(t);
      return s || (s = new qs({ name: t, source: n, url: i }), s.setProps(this._getWorkerPoolProps()), this.workerPools.set(t, s)), s;
    }
    _getWorkerPoolProps() {
      return { maxConcurrency: this.props.maxConcurrency, maxMobileConcurrency: this.props.maxMobileConcurrency, reuseWorkers: this.props.reuseWorkers, onDebug: this.props.onDebug };
    }
  };
  G(je, "_workerFarm", void 0);
  var mx = "latest";
  function Gc(r2, e = {}) {
    let t = e[r2.id] || {}, n = `${r2.id}-worker.js`, i = t.workerUrl;
    if (e._workerType === "test" && (i = `modules/${r2.module}/dist/${n}`), !i) {
      let s = r2.version;
      s === "latest" && (s = mx);
      let o = s ? `@${s}` : "";
      i = `https://unpkg.com/@loaders.gl/${r2.module}${o}/dist/${n}`;
    }
    return we(i), i;
  }
  function zc(r2, e = Wu) {
    we(r2, "no worker provided");
    let t = r2.version;
    return !(!e || !t);
  }
  function jc(r2, e) {
    return je.isSupported() ? r2.worker && (e == null ? void 0 : e.worker) : false;
  }
  async function Wc(r2, e, t, n, i) {
    let s = r2.id, o = Gc(r2, t), c = je.getWorkerFarm(t).getWorkerPool({ name: s, url: o });
    t = JSON.parse(JSON.stringify(t));
    let l = await c.startJob("process-on-worker", gx.bind(null, i));
    return l.postMessage("process", { input: e, options: t }), await (await l.result).result;
  }
  async function gx(r2, e, t, n) {
    switch (t) {
      case "done":
        e.done(n);
        break;
      case "error":
        e.error(n.error);
        break;
      case "process":
        let { id: i, input: s, options: o } = n;
        try {
          let a = await r2(s, o);
          e.postMessage("done", { id: i, result: a });
        } catch (a) {
          let c = a instanceof Error ? a.message : "unknown error";
          e.postMessage("error", { id: i, error: c });
        }
        break;
      default:
        console.warn(`parse-with-worker unknown message ${t}`);
    }
  }
  function Zs(r2) {
    if (Hc.toArrayBuffer && (r2 = Hc.toArrayBuffer(r2)), r2 instanceof ArrayBuffer)
      return r2;
    if (ArrayBuffer.isView(r2))
      return r2.buffer;
    if (typeof r2 == "string") {
      let e = r2;
      return new TextEncoder().encode(e).buffer;
    }
    if (r2 && typeof r2 == "object" && r2._toArrayBuffer)
      return r2._toArrayBuffer();
    throw new Error("toArrayBuffer");
  }
  function Xc(r2, e, t) {
    if (t = t || r2.byteLength, r2.byteLength < t || e.byteLength < t)
      return false;
    let n = new Uint8Array(r2), i = new Uint8Array(e);
    for (let s = 0; s < n.length; ++s)
      if (n[s] !== i[s])
        return false;
    return true;
  }
  function Yc(...r2) {
    let e = r2.map((s) => s instanceof ArrayBuffer ? new Uint8Array(s) : s), t = e.reduce((s, o) => s + o.byteLength, 0), n = new Uint8Array(t), i = 0;
    for (let s of e)
      n.set(s, i), i += s.byteLength;
    return n.buffer;
  }
  async function qc(r2) {
    let e = [];
    for await (let t of r2)
      e.push(t);
    return Yc(...e);
  }
  function yi() {
    let r2;
    if (typeof window != "undefined" && window.performance)
      r2 = window.performance.now();
    else if (typeof process != "undefined" && process.hrtime) {
      let e = process.hrtime();
      r2 = e[0] * 1e3 + e[1] / 1e6;
    } else
      r2 = Date.now();
    return r2;
  }
  var jr = class {
    constructor(e, t) {
      this.name = e, this.type = t, this.sampleSize = 1, this.reset();
    }
    setSampleSize(e) {
      return this.sampleSize = e, this;
    }
    incrementCount() {
      return this.addCount(1), this;
    }
    decrementCount() {
      return this.subtractCount(1), this;
    }
    addCount(e) {
      return this._count += e, this._samples++, this._checkSampling(), this;
    }
    subtractCount(e) {
      return this._count -= e, this._samples++, this._checkSampling(), this;
    }
    addTime(e) {
      return this._time += e, this.lastTiming = e, this._samples++, this._checkSampling(), this;
    }
    timeStart() {
      return this._startTime = yi(), this._timerPending = true, this;
    }
    timeEnd() {
      return this._timerPending ? (this.addTime(yi() - this._startTime), this._timerPending = false, this._checkSampling(), this) : this;
    }
    getSampleAverageCount() {
      return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
    getSampleAverageTime() {
      return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
    getSampleHz() {
      return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
    }
    getAverageCount() {
      return this.samples > 0 ? this.count / this.samples : 0;
    }
    getAverageTime() {
      return this.samples > 0 ? this.time / this.samples : 0;
    }
    getHz() {
      return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
    }
    reset() {
      return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = false, this;
    }
    _checkSampling() {
      this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0);
    }
  };
  var nt = class {
    constructor({ id: e, stats: t }) {
      this.id = e, this.stats = {}, this._initializeStats(t), Object.seal(this);
    }
    get(e, t = "count") {
      return this._getOrCreate({ name: e, type: t });
    }
    get size() {
      return Object.keys(this.stats).length;
    }
    reset() {
      for (let e in this.stats)
        this.stats[e].reset();
      return this;
    }
    forEach(e) {
      for (let t in this.stats)
        e(this.stats[t]);
    }
    getTable() {
      let e = {};
      return this.forEach((t) => {
        e[t.name] = { time: t.time || 0, count: t.count || 0, average: t.getAverageTime() || 0, hz: t.getHz() || 0 };
      }), e;
    }
    _initializeStats(e = []) {
      e.forEach((t) => this._getOrCreate(t));
    }
    _getOrCreate(e) {
      if (!e || !e.name)
        return null;
      let { name: t, type: n } = e;
      return this.stats[t] || (e instanceof jr ? this.stats[t] = e : this.stats[t] = new jr(t, n)), this.stats[t];
    }
  };
  var _x = "Queued Requests";
  var xx = "Active Requests";
  var yx = "Cancelled Requests";
  var Ex = "Queued Requests Ever";
  var bx = "Active Requests Ever";
  var Tx = { id: "request-scheduler", throttleRequests: true, maxRequests: 6 };
  var Ei = class {
    constructor(e = {}) {
      G(this, "props", void 0), G(this, "stats", void 0), G(this, "activeRequestCount", 0), G(this, "requestQueue", []), G(this, "requestMap", new Map()), G(this, "deferredUpdate", null), this.props = x(x({}, Tx), e), this.stats = new nt({ id: this.props.id }), this.stats.get(_x), this.stats.get(xx), this.stats.get(yx), this.stats.get(Ex), this.stats.get(bx);
    }
    scheduleRequest(e, t = () => 0) {
      if (!this.props.throttleRequests)
        return Promise.resolve({ done: () => {
        } });
      if (this.requestMap.has(e))
        return this.requestMap.get(e);
      let n = { handle: e, priority: 0, getPriority: t }, i = new Promise((s) => (n.resolve = s, n));
      return this.requestQueue.push(n), this.requestMap.set(e, i), this._issueNewRequests(), i;
    }
    _issueRequest(e) {
      let { handle: t, resolve: n } = e, i = false, s = () => {
        i || (i = true, this.requestMap.delete(t), this.activeRequestCount--, this._issueNewRequests());
      };
      return this.activeRequestCount++, n ? n({ done: s }) : Promise.resolve({ done: s });
    }
    _issueNewRequests() {
      this.deferredUpdate || (this.deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0));
    }
    _issueNewRequestsAsync() {
      this.deferredUpdate = null;
      let e = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
      if (e !== 0) {
        this._updateAllRequests();
        for (let t = 0; t < e; ++t) {
          let n = this.requestQueue.shift();
          n && this._issueRequest(n);
        }
      }
    }
    _updateAllRequests() {
      let e = this.requestQueue;
      for (let t = 0; t < e.length; ++t) {
        let n = e[t];
        this._updateRequest(n) || (e.splice(t, 1), this.requestMap.delete(n.handle), t--);
      }
      e.sort((t, n) => t.priority - n.priority);
    }
    _updateRequest(e) {
      return e.priority = e.getPriority(e.handle), e.priority < 0 ? (e.resolve(null), false) : true;
    }
  };
  var vx = "";
  var Ku = {};
  function Zc(r2) {
    for (let e in Ku)
      if (r2.startsWith(e)) {
        let t = Ku[e];
        r2 = r2.replace(e, t);
      }
    return !r2.startsWith("http://") && !r2.startsWith("https://") && (r2 = `${vx}${r2}`), r2;
  }
  var Ax = (r2) => typeof r2 == "boolean";
  var bi = (r2) => typeof r2 == "function";
  var dn = (r2) => r2 !== null && typeof r2 == "object";
  var Kc = (r2) => dn(r2) && r2.constructor === {}.constructor;
  var Qu = (r2) => r2 && typeof r2[Symbol.iterator] == "function";
  var Ju = (r2) => r2 && typeof r2[Symbol.asyncIterator] == "function";
  var qt = (r2) => typeof Response != "undefined" && r2 instanceof Response || r2 && r2.arrayBuffer && r2.text && r2.json;
  var mt = (r2) => typeof Blob != "undefined" && r2 instanceof Blob;
  var Sx = (r2) => typeof ReadableStream != "undefined" && r2 instanceof ReadableStream || dn(r2) && bi(r2.tee) && bi(r2.cancel) && bi(r2.getReader);
  var $u = (r2) => r2 && typeof r2 == "object" && r2.isBuffer;
  var wx = (r2) => dn(r2) && bi(r2.read) && bi(r2.pipe) && Ax(r2.readable);
  var Ks = (r2) => Sx(r2) || wx(r2);
  var Px = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
  var Lx = /^([-\w.]+\/[-\w.+]+)/;
  function eh(r2) {
    let e = Lx.exec(r2);
    return e ? e[1] : r2;
  }
  function Qc(r2) {
    let e = Px.exec(r2);
    return e ? e[1] : "";
  }
  var Cx = /\?.*/;
  function Wr(r2) {
    if (qt(r2)) {
      let e = Jc(r2.url || ""), t = r2.headers.get("content-type") || "";
      return { url: e, type: eh(t) || Qc(e) };
    }
    return mt(r2) ? { url: Jc(r2.name || ""), type: r2.type || "" } : typeof r2 == "string" ? { url: Jc(r2), type: Qc(r2) } : { url: "", type: "" };
  }
  function th(r2) {
    return qt(r2) ? r2.headers["content-length"] || -1 : mt(r2) ? r2.size : typeof r2 == "string" ? r2.length : r2 instanceof ArrayBuffer || ArrayBuffer.isView(r2) ? r2.byteLength : -1;
  }
  function Jc(r2) {
    return r2.replace(Cx, "");
  }
  async function Qs(r2) {
    if (qt(r2))
      return r2;
    let e = {}, t = th(r2);
    t >= 0 && (e["content-length"] = String(t));
    let { url: n, type: i } = Wr(r2);
    i && (e["content-type"] = i);
    let s = await Mx(r2);
    s && (e["x-first-bytes"] = s), typeof r2 == "string" && (r2 = new TextEncoder().encode(r2));
    let o = new Response(r2, { headers: e });
    return Object.defineProperty(o, "url", { value: n }), o;
  }
  async function rh(r2) {
    if (!r2.ok) {
      let e = await Rx(r2);
      throw new Error(e);
    }
  }
  async function Rx(r2) {
    let e = `Failed to fetch resource ${r2.url} (${r2.status}): `;
    try {
      let t = r2.headers.get("Content-Type"), n = r2.statusText;
      t.includes("application/json") && (n += ` ${await r2.text()}`), e += n, e = e.length > 60 ? `${e.slice(60)}...` : e;
    } catch (t) {
    }
    return e;
  }
  async function Mx(r2) {
    let e = 5;
    if (typeof r2 == "string")
      return `data:,${r2.slice(0, e)}`;
    if (r2 instanceof Blob) {
      let t = r2.slice(0, 5);
      return await new Promise((n) => {
        let i = new FileReader();
        i.onload = (s) => {
          var o;
          return n(s == null || (o = s.target) === null || o === void 0 ? void 0 : o.result);
        }, i.readAsDataURL(t);
      });
    }
    if (r2 instanceof ArrayBuffer) {
      let t = r2.slice(0, e);
      return `data:base64,${Ix(t)}`;
    }
    return null;
  }
  function Ix(r2) {
    let e = "", t = new Uint8Array(r2);
    for (let n = 0; n < t.byteLength; n++)
      e += String.fromCharCode(t[n]);
    return btoa(e);
  }
  async function $c(r2, e) {
    if (typeof r2 == "string") {
      r2 = Zc(r2);
      let t = e;
      return e != null && e.fetch && typeof (e == null ? void 0 : e.fetch) != "function" && (t = e.fetch), await fetch(r2, t);
    }
    return await Qs(r2);
  }
  function Ti(r2) {
    if (typeof window != "undefined" && typeof window.process == "object" && window.process.type === "renderer" || typeof process != "undefined" && typeof process.versions == "object" && Boolean(process.versions.electron))
      return true;
    let e = typeof navigator == "object" && typeof navigator.userAgent == "string" && navigator.userAgent, t = r2 || e;
    return !!(t && t.indexOf("Electron") >= 0);
  }
  function vi() {
    return !(typeof process == "object" && String(process) === "[object process]" && !process.browser) || Ti();
  }
  var gt = { self: typeof self != "undefined" && self, window: typeof window != "undefined" && window, global: typeof global != "undefined" && global, document: typeof document != "undefined" && document, process: typeof process == "object" && process };
  var Ox = gt.self || gt.window || gt.global;
  var fr = gt.window || gt.self || gt.global;
  var Nx = gt.global || gt.self || gt.window;
  var Fx = gt.document || {};
  var Js = gt.process || {};
  var el = typeof __VERSION__ != "undefined" ? __VERSION__ : "untranspiled source";
  var Hr = vi();
  function Dx(r2) {
    try {
      let e = window[r2], t = "__storage_test__";
      return e.setItem(t, t), e.removeItem(t), e;
    } catch (e) {
      return null;
    }
  }
  var $s = class {
    constructor(e, t, n = "sessionStorage") {
      this.storage = Dx(n), this.id = e, this.config = {}, Object.assign(this.config, t), this._loadConfiguration();
    }
    getConfiguration() {
      return this.config;
    }
    setConfiguration(e) {
      return this.config = {}, this.updateConfiguration(e);
    }
    updateConfiguration(e) {
      if (Object.assign(this.config, e), this.storage) {
        let t = JSON.stringify(this.config);
        this.storage.setItem(this.id, t);
      }
      return this;
    }
    _loadConfiguration() {
      let e = {};
      if (this.storage) {
        let t = this.storage.getItem(this.id);
        e = t ? JSON.parse(t) : {};
      }
      return Object.assign(this.config, e), this;
    }
  };
  function nh(r2) {
    let e;
    return r2 < 10 ? e = "".concat(r2.toFixed(2), "ms") : r2 < 100 ? e = "".concat(r2.toFixed(1), "ms") : r2 < 1e3 ? e = "".concat(r2.toFixed(0), "ms") : e = "".concat((r2 / 1e3).toFixed(2), "s"), e;
  }
  function ih(r2, e = 8) {
    let t = Math.max(e - r2.length, 0);
    return "".concat(" ".repeat(t)).concat(r2);
  }
  function eo(r2, e, t, n = 600) {
    let i = r2.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
    r2.width > n && (t = Math.min(t, n / r2.width));
    let s = r2.width * t, o = r2.height * t, a = ["font-size:1px;", "padding:".concat(Math.floor(o / 2), "px ").concat(Math.floor(s / 2), "px;"), "line-height:".concat(o, "px;"), "background:url(".concat(i, ");"), "background-size:".concat(s, "px ").concat(o, "px;"), "color:transparent;"].join("");
    return ["".concat(e, " %c+"), a];
  }
  var sh = { BLACK: 30, RED: 31, GREEN: 32, YELLOW: 33, BLUE: 34, MAGENTA: 35, CYAN: 36, WHITE: 37, BRIGHT_BLACK: 90, BRIGHT_RED: 91, BRIGHT_GREEN: 92, BRIGHT_YELLOW: 93, BRIGHT_BLUE: 94, BRIGHT_MAGENTA: 95, BRIGHT_CYAN: 96, BRIGHT_WHITE: 97 };
  function oh(r2) {
    return typeof r2 == "string" ? sh[r2.toUpperCase()] || sh.WHITE : r2;
  }
  function ah(r2, e, t) {
    return !Hr && typeof r2 == "string" && (e && (e = oh(e), r2 = "[".concat(e, "m").concat(r2, "[39m")), t && (e = oh(t), r2 = "[".concat(t + 10, "m").concat(r2, "[49m"))), r2;
  }
  function ch(r2, e = ["constructor"]) {
    let t = Object.getPrototypeOf(r2), n = Object.getOwnPropertyNames(t);
    for (let i of n)
      typeof r2[i] == "function" && (e.find((s) => i === s) || (r2[i] = r2[i].bind(r2)));
  }
  function pn(r2, e) {
    if (!r2)
      throw new Error(e || "Assertion failed");
  }
  function ur() {
    let r2;
    if (Hr && fr.performance)
      r2 = fr.performance.now();
    else if (Js.hrtime) {
      let e = Js.hrtime();
      r2 = e[0] * 1e3 + e[1] / 1e6;
    } else
      r2 = Date.now();
    return r2;
  }
  var mn = { debug: Hr && console.debug || console.log, log: console.log, info: console.info, warn: console.warn, error: console.error };
  var Bx = { enabled: true, level: 0 };
  function it() {
  }
  var lh = {};
  var fh = { once: true };
  function Ux(r2) {
    for (let e in r2)
      for (let t in r2[e])
        return t || "untitled";
    return "empty";
  }
  var st = class {
    constructor({ id: e } = { id: "" }) {
      this.id = e, this.VERSION = el, this._startTs = ur(), this._deltaTs = ur(), this.LOG_THROTTLE_TIMEOUT = 0, this._storage = new $s("__probe-".concat(this.id, "__"), Bx), this.userData = {}, this.timeStamp("".concat(this.id, " started")), ch(this), Object.seal(this);
    }
    set level(e) {
      this.setLevel(e);
    }
    get level() {
      return this.getLevel();
    }
    isEnabled() {
      return this._storage.config.enabled;
    }
    getLevel() {
      return this._storage.config.level;
    }
    getTotal() {
      return Number((ur() - this._startTs).toPrecision(10));
    }
    getDelta() {
      return Number((ur() - this._deltaTs).toPrecision(10));
    }
    set priority(e) {
      this.level = e;
    }
    get priority() {
      return this.level;
    }
    getPriority() {
      return this.level;
    }
    enable(e = true) {
      return this._storage.updateConfiguration({ enabled: e }), this;
    }
    setLevel(e) {
      return this._storage.updateConfiguration({ level: e }), this;
    }
    assert(e, t) {
      pn(e, t);
    }
    warn(e) {
      return this._getLogFunction(0, e, mn.warn, arguments, fh);
    }
    error(e) {
      return this._getLogFunction(0, e, mn.error, arguments);
    }
    deprecated(e, t) {
      return this.warn("`".concat(e, "` is deprecated and will be removed in a later version. Use `").concat(t, "` instead"));
    }
    removed(e, t) {
      return this.error("`".concat(e, "` has been removed. Use `").concat(t, "` instead"));
    }
    probe(e, t) {
      return this._getLogFunction(e, t, mn.log, arguments, { time: true, once: true });
    }
    log(e, t) {
      return this._getLogFunction(e, t, mn.debug, arguments);
    }
    info(e, t) {
      return this._getLogFunction(e, t, console.info, arguments);
    }
    once(e, t) {
      return this._getLogFunction(e, t, mn.debug || mn.info, arguments, fh);
    }
    table(e, t, n) {
      return t ? this._getLogFunction(e, t, console.table || it, n && [n], { tag: Ux(t) }) : it;
    }
    image({ logLevel: e, priority: t, image: n, message: i = "", scale: s = 1 }) {
      return this._shouldLog(e || t) ? Hr ? Gx({ image: n, message: i, scale: s }) : Vx({ image: n, message: i, scale: s }) : it;
    }
    settings() {
      console.table ? console.table(this._storage.config) : console.log(this._storage.config);
    }
    get(e) {
      return this._storage.config[e];
    }
    set(e, t) {
      this._storage.updateConfiguration({ [e]: t });
    }
    time(e, t) {
      return this._getLogFunction(e, t, console.time ? console.time : console.info);
    }
    timeEnd(e, t) {
      return this._getLogFunction(e, t, console.timeEnd ? console.timeEnd : console.info);
    }
    timeStamp(e, t) {
      return this._getLogFunction(e, t, console.timeStamp || it);
    }
    group(e, t, n = { collapsed: false }) {
      n = hh({ logLevel: e, message: t, opts: n });
      let { collapsed: i } = n;
      return n.method = (i ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(n);
    }
    groupCollapsed(e, t, n = {}) {
      return this.group(e, t, Object.assign({}, n, { collapsed: true }));
    }
    groupEnd(e) {
      return this._getLogFunction(e, "", console.groupEnd || it);
    }
    withGroup(e, t, n) {
      this.group(e, t)();
      try {
        n();
      } finally {
        this.groupEnd(e)();
      }
    }
    trace() {
      console.trace && console.trace();
    }
    _shouldLog(e) {
      return this.isEnabled() && this.getLevel() >= uh(e);
    }
    _getLogFunction(e, t, n, i = [], s) {
      if (this._shouldLog(e)) {
        s = hh({ logLevel: e, message: t, args: i, opts: s }), n = n || s.method, pn(n), s.total = this.getTotal(), s.delta = this.getDelta(), this._deltaTs = ur();
        let o = s.tag || s.message;
        if (s.once)
          if (!lh[o])
            lh[o] = ur();
          else
            return it;
        return t = kx(this.id, s.message, s), n.bind(console, t, ...s.args);
      }
      return it;
    }
  };
  st.VERSION = el;
  function uh(r2) {
    if (!r2)
      return 0;
    let e;
    switch (typeof r2) {
      case "number":
        e = r2;
        break;
      case "object":
        e = r2.logLevel || r2.priority || 0;
        break;
      default:
        return 0;
    }
    return pn(Number.isFinite(e) && e >= 0), e;
  }
  function hh(r2) {
    let { logLevel: e, message: t } = r2;
    r2.logLevel = uh(e);
    let n = r2.args ? Array.from(r2.args) : [];
    for (; n.length && n.shift() !== t; )
      ;
    switch (r2.args = n, typeof e) {
      case "string":
      case "function":
        t !== void 0 && n.unshift(t), r2.message = e;
        break;
      case "object":
        Object.assign(r2, e);
        break;
      default:
    }
    typeof r2.message == "function" && (r2.message = r2.message());
    let i = typeof r2.message;
    return pn(i === "string" || i === "object"), Object.assign(r2, r2.opts);
  }
  function kx(r2, e, t) {
    if (typeof e == "string") {
      let n = t.time ? ih(nh(t.total)) : "";
      e = t.time ? "".concat(r2, ": ").concat(n, "  ").concat(e) : "".concat(r2, ": ").concat(e), e = ah(e, t.color, t.background);
    }
    return e;
  }
  function Vx({ image: r2, message: e = "", scale: t = 1 }) {
    let n = null;
    try {
      n = module.require("asciify-image");
    } catch (i) {
    }
    return n ? () => n(r2, { fit: "box", width: "".concat(Math.round(80 * t), "%") }).then((i) => console.log(i)) : it;
  }
  function Gx({ image: r2, message: e = "", scale: t = 1 }) {
    if (typeof r2 == "string") {
      let i = new Image();
      return i.onload = () => {
        let s = eo(i, e, t);
        console.log(...s);
      }, i.src = r2, it;
    }
    let n = r2.nodeName || "";
    if (n.toLowerCase() === "img")
      return console.log(...eo(r2, e, t)), it;
    if (n.toLowerCase() === "canvas") {
      let i = new Image();
      return i.onload = () => console.log(...eo(i, e, t)), i.src = r2.toDataURL(), it;
    }
    return it;
  }
  function to(r2) {
    if (!r2 && !vi())
      return "Node";
    if (Ti(r2))
      return "Electron";
    let e = typeof navigator != "undefined" ? navigator : {}, t = r2 || e.userAgent || "";
    if (t.indexOf("Edge") > -1)
      return "Edge";
    let n = t.indexOf("MSIE ") !== -1, i = t.indexOf("Trident/") !== -1;
    return n || i ? "IE" : fr.chrome ? "Chrome" : fr.safari ? "Safari" : fr.mozInnerScreenX ? "Firefox" : "Unknown";
  }
  var TC = new st({ id: "probe.gl" });
  var tl = new st({ id: "loaders.gl" });
  var rl = class {
    log() {
      return () => {
      };
    }
    info() {
      return () => {
      };
    }
    warn() {
      return () => {
      };
    }
    error() {
      return () => {
      };
    }
  };
  var nl = class {
    constructor() {
      G(this, "console", void 0), this.console = console;
    }
    log(...e) {
      return this.console.log.bind(this.console, ...e);
    }
    info(...e) {
      return this.console.info.bind(this.console, ...e);
    }
    warn(...e) {
      return this.console.warn.bind(this.console, ...e);
    }
    error(...e) {
      return this.console.error.bind(this.console, ...e);
    }
  };
  var il = { fetch: null, mimeType: void 0, nothrow: false, log: new nl(), CDN: "https://unpkg.com/@loaders.gl", worker: true, maxConcurrency: 3, maxMobileConcurrency: 1, reuseWorkers: true, _workerType: "", limit: 0, _limitMB: 0, batchSize: "auto", batchDebounceMs: 0, metadata: false, transforms: [] };
  var dh = { throws: "nothrow", dataType: "(no longer used)", uri: "baseUri", method: "fetch.method", headers: "fetch.headers", body: "fetch.body", mode: "fetch.mode", credentials: "fetch.credentials", cache: "fetch.cache", redirect: "fetch.redirect", referrer: "fetch.referrer", referrerPolicy: "fetch.referrerPolicy", integrity: "fetch.integrity", keepalive: "fetch.keepalive", signal: "fetch.signal" };
  function sl() {
    xi.loaders = xi.loaders || {};
    let { loaders: r2 } = xi;
    return r2._state = r2._state || {}, r2._state;
  }
  var ph = () => {
    let r2 = sl();
    return r2.globalOptions = r2.globalOptions || x({}, il), r2.globalOptions;
  };
  function mh(r2, e, t, n) {
    return t = t || [], t = Array.isArray(t) ? t : [t], zx(r2, t), Wx(e, r2, n);
  }
  function ro(r2, e) {
    let t = ph(), n = r2 || t;
    return typeof n.fetch == "function" ? n.fetch : dn(n.fetch) ? (i) => $c(i, n) : e != null && e.fetch ? e == null ? void 0 : e.fetch : $c;
  }
  function zx(r2, e) {
    gh(r2, null, il, dh, e);
    for (let t of e) {
      let n = r2 && r2[t.id] || {}, i = t.options && t.options[t.id] || {}, s = t.deprecatedOptions && t.deprecatedOptions[t.id] || {};
      gh(n, t.id, i, s, e);
    }
  }
  function gh(r2, e, t, n, i) {
    let s = e || "Top level", o = e ? `${e}.` : "";
    for (let a in r2) {
      let c = !e && dn(r2[a]), l = a === "baseUri" && !e, f = a === "workerUrl" && e;
      if (!(a in t) && !l && !f) {
        if (a in n)
          tl.warn(`${s} loader option '${o}${a}' no longer supported, use '${n[a]}'`)();
        else if (!c) {
          let u = jx(a, i);
          tl.warn(`${s} loader option '${o}${a}' not recognized. ${u}`)();
        }
      }
    }
  }
  function jx(r2, e) {
    let t = r2.toLowerCase(), n = "";
    for (let i of e)
      for (let s in i.options) {
        if (r2 === s)
          return `Did you mean '${i.id}.${s}'?`;
        let o = s.toLowerCase();
        (t.startsWith(o) || o.startsWith(t)) && (n = n || `Did you mean '${i.id}.${s}'?`);
      }
    return n;
  }
  function Wx(r2, e, t) {
    let n = r2.options || {}, i = x({}, n);
    return Hx(i, t), i.log === null && (i.log = new rl()), _h(i, ph()), _h(i, e), i;
  }
  function _h(r2, e) {
    for (let t in e)
      if (t in e) {
        let n = e[t];
        Kc(n) && Kc(r2[t]) ? r2[t] = x(x({}, r2[t]), e[t]) : r2[t] = e[t];
      }
  }
  function Hx(r2, e) {
    e && !("baseUri" in r2) && (r2.baseUri = e);
  }
  function Ai(r2) {
    var e;
    return r2 ? (Array.isArray(r2) && (r2 = r2[0]), Array.isArray((e = r2) === null || e === void 0 ? void 0 : e.extensions)) : false;
  }
  function Si(r2) {
    var e, t;
    Xs(r2, "null loader"), Xs(Ai(r2), "invalid loader");
    let n;
    return Array.isArray(r2) && (n = r2[1], r2 = r2[0], r2 = L(x({}, r2), { options: x(x({}, r2.options), n) })), ((e = r2) !== null && e !== void 0 && e.parseTextSync || (t = r2) !== null && t !== void 0 && t.parseText) && (r2.text = true), r2.text || (r2.binary = true), r2;
  }
  var xh = () => {
    let r2 = sl();
    return r2.loaderRegistry = r2.loaderRegistry || [], r2.loaderRegistry;
  };
  function ol(r2) {
    let e = xh();
    r2 = Array.isArray(r2) ? r2 : [r2];
    for (let t of r2) {
      let n = Si(t);
      e.find((i) => n === i) || e.unshift(n);
    }
  }
  function yh() {
    return xh();
  }
  var Xx = /\.([^.]+)$/;
  async function Eh(r2, e = [], t, n) {
    if (!Th(r2))
      return null;
    let i = bh(r2, e, L(x({}, t), { nothrow: true }), n);
    if (i)
      return i;
    if (mt(r2) && (r2 = await r2.slice(0, 10).arrayBuffer(), i = bh(r2, e, t, n)), !i && !(t != null && t.nothrow))
      throw new Error(vh(r2));
    return i;
  }
  function bh(r2, e = [], t, n) {
    if (!Th(r2))
      return null;
    if (e && !Array.isArray(e))
      return Si(e);
    let i = [];
    e && (i = i.concat(e)), t != null && t.ignoreRegisteredLoaders || i.push(...yh()), qx(i);
    let s = Yx(r2, i, t, n);
    if (!s && !(t != null && t.nothrow))
      throw new Error(vh(r2));
    return s;
  }
  function Yx(r2, e, t, n) {
    let { url: i, type: s } = Wr(r2), o = i || (n == null ? void 0 : n.url), a = null;
    return t != null && t.mimeType && (a = al(e, t == null ? void 0 : t.mimeType)), a = a || Zx(e, o), a = a || al(e, s), a = a || Qx(e, r2), a = a || al(e, t == null ? void 0 : t.fallbackMimeType), a;
  }
  function Th(r2) {
    return !(r2 instanceof Response && r2.status === 204);
  }
  function vh(r2) {
    let { url: e, type: t } = Wr(r2), n = "No valid loader found";
    return r2 && (n += ` data: "${ey(r2)}", contentType: "${t}"`), e && (n += ` url: ${e}`), n;
  }
  function qx(r2) {
    for (let e of r2)
      Si(e);
  }
  function Zx(r2, e) {
    let t = e && Xx.exec(e), n = t && t[1];
    return n ? Kx(r2, n) : null;
  }
  function Kx(r2, e) {
    e = e.toLowerCase();
    for (let t of r2)
      for (let n of t.extensions)
        if (n.toLowerCase() === e)
          return t;
    return null;
  }
  function al(r2, e) {
    for (let t of r2)
      if (t.mimeTypes && t.mimeTypes.includes(e) || e === `application/x.${t.id}`)
        return t;
    return null;
  }
  function Qx(r2, e) {
    if (!e)
      return null;
    for (let t of r2)
      if (typeof e == "string") {
        if (Jx(e, t))
          return t;
      } else if (ArrayBuffer.isView(e)) {
        if (Ah(e.buffer, e.byteOffset, t))
          return t;
      } else if (e instanceof ArrayBuffer && Ah(e, 0, t))
        return t;
    return null;
  }
  function Jx(r2, e) {
    return e.testText ? e.testText(r2) : (Array.isArray(e.tests) ? e.tests : [e.tests]).some((n) => r2.startsWith(n));
  }
  function Ah(r2, e, t) {
    return (Array.isArray(t.tests) ? t.tests : [t.tests]).some((i) => $x(r2, e, t, i));
  }
  function $x(r2, e, t, n) {
    if (n instanceof ArrayBuffer)
      return Xc(n, r2, n.byteLength);
    switch (typeof n) {
      case "function":
        return n(r2, t);
      case "string":
        let i = cl(r2, e, n.length);
        return n === i;
      default:
        return false;
    }
  }
  function ey(r2, e = 5) {
    return typeof r2 == "string" ? r2.slice(0, e) : ArrayBuffer.isView(r2) ? cl(r2.buffer, r2.byteOffset, e) : r2 instanceof ArrayBuffer ? cl(r2, 0, e) : "";
  }
  function cl(r2, e, t) {
    if (r2.byteLength < e + t)
      return "";
    let n = new DataView(r2), i = "";
    for (let s = 0; s < t; s++)
      i += String.fromCharCode(n.getUint8(e + s));
    return i;
  }
  var ty = 256 * 1024;
  function* Sh(r2, e) {
    let t = (e == null ? void 0 : e.chunkSize) || ty, n = 0, i = new TextEncoder();
    for (; n < r2.length; ) {
      let s = Math.min(r2.length - n, t), o = r2.slice(n, n + s);
      n += s, yield i.encode(o);
    }
  }
  var ry = 256 * 1024;
  function* wh(r2, e = {}) {
    let { chunkSize: t = ry } = e, n = 0;
    for (; n < r2.byteLength; ) {
      let i = Math.min(r2.byteLength - n, t), s = new ArrayBuffer(i), o = new Uint8Array(r2, n, i);
      new Uint8Array(s).set(o), n += i, yield s;
    }
  }
  var ny = 1024 * 1024;
  async function* Ph(r2, e) {
    let t = (e == null ? void 0 : e.chunkSize) || ny, n = 0;
    for (; n < r2.size; ) {
      let i = n + t, s = await r2.slice(n, i).arrayBuffer();
      n = i, yield s;
    }
  }
  function ll(r2, e) {
    return Bc ? iy(r2, e) : sy(r2, e);
  }
  async function* iy(r2, e) {
    let t = r2.getReader(), n;
    try {
      for (; ; ) {
        let i = n || t.read();
        e != null && e._streamReadAhead && (n = t.read());
        let { done: s, value: o } = await i;
        if (s)
          return;
        yield Zs(o);
      }
    } catch (i) {
      t.releaseLock();
    }
  }
  async function* sy(r2, e) {
    for await (let t of r2)
      yield Zs(t);
  }
  function Lh(r2, e) {
    if (typeof r2 == "string")
      return Sh(r2, e);
    if (r2 instanceof ArrayBuffer)
      return wh(r2, e);
    if (mt(r2))
      return Ph(r2, e);
    if (Ks(r2))
      return ll(r2, e);
    if (qt(r2))
      return ll(r2.body, e);
    throw new Error("makeIterator");
  }
  var Ch = "Cannot convert supplied data type";
  function oy(r2, e, t) {
    if (e.text && typeof r2 == "string")
      return r2;
    if ($u(r2) && (r2 = r2.buffer), r2 instanceof ArrayBuffer) {
      let n = r2;
      return e.text && !e.binary ? new TextDecoder("utf8").decode(n) : n;
    }
    if (ArrayBuffer.isView(r2)) {
      if (e.text && !e.binary)
        return new TextDecoder("utf8").decode(r2);
      let n = r2.buffer, i = r2.byteLength || r2.length;
      return (r2.byteOffset !== 0 || i !== n.byteLength) && (n = n.slice(r2.byteOffset, r2.byteOffset + i)), n;
    }
    throw new Error(Ch);
  }
  async function Rh(r2, e, t) {
    let n = r2 instanceof ArrayBuffer || ArrayBuffer.isView(r2);
    if (typeof r2 == "string" || n)
      return oy(r2, e, t);
    if (mt(r2) && (r2 = await Qs(r2)), qt(r2)) {
      let i = r2;
      return await rh(i), e.binary ? await i.arrayBuffer() : await i.text();
    }
    if (Ks(r2) && (r2 = Lh(r2, t)), Qu(r2) || Ju(r2))
      return qc(r2);
    throw new Error(Ch);
  }
  function Mh(r2, e, t = null) {
    if (t)
      return t;
    let n = x({ fetch: ro(e, r2) }, r2);
    return Array.isArray(n.loaders) || (n.loaders = null), n;
  }
  function Ih(r2, e) {
    if (!e && r2 && !Array.isArray(r2))
      return r2;
    let t;
    if (r2 && (t = Array.isArray(r2) ? r2 : [r2]), e && e.loaders) {
      let n = Array.isArray(e.loaders) ? e.loaders : [e.loaders];
      t = t ? [...t, ...n] : n;
    }
    return t && t.length ? t : null;
  }
  async function no(r2, e, t, n) {
    we(!n || typeof n == "object"), e && !Array.isArray(e) && !Ai(e) && (n = void 0, t = e, e = void 0), r2 = await r2, t = t || {};
    let { url: i } = Wr(r2), o = Ih(e, n), a = await Eh(r2, o, t);
    return a ? (t = mh(t, a, o, i), n = Mh({ url: i, parse: no, loaders: o }, t, n), await ay(a, r2, t, n)) : null;
  }
  async function ay(r2, e, t, n) {
    if (zc(r2), e = await Rh(e, r2, t), r2.parseTextSync && typeof e == "string")
      return t.dataType = "text", r2.parseTextSync(e, t, n, r2);
    if (jc(r2, t))
      return await Wc(r2, e, t, n, no);
    if (r2.parseText && typeof e == "string")
      return await r2.parseText(e, t, n, r2);
    if (r2.parse)
      return await r2.parse(e, t, n, r2);
    throw we(!r2.parseSync), new Error(`${r2.id} loader - no parser found and worker is disabled`);
  }
  async function hr(r2, e, t, n) {
    !Array.isArray(e) && !Ai(e) && (n = void 0, t = e, e = void 0);
    let i = ro(t), s = r2;
    return typeof r2 == "string" && (s = await i(r2)), mt(r2) && (s = await i(r2)), await no(s, e, t);
  }
  var Oh = "3.0.8";
  function io(r2, e) {
    if (!r2)
      throw new Error(e);
  }
  var Nt = { self: typeof self != "undefined" && self, window: typeof window != "undefined" && window, global: typeof global != "undefined" && global, document: typeof document != "undefined" && document };
  var OR = Nt.self || Nt.window || Nt.global;
  var NR = Nt.window || Nt.self || Nt.global;
  var so = Nt.global || Nt.self || Nt.window;
  var FR = Nt.document || {};
  var Nh = typeof process != "object" || String(process) !== "[object process]" || process.browser;
  var DR = typeof importScripts == "function";
  var Fh = typeof process != "undefined" && process.version && /v([0-9]*)/.exec(process.version);
  var BR = Fh && parseFloat(Fh[1]) || 0;
  var { _parseImageNode: cy } = so;
  var fl = typeof Image != "undefined";
  var ul = typeof ImageBitmap != "undefined";
  var ly = Boolean(cy);
  var hl = Nh ? true : ly;
  function Dh(r2) {
    switch (r2) {
      case "auto":
        return ul || fl || hl;
      case "imagebitmap":
        return ul;
      case "image":
        return fl;
      case "data":
        return hl;
      default:
        throw new Error(`@loaders.gl/images: image ${r2} not supported in this environment`);
    }
  }
  function Bh() {
    if (ul)
      return "imagebitmap";
    if (fl)
      return "image";
    if (hl)
      return "data";
    throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
  }
  function fy(r2) {
    let e = uy(r2);
    if (!e)
      throw new Error("Not an image");
    return e;
  }
  function Uh(r2) {
    switch (fy(r2)) {
      case "data":
        return r2;
      case "image":
      case "imagebitmap":
        let e = document.createElement("canvas"), t = e.getContext("2d");
        if (!t)
          throw new Error("getImageData");
        return e.width = r2.width, e.height = r2.height, t.drawImage(r2, 0, 0), t.getImageData(0, 0, r2.width, r2.height);
      default:
        throw new Error("getImageData");
    }
  }
  function uy(r2) {
    return typeof ImageBitmap != "undefined" && r2 instanceof ImageBitmap ? "imagebitmap" : typeof Image != "undefined" && r2 instanceof Image ? "image" : r2 && typeof r2 == "object" && r2.data && r2.width && r2.height ? "data" : null;
  }
  var hy = /^data:image\/svg\+xml/;
  var dy = /\.svg((\?|#).*)?$/;
  function oo(r2) {
    return r2 && (hy.test(r2) || dy.test(r2));
  }
  function kh(r2, e) {
    if (oo(e)) {
      let n = new TextDecoder().decode(r2);
      return `data:image/svg+xml;base64,${btoa(n)}`;
    }
    return dl(r2, e);
  }
  function dl(r2, e) {
    if (oo(e))
      throw new Error("SVG cannot be parsed directly to imagebitmap");
    return new Blob([new Uint8Array(r2)]);
  }
  async function wi(r2, e, t) {
    let n = kh(r2, t), i = self.URL || self.webkitURL, s = typeof n != "string" && i.createObjectURL(n);
    try {
      return await py(s || n, e);
    } finally {
      s && i.revokeObjectURL(s);
    }
  }
  async function py(r2, e) {
    let t = new Image();
    return t.src = r2, e.image && e.image.decode && t.decode ? (await t.decode(), t) : await new Promise((n, i) => {
      try {
        t.onload = () => n(t), t.onerror = (s) => i(new Error(`Could not load image ${r2}: ${s}`));
      } catch (s) {
        i(s);
      }
    });
  }
  var my = {};
  var Vh = true;
  async function pl(r2, e, t) {
    let n;
    oo(t) ? n = await wi(r2, e, t) : n = dl(r2, t);
    let i = e && e.imagebitmap;
    return await gy(n, i);
  }
  async function gy(r2, e = null) {
    if ((_y(e) || !Vh) && (e = null), e)
      try {
        return await createImageBitmap(r2, e);
      } catch (t) {
        console.warn(t), Vh = false;
      }
    return await createImageBitmap(r2);
  }
  function _y(r2) {
    for (let e in r2 || my)
      return false;
    return true;
  }
  var Ft = false;
  var Pi = true;
  function ao(r2) {
    let e = Li(r2);
    return xy(e) || by(e) || yy(e) || Ey(e);
  }
  function xy(r2) {
    let e = Li(r2);
    return e.byteLength >= 24 && e.getUint32(0, Ft) === 2303741511 ? { mimeType: "image/png", width: e.getUint32(16, Ft), height: e.getUint32(20, Ft) } : null;
  }
  function yy(r2) {
    let e = Li(r2);
    return e.byteLength >= 10 && e.getUint32(0, Ft) === 1195984440 ? { mimeType: "image/gif", width: e.getUint16(6, Pi), height: e.getUint16(8, Pi) } : null;
  }
  function Ey(r2) {
    let e = Li(r2);
    return e.byteLength >= 14 && e.getUint16(0, Ft) === 16973 && e.getUint32(2, Pi) === e.byteLength ? { mimeType: "image/bmp", width: e.getUint32(18, Pi), height: e.getUint32(22, Pi) } : null;
  }
  function by(r2) {
    let e = Li(r2);
    if (!(e.byteLength >= 3 && e.getUint16(0, Ft) === 65496 && e.getUint8(2) === 255))
      return null;
    let { tableMarkers: n, sofMarkers: i } = Ty(), s = 2;
    for (; s + 9 < e.byteLength; ) {
      let o = e.getUint16(s, Ft);
      if (i.has(o))
        return { mimeType: "image/jpeg", height: e.getUint16(s + 5, Ft), width: e.getUint16(s + 7, Ft) };
      if (!n.has(o))
        return null;
      s += 2, s += e.getUint16(s, Ft);
    }
    return null;
  }
  function Ty() {
    let r2 = new Set([65499, 65476, 65484, 65501, 65534]);
    for (let t = 65504; t < 65520; ++t)
      r2.add(t);
    let e = new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502]);
    return { tableMarkers: r2, sofMarkers: e };
  }
  function Li(r2) {
    if (r2 instanceof DataView)
      return r2;
    if (ArrayBuffer.isView(r2))
      return new DataView(r2.buffer);
    if (r2 instanceof ArrayBuffer)
      return new DataView(r2);
    throw new Error("toDataView");
  }
  function ml(r2, e) {
    let { mimeType: t } = ao(r2) || {}, { _parseImageNode: n } = so;
    return io(n), n(r2, t, e);
  }
  async function gl(r2, e, t) {
    e = e || {};
    let i = (e.image || {}).type || "auto", { url: s } = t || {}, o = vy(i), a;
    switch (o) {
      case "imagebitmap":
        a = await pl(r2, e, s);
        break;
      case "image":
        a = await wi(r2, e, s);
        break;
      case "data":
        a = await ml(r2, e);
        break;
      default:
        io(false);
    }
    return i === "data" && (a = Uh(a)), a;
  }
  function vy(r2) {
    switch (r2) {
      case "auto":
      case "data":
        return Bh();
      default:
        return Dh(r2), r2;
    }
  }
  var Ay = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg"];
  var Sy = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"];
  var Ci = { id: "image", module: "images", name: "Images", version: Oh, mimeTypes: Sy, extensions: Ay, parse: gl, tests: [(r2) => Boolean(ao(new DataView(r2)))], options: { image: { type: "auto", decode: true } } };
  var xn = Mt(dr());
  var F = new st({ id: "deck" });
  var bl = {};
  function Qh(r2) {
    bl = r2;
  }
  function se(r2) {
    F.level > 0 && bl[r2] && bl[r2].call(...arguments);
  }
  function Yy(r2) {
    let e = r2[0], t = r2[r2.length - 1];
    return e === "{" && t === "}" || e === "[" && t === "]";
  }
  var Jh = { name: "JSON", extensions: ["json", "geojson"], mimeTypes: ["application/json", "application/geo+json"], testText: Yy, parseTextSync: JSON.parse };
  var Ii = "8.5.2";
  var po = xn.global.deck && xn.global.deck.VERSION;
  if (po && po !== Ii)
    throw new Error("deck.gl - multiple versions detected: ".concat(po, " vs ").concat(Ii));
  po || (F.log(1, "deck.gl ".concat(Ii))(), xn.global.deck = Object.assign(xn.global.deck || {}, { VERSION: Ii, version: Ii, log: F, _registerLoggers: Qh }), ol([Jh, [Ci, { imagebitmap: { premultiplyAlpha: "none" } }]]));
  var $h = xn.global.deck;
  var I = new st({ id: "luma.gl" });
  function le(r2, e) {
    if (!r2)
      throw new Error(e || "luma.gl: assertion failed.");
  }
  var qy = "Invalid WebGLRenderingContext";
  var Zy = "Requires WebGL2";
  function Zt(r2) {
    return typeof WebGLRenderingContext != "undefined" && r2 instanceof WebGLRenderingContext || typeof WebGL2RenderingContext != "undefined" && r2 instanceof WebGL2RenderingContext ? true : Boolean(r2 && Number.isFinite(r2._version));
  }
  function U(r2) {
    return typeof WebGL2RenderingContext != "undefined" && r2 instanceof WebGL2RenderingContext ? true : Boolean(r2 && r2._version === 2);
  }
  function Tl(r2) {
    return U(r2) ? r2 : null;
  }
  function Kt(r2) {
    return le(Zt(r2), qy), r2;
  }
  function te(r2) {
    return le(U(r2), Zy), r2;
  }
  var Xr = Mt(dr());
  var Oi = {};
  function Ky(r2) {
    Xr.global.console && Xr.global.console.error && Xr.global.console.error(r2);
  }
  function Qy(r2) {
    Xr.global.console && Xr.global.console.log && Xr.global.console.log(r2);
  }
  function Jy(r2, e) {
    Oi[r2] = true, e !== void 0 && Ky(e);
  }
  function $y(r2) {
    let e = r2.getError;
    r2.getError = function() {
      let n;
      do
        n = e.apply(r2), n !== 0 && (Oi[n] = true);
      while (n !== 0);
      for (n in Oi)
        if (Oi[n])
          return delete Oi[n], parseInt(n, 10);
      return 0;
    };
  }
  var Ni = function r(e) {
    let t = e.gl;
    this.ext = e, this.isAlive = true, this.hasBeenBound = false, this.elementArrayBuffer = null, this.attribs = new Array(e.maxVertexAttribs);
    for (let n = 0; n < this.attribs.length; n++) {
      let i = new r.VertexAttrib(t);
      this.attribs[n] = i;
    }
    this.maxAttrib = 0;
  };
  Ni.VertexAttrib = function(e) {
    this.enabled = false, this.buffer = null, this.size = 4, this.type = 5126, this.normalized = false, this.stride = 16, this.offset = 0, this.cached = "", this.recache();
  };
  Ni.VertexAttrib.prototype.recache = function() {
    this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
  };
  var Yr = function(e) {
    let t = this;
    this.gl = e, $y(e);
    let n = this.original = { getParameter: e.getParameter, enableVertexAttribArray: e.enableVertexAttribArray, disableVertexAttribArray: e.disableVertexAttribArray, bindBuffer: e.bindBuffer, getVertexAttrib: e.getVertexAttrib, vertexAttribPointer: e.vertexAttribPointer };
    e.getParameter = function(s) {
      return s === t.VERTEX_ARRAY_BINDING_OES ? t.currentVertexArrayObject === t.defaultVertexArrayObject ? null : t.currentVertexArrayObject : n.getParameter.apply(this, arguments);
    }, e.enableVertexAttribArray = function(s) {
      let o = t.currentVertexArrayObject;
      o.maxAttrib = Math.max(o.maxAttrib, s);
      let a = o.attribs[s];
      return a.enabled = true, n.enableVertexAttribArray.apply(this, arguments);
    }, e.disableVertexAttribArray = function(s) {
      let o = t.currentVertexArrayObject;
      o.maxAttrib = Math.max(o.maxAttrib, s);
      let a = o.attribs[s];
      return a.enabled = false, n.disableVertexAttribArray.apply(this, arguments);
    }, e.bindBuffer = function(s, o) {
      switch (s) {
        case 34962:
          t.currentArrayBuffer = o;
          break;
        case 34963:
          t.currentVertexArrayObject.elementArrayBuffer = o;
          break;
        default:
      }
      return n.bindBuffer.apply(this, arguments);
    }, e.getVertexAttrib = function(s, o) {
      let c = t.currentVertexArrayObject.attribs[s];
      switch (o) {
        case 34975:
          return c.buffer;
        case 34338:
          return c.enabled;
        case 34339:
          return c.size;
        case 34340:
          return c.stride;
        case 34341:
          return c.type;
        case 34922:
          return c.normalized;
        default:
          return n.getVertexAttrib.apply(this, arguments);
      }
    }, e.vertexAttribPointer = function(s, o, a, c, l, f) {
      let u = t.currentVertexArrayObject;
      u.maxAttrib = Math.max(u.maxAttrib, s);
      let h = u.attribs[s];
      return h.buffer = t.currentArrayBuffer, h.size = o, h.type = a, h.normalized = c, h.stride = l, h.offset = f, h.recache(), n.vertexAttribPointer.apply(this, arguments);
    }, e.instrumentExtension && e.instrumentExtension(this, "OES_vertex_array_object"), e.canvas && e.canvas.addEventListener("webglcontextrestored", () => {
      Qy("OESVertexArrayObject emulation library context restored"), t.reset_();
    }, true), this.reset_();
  };
  Yr.prototype.VERTEX_ARRAY_BINDING_OES = 34229;
  Yr.prototype.reset_ = function() {
    if (this.vertexArrayObjects !== void 0)
      for (let n = 0; n < this.vertexArrayObjects.length; ++n)
        this.vertexArrayObjects.isAlive = false;
    let t = this.gl;
    this.maxVertexAttribs = t.getParameter(34921), this.defaultVertexArrayObject = new Ni(this), this.currentVertexArrayObject = null, this.currentArrayBuffer = null, this.vertexArrayObjects = [this.defaultVertexArrayObject], this.bindVertexArrayOES(null);
  };
  Yr.prototype.createVertexArrayOES = function() {
    let e = new Ni(this);
    return this.vertexArrayObjects.push(e), e;
  };
  Yr.prototype.deleteVertexArrayOES = function(e) {
    e.isAlive = false, this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(e), 1), this.currentVertexArrayObject === e && this.bindVertexArrayOES(null);
  };
  Yr.prototype.isVertexArrayOES = function(e) {
    return !!(e && e instanceof Ni && e.hasBeenBound && e.ext === this);
  };
  Yr.prototype.bindVertexArrayOES = function(e) {
    let t = this.gl;
    if (e && !e.isAlive) {
      Jy(1282, "bindVertexArrayOES: attempt to bind deleted arrayObject");
      return;
    }
    let n = this.original, i = this.currentVertexArrayObject;
    this.currentVertexArrayObject = e || this.defaultVertexArrayObject, this.currentVertexArrayObject.hasBeenBound = true;
    let s = this.currentVertexArrayObject;
    if (i === s)
      return;
    (!i || s.elementArrayBuffer !== i.elementArrayBuffer) && n.bindBuffer.call(t, 34963, s.elementArrayBuffer);
    let o = this.currentArrayBuffer, a = Math.max(i ? i.maxAttrib : 0, s.maxAttrib);
    for (let c = 0; c <= a; c++) {
      let l = s.attribs[c], f = i ? i.attribs[c] : null;
      if ((!i || l.enabled !== f.enabled) && (l.enabled ? n.enableVertexAttribArray.call(t, c) : n.disableVertexAttribArray.call(t, c)), l.enabled) {
        let u = false;
        (!i || l.buffer !== f.buffer) && (o !== l.buffer && (n.bindBuffer.call(t, 34962, l.buffer), o = l.buffer), u = true), (u || l.cached !== f.cached) && n.vertexAttribPointer.call(t, c, l.size, l.type, l.normalized, l.stride, l.offset);
      }
    }
    this.currentArrayBuffer !== o && n.bindBuffer.call(t, 34962, this.currentArrayBuffer);
  };
  function ed(r2) {
    if (typeof r2.createVertexArray == "function")
      return;
    let e = r2.getSupportedExtensions;
    r2.getSupportedExtensions = function() {
      let i = e.call(this) || [];
      return i.indexOf("OES_vertex_array_object") < 0 && i.push("OES_vertex_array_object"), i;
    };
    let t = r2.getExtension;
    r2.getExtension = function(i) {
      let s = t.call(this, i);
      return s || (i !== "OES_vertex_array_object" ? null : (r2.__OESVertexArrayObject || (this.__OESVertexArrayObject = new Yr(this)), this.__OESVertexArrayObject));
    };
  }
  var td = "OES_element_index";
  var rd = "WEBGL_draw_buffers";
  var eE = "EXT_disjoint_timer_query";
  var tE = "EXT_disjoint_timer_query_webgl2";
  var rE = "EXT_texture_filter_anisotropic";
  var nd = "WEBGL_debug_renderer_info";
  var nE = 35723;
  var iE = 4352;
  var sE = 36795;
  var oE = 34047;
  var aE = 37445;
  var cE = 37446;
  var $ = (r2) => U(r2) ? void 0 : 0;
  var lE = { [3074]: (r2) => U(r2) ? void 0 : 36064, [nE]: (r2) => U(r2) ? void 0 : iE, [35977]: $, [32937]: $, [sE]: (r2, e) => {
    let t = U(r2) ? r2.getExtension(tE) : r2.getExtension(eE);
    return t && t.GPU_DISJOINT_EXT ? e(t.GPU_DISJOINT_EXT) : 0;
  }, [aE]: (r2, e) => {
    let t = r2.getExtension(nd);
    return e(t && t.UNMASKED_VENDOR_WEBGL || 7936);
  }, [cE]: (r2, e) => {
    let t = r2.getExtension(nd);
    return e(t && t.UNMASKED_RENDERER_WEBGL || 7937);
  }, [oE]: (r2, e) => {
    let t = r2.luma.extensions[rE];
    return t ? e(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
  }, [32883]: $, [35071]: $, [37447]: $, [36063]: (r2, e) => {
    if (!U(r2)) {
      let t = r2.getExtension(rd);
      return t ? e(t.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
    }
  }, [35379]: $, [35374]: $, [35377]: $, [34852]: (r2) => {
    if (!U(r2)) {
      let e = r2.getExtension(rd);
      return e ? e.MAX_DRAW_BUFFERS_WEBGL : 0;
    }
  }, [36203]: (r2) => r2.getExtension(td) ? 2147483647 : 65535, [33001]: (r2) => r2.getExtension(td) ? 16777216 : 65535, [33e3]: (r2) => 16777216, [37157]: $, [35373]: $, [35657]: $, [36183]: $, [37137]: $, [34045]: $, [35978]: $, [35979]: $, [35968]: $, [35376]: $, [35375]: $, [35659]: $, [37154]: $, [35371]: $, [35658]: $, [35076]: $, [35077]: $, [35380]: $ };
  function id(r2, e, t) {
    let n = lE[t], i = typeof n == "function" ? n(r2, e, t) : n;
    return i !== void 0 ? i : e(t);
  }
  var fE = "OES_vertex_array_object";
  var sd = "ANGLE_instanced_arrays";
  var uE = "WEBGL_draw_buffers";
  var hE = "EXT_disjoint_timer_query";
  var dE = "EXT_texture_filter_anisotropic";
  var pE = "VertexArray requires WebGL2 or OES_vertex_array_object extension";
  function mE(r2, e) {
    return { webgl2: U(r2), ext: r2.getExtension(e) };
  }
  var vl = { [fE]: { meta: { suffix: "OES" }, createVertexArray: () => {
    le(false, pE);
  }, deleteVertexArray: () => {
  }, bindVertexArray: () => {
  }, isVertexArray: () => false }, [sd]: { meta: { suffix: "ANGLE" }, vertexAttribDivisor(r2, e) {
    le(e === 0, "WebGL instanced rendering not supported");
  }, drawElementsInstanced: () => {
  }, drawArraysInstanced: () => {
  } }, [uE]: { meta: { suffix: "WEBGL" }, drawBuffers: () => {
    le(false);
  } }, [hE]: { meta: { suffix: "EXT" }, createQuery: () => {
    le(false);
  }, deleteQuery: () => {
    le(false);
  }, beginQuery: () => {
    le(false);
  }, endQuery: () => {
  }, getQuery(r2, e) {
    return this.getQueryObject(r2, e);
  }, getQueryParameter(r2, e) {
    return this.getQueryObject(r2, e);
  }, getQueryObject: () => {
  } } };
  var mo = { readBuffer: (r2, e, t) => {
    U(r2) && e(t);
  }, getVertexAttrib: (r2, e, t, n) => {
    let { webgl2: i, ext: s } = mE(r2, sd), o;
    switch (n) {
      case 35069:
        o = i ? void 0 : false;
        break;
      case 35070:
        o = !i && !s ? 0 : void 0;
        break;
      default:
    }
    return o !== void 0 ? o : e(t, n);
  }, getProgramParameter: (r2, e, t, n) => {
    if (!U(r2))
      switch (n) {
        case 35967:
          return 35981;
        case 35971:
          return 0;
        case 35382:
          return 0;
        default:
      }
    return e(t, n);
  }, getInternalformatParameter: (r2, e, t, n, i) => {
    if (!U(r2))
      switch (i) {
        case 32937:
          return new Int32Array([0]);
        default:
      }
    return r2.getInternalformatParameter(t, n, i);
  }, getTexParameter(r2, e, t, n) {
    switch (n) {
      case 34046:
        let { extensions: i } = r2.luma, s = i[dE];
        n = s && s.TEXTURE_MAX_ANISOTROPY_EXT || 34046;
        break;
      default:
    }
    return e(t, n);
  }, getParameter: id, hint(r2, e, t, n) {
    return e(t, n);
  } };
  function od(r2) {
    r2.luma = r2.luma || {};
    let { luma: e } = r2;
    return e.polyfilled || (ed(r2), _E(r2), yE(r2, vl), xE(r2, { target: e, target2: r2 }), e.polyfilled = true), r2;
  }
  var gE = typeof global != "undefined" ? global : window;
  gE.polyfillContext = od;
  function _E(r2) {
    r2.luma.extensions = {};
    let e = r2.getSupportedExtensions() || [];
    for (let t of e)
      r2.luma[t] = r2.getExtension(t);
  }
  function xE(r2, { target: e, target2: t }) {
    Object.keys(mo).forEach((n) => {
      if (typeof mo[n] == "function") {
        let i = r2[n] ? r2[n].bind(r2) : () => {
        }, s = mo[n].bind(null, r2, i);
        e[n] = s, t[n] = s;
      }
    });
  }
  function yE(r2, e) {
    for (let t of Object.getOwnPropertyNames(e))
      t !== "overrides" && EE(r2, { extension: t, target: r2.luma, target2: r2 });
  }
  function EE(r2, { extension: e, target: t, target2: n }) {
    let i = vl[e];
    le(i);
    let { meta: s = {} } = i, { suffix: o = "" } = s, a = r2.getExtension(e);
    for (let c of Object.keys(i)) {
      let l = "".concat(c).concat(o), f = null;
      c === "meta" || typeof r2[c] == "function" || (a && typeof a[l] == "function" ? f = (...u) => a[l](...u) : typeof i[c] == "function" && (f = i[c].bind(t))), f && (t[c] = f, n[c] = f);
    }
  }
  var Fi = { [3042]: false, [32773]: new Float32Array([0, 0, 0, 0]), [32777]: 32774, [34877]: 32774, [32969]: 1, [32968]: 0, [32971]: 1, [32970]: 0, [3106]: new Float32Array([0, 0, 0, 0]), [3107]: [true, true, true, true], [2884]: false, [2885]: 1029, [2929]: false, [2931]: 1, [2932]: 513, [2928]: new Float32Array([0, 1]), [2930]: true, [3024]: true, [36006]: null, [2886]: 2305, [33170]: 4352, [2849]: 1, [32823]: false, [32824]: 0, [10752]: 0, [32938]: 1, [32939]: false, [3089]: false, [3088]: new Int32Array([0, 0, 1024, 1024]), [2960]: false, [2961]: 0, [2968]: 4294967295, [36005]: 4294967295, [2962]: 519, [2967]: 0, [2963]: 4294967295, [34816]: 519, [36003]: 0, [36004]: 4294967295, [2964]: 7680, [2965]: 7680, [2966]: 7680, [34817]: 7680, [34818]: 7680, [34819]: 7680, [2978]: [0, 0, 1024, 1024], [3333]: 4, [3317]: 4, [37440]: false, [37441]: false, [37443]: 37444, [35723]: 4352, [36010]: null, [35977]: false, [3330]: 0, [3332]: 0, [3331]: 0, [3314]: 0, [32878]: 0, [3316]: 0, [3315]: 0, [32877]: 0 };
  var pr = (r2, e, t) => e ? r2.enable(t) : r2.disable(t);
  var ad = (r2, e, t) => r2.hint(t, e);
  var Xe = (r2, e, t) => r2.pixelStorei(t, e);
  var bE = (r2, e) => {
    let t = U(r2) ? 36009 : 36160;
    return r2.bindFramebuffer(t, e);
  };
  var TE = (r2, e) => r2.bindFramebuffer(36008, e);
  function Di(r2) {
    return Array.isArray(r2) || ArrayBuffer.isView(r2);
  }
  var cd = { [3042]: pr, [32773]: (r2, e) => r2.blendColor(...e), [32777]: "blendEquation", [34877]: "blendEquation", [32969]: "blendFunc", [32968]: "blendFunc", [32971]: "blendFunc", [32970]: "blendFunc", [3106]: (r2, e) => r2.clearColor(...e), [3107]: (r2, e) => r2.colorMask(...e), [2884]: pr, [2885]: (r2, e) => r2.cullFace(e), [2929]: pr, [2931]: (r2, e) => r2.clearDepth(e), [2932]: (r2, e) => r2.depthFunc(e), [2928]: (r2, e) => r2.depthRange(...e), [2930]: (r2, e) => r2.depthMask(e), [3024]: pr, [35723]: ad, [36006]: bE, [2886]: (r2, e) => r2.frontFace(e), [33170]: ad, [2849]: (r2, e) => r2.lineWidth(e), [32823]: pr, [32824]: "polygonOffset", [10752]: "polygonOffset", [35977]: pr, [32938]: "sampleCoverage", [32939]: "sampleCoverage", [3089]: pr, [3088]: (r2, e) => r2.scissor(...e), [2960]: pr, [2961]: (r2, e) => r2.clearStencil(e), [2968]: (r2, e) => r2.stencilMaskSeparate(1028, e), [36005]: (r2, e) => r2.stencilMaskSeparate(1029, e), [2962]: "stencilFuncFront", [2967]: "stencilFuncFront", [2963]: "stencilFuncFront", [34816]: "stencilFuncBack", [36003]: "stencilFuncBack", [36004]: "stencilFuncBack", [2964]: "stencilOpFront", [2965]: "stencilOpFront", [2966]: "stencilOpFront", [34817]: "stencilOpBack", [34818]: "stencilOpBack", [34819]: "stencilOpBack", [2978]: (r2, e) => r2.viewport(...e), [3333]: Xe, [3317]: Xe, [37440]: Xe, [37441]: Xe, [37443]: Xe, [3330]: Xe, [3332]: Xe, [3331]: Xe, [36010]: TE, [3314]: Xe, [32878]: Xe, [3316]: Xe, [3315]: Xe, [32877]: Xe, framebuffer: (r2, e) => {
    let t = e && "handle" in e ? e.handle : e;
    return r2.bindFramebuffer(36160, t);
  }, blend: (r2, e) => e ? r2.enable(3042) : r2.disable(3042), blendColor: (r2, e) => r2.blendColor(...e), blendEquation: (r2, e) => {
    e = Di(e) ? e : [e, e], r2.blendEquationSeparate(...e);
  }, blendFunc: (r2, e) => {
    e = Di(e) && e.length === 2 ? [...e, ...e] : e, r2.blendFuncSeparate(...e);
  }, clearColor: (r2, e) => r2.clearColor(...e), clearDepth: (r2, e) => r2.clearDepth(e), clearStencil: (r2, e) => r2.clearStencil(e), colorMask: (r2, e) => r2.colorMask(...e), cull: (r2, e) => e ? r2.enable(2884) : r2.disable(2884), cullFace: (r2, e) => r2.cullFace(e), depthTest: (r2, e) => e ? r2.enable(2929) : r2.disable(2929), depthFunc: (r2, e) => r2.depthFunc(e), depthMask: (r2, e) => r2.depthMask(e), depthRange: (r2, e) => r2.depthRange(...e), dither: (r2, e) => e ? r2.enable(3024) : r2.disable(3024), derivativeHint: (r2, e) => {
    r2.hint(35723, e);
  }, frontFace: (r2, e) => r2.frontFace(e), mipmapHint: (r2, e) => r2.hint(33170, e), lineWidth: (r2, e) => r2.lineWidth(e), polygonOffsetFill: (r2, e) => e ? r2.enable(32823) : r2.disable(32823), polygonOffset: (r2, e) => r2.polygonOffset(...e), sampleCoverage: (r2, e) => r2.sampleCoverage(...e), scissorTest: (r2, e) => e ? r2.enable(3089) : r2.disable(3089), scissor: (r2, e) => r2.scissor(...e), stencilTest: (r2, e) => e ? r2.enable(2960) : r2.disable(2960), stencilMask: (r2, e) => {
    e = Di(e) ? e : [e, e];
    let [t, n] = e;
    r2.stencilMaskSeparate(1028, t), r2.stencilMaskSeparate(1029, n);
  }, stencilFunc: (r2, e) => {
    e = Di(e) && e.length === 3 ? [...e, ...e] : e;
    let [t, n, i, s, o, a] = e;
    r2.stencilFuncSeparate(1028, t, n, i), r2.stencilFuncSeparate(1029, s, o, a);
  }, stencilOp: (r2, e) => {
    e = Di(e) && e.length === 3 ? [...e, ...e] : e;
    let [t, n, i, s, o, a] = e;
    r2.stencilOpSeparate(1028, t, n, i), r2.stencilOpSeparate(1029, s, o, a);
  }, viewport: (r2, e) => r2.viewport(...e) };
  function oe(r2, e, t) {
    return e[r2] !== void 0 ? e[r2] : t[r2];
  }
  var ld = { blendEquation: (r2, e, t) => r2.blendEquationSeparate(oe(32777, e, t), oe(34877, e, t)), blendFunc: (r2, e, t) => r2.blendFuncSeparate(oe(32969, e, t), oe(32968, e, t), oe(32971, e, t), oe(32970, e, t)), polygonOffset: (r2, e, t) => r2.polygonOffset(oe(32824, e, t), oe(10752, e, t)), sampleCoverage: (r2, e, t) => r2.sampleCoverage(oe(32938, e, t), oe(32939, e, t)), stencilFuncFront: (r2, e, t) => r2.stencilFuncSeparate(1028, oe(2962, e, t), oe(2967, e, t), oe(2963, e, t)), stencilFuncBack: (r2, e, t) => r2.stencilFuncSeparate(1029, oe(34816, e, t), oe(36003, e, t), oe(36004, e, t)), stencilOpFront: (r2, e, t) => r2.stencilOpSeparate(1028, oe(2964, e, t), oe(2965, e, t), oe(2966, e, t)), stencilOpBack: (r2, e, t) => r2.stencilOpSeparate(1029, oe(34817, e, t), oe(34818, e, t), oe(34819, e, t)) };
  var Al = { enable: (r2, e) => r2({ [e]: true }), disable: (r2, e) => r2({ [e]: false }), pixelStorei: (r2, e, t) => r2({ [e]: t }), hint: (r2, e, t) => r2({ [e]: t }), bindFramebuffer: (r2, e, t) => {
    switch (e) {
      case 36160:
        return r2({ [36006]: t, [36010]: t });
      case 36009:
        return r2({ [36006]: t });
      case 36008:
        return r2({ [36010]: t });
      default:
        return null;
    }
  }, blendColor: (r2, e, t, n, i) => r2({ [32773]: new Float32Array([e, t, n, i]) }), blendEquation: (r2, e) => r2({ [32777]: e, [34877]: e }), blendEquationSeparate: (r2, e, t) => r2({ [32777]: e, [34877]: t }), blendFunc: (r2, e, t) => r2({ [32969]: e, [32968]: t, [32971]: e, [32970]: t }), blendFuncSeparate: (r2, e, t, n, i) => r2({ [32969]: e, [32968]: t, [32971]: n, [32970]: i }), clearColor: (r2, e, t, n, i) => r2({ [3106]: new Float32Array([e, t, n, i]) }), clearDepth: (r2, e) => r2({ [2931]: e }), clearStencil: (r2, e) => r2({ [2961]: e }), colorMask: (r2, e, t, n, i) => r2({ [3107]: [e, t, n, i] }), cullFace: (r2, e) => r2({ [2885]: e }), depthFunc: (r2, e) => r2({ [2932]: e }), depthRange: (r2, e, t) => r2({ [2928]: new Float32Array([e, t]) }), depthMask: (r2, e) => r2({ [2930]: e }), frontFace: (r2, e) => r2({ [2886]: e }), lineWidth: (r2, e) => r2({ [2849]: e }), polygonOffset: (r2, e, t) => r2({ [32824]: e, [10752]: t }), sampleCoverage: (r2, e, t) => r2({ [32938]: e, [32939]: t }), scissor: (r2, e, t, n, i) => r2({ [3088]: new Int32Array([e, t, n, i]) }), stencilMask: (r2, e) => r2({ [2968]: e, [36005]: e }), stencilMaskSeparate: (r2, e, t) => r2({ [e === 1028 ? 2968 : 36005]: t }), stencilFunc: (r2, e, t, n) => r2({ [2962]: e, [2967]: t, [2963]: n, [34816]: e, [36003]: t, [36004]: n }), stencilFuncSeparate: (r2, e, t, n, i) => r2({ [e === 1028 ? 2962 : 34816]: t, [e === 1028 ? 2967 : 36003]: n, [e === 1028 ? 2963 : 36004]: i }), stencilOp: (r2, e, t, n) => r2({ [2964]: e, [2965]: t, [2966]: n, [34817]: e, [34818]: t, [34819]: n }), stencilOpSeparate: (r2, e, t, n, i) => r2({ [e === 1028 ? 2964 : 34817]: t, [e === 1028 ? 2965 : 34818]: n, [e === 1028 ? 2966 : 34819]: i }), viewport: (r2, e, t, n, i) => r2({ [2978]: [e, t, n, i] }) };
  var Dt = (r2, e) => r2.isEnabled(e);
  var Sl = { [3042]: Dt, [2884]: Dt, [2929]: Dt, [3024]: Dt, [32823]: Dt, [32926]: Dt, [32928]: Dt, [3089]: Dt, [2960]: Dt, [35977]: Dt };
  function wl(r2) {
    for (let e in r2)
      return false;
    return true;
  }
  function fd(r2, e) {
    if (r2 === e)
      return true;
    let t = Array.isArray(r2) || ArrayBuffer.isView(r2), n = Array.isArray(e) || ArrayBuffer.isView(e);
    if (t && n && r2.length === e.length) {
      for (let i = 0; i < r2.length; ++i)
        if (r2[i] !== e[i])
          return false;
      return true;
    }
    return false;
  }
  function ud(r2, e) {
    let t = r2[e].bind(r2);
    r2[e] = function(...i) {
      let s = i[0];
      return s in r2.state.cache || (r2.state.cache[s] = t(...i)), r2.state.enable ? r2.state.cache[s] : t(...i);
    }, Object.defineProperty(r2[e], "name", { value: "".concat(e, "-from-cache"), configurable: false });
  }
  function vE(r2, e, t) {
    let n = r2[e].bind(r2);
    r2[e] = function(...s) {
      let { valueChanged: o, oldValue: a } = t(r2.state._updateCache, ...s);
      return o && n(...s), a;
    }, Object.defineProperty(r2[e], "name", { value: "".concat(e, "-to-cache"), configurable: false });
  }
  function AE(r2) {
    let e = r2.useProgram.bind(r2);
    r2.useProgram = function(n) {
      r2.state.program !== n && (e(n), r2.state.program = n);
    };
  }
  var hd = class {
    constructor(e, { copyState: t = false, log: n = () => {
    } } = {}) {
      this.gl = e, this.program = null, this.stateStack = [], this.enable = true, this.cache = t ? xo(e) : Object.assign({}, Fi), this.log = n, this._updateCache = this._updateCache.bind(this), Object.seal(this);
    }
    push(e = {}) {
      this.stateStack.push({});
    }
    pop() {
      le(this.stateStack.length > 0);
      let e = this.stateStack[this.stateStack.length - 1];
      De(this.gl, e), this.stateStack.pop();
    }
    _updateCache(e) {
      let t = false, n, i = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];
      for (let s in e) {
        le(s !== void 0);
        let o = e[s], a = this.cache[s];
        fd(o, a) || (t = true, n = a, i && !(s in i) && (i[s] = a), this.cache[s] = o);
      }
      return { valueChanged: t, oldValue: n };
    }
  };
  function go(r2, e = {}) {
    let { enable: t = true, copyState: n } = e;
    if (le(n !== void 0), !r2.state) {
      let i = typeof global != "undefined" ? global : window, { polyfillContext: s } = i;
      s && s(r2), r2.state = new hd(r2, { copyState: n }), AE(r2);
      for (let o in Al) {
        let a = Al[o];
        vE(r2, o, a);
      }
      ud(r2, "getParameter"), ud(r2, "isEnabled");
    }
    return r2.state.enable = t, r2;
  }
  function Pl(r2) {
    r2.state || go(r2, { copyState: false }), r2.state.push();
  }
  function _o(r2) {
    le(r2.state), r2.state.pop();
  }
  function De(r2, e) {
    if (le(Zt(r2), "setParameters requires a WebGL context"), wl(e))
      return;
    let t = {};
    for (let i in e) {
      let s = Number(i), o = cd[i];
      o && (typeof o == "string" ? t[o] = true : o(r2, e[i], s));
    }
    let n = r2.state && r2.state.cache;
    if (n)
      for (let i in t)
        ld[i](r2, e, n);
  }
  function xo(r2, e) {
    if (e = e || Fi, typeof e == "number") {
      let i = e, s = Sl[i];
      return s ? s(r2, i) : r2.getParameter(i);
    }
    let t = Array.isArray(e) ? e : Object.keys(e), n = {};
    for (let i of t) {
      let s = Sl[i];
      n[i] = s ? s(r2, Number(i)) : r2.getParameter(Number(i));
    }
    return n;
  }
  function yo(r2) {
    De(r2, Fi);
  }
  function ae(r2, e, t) {
    if (wl(e))
      return t(r2);
    let { nocatch: n = true } = e;
    Pl(r2), De(r2, e);
    let i;
    if (n)
      i = t(r2), _o(r2);
    else
      try {
        i = t(r2);
      } finally {
        _o(r2);
      }
    return i;
  }
  var Bi = Mt(dr());
  function xt(r2) {
    let { luma: e } = r2;
    if (r2.canvas && e) {
      let { clientWidth: t } = e.canvasSizeInfo;
      return t ? r2.drawingBufferWidth / t : 1;
    }
    return 1;
  }
  function yn(r2, e, t = true) {
    let n = xt(r2), i = r2.drawingBufferWidth, s = r2.drawingBufferHeight;
    return SE(e, n, i, s, t);
  }
  function dd(r2) {
    let e = typeof window == "undefined" ? 1 : window.devicePixelRatio || 1;
    return Number.isFinite(r2) ? r2 <= 0 ? 1 : r2 : r2 ? e : 1;
  }
  function SE(r2, e, t, n, i) {
    let s = pd(r2[0], e, t), o = md(r2[1], e, n, i), a = pd(r2[0] + 1, e, t), c = a === t - 1 ? a : a - 1;
    a = md(r2[1] + 1, e, n, i);
    let l;
    return i ? (a = a === 0 ? a : a + 1, l = o, o = a) : l = a === n - 1 ? a : a - 1, { x: s, y: o, width: Math.max(c - s + 1, 1), height: Math.max(l - o + 1, 1) };
  }
  function pd(r2, e, t) {
    return Math.min(Math.round(r2 * e), t - 1);
  }
  function md(r2, e, t, n) {
    return n ? Math.max(0, t - 1 - Math.round(r2 * e)) : Math.min(Math.round(r2 * e), t - 1);
  }
  var Ll = (0, Bi.isBrowser)();
  var wE = Ll && typeof document != "undefined";
  var gd = { webgl2: true, webgl1: true, throwOnError: true, manageState: true, canvas: null, debug: false, width: 800, height: 600 };
  function En(r2 = {}) {
    le(Ll, `createGLContext only available in the browser.
Create your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils`), r2 = Object.assign({}, gd, r2);
    let { width: e, height: t } = r2;
    function n(a) {
      if (r2.throwOnError)
        throw new Error(a);
      return console.error(a), null;
    }
    r2.onError = n;
    let i, { canvas: s } = r2, o = LE({ canvas: s, width: e, height: t, onError: n });
    return i = PE(o, r2), i ? (i = qr(i, r2), CE(i), i) : null;
  }
  function qr(r2, e = {}) {
    if (!r2 || r2._instrumented)
      return r2;
    r2._version = r2._version || RE(r2), r2.luma = r2.luma || {}, r2.luma.canvasSizeInfo = r2.luma.canvasSizeInfo || {}, e = Object.assign({}, gd, e);
    let { manageState: t, debug: n } = e;
    return t && go(r2, { copyState: false, log: (...i) => I.log(1, ...i)() }), Ll && n && (Bi.global.makeDebugContext ? (r2 = Bi.global.makeDebugContext(r2, e), I.level = Math.max(I.level, 1)) : I.warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')()), r2._instrumented = true, r2;
  }
  function _d(r2) {
    let e = r2.getParameter(7936), t = r2.getParameter(7937), n = r2.getExtension("WEBGL_debug_renderer_info"), i = n && r2.getParameter(n.UNMASKED_VENDOR_WEBGL || 7936), s = n && r2.getParameter(n.UNMASKED_RENDERER_WEBGL || 7937);
    return { vendor: i || e, renderer: s || t, vendorMasked: e, rendererMasked: t, version: r2.getParameter(7938), shadingLanguageVersion: r2.getParameter(35724) };
  }
  function Cl(r2, e = {}) {
    if (r2.canvas) {
      let n = dd(e.useDevicePixels);
      ME(r2, n, e);
      return;
    }
    let t = r2.getExtension("STACKGL_resize_drawingbuffer");
    t && "width" in e && "height" in e && t.resize(e.width, e.height);
  }
  function PE(r2, e) {
    let { onError: t } = e, n = null, i = (c) => n = c.statusMessage || n;
    r2.addEventListener("webglcontextcreationerror", i, false);
    let { webgl1: s = true, webgl2: o = true } = e, a = null;
    return o && (a = a || r2.getContext("webgl2", e), a = a || r2.getContext("experimental-webgl2", e)), s && (a = a || r2.getContext("webgl", e), a = a || r2.getContext("experimental-webgl", e)), r2.removeEventListener("webglcontextcreationerror", i, false), a ? (e.onContextLost && r2.addEventListener("webglcontextlost", e.onContextLost, false), e.onContextRestored && r2.addEventListener("webglcontextrestored", e.onContextRestored, false), a) : t("Failed to create ".concat(o && !s ? "WebGL2" : "WebGL", " context: ").concat(n || "Unknown error"));
  }
  function LE({ canvas: r2, width: e = 800, height: t = 600, onError: n }) {
    let i;
    return typeof r2 == "string" ? (wE && document.readyState === "complete" || n("createGLContext called on canvas '".concat(r2, "' before page was loaded")), i = document.getElementById(r2)) : r2 ? i = r2 : (i = document.createElement("canvas"), i.id = "lumagl-canvas", i.style.width = Number.isFinite(e) ? "".concat(e, "px") : "100%", i.style.height = Number.isFinite(t) ? "".concat(t, "px") : "100%", document.body.insertBefore(i, document.body.firstChild)), i;
  }
  function CE(r2) {
    let e = U(r2) ? "WebGL2" : "WebGL1", t = _d(r2), n = t ? "(".concat(t.vendor, ",").concat(t.renderer, ")") : "", i = r2.debug ? " debug" : "";
    I.info(1, "".concat(e).concat(i, " context ").concat(n))();
  }
  function RE(r2) {
    return typeof WebGL2RenderingContext != "undefined" && r2 instanceof WebGL2RenderingContext ? 2 : 1;
  }
  function ME(r2, e, t) {
    let n = "width" in t ? t.width : r2.canvas.clientWidth, i = "height" in t ? t.height : r2.canvas.clientHeight;
    (!n || !i) && (I.log(1, "Canvas clientWidth/clientHeight is 0")(), e = 1, n = r2.canvas.width || 1, i = r2.canvas.height || 1), r2.luma = r2.luma || {}, r2.luma.canvasSizeInfo = r2.luma.canvasSizeInfo || {};
    let s = r2.luma.canvasSizeInfo;
    if (s.clientWidth !== n || s.clientHeight !== i || s.devicePixelRatio !== e) {
      let o = e, a = Math.floor(n * o), c = Math.floor(i * o);
      r2.canvas.width = a, r2.canvas.height = c, (r2.drawingBufferWidth !== a || r2.drawingBufferHeight !== c) && (I.warn("Device pixel ratio clamped")(), o = Math.min(r2.drawingBufferWidth / n, r2.drawingBufferHeight / i), r2.canvas.width = Math.floor(n * o), r2.canvas.height = Math.floor(i * o)), Object.assign(r2.luma.canvasSizeInfo, { clientWidth: n, clientHeight: i, devicePixelRatio: e });
    }
  }
  var Bt = Mt(dr());
  var Ui = "8.5.4";
  var IE = "set luma.log.level=1 (or higher) to trace rendering";
  var xd = class {
    constructor() {
      this.stats = new Map();
    }
    get(e) {
      return this.stats.has(e) || this.stats.set(e, new nt({ id: e })), this.stats.get(e);
    }
  };
  var ot = new xd();
  if (Bt.global.luma && Bt.global.luma.VERSION !== Ui)
    throw new Error("luma.gl - multiple VERSIONs detected: ".concat(Bt.global.luma.VERSION, " vs ").concat(Ui));
  Bt.global.luma || ((0, Bt.isBrowser)() && I.log(1, "luma.gl ".concat(Ui, " - ").concat(IE))(), Bt.global.luma = Bt.global.luma || { VERSION: Ui, version: Ui, log: I, stats: ot, globals: { modules: {}, nodeIO: {} } });
  var AI = Bt.global.luma;
  function Rl(r2) {
    return typeof window != "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame(r2) : setTimeout(r2, 1e3 / 60);
  }
  function Eo(r2) {
    return typeof window != "undefined" && window.cancelAnimationFrame ? window.cancelAnimationFrame(r2) : clearTimeout(r2);
  }
  var vd = Mt(dr());
  var OE = "Failed to deduce GL constant from typed array";
  function bn(r2) {
    switch (ArrayBuffer.isView(r2) ? r2.constructor : r2) {
      case Float32Array:
        return 5126;
      case Uint16Array:
        return 5123;
      case Uint32Array:
        return 5125;
      case Uint8Array:
        return 5121;
      case Uint8ClampedArray:
        return 5121;
      case Int8Array:
        return 5120;
      case Int16Array:
        return 5122;
      case Int32Array:
        return 5124;
      default:
        throw new Error(OE);
    }
  }
  function Qt(r2, { clamped: e = true } = {}) {
    switch (r2) {
      case 5126:
        return Float32Array;
      case 5123:
      case 33635:
      case 32819:
      case 32820:
        return Uint16Array;
      case 5125:
        return Uint32Array;
      case 5121:
        return e ? Uint8ClampedArray : Uint8Array;
      case 5120:
        return Int8Array;
      case 5122:
        return Int16Array;
      case 5124:
        return Int32Array;
      default:
        throw new Error("Failed to deduce typed array type from GL constant");
    }
  }
  function Ml({ data: r2, width: e, height: t, bytesPerPixel: n = 4, temp: i }) {
    let s = e * n;
    i = i || new Uint8Array(s);
    for (let o = 0; o < t / 2; ++o) {
      let a = o * s, c = (t - o - 1) * s;
      i.set(r2.subarray(a, a + s)), r2.copyWithin(a, c, c + s), r2.set(i, c);
    }
  }
  function Il({ data: r2, width: e, height: t }) {
    let n = Math.round(e / 2), i = Math.round(t / 2), s = new Uint8Array(n * i * 4);
    for (let o = 0; o < i; o++)
      for (let a = 0; a < n; a++)
        for (let c = 0; c < 4; c++)
          s[(o * n + a) * 4 + c] = r2[(o * 2 * e + a * 2) * 4 + c];
    return { data: s, width: n, height: i };
  }
  function w(r2, e) {
    if (!r2)
      throw new Error(e || "luma.gl: assertion failed.");
  }
  var Ol = {};
  function Pe(r2 = "id") {
    Ol[r2] = Ol[r2] || 1;
    let e = Ol[r2]++;
    return "".concat(r2, "-").concat(e);
  }
  function bo(r2) {
    return w(typeof r2 == "number", "Input must be a number"), r2 && (r2 & r2 - 1) == 0;
  }
  function yt(r2) {
    let e = true;
    for (let t in r2) {
      e = false;
      break;
    }
    return e;
  }
  function NE(r2, e) {
    let { maxElts: t = 16, size: n = 1 } = e, i = "[";
    for (let o = 0; o < r2.length && o < t; ++o)
      o > 0 && (i += ",".concat(o % n == 0 ? " " : "")), i += mr(r2[o], e);
    let s = r2.length > t ? "..." : "]";
    return "".concat(i).concat(s);
  }
  function mr(r2, e = {}) {
    let t = 1e-16, { isInteger: n = false } = e;
    if (Array.isArray(r2) || ArrayBuffer.isView(r2))
      return NE(r2, e);
    if (!Number.isFinite(r2))
      return String(r2);
    if (Math.abs(r2) < t)
      return n ? "0" : "0.";
    if (n || Math.abs(r2) > 100 && Math.abs(r2) < 1e4)
      return r2.toFixed(0);
    let i = r2.toPrecision(2);
    return i.indexOf(".0") === i.length - 2 ? i.slice(0, -1) : i;
  }
  function ki(r2, e, t, n) {
    let i = "See luma.gl ".concat(t, " Upgrade Guide at https://luma.gl/docs/upgrade-guide"), s = Object.getPrototypeOf(r2);
    n.forEach((o) => {
      s.methodName || (s[o] = () => {
        throw I.removed("Calling removed method ".concat(e, ".").concat(o, ": "), i)(), new Error(o);
      });
    });
  }
  function Tn(r2, e, t) {
    let { removedProps: n = {}, deprecatedProps: i = {}, replacedProps: s = {} } = t;
    for (let a in n)
      if (a in e) {
        let l = n[a] ? "".concat(r2, ".").concat(n[a]) : "N/A";
        I.removed("".concat(r2, ".").concat(a), l)();
      }
    for (let a in i)
      if (a in e) {
        let c = i[a];
        I.deprecated("".concat(r2, ".").concat(a), "".concat(r2, ".").concat(c))();
      }
    let o = null;
    for (let a in s)
      if (a in e) {
        let c = s[a];
        I.deprecated("".concat(r2, ".").concat(a), "".concat(r2, ".").concat(c))(), o = o || Object.assign({}, e), o[c] = e[a], delete o[a];
      }
    return o || e;
  }
  function Vi(r2, e) {
    if (typeof e != "string")
      return e;
    let t = Number(e);
    if (!isNaN(t))
      return t;
    e = e.replace(/^.*\./, "");
    let n = r2[e];
    return w(n !== void 0, "Accessing undefined constant GL.".concat(e)), n;
  }
  function Ye(r2, e) {
    e = Number(e);
    for (let t in r2)
      if (r2[t] === e)
        return "GL.".concat(t);
    return String(e);
  }
  var vn = "Resource subclass must define virtual methods";
  var me = class {
    constructor(e, t = {}) {
      Kt(e);
      let { id: n, userData: i = {} } = t;
      this.gl = e, this.gl2 = e, this.id = n || Pe(this.constructor.name), this.userData = i, this._bound = false, this._handle = t.handle, this._handle === void 0 && (this._handle = this._createHandle()), this.byteLength = 0, this._addStats();
    }
    toString() {
      return "".concat(this.constructor.name, "(").concat(this.id, ")");
    }
    get handle() {
      return this._handle;
    }
    delete({ deleteChildren: e = false } = {}) {
      let t = this._handle && this._deleteHandle(this._handle);
      return this._handle && this._removeStats(), this._handle = null, t && e && t.filter(Boolean).forEach((n) => n.delete()), this;
    }
    bind(e = this.handle) {
      if (typeof e != "function")
        return this._bindHandle(e), this;
      let t;
      return this._bound ? t = e() : (this._bindHandle(this.handle), this._bound = true, t = e(), this._bound = false, this._bindHandle(null)), t;
    }
    unbind() {
      this.bind(null);
    }
    getParameter(e, t = {}) {
      e = Vi(this.gl, e), w(e);
      let i = (this.constructor.PARAMETERS || {})[e];
      if (i) {
        let s = U(this.gl);
        if (!((!("webgl2" in i) || s) && (!("extension" in i) || this.gl.getExtension(i.extension)))) {
          let a = i.webgl1, c = "webgl2" in i ? i.webgl2 : i.webgl1;
          return s ? c : a;
        }
      }
      return this._getParameter(e, t);
    }
    getParameters(e = {}) {
      let { parameters: t, keys: n } = e, i = this.constructor.PARAMETERS || {}, s = U(this.gl), o = {}, a = t || Object.keys(i);
      for (let c of a) {
        let l = i[c];
        if (l && (!("webgl2" in l) || s) && (!("extension" in l) || this.gl.getExtension(l.extension))) {
          let u = n ? Ye(this.gl, c) : c;
          o[u] = this.getParameter(c, e), n && l.type === "GLenum" && (o[u] = Ye(this.gl, o[u]));
        }
      }
      return o;
    }
    setParameter(e, t) {
      e = Vi(this.gl, e), w(e);
      let i = (this.constructor.PARAMETERS || {})[e];
      if (i) {
        let s = U(this.gl);
        if (!((!("webgl2" in i) || s) && (!("extension" in i) || this.gl.getExtension(i.extension))))
          throw new Error("Parameter not available on this platform");
        i.type === "GLenum" && (t = Vi(t));
      }
      return this._setParameter(e, t), this;
    }
    setParameters(e) {
      for (let t in e)
        this.setParameter(t, e[t]);
      return this;
    }
    stubRemovedMethods(e, t, n) {
      return ki(this, e, t, n);
    }
    initialize(e) {
    }
    _createHandle() {
      throw new Error(vn);
    }
    _deleteHandle() {
      throw new Error(vn);
    }
    _bindHandle(e) {
      throw new Error(vn);
    }
    _getOptsFromHandle() {
      throw new Error(vn);
    }
    _getParameter(e, t) {
      throw new Error(vn);
    }
    _setParameter(e, t) {
      throw new Error(vn);
    }
    _context() {
      return this.gl.luma = this.gl.luma || {}, this.gl.luma;
    }
    _addStats() {
      let e = this.constructor.name, t = ot.get("Resource Counts");
      t.get("Resources Created").incrementCount(), t.get("".concat(e, "s Created")).incrementCount(), t.get("".concat(e, "s Active")).incrementCount();
    }
    _removeStats() {
      let e = this.constructor.name;
      ot.get("Resource Counts").get("".concat(e, "s Active")).decrementCount();
    }
    _trackAllocatedMemory(e, t = this.constructor.name) {
      let n = ot.get("Memory Usage");
      n.get("GPU Memory").addCount(e), n.get("".concat(t, " Memory")).addCount(e), this.byteLength = e;
    }
    _trackDeallocatedMemory(e = this.constructor.name) {
      let t = ot.get("Memory Usage");
      t.get("GPU Memory").subtractCount(this.byteLength), t.get("".concat(e, " Memory")).subtractCount(this.byteLength), this.byteLength = 0;
    }
  };
  var FE = { offset: 0, stride: 0, type: 5126, size: 1, divisor: 0, normalized: false, integer: false };
  var DE = { deprecatedProps: { instanced: "divisor", isInstanced: "divisor" } };
  var be = class {
    static getBytesPerElement(e) {
      return Qt(e.type || 5126).BYTES_PER_ELEMENT;
    }
    static getBytesPerVertex(e) {
      return w(e.size), Qt(e.type || 5126).BYTES_PER_ELEMENT * e.size;
    }
    static resolve(...e) {
      return new be(...[FE, ...e]);
    }
    constructor(...e) {
      e.forEach((t) => this._assign(t)), Object.freeze(this);
    }
    toString() {
      return JSON.stringify(this);
    }
    get BYTES_PER_ELEMENT() {
      return be.getBytesPerElement(this);
    }
    get BYTES_PER_VERTEX() {
      return be.getBytesPerVertex(this);
    }
    _assign(e = {}) {
      return e = Tn("Accessor", e, DE), e.type !== void 0 && (this.type = e.type, (e.type === 5124 || e.type === 5125) && (this.integer = true)), e.size !== void 0 && (this.size = e.size), e.offset !== void 0 && (this.offset = e.offset), e.stride !== void 0 && (this.stride = e.stride), e.normalized !== void 0 && (this.normalized = e.normalized), e.integer !== void 0 && (this.integer = e.integer), e.divisor !== void 0 && (this.divisor = e.divisor), e.buffer !== void 0 && (this.buffer = e.buffer), e.index !== void 0 && (typeof e.index == "boolean" ? this.index = e.index ? 1 : 0 : this.index = e.index), e.instanced !== void 0 && (this.divisor = e.instanced ? 1 : 0), e.isInstanced !== void 0 && (this.divisor = e.isInstanced ? 1 : 0), this;
    }
  };
  var yd = 10;
  var Ed = { offset: "accessor.offset", stride: "accessor.stride", type: "accessor.type", size: "accessor.size", divisor: "accessor.divisor", normalized: "accessor.normalized", integer: "accessor.integer", instanced: "accessor.divisor", isInstanced: "accessor.divisor" };
  var BE = { removedProps: {}, replacedProps: { bytes: "byteLength" }, deprecatedProps: Ed };
  var UE = { removedProps: Ed };
  var k = class extends me {
    constructor(e, t = {}) {
      super(e, t);
      this.stubRemovedMethods("Buffer", "v6.0", ["layout", "setLayout", "getIndexedParameter"]), this.target = t.target || (this.gl.webgl2 ? 36662 : 34962), this.initialize(t), Object.seal(this);
    }
    getElementCount(e = this.accessor) {
      return Math.round(this.byteLength / be.getBytesPerElement(e));
    }
    getVertexCount(e = this.accessor) {
      return Math.round(this.byteLength / be.getBytesPerVertex(e));
    }
    initialize(e = {}) {
      return ArrayBuffer.isView(e) && (e = { data: e }), Number.isFinite(e) && (e = { byteLength: e }), e = Tn("Buffer", e, BE), this.usage = e.usage || 35044, this.debugData = null, this.setAccessor(Object.assign({}, e, e.accessor)), e.data ? this._setData(e.data, e.offset, e.byteLength) : this._setByteLength(e.byteLength || 0), this;
    }
    setProps(e) {
      return e = Tn("Buffer", e, UE), "accessor" in e && this.setAccessor(e.accessor), this;
    }
    setAccessor(e) {
      return e = Object.assign({}, e), delete e.buffer, this.accessor = new be(e), this;
    }
    reallocate(e) {
      return e > this.byteLength ? (this._setByteLength(e), true) : (this.bytesUsed = e, false);
    }
    setData(e) {
      return this.initialize(e);
    }
    subData(e) {
      ArrayBuffer.isView(e) && (e = { data: e });
      let { data: t, offset: n = 0, srcOffset: i = 0 } = e, s = e.byteLength || e.length;
      w(t);
      let o = this.gl.webgl2 ? 36663 : this.target;
      return this.gl.bindBuffer(o, this.handle), i !== 0 || s !== void 0 ? (te(this.gl), this.gl.bufferSubData(this.target, n, t, i, s)) : this.gl.bufferSubData(o, n, t), this.gl.bindBuffer(o, null), this.debugData = null, this._inferType(t), this;
    }
    copyData({ sourceBuffer: e, readOffset: t = 0, writeOffset: n = 0, size: i }) {
      let { gl: s } = this;
      return te(s), s.bindBuffer(36662, e.handle), s.bindBuffer(36663, this.handle), s.copyBufferSubData(36662, 36663, t, n, i), s.bindBuffer(36662, null), s.bindBuffer(36663, null), this.debugData = null, this;
    }
    getData({ dstData: e = null, srcByteOffset: t = 0, dstOffset: n = 0, length: i = 0 } = {}) {
      te(this.gl);
      let s = Qt(this.accessor.type || 5126, { clamped: false }), o = this._getAvailableElementCount(t), a = n, c, l;
      e ? (l = e.length, c = l - a) : (c = Math.min(o, i || o), l = a + c);
      let f = Math.min(o, c);
      return i = i || f, w(i <= f), e = e || new s(l), this.gl.bindBuffer(36662, this.handle), this.gl.getBufferSubData(36662, t, e, n, i), this.gl.bindBuffer(36662, null), e;
    }
    bind({ target: e = this.target, index: t = this.accessor && this.accessor.index, offset: n = 0, size: i } = {}) {
      return e === 35345 || e === 35982 ? i !== void 0 ? this.gl.bindBufferRange(e, t, this.handle, n, i) : (w(n === 0), this.gl.bindBufferBase(e, t, this.handle)) : this.gl.bindBuffer(e, this.handle), this;
    }
    unbind({ target: e = this.target, index: t = this.accessor && this.accessor.index } = {}) {
      return e === 35345 || e === 35982 ? this.gl.bindBufferBase(e, t, null) : this.gl.bindBuffer(e, null), this;
    }
    getDebugData() {
      return this.debugData ? { data: this.debugData, changed: false } : (this.debugData = this.getData({ length: Math.min(yd, this.byteLength) }), { data: this.debugData, changed: true });
    }
    invalidateDebugData() {
      this.debugData = null;
    }
    _setData(e, t = 0, n = e.byteLength + t) {
      w(ArrayBuffer.isView(e)), this._trackDeallocatedMemory();
      let i = this._getTarget();
      this.gl.bindBuffer(i, this.handle), this.gl.bufferData(i, n, this.usage), this.gl.bufferSubData(i, t, e), this.gl.bindBuffer(i, null), this.debugData = e.slice(0, yd), this.bytesUsed = n, this._trackAllocatedMemory(n);
      let s = bn(e);
      return w(s), this.setAccessor(new be(this.accessor, { type: s })), this;
    }
    _setByteLength(e, t = this.usage) {
      w(e >= 0), this._trackDeallocatedMemory();
      let n = e;
      e === 0 && (n = new Float32Array(0));
      let i = this._getTarget();
      return this.gl.bindBuffer(i, this.handle), this.gl.bufferData(i, n, t), this.gl.bindBuffer(i, null), this.usage = t, this.debugData = null, this.bytesUsed = e, this._trackAllocatedMemory(e), this;
    }
    _getTarget() {
      return this.gl.webgl2 ? 36663 : this.target;
    }
    _getAvailableElementCount(e) {
      let t = Qt(this.accessor.type || 5126, { clamped: false }), n = e / t.BYTES_PER_ELEMENT;
      return this.getElementCount() - n;
    }
    _inferType(e) {
      this.accessor.type || this.setAccessor(new be(this.accessor, { type: bn(e) }));
    }
    _createHandle() {
      return this.gl.createBuffer();
    }
    _deleteHandle() {
      this.gl.deleteBuffer(this.handle), this._trackDeallocatedMemory();
    }
    _getParameter(e) {
      this.gl.bindBuffer(this.target, this.handle);
      let t = this.gl.getBufferParameter(this.target, e);
      return this.gl.bindBuffer(this.target, null), t;
    }
    get type() {
      return I.deprecated("Buffer.type", "Buffer.accessor.type")(), this.accessor.type;
    }
    get bytes() {
      return I.deprecated("Buffer.bytes", "Buffer.byteLength")(), this.byteLength;
    }
    setByteLength(e) {
      return I.deprecated("setByteLength", "reallocate")(), this.reallocate(e);
    }
    updateAccessor(e) {
      return I.deprecated("updateAccessor(...)", "setAccessor(new Accessor(buffer.accessor, ...)")(), this.accessor = new be(this.accessor, e), this;
    }
  };
  var To = { [6407]: { dataFormat: 6407, types: [5121, 33635] }, [6408]: { dataFormat: 6408, types: [5121, 32819, 32820] }, [6406]: { dataFormat: 6406, types: [5121] }, [6409]: { dataFormat: 6409, types: [5121] }, [6410]: { dataFormat: 6410, types: [5121] }, [33326]: { dataFormat: 6403, types: [5126], gl2: true }, [33328]: { dataFormat: 33319, types: [5126], gl2: true }, [34837]: { dataFormat: 6407, types: [5126], gl2: true }, [34836]: { dataFormat: 6408, types: [5126], gl2: true } };
  var vo = { [6403]: 1, [36244]: 1, [33319]: 2, [33320]: 2, [6407]: 3, [36248]: 3, [6408]: 4, [36249]: 4, [6402]: 1, [34041]: 1, [6406]: 1, [6409]: 1, [6410]: 2 };
  var Ao = { [5126]: 4, [5125]: 4, [5124]: 4, [5123]: 2, [5122]: 2, [5131]: 2, [5120]: 1, [5121]: 1 };
  function bd(r2, e) {
    let t = To[e];
    if (!t)
      return false;
    if (t.gl1 === void 0 && t.gl2 === void 0)
      return true;
    let n = U(r2) && t.gl2 || t.gl1;
    return typeof n == "string" ? r2.getExtension(n) : n;
  }
  function Td(r2, e) {
    let t = To[e];
    switch (t && t.types[0]) {
      case 5126:
        return r2.getExtension("OES_texture_float_linear");
      case 5131:
        return r2.getExtension("OES_texture_half_float_linear");
      default:
        return true;
    }
  }
  var kE = [9729, 9728];
  var Ad = vd.global.WebGLBuffer || function() {
  };
  var Be = class extends me {
    static isSupported(e, t = {}) {
      let { format: n, linearFiltering: i } = t, s = true;
      return n && (s = s && bd(e, n), s = s && (!i || Td(e, n))), s;
    }
    constructor(e, t) {
      let { id: n = Pe("texture"), handle: i, target: s } = t;
      super(e, { id: n, handle: i });
      this.target = s, this.textureUnit = void 0, this.loaded = false, this.width = void 0, this.height = void 0, this.depth = void 0, this.format = void 0, this.type = void 0, this.dataFormat = void 0, this.border = void 0, this.textureUnit = void 0, this.mipmaps = void 0;
    }
    toString() {
      return "Texture(".concat(this.id, ",").concat(this.width, "x").concat(this.height, ")");
    }
    initialize(e = {}) {
      let t = e.data;
      if (t instanceof Promise)
        return t.then((T) => this.initialize(Object.assign({}, e, { pixels: T, data: T }))), this;
      let n = typeof HTMLVideoElement != "undefined" && t instanceof HTMLVideoElement;
      if (n && t.readyState < HTMLVideoElement.HAVE_METADATA)
        return this._video = null, t.addEventListener("loadeddata", () => this.initialize(e)), this;
      let { pixels: i = null, format: s = 6408, border: o = 0, recreate: a = false, parameters: c = {}, pixelStore: l = {}, textureUnit: f = void 0 } = e;
      t || (t = i);
      let { width: u, height: h, dataFormat: d, type: m, compressed: _ = false, mipmaps: E = true } = e, { depth: b = 0 } = e;
      return { width: u, height: h, compressed: _, dataFormat: d, type: m } = this._deduceParameters({ format: s, type: m, dataFormat: d, compressed: _, data: t, width: u, height: h }), this.width = u, this.height = h, this.depth = b, this.format = s, this.type = m, this.dataFormat = d, this.border = o, this.textureUnit = f, Number.isFinite(this.textureUnit) && (this.gl.activeTexture(33984 + this.textureUnit), this.gl.bindTexture(this.target, this.handle)), E && this._isNPOT() && (I.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))(), E = false, this._updateForNPOT(c)), this.mipmaps = E, this.setImageData({ data: t, width: u, height: h, depth: b, format: s, type: m, dataFormat: d, border: o, mipmaps: E, parameters: l, compressed: _ }), E && this.generateMipmap(), this.setParameters(c), a && (this.data = t), n && (this._video = { video: t, parameters: c, lastTime: t.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? t.currentTime : -1 }), this;
    }
    update() {
      if (this._video) {
        let { video: e, parameters: t, lastTime: n } = this._video;
        if (n === e.currentTime || e.readyState < HTMLVideoElement.HAVE_CURRENT_DATA)
          return;
        this.setSubImageData({ data: e, parameters: t }), this.mipmaps && this.generateMipmap(), this._video.lastTime = e.currentTime;
      }
    }
    resize({ height: e, width: t, mipmaps: n = false }) {
      return t !== this.width || e !== this.height ? this.initialize({ width: t, height: e, format: this.format, type: this.type, dataFormat: this.dataFormat, border: this.border, mipmaps: n }) : this;
    }
    generateMipmap(e = {}) {
      return this._isNPOT() ? (I.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))(), this) : (this.mipmaps = true, this.gl.bindTexture(this.target, this.handle), ae(this.gl, e, () => {
        this.gl.generateMipmap(this.target);
      }), this.gl.bindTexture(this.target, null), this);
    }
    setImageData(e) {
      this._trackDeallocatedMemory("Texture");
      let { target: t = this.target, pixels: n = null, level: i = 0, format: s = this.format, border: o = this.border, offset: a = 0, parameters: c = {} } = e, { data: l = null, type: f = this.type, width: u = this.width, height: h = this.height, dataFormat: d = this.dataFormat, compressed: m = false } = e;
      l || (l = n), { type: f, dataFormat: d, compressed: m, width: u, height: h } = this._deduceParameters({ format: s, type: f, dataFormat: d, compressed: m, data: l, width: u, height: h });
      let { gl: _ } = this;
      _.bindTexture(this.target, this.handle);
      let E = null;
      ({ data: l, dataType: E } = this._getDataType({ data: l, compressed: m }));
      let b;
      if (ae(this.gl, c, () => {
        switch (E) {
          case "null":
            _.texImage2D(t, i, s, u, h, o, d, f, l);
            break;
          case "typed-array":
            _.texImage2D(t, i, s, u, h, o, d, f, l, a);
            break;
          case "buffer":
            b = te(_), b.bindBuffer(35052, l.handle || l), b.texImage2D(t, i, s, u, h, o, d, f, a), b.bindBuffer(35052, null);
            break;
          case "browser-object":
            U(_) ? _.texImage2D(t, i, s, u, h, o, d, f, l) : _.texImage2D(t, i, s, d, f, l);
            break;
          case "compressed":
            for (let [T, v] of l.entries())
              _.compressedTexImage2D(t, T, v.format, v.width, v.height, o, v.data);
            break;
          default:
            w(false, "Unknown image data type");
        }
      }), l && l.byteLength)
        this._trackAllocatedMemory(l.byteLength, "Texture");
      else {
        let T = vo[this.dataFormat] || 4, v = Ao[this.type] || 1;
        this._trackAllocatedMemory(this.width * this.height * T * v, "Texture");
      }
      return this.loaded = true, this;
    }
    setSubImageData({ target: e = this.target, pixels: t = null, data: n = null, x: i = 0, y: s = 0, width: o = this.width, height: a = this.height, level: c = 0, format: l = this.format, type: f = this.type, dataFormat: u = this.dataFormat, compressed: h = false, offset: d = 0, border: m = this.border, parameters: _ = {} }) {
      if ({ type: f, dataFormat: u, compressed: h, width: o, height: a } = this._deduceParameters({ format: l, type: f, dataFormat: u, compressed: h, data: n, width: o, height: a }), w(this.depth === 0, "texSubImage not supported for 3D textures"), n || (n = t), n && n.data) {
        let E = n;
        n = E.data, o = E.shape[0], a = E.shape[1];
      }
      n instanceof k && (n = n.handle), this.gl.bindTexture(this.target, this.handle), ae(this.gl, _, () => {
        if (h)
          this.gl.compressedTexSubImage2D(e, c, i, s, o, a, l, n);
        else if (n === null)
          this.gl.texSubImage2D(e, c, i, s, o, a, u, f, null);
        else if (ArrayBuffer.isView(n))
          this.gl.texSubImage2D(e, c, i, s, o, a, u, f, n, d);
        else if (n instanceof Ad) {
          let E = te(this.gl);
          E.bindBuffer(35052, n), E.texSubImage2D(e, c, i, s, o, a, u, f, d), E.bindBuffer(35052, null);
        } else
          U(this.gl) ? te(this.gl).texSubImage2D(e, c, i, s, o, a, u, f, n) : this.gl.texSubImage2D(e, c, i, s, u, f, n);
      }), this.gl.bindTexture(this.target, null);
    }
    copyFramebuffer(e = {}) {
      return I.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")(), null;
    }
    getActiveUnit() {
      return this.gl.getParameter(34016) - 33984;
    }
    bind(e = this.textureUnit) {
      let { gl: t } = this;
      return e !== void 0 && (this.textureUnit = e, t.activeTexture(33984 + e)), t.bindTexture(this.target, this.handle), e;
    }
    unbind(e = this.textureUnit) {
      let { gl: t } = this;
      return e !== void 0 && (this.textureUnit = e, t.activeTexture(33984 + e)), t.bindTexture(this.target, null), e;
    }
    _getDataType({ data: e, compressed: t = false }) {
      return t ? { data: e, dataType: "compressed" } : e === null ? { data: e, dataType: "null" } : ArrayBuffer.isView(e) ? { data: e, dataType: "typed-array" } : e instanceof k ? { data: e.handle, dataType: "buffer" } : e instanceof Ad ? { data: e, dataType: "buffer" } : { data: e, dataType: "browser-object" };
    }
    _deduceParameters(e) {
      let { format: t, data: n } = e, { width: i, height: s, dataFormat: o, type: a, compressed: c } = e, l = To[t];
      return o = o || l && l.dataFormat, a = a || l && l.types[0], c = c || l && l.compressed, { width: i, height: s } = this._deduceImageSize(n, i, s), { dataFormat: o, type: a, compressed: c, width: i, height: s, format: t, data: n };
    }
    _deduceImageSize(e, t, n) {
      let i;
      return typeof ImageData != "undefined" && e instanceof ImageData ? i = { width: e.width, height: e.height } : typeof HTMLImageElement != "undefined" && e instanceof HTMLImageElement ? i = { width: e.naturalWidth, height: e.naturalHeight } : typeof HTMLCanvasElement != "undefined" && e instanceof HTMLCanvasElement ? i = { width: e.width, height: e.height } : typeof ImageBitmap != "undefined" && e instanceof ImageBitmap ? i = { width: e.width, height: e.height } : typeof HTMLVideoElement != "undefined" && e instanceof HTMLVideoElement ? i = { width: e.videoWidth, height: e.videoHeight } : e ? i = { width: t, height: n } : i = { width: t >= 0 ? t : 1, height: n >= 0 ? n : 1 }, w(i, "Could not deduced texture size"), w(t === void 0 || i.width === t, "Deduced texture width does not match supplied width"), w(n === void 0 || i.height === n, "Deduced texture height does not match supplied height"), i;
    }
    _createHandle() {
      return this.gl.createTexture();
    }
    _deleteHandle() {
      this.gl.deleteTexture(this.handle), this._trackDeallocatedMemory("Texture");
    }
    _getParameter(e) {
      switch (e) {
        case 4096:
          return this.width;
        case 4097:
          return this.height;
        default:
          this.gl.bindTexture(this.target, this.handle);
          let t = this.gl.getTexParameter(this.target, e);
          return this.gl.bindTexture(this.target, null), t;
      }
    }
    _setParameter(e, t) {
      switch (this.gl.bindTexture(this.target, this.handle), t = this._getNPOTParam(e, t), e) {
        case 33082:
        case 33083:
          this.gl.texParameterf(this.handle, e, t);
          break;
        case 4096:
        case 4097:
          w(false);
          break;
        default:
          this.gl.texParameteri(this.target, e, t);
          break;
      }
      return this.gl.bindTexture(this.target, null), this;
    }
    _isNPOT() {
      return U(this.gl) || !this.width || !this.height ? false : !bo(this.width) || !bo(this.height);
    }
    _updateForNPOT(e) {
      e[this.gl.TEXTURE_MIN_FILTER] === void 0 && (e[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR), e[this.gl.TEXTURE_WRAP_S] === void 0 && (e[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE), e[this.gl.TEXTURE_WRAP_T] === void 0 && (e[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE);
    }
    _getNPOTParam(e, t) {
      if (this._isNPOT())
        switch (e) {
          case 10241:
            kE.indexOf(t) === -1 && (t = 9729);
            break;
          case 10242:
          case 10243:
            t !== 33071 && (t = 33071);
            break;
          default:
            break;
        }
      return t;
    }
  };
  var VE = "";
  function Sd(r2, e) {
    return w(typeof r2 == "string"), r2 = VE + r2, new Promise((t, n) => {
      try {
        let i = new Image();
        i.onload = () => t(i), i.onerror = () => n(new Error("Could not load image ".concat(r2, "."))), i.crossOrigin = e && e.crossOrigin || "anonymous", i.src = r2;
      } catch (i) {
        n(i);
      }
    });
  }
  var Q = class extends Be {
    static isSupported(e, t) {
      return Be.isSupported(e, t);
    }
    constructor(e, t = {}) {
      Kt(e), (t instanceof Promise || typeof t == "string") && (t = { data: t }), typeof t.data == "string" && (t = Object.assign({}, t, { data: Sd(t.data) }));
      super(e, Object.assign({}, t, { target: 3553 }));
      this.initialize(t), Object.seal(this);
    }
  };
  var Nl = [34069, 34070, 34071, 34072, 34073, 34074];
  var An = class extends Be {
    constructor(e, t = {}) {
      Kt(e);
      super(e, Object.assign({}, t, { target: 34067 }));
      this.initialize(t), Object.seal(this);
    }
    initialize(e = {}) {
      let { mipmaps: t = true, parameters: n = {} } = e;
      return this.opts = e, this.setCubeMapImageData(e).then(() => {
        this.loaded = true, t && this.generateMipmap(e), this.setParameters(n);
      }), this;
    }
    subImage({ face: e, data: t, x: n = 0, y: i = 0, mipmapLevel: s = 0 }) {
      return this._subImage({ target: e, data: t, x: n, y: i, mipmapLevel: s });
    }
    async setCubeMapImageData({ width: e, height: t, pixels: n, data: i, border: s = 0, format: o = 6408, type: a = 5121 }) {
      let { gl: c } = this, l = n || i, f = await Promise.all(Nl.map((u) => {
        let h = l[u];
        return Promise.all(Array.isArray(h) ? h : [h]);
      }));
      this.bind(), Nl.forEach((u, h) => {
        f[h].length > 1 && this.opts.mipmaps !== false && I.warn("".concat(this.id, " has mipmap and multiple LODs."))(), f[h].forEach((d, m) => {
          e && t ? c.texImage2D(u, m, o, e, t, s, o, a, d) : c.texImage2D(u, m, o, o, a, d);
        });
      }), this.unbind();
    }
    setImageDataForFace(e) {
      let { face: t, width: n, height: i, pixels: s, data: o, border: a = 0, format: c = 6408, type: l = 5121 } = e, { gl: f } = this, u = s || o;
      return this.bind(), u instanceof Promise ? u.then((h) => this.setImageDataForFace(Object.assign({}, e, { face: t, data: h, pixels: h }))) : this.width || this.height ? f.texImage2D(t, 0, c, n, i, a, c, l, u) : f.texImage2D(t, 0, c, c, l, u), this;
    }
  };
  An.FACES = Nl;
  var Gi = class extends Be {
    static isSupported(e) {
      return U(e);
    }
    constructor(e, t = {}) {
      te(e), t = Object.assign({ depth: 1 }, t, { target: 32879, unpackFlipY: false });
      super(e, t);
      this.initialize(t), Object.seal(this);
    }
    setImageData({ level: e = 0, dataFormat: t = 6408, width: n, height: i, depth: s = 1, border: o = 0, format: a, type: c = 5121, offset: l = 0, data: f, parameters: u = {} }) {
      if (this._trackDeallocatedMemory("Texture"), this.gl.bindTexture(this.target, this.handle), ae(this.gl, u, () => {
        ArrayBuffer.isView(f) && this.gl.texImage3D(this.target, e, t, n, i, s, o, a, c, f), f instanceof k && (this.gl.bindBuffer(35052, f.handle), this.gl.texImage3D(this.target, e, t, n, i, s, o, a, c, l));
      }), f && f.byteLength)
        this._trackAllocatedMemory(f.byteLength, "Texture");
      else {
        let h = vo[this.dataFormat] || 4, d = Ao[this.type] || 1;
        this._trackAllocatedMemory(this.width * this.height * this.depth * h * d, "Texture");
      }
      return this.loaded = true, this;
    }
  };
  var Zr = "EXT_color_buffer_float";
  var Fl = { [33189]: { bpp: 2 }, [33190]: { gl2: true, bpp: 3 }, [36012]: { gl2: true, bpp: 4 }, [36168]: { bpp: 1 }, [34041]: { bpp: 4 }, [35056]: { gl2: true, bpp: 4 }, [36013]: { gl2: true, bpp: 5 }, [32854]: { bpp: 2 }, [36194]: { bpp: 2 }, [32855]: { bpp: 2 }, [33321]: { gl2: true, bpp: 1 }, [33330]: { gl2: true, bpp: 1 }, [33329]: { gl2: true, bpp: 1 }, [33332]: { gl2: true, bpp: 2 }, [33331]: { gl2: true, bpp: 2 }, [33334]: { gl2: true, bpp: 4 }, [33333]: { gl2: true, bpp: 4 }, [33323]: { gl2: true, bpp: 2 }, [33336]: { gl2: true, bpp: 2 }, [33335]: { gl2: true, bpp: 2 }, [33338]: { gl2: true, bpp: 4 }, [33337]: { gl2: true, bpp: 4 }, [33340]: { gl2: true, bpp: 8 }, [33339]: { gl2: true, bpp: 8 }, [32849]: { gl2: true, bpp: 3 }, [32856]: { gl2: true, bpp: 4 }, [32857]: { gl2: true, bpp: 4 }, [36220]: { gl2: true, bpp: 4 }, [36238]: { gl2: true, bpp: 4 }, [36975]: { gl2: true, bpp: 4 }, [36214]: { gl2: true, bpp: 8 }, [36232]: { gl2: true, bpp: 8 }, [36226]: { gl2: true, bpp: 16 }, [36208]: { gl2: true, bpp: 16 }, [33325]: { gl2: Zr, bpp: 2 }, [33327]: { gl2: Zr, bpp: 4 }, [34842]: { gl2: Zr, bpp: 8 }, [33326]: { gl2: Zr, bpp: 4 }, [33328]: { gl2: Zr, bpp: 8 }, [34836]: { gl2: Zr, bpp: 16 }, [35898]: { gl2: Zr, bpp: 4 } };
  function GE(r2, e, t) {
    let n = t[e];
    if (!n)
      return false;
    let i = U(r2) && n.gl2 || n.gl1;
    return typeof i == "string" ? r2.getExtension(i) : i;
  }
  var qe = class extends me {
    static isSupported(e, { format: t } = { format: null }) {
      return !t || GE(e, t, Fl);
    }
    static getSamplesForFormat(e, { format: t }) {
      return e.getInternalformatParameter(36161, t, 32937);
    }
    constructor(e, t = {}) {
      super(e, t);
      this.initialize(t), Object.seal(this);
    }
    initialize({ format: e, width: t = 1, height: n = 1, samples: i = 0 }) {
      return w(e, "Needs format"), this._trackDeallocatedMemory(), this.gl.bindRenderbuffer(36161, this.handle), i !== 0 && U(this.gl) ? this.gl.renderbufferStorageMultisample(36161, i, e, t, n) : this.gl.renderbufferStorage(36161, e, t, n), this.format = e, this.width = t, this.height = n, this.samples = i, this._trackAllocatedMemory(this.width * this.height * (this.samples || 1) * Fl[this.format].bpp), this;
    }
    resize({ width: e, height: t }) {
      return e !== this.width || t !== this.height ? this.initialize({ width: e, height: t, format: this.format, samples: this.samples }) : this;
    }
    _createHandle() {
      return this.gl.createRenderbuffer();
    }
    _deleteHandle() {
      this.gl.deleteRenderbuffer(this.handle), this._trackDeallocatedMemory();
    }
    _bindHandle(e) {
      this.gl.bindRenderbuffer(36161, e);
    }
    _syncHandle(e) {
      this.format = this.getParameter(36164), this.width = this.getParameter(36162), this.height = this.getParameter(36163), this.samples = this.getParameter(36011);
    }
    _getParameter(e) {
      return this.gl.bindRenderbuffer(36161, this.handle), this.gl.getRenderbufferParameter(36161, e);
    }
  };
  var zE = 256;
  var jE = 1024;
  var WE = 16384;
  var wd = 6144;
  var Pd = 6145;
  var Ld = 6146;
  var Cd = 34041;
  var Rd = "clear: bad arguments";
  function gr(r2, { framebuffer: e = null, color: t = null, depth: n = null, stencil: i = null } = {}) {
    let s = {};
    e && (s.framebuffer = e);
    let o = 0;
    t && (o |= WE, t !== true && (s.clearColor = t)), n && (o |= zE, n !== true && (s.clearDepth = n)), i && (o |= jE, n !== true && (s.clearStencil = n)), w(o !== 0, Rd), ae(r2, s, () => {
      r2.clear(o);
    });
  }
  function Dl(r2, { framebuffer: e = null, buffer: t = wd, drawBuffer: n = 0, value: i = [0, 0, 0, 0] } = {}) {
    te(r2), ae(r2, { framebuffer: e }, () => {
      switch (t) {
        case wd:
          switch (i.constructor) {
            case Int32Array:
              r2.clearBufferiv(t, n, i);
              break;
            case Uint32Array:
              r2.clearBufferuiv(t, n, i);
              break;
            case Float32Array:
            default:
              r2.clearBufferfv(t, n, i);
          }
          break;
        case Pd:
          r2.clearBufferfv(Pd, 0, [i]);
          break;
        case Ld:
          r2.clearBufferiv(Ld, 0, [i]);
          break;
        case Cd:
          let [s, o] = i;
          r2.clearBufferfi(Cd, 0, s, o);
          break;
        default:
          w(false, Rd);
      }
    });
  }
  function Md(r2) {
    switch (r2) {
      case 6406:
      case 33326:
      case 6403:
        return 1;
      case 33328:
      case 33319:
        return 2;
      case 6407:
      case 34837:
        return 3;
      case 6408:
      case 34836:
        return 4;
      default:
        return w(false), 0;
    }
  }
  function Jt(r2, e = {}) {
    let { sourceX: t = 0, sourceY: n = 0, sourceFormat: i = 6408 } = e, { sourceAttachment: s = 36064, target: o = null, sourceWidth: a, sourceHeight: c, sourceType: l } = e, { framebuffer: f, deleteFramebuffer: u } = Id(r2);
    w(f);
    let { gl: h, handle: d, attachments: m } = f;
    a = a || f.width, c = c || f.height, s === 36064 && d === null && (s = 1028), w(m[s]), l = l || m[s].type, o = HE(o, l, i, a, c), l = l || bn(o);
    let _ = h.bindFramebuffer(36160, d);
    return h.readPixels(t, n, a, c, i, l, o), h.bindFramebuffer(36160, _ || null), u && f.delete(), o;
  }
  function So(r2, { sourceAttachment: e = 36064, targetMaxHeight: t = Number.MAX_SAFE_INTEGER } = {}) {
    let n = Jt(r2, { sourceAttachment: e }), { width: i, height: s } = r2;
    for (; s > t; )
      ({ data: n, width: i, height: s } = Il({ data: n, width: i, height: s }));
    Ml({ data: n, width: i, height: s });
    let o = document.createElement("canvas");
    o.width = i, o.height = s;
    let a = o.getContext("2d"), c = a.createImageData(i, s);
    return c.data.set(n), a.putImageData(c, 0, 0), o.toDataURL();
  }
  function wo(r2, e, t = {}) {
    let { sourceX: n = 0, sourceY: i = 0, targetMipmaplevel: s = 0, targetInternalFormat: o = 6408 } = t, { targetX: a, targetY: c, targetZ: l, width: f, height: u } = t, { framebuffer: h, deleteFramebuffer: d } = Id(r2);
    w(h);
    let { gl: m, handle: _ } = h, E = typeof a != "undefined" || typeof c != "undefined" || typeof l != "undefined";
    a = a || 0, c = c || 0, l = l || 0;
    let b = m.bindFramebuffer(36160, _);
    w(e);
    let T = null;
    if (e instanceof Be && (T = e, f = Number.isFinite(f) ? f : T.width, u = Number.isFinite(u) ? u : T.height, T.bind(0), e = T.target), !E)
      m.copyTexImage2D(e, s, o, n, i, f, u, 0);
    else
      switch (e) {
        case 3553:
        case 34067:
          m.copyTexSubImage2D(e, s, a, c, n, i, f, u);
          break;
        case 35866:
        case 32879:
          te(m).copyTexSubImage3D(e, s, a, c, l, n, i, f, u);
          break;
        default:
      }
    return T && T.unbind(), m.bindFramebuffer(36160, b || null), d && h.delete(), T;
  }
  function Id(r2) {
    return r2 instanceof Z ? { framebuffer: r2, deleteFramebuffer: false } : { framebuffer: Od(r2), deleteFramebuffer: true };
  }
  function HE(r2, e, t, n, i) {
    if (r2)
      return r2;
    e = e || 5121;
    let s = Qt(e, { clamped: false }), o = Md(t);
    return new s(n * i * o);
  }
  var K = { WEBGL2: "WEBGL2", VERTEX_ARRAY_OBJECT: "VERTEX_ARRAY_OBJECT", TIMER_QUERY: "TIMER_QUERY", INSTANCED_RENDERING: "INSTANCED_RENDERING", MULTIPLE_RENDER_TARGETS: "MULTIPLE_RENDER_TARGETS", ELEMENT_INDEX_UINT32: "ELEMENT_INDEX_UINT32", BLEND_EQUATION_MINMAX: "BLEND_EQUATION_MINMAX", FLOAT_BLEND: "FLOAT_BLEND", COLOR_ENCODING_SRGB: "COLOR_ENCODING_SRGB", TEXTURE_DEPTH: "TEXTURE_DEPTH", TEXTURE_FLOAT: "TEXTURE_FLOAT", TEXTURE_HALF_FLOAT: "TEXTURE_HALF_FLOAT", TEXTURE_FILTER_LINEAR_FLOAT: "TEXTURE_FILTER_LINEAR_FLOAT", TEXTURE_FILTER_LINEAR_HALF_FLOAT: "TEXTURE_FILTER_LINEAR_HALF_FLOAT", TEXTURE_FILTER_ANISOTROPIC: "TEXTURE_FILTER_ANISOTROPIC", COLOR_ATTACHMENT_RGBA32F: "COLOR_ATTACHMENT_RGBA32F", COLOR_ATTACHMENT_FLOAT: "COLOR_ATTACHMENT_FLOAT", COLOR_ATTACHMENT_HALF_FLOAT: "COLOR_ATTACHMENT_HALF_FLOAT", GLSL_FRAG_DATA: "GLSL_FRAG_DATA", GLSL_FRAG_DEPTH: "GLSL_FRAG_DEPTH", GLSL_DERIVATIVES: "GLSL_DERIVATIVES", GLSL_TEXTURE_LOD: "GLSL_TEXTURE_LOD" };
  function XE(r2) {
    let e = new Q(r2, { format: 6408, type: 5126, dataFormat: 6408 }), t = new Z(r2, { id: "test-framebuffer", check: false, attachments: { [36064]: e } }), n = t.getStatus();
    return e.delete(), t.delete(), n === 36053;
  }
  var Bl = { [K.WEBGL2]: [false, true], [K.VERTEX_ARRAY_OBJECT]: ["OES_vertex_array_object", true], [K.TIMER_QUERY]: ["EXT_disjoint_timer_query", "EXT_disjoint_timer_query_webgl2"], [K.INSTANCED_RENDERING]: ["ANGLE_instanced_arrays", true], [K.MULTIPLE_RENDER_TARGETS]: ["WEBGL_draw_buffers", true], [K.ELEMENT_INDEX_UINT32]: ["OES_element_index_uint", true], [K.BLEND_EQUATION_MINMAX]: ["EXT_blend_minmax", true], [K.FLOAT_BLEND]: ["EXT_float_blend"], [K.COLOR_ENCODING_SRGB]: ["EXT_sRGB", true], [K.TEXTURE_DEPTH]: ["WEBGL_depth_texture", true], [K.TEXTURE_FLOAT]: ["OES_texture_float", true], [K.TEXTURE_HALF_FLOAT]: ["OES_texture_half_float", true], [K.TEXTURE_FILTER_LINEAR_FLOAT]: ["OES_texture_float_linear"], [K.TEXTURE_FILTER_LINEAR_HALF_FLOAT]: ["OES_texture_half_float_linear"], [K.TEXTURE_FILTER_ANISOTROPIC]: ["EXT_texture_filter_anisotropic"], [K.COLOR_ATTACHMENT_RGBA32F]: [XE, "EXT_color_buffer_float"], [K.COLOR_ATTACHMENT_FLOAT]: [false, "EXT_color_buffer_float"], [K.COLOR_ATTACHMENT_HALF_FLOAT]: ["EXT_color_buffer_half_float"], [K.GLSL_FRAG_DATA]: ["WEBGL_draw_buffers", true], [K.GLSL_FRAG_DEPTH]: ["EXT_frag_depth", true], [K.GLSL_DERIVATIVES]: ["OES_standard_derivatives", true], [K.GLSL_TEXTURE_LOD]: ["EXT_shader_texture_lod", true] };
  var YE = 2;
  function zi(r2, e) {
    return _r(r2, e);
  }
  function _r(r2, e) {
    return e = Array.isArray(e) ? e : [e], e.every((t) => Nd(r2, t));
  }
  function Po(r2) {
    r2.luma = r2.luma || {}, r2.luma.caps = r2.luma.caps || {};
    for (let e in Bl)
      r2.luma.caps[e] === void 0 && (r2.luma.caps[e] = Nd(r2, e));
    return r2.luma.caps;
  }
  function Nd(r2, e) {
    return r2.luma = r2.luma || {}, r2.luma.caps = r2.luma.caps || {}, r2.luma.caps[e] === void 0 && (r2.luma.caps[e] = qE(r2, e)), r2.luma.caps[e] || I.log(YE, "Feature: ".concat(e, " not supported"))(), r2.luma.caps[e];
  }
  function qE(r2, e) {
    let t = Bl[e];
    w(t, e);
    let n, i = U(r2) && t[1] || t[0];
    if (typeof i == "function")
      n = i(r2);
    else if (Array.isArray(i)) {
      n = true;
      for (let s of i)
        n = n && Boolean(r2.getExtension(s));
    } else
      typeof i == "string" ? n = Boolean(r2.getExtension(i)) : typeof i == "boolean" ? n = i : w(false);
    return n;
  }
  var Fd = "Multiple render targets not supported";
  var Z = class extends me {
    static isSupported(e, t = {}) {
      let { colorBufferFloat: n, colorBufferHalfFloat: i } = t, s = true;
      return n && (s = Boolean(e.getExtension("EXT_color_buffer_float") || e.getExtension("WEBGL_color_buffer_float") || e.getExtension("OES_texture_float"))), i && (s = s && Boolean(e.getExtension("EXT_color_buffer_float") || e.getExtension("EXT_color_buffer_half_float"))), s;
    }
    static getDefaultFramebuffer(e) {
      return e.luma = e.luma || {}, e.luma.defaultFramebuffer = e.luma.defaultFramebuffer || new Z(e, { id: "default-framebuffer", handle: null, attachments: {} }), e.luma.defaultFramebuffer;
    }
    get MAX_COLOR_ATTACHMENTS() {
      let e = te(this.gl);
      return e.getParameter(e.MAX_COLOR_ATTACHMENTS);
    }
    get MAX_DRAW_BUFFERS() {
      let e = te(this.gl);
      return e.getParameter(e.MAX_DRAW_BUFFERS);
    }
    constructor(e, t = {}) {
      super(e, t);
      this.width = null, this.height = null, this.attachments = {}, this.readBuffer = 36064, this.drawBuffers = [36064], this.ownResources = [], this.initialize(t), Object.seal(this);
    }
    get color() {
      return this.attachments[36064] || null;
    }
    get texture() {
      return this.attachments[36064] || null;
    }
    get depth() {
      return this.attachments[36096] || this.attachments[33306] || null;
    }
    get stencil() {
      return this.attachments[36128] || this.attachments[33306] || null;
    }
    initialize({ width: e = 1, height: t = 1, attachments: n = null, color: i = true, depth: s = true, stencil: o = false, check: a = true, readBuffer: c = void 0, drawBuffers: l = void 0 }) {
      if (w(e >= 0 && t >= 0, "Width and height need to be integers"), this.width = e, this.height = t, n)
        for (let f in n) {
          let u = n[f];
          (Array.isArray(u) ? u[0] : u).resize({ width: e, height: t });
        }
      else
        n = this._createDefaultAttachments(i, s, o, e, t);
      this.update({ clearAttachments: true, attachments: n, readBuffer: c, drawBuffers: l }), n && a && this.checkStatus();
    }
    delete() {
      for (let e of this.ownResources)
        e.delete();
      return super.delete(), this;
    }
    update({ attachments: e = {}, readBuffer: t, drawBuffers: n, clearAttachments: i = false, resizeAttachments: s = true }) {
      this.attach(e, { clearAttachments: i, resizeAttachments: s });
      let { gl: o } = this, a = o.bindFramebuffer(36160, this.handle);
      return t && this._setReadBuffer(t), n && this._setDrawBuffers(n), o.bindFramebuffer(36160, a || null), this;
    }
    resize(e = {}) {
      let { width: t, height: n } = e;
      if (this.handle === null)
        return w(t === void 0 && n === void 0), this.width = this.gl.drawingBufferWidth, this.height = this.gl.drawingBufferHeight, this;
      t === void 0 && (t = this.gl.drawingBufferWidth), n === void 0 && (n = this.gl.drawingBufferHeight), t !== this.width && n !== this.height && I.log(2, "Resizing framebuffer ".concat(this.id, " to ").concat(t, "x").concat(n))();
      for (let i in this.attachments)
        this.attachments[i].resize({ width: t, height: n });
      return this.width = t, this.height = n, this;
    }
    attach(e, { clearAttachments: t = false, resizeAttachments: n = true } = {}) {
      let i = {};
      t && Object.keys(this.attachments).forEach((o) => {
        i[o] = null;
      }), Object.assign(i, e);
      let s = this.gl.bindFramebuffer(36160, this.handle);
      for (let o in i) {
        w(o !== void 0, "Misspelled framebuffer binding point?");
        let a = Number(o), c = i[a], l = c;
        if (!l)
          this._unattach(a);
        else if (l instanceof qe)
          this._attachRenderbuffer({ attachment: a, renderbuffer: l });
        else if (Array.isArray(c)) {
          let [f, u = 0, h = 0] = c;
          l = f, this._attachTexture({ attachment: a, texture: f, layer: u, level: h });
        } else
          this._attachTexture({ attachment: a, texture: l, layer: 0, level: 0 });
        n && l && l.resize({ width: this.width, height: this.height });
      }
      this.gl.bindFramebuffer(36160, s || null), Object.assign(this.attachments, e), Object.keys(this.attachments).filter((o) => !this.attachments[o]).forEach((o) => {
        delete this.attachments[o];
      });
    }
    checkStatus() {
      let { gl: e } = this, t = this.getStatus();
      if (t !== 36053)
        throw new Error(KE(t));
      return this;
    }
    getStatus() {
      let { gl: e } = this, t = e.bindFramebuffer(36160, this.handle), n = e.checkFramebufferStatus(36160);
      return e.bindFramebuffer(36160, t || null), n;
    }
    clear(e = {}) {
      let { color: t, depth: n, stencil: i, drawBuffers: s = [] } = e, o = this.gl.bindFramebuffer(36160, this.handle);
      return (t || n || i) && gr(this.gl, { color: t, depth: n, stencil: i }), s.forEach((a, c) => {
        Dl(this.gl, { drawBuffer: c, value: a });
      }), this.gl.bindFramebuffer(36160, o || null), this;
    }
    readPixels(e = {}) {
      return I.error("Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)")(), null;
    }
    readPixelsToBuffer(e = {}) {
      return I.error("Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)")(), null;
    }
    copyToDataUrl(e = {}) {
      return I.error("Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)")(), null;
    }
    copyToImage(e = {}) {
      return I.error("Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)")(), null;
    }
    copyToTexture(e = {}) {
      return I.error("Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})")(), null;
    }
    blit(e = {}) {
      return I.error("Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)")(), null;
    }
    invalidate({ attachments: e = [], x: t = 0, y: n = 0, width: i, height: s }) {
      let o = te(this.gl), a = o.bindFramebuffer(36008, this.handle);
      return t === 0 && n === 0 && i === void 0 && s === void 0 ? o.invalidateFramebuffer(36008, e) : o.invalidateFramebuffer(36008, e, t, n, i, s), o.bindFramebuffer(36008, a), this;
    }
    getAttachmentParameter(e, t, n) {
      let i = this._getAttachmentParameterFallback(t);
      return i === null && (this.gl.bindFramebuffer(36160, this.handle), i = this.gl.getFramebufferAttachmentParameter(36160, e, t), this.gl.bindFramebuffer(36160, null)), n && i > 1e3 && (i = Ye(this.gl, i)), i;
    }
    getAttachmentParameters(e = 36064, t, n = this.constructor.ATTACHMENT_PARAMETERS || []) {
      let i = {};
      for (let s of n) {
        let o = t ? Ye(this.gl, s) : s;
        i[o] = this.getAttachmentParameter(e, s, t);
      }
      return i;
    }
    getParameters(e = true) {
      let t = Object.keys(this.attachments), n = {};
      for (let i of t) {
        let s = Number(i), o = e ? Ye(this.gl, s) : s;
        n[o] = this.getAttachmentParameters(s, e);
      }
      return n;
    }
    show() {
      return typeof window != "undefined" && window.open(So(this), "luma-debug-texture"), this;
    }
    log(e = 0, t = "") {
      if (e > I.level || typeof window == "undefined")
        return this;
      t = t || "Framebuffer ".concat(this.id);
      let n = So(this, { targetMaxHeight: 100 });
      return I.image({ logLevel: e, message: t, image: n }, t)(), this;
    }
    bind({ target: e = 36160 } = {}) {
      return this.gl.bindFramebuffer(e, this.handle), this;
    }
    unbind({ target: e = 36160 } = {}) {
      return this.gl.bindFramebuffer(e, null), this;
    }
    _createDefaultAttachments(e, t, n, i, s) {
      let o = null;
      return e && (o = o || {}, o[36064] = new Q(this.gl, { id: "".concat(this.id, "-color0"), pixels: null, format: 6408, type: 5121, width: i, height: s, mipmaps: false, parameters: { [10241]: 9729, [10240]: 9729, [10242]: 33071, [10243]: 33071 } }), this.ownResources.push(o[36064])), t && n ? (o = o || {}, o[33306] = new qe(this.gl, { id: "".concat(this.id, "-depth-stencil"), format: 35056, width: i, height: 111 }), this.ownResources.push(o[33306])) : t ? (o = o || {}, o[36096] = new qe(this.gl, { id: "".concat(this.id, "-depth"), format: 33189, width: i, height: s }), this.ownResources.push(o[36096])) : n && w(false), o;
    }
    _unattach(e) {
      let t = this.attachments[e];
      !t || (t instanceof qe ? this.gl.framebufferRenderbuffer(36160, e, 36161, null) : this.gl.framebufferTexture2D(36160, e, 3553, null, 0), delete this.attachments[e]);
    }
    _attachRenderbuffer({ attachment: e = 36064, renderbuffer: t }) {
      let { gl: n } = this;
      n.framebufferRenderbuffer(36160, e, 36161, t.handle), this.attachments[e] = t;
    }
    _attachTexture({ attachment: e = 36064, texture: t, layer: n, level: i }) {
      let { gl: s } = this;
      switch (s.bindTexture(t.target, t.handle), t.target) {
        case 35866:
        case 32879:
          te(s).framebufferTextureLayer(36160, e, t.target, i, n);
          break;
        case 34067:
          let a = ZE(n);
          s.framebufferTexture2D(36160, e, a, t.handle, i);
          break;
        case 3553:
          s.framebufferTexture2D(36160, e, 3553, t.handle, i);
          break;
        default:
          w(false, "Illegal texture type");
      }
      s.bindTexture(t.target, null), this.attachments[e] = t;
    }
    _setReadBuffer(e) {
      let t = Tl(this.gl);
      t ? t.readBuffer(e) : w(e === 36064 || e === 1029, Fd), this.readBuffer = e;
    }
    _setDrawBuffers(e) {
      let { gl: t } = this, n = te(t);
      if (n)
        n.drawBuffers(e);
      else {
        let i = t.getExtension("WEBGL_draw_buffers");
        i ? i.drawBuffersWEBGL(e) : w(e.length === 1 && (e[0] === 36064 || e[0] === 1029), Fd);
      }
      this.drawBuffers = e;
    }
    _getAttachmentParameterFallback(e) {
      let t = Po(this.gl);
      switch (e) {
        case 36052:
          return t.WEBGL2 ? null : 0;
        case 33298:
        case 33299:
        case 33300:
        case 33301:
        case 33302:
        case 33303:
          return t.WEBGL2 ? null : 8;
        case 33297:
          return t.WEBGL2 ? null : 5125;
        case 33296:
          return !t.WEBGL2 && !t.EXT_sRGB ? 9729 : null;
        default:
          return null;
      }
    }
    _createHandle() {
      return this.gl.createFramebuffer();
    }
    _deleteHandle() {
      this.gl.deleteFramebuffer(this.handle);
    }
    _bindHandle(e) {
      return this.gl.bindFramebuffer(36160, e);
    }
  };
  function ZE(r2) {
    return r2 < 34069 ? r2 + 34069 : r2;
  }
  function KE(r2) {
    return (Z.STATUS || {})[r2] || "Framebuffer error ".concat(r2);
  }
  var QE = [36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303];
  Z.ATTACHMENT_PARAMETERS = QE;
  function Sn(r2, e) {
    w(r2 instanceof Q || r2 instanceof An || r2 instanceof Gi);
    let t = r2.constructor, { gl: n, width: i, height: s, format: o, type: a, dataFormat: c, border: l, mipmaps: f } = r2, u = Object.assign({ width: i, height: s, format: o, type: a, dataFormat: c, border: l, mipmaps: f }, e);
    return new t(n, u);
  }
  function Od(r2, e) {
    let { gl: t, width: n, height: i, id: s } = r2;
    return new Z(t, Object.assign({}, e, { id: "framebuffer-for-".concat(s), width: n, height: i, attachments: { [36064]: r2 } }));
  }
  function xr(r2, e = "unnamed") {
    let t = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/, n = r2.match(t);
    return n ? n[1] : e;
  }
  var JE = 35632;
  var $E = 35633;
  function Ul(r2) {
    switch (r2) {
      case JE:
        return "fragment";
      case $E:
        return "vertex";
      default:
        return "unknown type";
    }
  }
  function kl(r2, e, t, n) {
    let i = r2.split(/\r?\n/), s = {}, o = {}, a = n || xr(e) || "(unnamed)", c = "".concat(Ul(t), " shader ").concat(a);
    for (let f = 0; f < i.length; f++) {
      let u = i[f];
      if (u.length <= 1)
        continue;
      let h = u.split(":"), d = h[0], m = parseInt(h[2], 10);
      if (isNaN(m))
        throw new Error("GLSL compilation error in ".concat(c, ": ").concat(r2));
      d !== "WARNING" ? s[m] = u : o[m] = u;
    }
    let l = eb(e);
    return { shaderName: c, errors: Dd(s, l), warnings: Dd(o, l) };
  }
  function Dd(r2, e) {
    let t = "";
    for (let n = 0; n < e.length; n++) {
      let i = e[n];
      if (!(!r2[n + 3] && !r2[n + 2] && !r2[n + 1]) && (t += "".concat(i, `
`), r2[n + 1])) {
        let s = r2[n + 1], o = s.split(":", 3), a = o[0], c = parseInt(o[1], 10) || 0, l = s.substring(o.join(":").length + 1).trim();
        t += Bd("^^^ ".concat(a, ": ").concat(l, `

`), c);
      }
    }
    return t;
  }
  function eb(r2, e = 1, t = ": ") {
    let n = r2.split(/\r?\n/), i = String(n.length + e - 1).length;
    return n.map((s, o) => {
      let a = String(o + e), c = a.length;
      return Bd(a, i - c) + t + s;
    });
  }
  function Bd(r2, e) {
    let t = "";
    for (let n = 0; n < e; ++n)
      t += " ";
    return "".concat(t).concat(r2);
  }
  function wn(r2) {
    let e = 100, t = r2.match(/[^\s]+/g);
    if (t.length >= 2 && t[0] === "#version") {
      let n = parseInt(t[1], 10);
      Number.isFinite(n) && (e = n);
    }
    return e;
  }
  var tb = "Shader: GLSL source code must be a JavaScript string";
  var Pn = class extends me {
    static getTypeName(e) {
      switch (e) {
        case 35633:
          return "vertex-shader";
        case 35632:
          return "fragment-shader";
        default:
          return w(false), "unknown";
      }
    }
    constructor(e, t) {
      Kt(e), w(typeof t.source == "string", tb);
      let n = xr(t.source, null) || t.id || Pe("unnamed ".concat(Pn.getTypeName(t.shaderType)));
      super(e, { id: n });
      this.shaderType = t.shaderType, this.source = t.source, this.initialize(t);
    }
    initialize({ source: e }) {
      let t = xr(e, null);
      t && (this.id = Pe(t)), this._compile(e);
    }
    getParameter(e) {
      return this.gl.getShaderParameter(this.handle, e);
    }
    toString() {
      return "".concat(Pn.getTypeName(this.shaderType), ":").concat(this.id);
    }
    getName() {
      return xr(this.source) || "unnamed-shader";
    }
    getSource() {
      return this.gl.getShaderSource(this.handle);
    }
    getTranslatedSource() {
      let e = this.gl.getExtension("WEBGL_debug_shaders");
      return e ? e.getTranslatedShaderSource(this.handle) : "No translated source available. WEBGL_debug_shaders not implemented";
    }
    _compile(e = this.source) {
      if (e.startsWith("#version ") || (e = `#version 100
`.concat(e)), this.source = e, this.gl.shaderSource(this.handle, this.source), this.gl.compileShader(this.handle), !this.getParameter(35713)) {
        let n = this.gl.getShaderInfoLog(this.handle), { shaderName: i, errors: s, warnings: o } = kl(n, this.source, this.shaderType, this.id);
        throw I.error("GLSL compilation errors in ".concat(i, `
`).concat(s))(), I.warn("GLSL compilation warnings in ".concat(i, `
`).concat(o))(), new Error("GLSL compilation errors in ".concat(i));
      }
    }
    _deleteHandle() {
      this.gl.deleteShader(this.handle);
    }
    _getOptsFromHandle() {
      return { type: this.getParameter(35663), source: this.getSource() };
    }
  };
  var ji = class extends Pn {
    constructor(e, t) {
      typeof t == "string" && (t = { source: t });
      super(e, Object.assign({}, t, { shaderType: 35633 }));
    }
    _createHandle() {
      return this.gl.createShader(35633);
    }
  };
  var Wi = class extends Pn {
    constructor(e, t) {
      typeof t == "string" && (t = { source: t });
      super(e, Object.assign({}, t, { shaderType: 35632 }));
    }
    _createHandle() {
      return this.gl.createShader(35632);
    }
  };
  var rb = { [5126]: re.bind(null, "uniform1fv", Ze, 1, Le), [35664]: re.bind(null, "uniform2fv", Ze, 2, Le), [35665]: re.bind(null, "uniform3fv", Ze, 3, Le), [35666]: re.bind(null, "uniform4fv", Ze, 4, Le), [5124]: re.bind(null, "uniform1iv", yr, 1, Le), [35667]: re.bind(null, "uniform2iv", yr, 2, Le), [35668]: re.bind(null, "uniform3iv", yr, 3, Le), [35669]: re.bind(null, "uniform4iv", yr, 4, Le), [35670]: re.bind(null, "uniform1iv", yr, 1, Le), [35671]: re.bind(null, "uniform2iv", yr, 2, Le), [35672]: re.bind(null, "uniform3iv", yr, 3, Le), [35673]: re.bind(null, "uniform4iv", yr, 4, Le), [35674]: re.bind(null, "uniformMatrix2fv", Ze, 4, $t), [35675]: re.bind(null, "uniformMatrix3fv", Ze, 9, $t), [35676]: re.bind(null, "uniformMatrix4fv", Ze, 16, $t), [35678]: ve, [35680]: ve, [5125]: re.bind(null, "uniform1uiv", Lo, 1, Le), [36294]: re.bind(null, "uniform2uiv", Lo, 2, Le), [36295]: re.bind(null, "uniform3uiv", Lo, 3, Le), [36296]: re.bind(null, "uniform4uiv", Lo, 4, Le), [35685]: re.bind(null, "uniformMatrix2x3fv", Ze, 6, $t), [35686]: re.bind(null, "uniformMatrix2x4fv", Ze, 8, $t), [35687]: re.bind(null, "uniformMatrix3x2fv", Ze, 6, $t), [35688]: re.bind(null, "uniformMatrix3x4fv", Ze, 12, $t), [35689]: re.bind(null, "uniformMatrix4x2fv", Ze, 8, $t), [35690]: re.bind(null, "uniformMatrix4x3fv", Ze, 12, $t), [35678]: ve, [35680]: ve, [35679]: ve, [35682]: ve, [36289]: ve, [36292]: ve, [36293]: ve, [36298]: ve, [36299]: ve, [36300]: ve, [36303]: ve, [36306]: ve, [36307]: ve, [36308]: ve, [36311]: ve };
  var nb = {};
  var ib = {};
  var sb = {};
  var Ud = [0];
  function Vl(r2, e, t, n) {
    e === 1 && typeof r2 == "boolean" && (r2 = r2 ? 1 : 0), Number.isFinite(r2) && (Ud[0] = r2, r2 = Ud);
    let i = r2.length;
    if (i % e && I.warn("Uniform size should be multiples of ".concat(e), r2)(), r2 instanceof t)
      return r2;
    let s = n[i];
    s || (s = new t(i), n[i] = s);
    for (let o = 0; o < i; o++)
      s[o] = r2[o];
    return s;
  }
  function Ze(r2, e) {
    return Vl(r2, e, Float32Array, nb);
  }
  function yr(r2, e) {
    return Vl(r2, e, Int32Array, ib);
  }
  function Lo(r2, e) {
    return Vl(r2, e, Uint32Array, sb);
  }
  function Gl(r2, e, t) {
    let n = rb[t.type];
    if (!n)
      throw new Error("Unknown GLSL uniform type ".concat(t.type));
    return n().bind(null, r2, e);
  }
  function kd(r2) {
    if (r2[r2.length - 1] !== "]")
      return { name: r2, length: 1, isArray: false };
    let e = /([^[]*)(\[[0-9]+\])?/, t = r2.match(e);
    if (!t || t.length < 2)
      throw new Error("Failed to parse GLSL uniform name ".concat(r2));
    return { name: t[1], length: t[2] || 1, isArray: Boolean(t[2]) };
  }
  function Vd(r2, e, t) {
    for (let n in r2) {
      let i = r2[n];
      if ((!t || Boolean(t[n])) && !ob(i))
        throw e = e ? "".concat(e, " ") : "", console.error("".concat(e, " Bad uniform ").concat(n), i), new Error("".concat(e, " Bad uniform ").concat(n));
    }
    return true;
  }
  function ob(r2) {
    return Array.isArray(r2) || ArrayBuffer.isView(r2) ? ab(r2) : isFinite(r2) || r2 === true || r2 === false || r2 instanceof Be || r2 instanceof qe ? true : r2 instanceof Z ? Boolean(r2.texture) : false;
  }
  function Gd(r2, e, t) {
    if (Array.isArray(t) || ArrayBuffer.isView(t))
      if (r2[e]) {
        let n = r2[e];
        for (let i = 0, s = t.length; i < s; ++i)
          n[i] = t[i];
      } else
        r2[e] = t.slice();
    else
      r2[e] = t;
  }
  function ab(r2) {
    if (r2.length === 0)
      return false;
    let e = Math.min(r2.length, 16);
    for (let t = 0; t < e; ++t)
      if (!Number.isFinite(r2[t]))
        return false;
    return true;
  }
  function ve() {
    let r2 = null;
    return (e, t, n) => {
      let i = r2 !== n;
      return i && (e.uniform1i(t, n), r2 = n), i;
    };
  }
  function re(r2, e, t, n) {
    let i = null, s = null;
    return (o, a, c) => {
      let l = e(c, t), f = l.length, u = false;
      if (i === null)
        i = new Float32Array(f), s = f, u = true;
      else {
        w(s === f, "Uniform length cannot change.");
        for (let h = 0; h < f; ++h)
          if (l[h] !== i[h]) {
            u = true;
            break;
          }
      }
      return u && (n(o, r2, a, l), i.set(l)), u;
    };
  }
  function Le(r2, e, t, n) {
    r2[e](t, n);
  }
  function $t(r2, e, t, n) {
    r2[e](t, false, n);
  }
  var cb = 5120;
  var lb = 5121;
  var fb = 5122;
  var ub = 5123;
  var zd = 0;
  var Co = 1;
  var hb = 2;
  var db = 3;
  var Ro = 4;
  var pb = 5;
  var mb = 6;
  var _e = 5126;
  var gb = 35664;
  var _b = 35665;
  var xb = 35666;
  var Hi = 5124;
  var yb = 35667;
  var Eb = 35668;
  var bb = 35669;
  var Xi = 5125;
  var Tb = 36294;
  var vb = 36295;
  var Ab = 36296;
  var Sb = 35670;
  var wb = 35671;
  var Pb = 35672;
  var Lb = 35673;
  var Cb = 35674;
  var Rb = 35675;
  var Mb = 35676;
  var Ib = 35685;
  var Ob = 35686;
  var Nb = 35687;
  var Fb = 35688;
  var Db = 35689;
  var Bb = 35690;
  var zl = { [_e]: [_e, 1, "float"], [gb]: [_e, 2, "vec2"], [_b]: [_e, 3, "vec3"], [xb]: [_e, 4, "vec4"], [Hi]: [Hi, 1, "int"], [yb]: [Hi, 2, "ivec2"], [Eb]: [Hi, 3, "ivec3"], [bb]: [Hi, 4, "ivec4"], [Xi]: [Xi, 1, "uint"], [Tb]: [Xi, 2, "uvec2"], [vb]: [Xi, 3, "uvec3"], [Ab]: [Xi, 4, "uvec4"], [Sb]: [_e, 1, "bool"], [wb]: [_e, 2, "bvec2"], [Pb]: [_e, 3, "bvec3"], [Lb]: [_e, 4, "bvec4"], [Cb]: [_e, 8, "mat2"], [Ib]: [_e, 8, "mat2x3"], [Ob]: [_e, 8, "mat2x4"], [Rb]: [_e, 12, "mat3"], [Nb]: [_e, 12, "mat3x2"], [Fb]: [_e, 12, "mat3x4"], [Mb]: [_e, 16, "mat4"], [Db]: [_e, 16, "mat4x2"], [Bb]: [_e, 16, "mat4x3"] };
  function jd(r2) {
    switch (r2) {
      case zd:
        return zd;
      case Co:
        return Co;
      case db:
        return Co;
      case hb:
        return Co;
      case Ro:
        return Ro;
      case pb:
        return Ro;
      case mb:
        return Ro;
      default:
        return w(false), 0;
    }
  }
  function jl(r2) {
    let e = zl[r2];
    if (!e)
      return null;
    let [t, n] = e;
    return { type: t, components: n };
  }
  function Mo(r2, e) {
    switch (r2) {
      case cb:
      case lb:
      case fb:
      case ub:
        r2 = _e;
        break;
      default:
    }
    for (let t in zl) {
      let [n, i, s] = zl[t];
      if (n === r2 && i === e)
        return { glType: t, name: s };
    }
    return null;
  }
  var Io = class {
    constructor(e) {
      this.id = e.id, this.attributeInfos = [], this.attributeInfosByName = {}, this.attributeInfosByLocation = [], this.varyingInfos = [], this.varyingInfosByName = {}, Object.seal(this), this._readAttributesFromProgram(e), this._readVaryingsFromProgram(e);
    }
    getAttributeInfo(e) {
      let t = Number(e);
      return Number.isFinite(t) ? this.attributeInfosByLocation[t] : this.attributeInfosByName[e] || null;
    }
    getAttributeLocation(e) {
      let t = this.getAttributeInfo(e);
      return t ? t.location : -1;
    }
    getAttributeAccessor(e) {
      let t = this.getAttributeInfo(e);
      return t ? t.accessor : null;
    }
    getVaryingInfo(e) {
      let t = Number(e);
      return Number.isFinite(t) ? this.varyingInfos[t] : this.varyingInfosByName[e] || null;
    }
    getVaryingIndex(e) {
      let t = this.getVaryingInfo();
      return t ? t.location : -1;
    }
    getVaryingAccessor(e) {
      let t = this.getVaryingInfo();
      return t ? t.accessor : null;
    }
    _readAttributesFromProgram(e) {
      let { gl: t } = e, n = t.getProgramParameter(e.handle, 35721);
      for (let i = 0; i < n; i++) {
        let { name: s, type: o, size: a } = t.getActiveAttrib(e.handle, i), c = t.getAttribLocation(e.handle, s);
        c >= 0 && this._addAttribute(c, s, o, a);
      }
      this.attributeInfos.sort((i, s) => i.location - s.location);
    }
    _readVaryingsFromProgram(e) {
      let { gl: t } = e;
      if (!U(t))
        return;
      let n = t.getProgramParameter(e.handle, 35971);
      for (let i = 0; i < n; i++) {
        let { name: s, type: o, size: a } = t.getTransformFeedbackVarying(e.handle, i);
        this._addVarying(i, s, o, a);
      }
      this.varyingInfos.sort((i, s) => i.location - s.location);
    }
    _addAttribute(e, t, n, i) {
      let { type: s, components: o } = jl(n), a = { type: s, size: i * o };
      this._inferProperties(e, t, a);
      let c = { location: e, name: t, accessor: new be(a) };
      this.attributeInfos.push(c), this.attributeInfosByLocation[e] = c, this.attributeInfosByName[c.name] = c;
    }
    _inferProperties(e, t, n) {
      /instance/i.test(t) && (n.divisor = 1);
    }
    _addVarying(e, t, n, i) {
      let { type: s, components: o } = jl(n), a = new be({ type: s, size: i * o }), c = { location: e, name: t, accessor: a };
      this.varyingInfos.push(c), this.varyingInfosByName[c.name] = c;
    }
  };
  var Wd = 4;
  var Ub = 35981;
  var kb = ["setVertexArray", "setAttributes", "setBuffers", "unsetBuffers", "use", "getUniformCount", "getUniformInfo", "getUniformLocation", "getUniformValue", "getVarying", "getFragDataLocation", "getAttachedShaders", "getAttributeCount", "getAttributeLocation", "getAttributeInfo"];
  var Er = class extends me {
    constructor(e, t = {}) {
      super(e, t);
      this.stubRemovedMethods("Program", "v6.0", kb), this._isCached = false, this.initialize(t), Object.seal(this), this._setId(t.id);
    }
    initialize(e = {}) {
      let { hash: t, vs: n, fs: i, varyings: s, bufferMode: o = Ub } = e;
      return this.hash = t || "", this.vs = typeof n == "string" ? new ji(this.gl, { id: "".concat(e.id, "-vs"), source: n }) : n, this.fs = typeof i == "string" ? new Wi(this.gl, { id: "".concat(e.id, "-fs"), source: i }) : i, w(this.vs instanceof ji), w(this.fs instanceof Wi), this.uniforms = {}, this._textureUniforms = {}, s && s.length > 0 && (te(this.gl), this.varyings = s, this.gl2.transformFeedbackVaryings(this.handle, s, o)), this._compileAndLink(), this._readUniformLocationsFromLinkedProgram(), this.configuration = new Io(this), this.setProps(e);
    }
    delete(e = {}) {
      return this._isCached ? this : super.delete(e);
    }
    setProps(e) {
      return "uniforms" in e && this.setUniforms(e.uniforms), this;
    }
    draw({ logPriority: e, drawMode: t = 4, vertexCount: n, offset: i = 0, start: s, end: o, isIndexed: a = false, indexType: c = 5123, instanceCount: l = 0, isInstanced: f = l > 0, vertexArray: u = null, transformFeedback: h, framebuffer: d, parameters: m = {}, uniforms: _, samplers: E }) {
      if ((_ || E) && (I.deprecated("Program.draw({uniforms})", "Program.setUniforms(uniforms)")(), this.setUniforms(_ || {})), I.priority >= e) {
        let b = d ? d.id : "default", T = "mode=".concat(Ye(this.gl, t), " verts=").concat(n, " ") + "instances=".concat(l, " indexType=").concat(Ye(this.gl, c), " ") + "isInstanced=".concat(f, " isIndexed=").concat(a, " ") + "Framebuffer=".concat(b);
        I.log(e, T)();
      }
      return w(u), this.gl.useProgram(this.handle), !this._areTexturesRenderable() || n === 0 || f && l === 0 ? false : (u.bindForDraw(n, l, () => {
        if (d !== void 0 && (m = Object.assign({}, m, { framebuffer: d })), h) {
          let b = jd(t);
          h.begin(b);
        }
        this._bindTextures(), ae(this.gl, m, () => {
          a && f ? this.gl2.drawElementsInstanced(t, n, c, i, l) : a && U(this.gl) && !isNaN(s) && !isNaN(o) ? this.gl2.drawRangeElements(t, s, o, n, c, i) : a ? this.gl.drawElements(t, n, c, i) : f ? this.gl2.drawArraysInstanced(t, i, n, l) : this.gl.drawArrays(t, i, n);
        }), h && h.end();
      }), true);
    }
    setUniforms(e = {}) {
      I.priority >= 2 && Vd(e, this.id, this._uniformSetters), this.gl.useProgram(this.handle);
      for (let t in e) {
        let n = e[t], i = this._uniformSetters[t];
        if (i) {
          let s = n, o = false;
          if (s instanceof Z && (s = s.texture), s instanceof Be)
            if (o = this.uniforms[t] !== n, o) {
              i.textureIndex === void 0 && (i.textureIndex = this._textureIndexCounter++);
              let a = s, { textureIndex: c } = i;
              a.bind(c), s = c, this._textureUniforms[t] = a;
            } else
              s = i.textureIndex;
          else
            this._textureUniforms[t] && delete this._textureUniforms[t];
          (i(s) || o) && Gd(this.uniforms, t, n);
        }
      }
      return this;
    }
    _areTexturesRenderable() {
      let e = true;
      for (let t in this._textureUniforms) {
        let n = this._textureUniforms[t];
        n.update(), e = e && n.loaded;
      }
      return e;
    }
    _bindTextures() {
      for (let e in this._textureUniforms) {
        let t = this._uniformSetters[e].textureIndex;
        this._textureUniforms[e].bind(t);
      }
    }
    _createHandle() {
      return this.gl.createProgram();
    }
    _deleteHandle() {
      this.gl.deleteProgram(this.handle);
    }
    _getOptionsFromHandle(e) {
      let t = this.gl.getAttachedShaders(e), n = {};
      for (let i of t)
        switch (this.gl.getShaderParameter(this.handle, 35663)) {
          case 35633:
            n.vs = new ji({ handle: i });
            break;
          case 35632:
            n.fs = new Wi({ handle: i });
            break;
          default:
        }
      return n;
    }
    _getParameter(e) {
      return this.gl.getProgramParameter(this.handle, e);
    }
    _setId(e) {
      if (!e) {
        let t = this._getName();
        this.id = Pe(t);
      }
    }
    _getName() {
      let e = this.vs.getName() || this.fs.getName();
      return e = e.replace(/shader/i, ""), e = e ? "".concat(e, "-program") : "program", e;
    }
    _compileAndLink() {
      let { gl: e } = this;
      if (e.attachShader(this.handle, this.vs.handle), e.attachShader(this.handle, this.fs.handle), I.time(Wd, "linkProgram for ".concat(this._getName()))(), e.linkProgram(this.handle), I.timeEnd(Wd, "linkProgram for ".concat(this._getName()))(), e.debug || I.level > 0) {
        if (!e.getProgramParameter(this.handle, 35714))
          throw new Error("Error linking: ".concat(e.getProgramInfoLog(this.handle)));
        if (e.validateProgram(this.handle), !e.getProgramParameter(this.handle, 35715))
          throw new Error("Error validating: ".concat(e.getProgramInfoLog(this.handle)));
      }
    }
    _readUniformLocationsFromLinkedProgram() {
      let { gl: e } = this;
      this._uniformSetters = {}, this._uniformCount = this._getParameter(35718);
      for (let t = 0; t < this._uniformCount; t++) {
        let n = this.gl.getActiveUniform(this.handle, t), { name: i } = kd(n.name), s = e.getUniformLocation(this.handle, i);
        if (this._uniformSetters[i] = Gl(e, s, n), n.size > 1)
          for (let o = 0; o < n.size; o++)
            s = e.getUniformLocation(this.handle, "".concat(i, "[").concat(o, "]")), this._uniformSetters["".concat(i, "[").concat(o, "]")] = Gl(e, s, n);
      }
      this._textureIndexCounter = 0;
    }
    getActiveUniforms(e, t) {
      return this.gl2.getActiveUniforms(this.handle, e, t);
    }
    getUniformBlockIndex(e) {
      return this.gl2.getUniformBlockIndex(this.handle, e);
    }
    getActiveUniformBlockParameter(e, t) {
      return this.gl2.getActiveUniformBlockParameter(this.handle, e, t);
    }
    uniformBlockBinding(e, t) {
      this.gl2.uniformBlockBinding(this.handle, e, t);
    }
  };
  var Vb = 34918;
  var Gb = 34919;
  var zb = 35007;
  var jb = 36795;
  var Wb = 35976;
  var Hb = 35887;
  var Xb = 36202;
  var br = class extends me {
    static isSupported(e, t = []) {
      let n = U(e), i = _r(e, K.TIMER_QUERY), s = n || i;
      for (let o of t)
        switch (o) {
          case "queries":
            s = s && n;
            break;
          case "timers":
            s = s && i;
            break;
          default:
            w(false);
        }
      return s;
    }
    constructor(e, t = {}) {
      super(e, t);
      this.target = null, this._queryPending = false, this._pollingPromise = null, Object.seal(this);
    }
    beginTimeElapsedQuery() {
      return this.begin(zb);
    }
    beginOcclusionQuery({ conservative: e = false } = {}) {
      return this.begin(e ? Xb : Hb);
    }
    beginTransformFeedbackQuery() {
      return this.begin(Wb);
    }
    begin(e) {
      return this._queryPending ? this : (this.target = e, this.gl2.beginQuery(this.target, this.handle), this);
    }
    end() {
      return this._queryPending ? this : (this.target && (this.gl2.endQuery(this.target), this.target = null, this._queryPending = true), this);
    }
    isResultAvailable() {
      if (!this._queryPending)
        return false;
      let e = this.gl2.getQueryParameter(this.handle, Gb);
      return e && (this._queryPending = false), e;
    }
    isTimerDisjoint() {
      return this.gl2.getParameter(jb);
    }
    getResult() {
      return this.gl2.getQueryParameter(this.handle, Vb);
    }
    getTimerMilliseconds() {
      return this.getResult() / 1e6;
    }
    createPoll(e = Number.POSITIVE_INFINITY) {
      if (this._pollingPromise)
        return this._pollingPromise;
      let t = 0;
      return this._pollingPromise = new Promise((n, i) => {
        let s = () => {
          this.isResultAvailable() ? (n(this.getResult()), this._pollingPromise = null) : t++ > e ? (i("Timed out"), this._pollingPromise = null) : requestAnimationFrame(s);
        };
        requestAnimationFrame(s);
      }), this._pollingPromise;
    }
    _createHandle() {
      return br.isSupported(this.gl) ? this.gl2.createQuery() : null;
    }
    _deleteHandle() {
      this.gl2.deleteQuery(this.handle);
    }
  };
  var Tr = class extends me {
    static isSupported(e) {
      return U(e);
    }
    constructor(e, t = {}) {
      te(e);
      super(e, t);
      this.initialize(t), this.stubRemovedMethods("TransformFeedback", "v6.0", ["pause", "resume"]), Object.seal(this);
    }
    initialize(e = {}) {
      return this.buffers = {}, this.unused = {}, this.configuration = null, this.bindOnUse = true, yt(this.buffers) || this.bind(() => this._unbindBuffers()), this.setProps(e), this;
    }
    setProps(e) {
      "program" in e && (this.configuration = e.program && e.program.configuration), "configuration" in e && (this.configuration = e.configuration), "bindOnUse" in e && (e = e.bindOnUse), "buffers" in e && this.setBuffers(e.buffers);
    }
    setBuffers(e = {}) {
      return this.bind(() => {
        for (let t in e)
          this.setBuffer(t, e[t]);
      }), this;
    }
    setBuffer(e, t) {
      let n = this._getVaryingIndex(e), { buffer: i, byteSize: s, byteOffset: o } = this._getBufferParams(t);
      return n < 0 ? (this.unused[e] = i, I.warn(() => "".concat(this.id, " unused varying buffer ").concat(e))(), this) : (this.buffers[n] = t, this.bindOnUse || this._bindBuffer(n, i, o, s), this);
    }
    begin(e = 0) {
      return this.gl.bindTransformFeedback(36386, this.handle), this._bindBuffers(), this.gl.beginTransformFeedback(e), this;
    }
    end() {
      return this.gl.endTransformFeedback(), this._unbindBuffers(), this.gl.bindTransformFeedback(36386, null), this;
    }
    _getBufferParams(e) {
      let t, n, i;
      return e instanceof k ? i = e : (i = e.buffer, n = e.byteSize, t = e.byteOffset), (t !== void 0 || n !== void 0) && (t = t || 0, n = n || i.byteLength - t), { buffer: i, byteOffset: t, byteSize: n };
    }
    _getVaryingInfo(e) {
      return this.configuration && this.configuration.getVaryingInfo(e);
    }
    _getVaryingIndex(e) {
      if (this.configuration)
        return this.configuration.getVaryingInfo(e).location;
      let t = Number(e);
      return Number.isFinite(t) ? t : -1;
    }
    _bindBuffers() {
      if (this.bindOnUse)
        for (let e in this.buffers) {
          let { buffer: t, byteSize: n, byteOffset: i } = this._getBufferParams(this.buffers[e]);
          this._bindBuffer(e, t, i, n);
        }
    }
    _unbindBuffers() {
      if (this.bindOnUse)
        for (let e in this.buffers)
          this._bindBuffer(e, null);
    }
    _bindBuffer(e, t, n = 0, i) {
      let s = t && t.handle;
      return !s || i === void 0 ? this.gl.bindBufferBase(35982, e, s) : this.gl.bindBufferRange(35982, e, s, n, i), this;
    }
    _createHandle() {
      return this.gl.createTransformFeedback();
    }
    _deleteHandle() {
      this.gl.deleteTransformFeedback(this.handle);
    }
    _bindHandle(e) {
      this.gl.bindTransformFeedback(36386, this.handle);
    }
  };
  var Oo = null;
  function Yb(r2) {
    return (!Oo || Oo.byteLength < r2) && (Oo = new ArrayBuffer(r2)), Oo;
  }
  function Hd(r2, e) {
    let t = Yb(r2.BYTES_PER_ELEMENT * e);
    return new r2(t, 0, e);
  }
  function Xd({ target: r2, source: e, start: t = 0, count: n = 1 }) {
    let i = e.length, s = n * i, o = 0;
    for (let a = t; o < i; o++)
      r2[a++] = e[o];
    for (; o < s; )
      o < s - o ? (r2.copyWithin(t + o, t, t + o), o *= 2) : (r2.copyWithin(t + o, t, t + s - o), o = s);
    return r2;
  }
  var qb = "elements must be GL.ELEMENT_ARRAY_BUFFER";
  var Ce = class extends me {
    static isSupported(e, t = {}) {
      return t.constantAttributeZero ? U(e) || to() === "Chrome" : true;
    }
    static getDefaultArray(e) {
      return e.luma = e.luma || {}, e.luma.defaultVertexArray || (e.luma.defaultVertexArray = new Ce(e, { handle: null, isDefaultArray: true })), e.luma.defaultVertexArray;
    }
    static getMaxAttributes(e) {
      return Ce.MAX_ATTRIBUTES = Ce.MAX_ATTRIBUTES || e.getParameter(34921), Ce.MAX_ATTRIBUTES;
    }
    static setConstant(e, t, n) {
      switch (n.constructor) {
        case Float32Array:
          Ce._setConstantFloatArray(e, t, n);
          break;
        case Int32Array:
          Ce._setConstantIntArray(e, t, n);
          break;
        case Uint32Array:
          Ce._setConstantUintArray(e, t, n);
          break;
        default:
          w(false);
      }
    }
    constructor(e, t = {}) {
      let n = t.id || t.program && t.program.id;
      super(e, Object.assign({}, t, { id: n }));
      this.buffer = null, this.bufferValue = null, this.isDefaultArray = t.isDefaultArray || false, this.gl2 = e, this.initialize(t), Object.seal(this);
    }
    delete() {
      return super.delete(), this.buffer && this.buffer.delete(), this;
    }
    get MAX_ATTRIBUTES() {
      return Ce.getMaxAttributes(this.gl);
    }
    initialize(e = {}) {
      return this.setProps(e);
    }
    setProps(e) {
      return this;
    }
    setElementBuffer(e = null, t = {}) {
      return w(!e || e.target === 34963, qb), this.bind(() => {
        this.gl.bindBuffer(34963, e ? e.handle : null);
      }), this;
    }
    setBuffer(e, t, n) {
      if (t.target === 34963)
        return this.setElementBuffer(t, n);
      let { size: i, type: s, stride: o, offset: a, normalized: c, integer: l, divisor: f } = n, { gl: u, gl2: h } = this;
      return e = Number(e), this.bind(() => {
        u.bindBuffer(34962, t.handle), l ? (w(U(u)), h.vertexAttribIPointer(e, i, s, o, a)) : u.vertexAttribPointer(e, i, s, c, o, a), u.enableVertexAttribArray(e), h.vertexAttribDivisor(e, f || 0);
      }), this;
    }
    enable(e, t = true) {
      return !t && e === 0 && !Ce.isSupported(this.gl, { constantAttributeZero: true }) || (e = Number(e), this.bind(() => t ? this.gl.enableVertexAttribArray(e) : this.gl.disableVertexAttribArray(e))), this;
    }
    getConstantBuffer(e, t) {
      let n = this._normalizeConstantArrayValue(t), i = n.byteLength * e, s = n.length * e, o = !this.buffer;
      if (this.buffer = this.buffer || new k(this.gl, i), o = o || this.buffer.reallocate(i), o = o || !this._compareConstantArrayValues(n, this.bufferValue), o) {
        let a = Hd(t.constructor, s);
        Xd({ target: a, source: n, start: 0, count: s }), this.buffer.subData(a), this.bufferValue = t;
      }
      return this.buffer;
    }
    _normalizeConstantArrayValue(e) {
      return Array.isArray(e) ? new Float32Array(e) : e;
    }
    _compareConstantArrayValues(e, t) {
      if (!e || !t || e.length !== t.length || e.constructor !== t.constructor)
        return false;
      for (let n = 0; n < e.length; ++n)
        if (e[n] !== t[n])
          return false;
      return true;
    }
    static _setConstantFloatArray(e, t, n) {
      switch (n.length) {
        case 1:
          e.vertexAttrib1fv(t, n);
          break;
        case 2:
          e.vertexAttrib2fv(t, n);
          break;
        case 3:
          e.vertexAttrib3fv(t, n);
          break;
        case 4:
          e.vertexAttrib4fv(t, n);
          break;
        default:
          w(false);
      }
    }
    static _setConstantIntArray(e, t, n) {
      switch (w(U(e)), n.length) {
        case 1:
          e.vertexAttribI1iv(t, n);
          break;
        case 2:
          e.vertexAttribI2iv(t, n);
          break;
        case 3:
          e.vertexAttribI3iv(t, n);
          break;
        case 4:
          e.vertexAttribI4iv(t, n);
          break;
        default:
          w(false);
      }
    }
    static _setConstantUintArray(e, t, n) {
      switch (w(U(e)), n.length) {
        case 1:
          e.vertexAttribI1uiv(t, n);
          break;
        case 2:
          e.vertexAttribI2uiv(t, n);
          break;
        case 3:
          e.vertexAttribI3uiv(t, n);
          break;
        case 4:
          e.vertexAttribI4uiv(t, n);
          break;
        default:
          w(false);
      }
    }
    _createHandle() {
      return this.gl.createVertexArray();
    }
    _deleteHandle(e) {
      return this.gl2.deleteVertexArray(e), [this.elements];
    }
    _bindHandle(e) {
      this.gl2.bindVertexArray(e);
    }
    _getParameter(e, { location: t }) {
      return w(Number.isFinite(t)), this.bind(() => {
        switch (e) {
          case 34373:
            return this.gl.getVertexAttribOffset(t, e);
          default:
            return this.gl.getVertexAttrib(t, e);
        }
      });
    }
  };
  var Zb = "VertexArray: attributes must be Buffers or constants (i.e. typed array)";
  var Kb = /^(.+)__LOCATION_([0-9]+)$/;
  var Qb = ["setBuffers", "setGeneric", "clearBindings", "setLocations", "setGenericValues", "setDivisor", "enable", "disable"];
  var Yi = class {
    constructor(e, t = {}) {
      let n = t.id || t.program && t.program.id;
      this.id = n, this.gl = e, this.configuration = null, this.elements = null, this.elementsAccessor = null, this.values = null, this.accessors = null, this.unused = null, this.drawParams = null, this.buffer = null, this.attributes = {}, this.vertexArrayObject = new Ce(e), ki(this, "VertexArray", "v6.0", Qb), this.initialize(t), Object.seal(this);
    }
    delete() {
      this.buffer && this.buffer.delete(), this.vertexArrayObject.delete();
    }
    initialize(e = {}) {
      return this.reset(), this.configuration = null, this.bindOnUse = false, this.setProps(e);
    }
    reset() {
      this.elements = null, this.elementsAccessor = null;
      let { MAX_ATTRIBUTES: e } = this.vertexArrayObject;
      return this.values = new Array(e).fill(null), this.accessors = new Array(e).fill(null), this.unused = {}, this.drawParams = null, this;
    }
    setProps(e) {
      return "program" in e && (this.configuration = e.program && e.program.configuration), "configuration" in e && (this.configuration = e.configuration), "attributes" in e && this.setAttributes(e.attributes), "elements" in e && this.setElementBuffer(e.elements), "bindOnUse" in e && (e = e.bindOnUse), this;
    }
    clearDrawParams() {
      this.drawParams = null;
    }
    getDrawParams() {
      return this.drawParams = this.drawParams || this._updateDrawParams(), this.drawParams;
    }
    setAttributes(e) {
      return Object.assign(this.attributes, e), this.vertexArrayObject.bind(() => {
        for (let t in e) {
          let n = e[t];
          this._setAttribute(t, n);
        }
        this.gl.bindBuffer(34962, null);
      }), this;
    }
    setElementBuffer(e = null, t = {}) {
      return this.elements = e, this.elementsAccessor = t, this.clearDrawParams(), this.vertexArrayObject.setElementBuffer(e, t), this;
    }
    setBuffer(e, t, n = {}) {
      if (t.target === 34963)
        return this.setElementBuffer(t, n);
      let { location: i, accessor: s } = this._resolveLocationAndAccessor(e, t, t.accessor, n);
      return i >= 0 && (this.values[i] = t, this.accessors[i] = s, this.clearDrawParams(), this.vertexArrayObject.setBuffer(i, t, s)), this;
    }
    setConstant(e, t, n = {}) {
      let { location: i, accessor: s } = this._resolveLocationAndAccessor(e, t, Object.assign({ size: t.length }, n));
      return i >= 0 && (t = this.vertexArrayObject._normalizeConstantArrayValue(t), this.values[i] = t, this.accessors[i] = s, this.clearDrawParams(), this.vertexArrayObject.enable(i, false)), this;
    }
    unbindBuffers() {
      return this.vertexArrayObject.bind(() => {
        this.elements && this.vertexArrayObject.setElementBuffer(null), this.buffer = this.buffer || new k(this.gl, { accessor: { size: 4 } });
        for (let e = 0; e < this.vertexArrayObject.MAX_ATTRIBUTES; e++)
          this.values[e] instanceof k && (this.gl.disableVertexAttribArray(e), this.gl.bindBuffer(34962, this.buffer.handle), this.gl.vertexAttribPointer(e, 1, 5126, false, 0, 0));
      }), this;
    }
    bindBuffers() {
      return this.vertexArrayObject.bind(() => {
        this.elements && this.setElementBuffer(this.elements);
        for (let e = 0; e < this.vertexArrayObject.MAX_ATTRIBUTES; e++) {
          let t = this.values[e];
          t instanceof k && this.setBuffer(e, t);
        }
      }), this;
    }
    bindForDraw(e, t, n) {
      let i;
      return this.vertexArrayObject.bind(() => {
        this._setConstantAttributes(e, t), i = n();
      }), i;
    }
    _resolveLocationAndAccessor(e, t, n, i) {
      let s = { location: -1, accessor: null }, { location: o, name: a } = this._getAttributeIndex(e);
      if (!Number.isFinite(o) || o < 0)
        return this.unused[e] = t, I.once(3, () => "unused value ".concat(e, " in ").concat(this.id))(), s;
      let c = this._getAttributeInfo(a || o);
      if (!c)
        return s;
      let l = this.accessors[o] || {}, f = be.resolve(c.accessor, l, n, i), { size: u, type: h } = f;
      return w(Number.isFinite(u) && Number.isFinite(h)), { location: o, accessor: f };
    }
    _getAttributeInfo(e) {
      return this.configuration && this.configuration.getAttributeInfo(e);
    }
    _getAttributeIndex(e) {
      let t = Number(e);
      if (Number.isFinite(t))
        return { location: t };
      let n = Kb.exec(e), i = n ? n[1] : e, s = n ? Number(n[2]) : 0;
      return this.configuration ? { location: this.configuration.getAttributeLocation(i) + s, name: i } : { location: -1 };
    }
    _setAttribute(e, t) {
      if (t instanceof k)
        this.setBuffer(e, t);
      else if (Array.isArray(t) && t.length && t[0] instanceof k) {
        let n = t[0], i = t[1];
        this.setBuffer(e, n, i);
      } else if (ArrayBuffer.isView(t) || Array.isArray(t)) {
        let n = t;
        this.setConstant(e, n);
      } else if (t.buffer instanceof k) {
        let n = t;
        this.setBuffer(e, n.buffer, n);
      } else
        throw new Error(Zb);
    }
    _setConstantAttributes(e, t) {
      let n = Math.max(e | 0, t | 0), i = this.values[0];
      ArrayBuffer.isView(i) && this._setConstantAttributeZero(i, n);
      for (let s = 1; s < this.vertexArrayObject.MAX_ATTRIBUTES; s++)
        i = this.values[s], ArrayBuffer.isView(i) && this._setConstantAttribute(s, i);
    }
    _setConstantAttributeZero(e, t) {
      if (Ce.isSupported(this.gl, { constantAttributeZero: true })) {
        this._setConstantAttribute(0, e);
        return;
      }
      let n = this.vertexArrayObject.getConstantBuffer(t, e);
      this.vertexArrayObject.setBuffer(0, n, this.accessors[0]);
    }
    _setConstantAttribute(e, t) {
      Ce.setConstant(this.gl, e, t);
    }
    _updateDrawParams() {
      let e = { isIndexed: false, isInstanced: false, indexCount: 1 / 0, vertexCount: 1 / 0, instanceCount: 1 / 0 };
      for (let t = 0; t < this.vertexArrayObject.MAX_ATTRIBUTES; t++)
        this._updateDrawParamsForLocation(e, t);
      return this.elements && (e.elementCount = this.elements.getElementCount(this.elements.accessor), e.isIndexed = true, e.indexType = this.elementsAccessor.type || this.elements.accessor.type, e.indexOffset = this.elementsAccessor.offset || 0), e.indexCount === 1 / 0 && (e.indexCount = 0), e.vertexCount === 1 / 0 && (e.vertexCount = 0), e.instanceCount === 1 / 0 && (e.instanceCount = 0), e;
    }
    _updateDrawParamsForLocation(e, t) {
      let n = this.values[t], i = this.accessors[t];
      if (!n)
        return;
      let { divisor: s } = i, o = s > 0;
      if (e.isInstanced = e.isInstanced || o, n instanceof k) {
        let a = n;
        if (o) {
          let c = a.getVertexCount(i);
          e.instanceCount = Math.min(e.instanceCount, c);
        } else {
          let c = a.getVertexCount(i);
          e.vertexCount = Math.min(e.vertexCount, c);
        }
      }
    }
    setElements(e = null, t = {}) {
      return I.deprecated("setElements", "setElementBuffer")(), this.setElementBuffer(e, t);
    }
  };
  function No({ header: r2 = "Uniforms", program: e, uniforms: t, undefinedOnly: n = false }) {
    w(e);
    let i = ".*_.*", s = ".*Matrix", o = e._uniformSetters, a = {}, c = Object.keys(o).sort(), l = 0;
    for (let h of c)
      !h.match(i) && !h.match(s) && Wl({ table: a, header: r2, uniforms: t, uniformName: h, undefinedOnly: n }) && l++;
    for (let h of c)
      h.match(s) && Wl({ table: a, header: r2, uniforms: t, uniformName: h, undefinedOnly: n }) && l++;
    for (let h of c)
      a[h] || Wl({ table: a, header: r2, uniforms: t, uniformName: h, undefinedOnly: n }) && l++;
    let f = 0, u = {};
    if (!n)
      for (let h in t) {
        let d = t[h];
        a[h] || (f++, u[h] = { Type: "NOT USED: ".concat(d), [r2]: mr(d) });
      }
    return { table: a, count: l, unusedTable: u, unusedCount: f };
  }
  function Wl({ table: r2, header: e, uniforms: t, uniformName: n, undefinedOnly: i }) {
    let s = t[n], o = Jb(s);
    return !i || !o ? (r2[n] = { [e]: o ? mr(s) : "N/A", "Uniform Type": o ? s : "NOT PROVIDED" }, true) : false;
  }
  function Jb(r2) {
    return r2 != null;
  }
  function Hl({ vertexArray: r2, header: e = "Attributes" }) {
    if (!r2.configuration)
      return {};
    let t = {};
    r2.elements && (t.ELEMENT_ARRAY_BUFFER = Yd(r2, r2.elements, null, e));
    let n = r2.values;
    for (let i in n) {
      let s = r2._getAttributeInfo(i);
      if (s) {
        let o = "".concat(i, ": ").concat(s.name), a = r2.accessors[s.location];
        a && (o = "".concat(i, ": ").concat($b(s.name, a))), t[o] = Yd(r2, n[i], a, e);
      }
    }
    return t;
  }
  function Yd(r2, e, t, n) {
    let { gl: i } = r2;
    if (!e)
      return { [n]: "null", "Format ": "N/A" };
    let s = "NOT PROVIDED", o = 1, a = 0, c = 0, l, f, u;
    if (t && (s = t.type, o = t.size, s = String(s).replace("Array", ""), l = s.indexOf("nt") !== -1), e instanceof k) {
      let h = e, { data: d, changed: m } = h.getDebugData();
      f = m ? "*" : "", u = d, c = h.byteLength, a = c / d.BYTES_PER_ELEMENT / o;
      let _;
      if (t) {
        let E = t.divisor > 0;
        _ = "".concat(E ? "I " : "P ", " ").concat(a, " (x").concat(o, "=").concat(c, " bytes ").concat(Ye(i, s), ")");
      } else
        l = true, _ = "".concat(c, " bytes");
      return { [n]: "".concat(f).concat(mr(u, { size: o, isInteger: l })), "Format ": _ };
    }
    return u = e, o = e.length, s = String(e.constructor.name).replace("Array", ""), l = s.indexOf("nt") !== -1, { [n]: "".concat(mr(u, { size: o, isInteger: l }), " (constant)"), "Format ": "".concat(o, "x").concat(s, " (constant)") };
  }
  function $b(r2, e) {
    let { type: t, size: n } = e, i = Mo(t, n);
    return i ? "".concat(r2, " (").concat(i.name, ")") : r2;
  }
  function Xl(r2) {
    let e = {}, t = "Accessors for ".concat(r2.id);
    for (let n of r2.attributeInfos)
      if (n) {
        let i = qd(n);
        e["in ".concat(i)] = { [t]: JSON.stringify(n.accessor) };
      }
    for (let n of r2.varyingInfos)
      if (n) {
        let i = qd(n);
        e["out ".concat(i)] = { [t]: JSON.stringify(n.accessor) };
      }
    return e;
  }
  function qd(r2) {
    let { type: e, size: t } = r2.accessor, n = Mo(e, t);
    return n ? "".concat(n.name, " ").concat(r2.name) : r2.name;
  }
  var Zd = Mt(dr());
  var Kd = (0, Zd.isBrowser)() && typeof document != "undefined";
  var tT = 0;
  var Ln = class {
    constructor(e = {}) {
      let { onCreateContext: t = (E) => En(E), onAddHTML: n = null, onInitialize: i = () => {
      }, onRender: s = () => {
      }, onFinalize: o = () => {
      }, onError: a, gl: c = null, glOptions: l = {}, debug: f = false, createFramebuffer: u = false, autoResizeViewport: h = true, autoResizeDrawingBuffer: d = true, stats: m = ot.get("animation-loop-".concat(tT++)) } = e, { useDevicePixels: _ = true } = e;
      "useDevicePixelRatio" in e && (I.deprecated("useDevicePixelRatio", "useDevicePixels")(), _ = e.useDevicePixelRatio), this.props = { onCreateContext: t, onAddHTML: n, onInitialize: i, onRender: s, onFinalize: o, onError: a, gl: c, glOptions: l, debug: f, createFramebuffer: u }, this.gl = c, this.needsRedraw = null, this.timeline = null, this.stats = m, this.cpuTime = this.stats.get("CPU Time"), this.gpuTime = this.stats.get("GPU Time"), this.frameRate = this.stats.get("Frame Rate"), this._initialized = false, this._running = false, this._animationFrameId = null, this._nextFramePromise = null, this._resolveNextFrame = null, this._cpuStartTime = 0, this.setProps({ autoResizeViewport: h, autoResizeDrawingBuffer: d, useDevicePixels: _ }), this.start = this.start.bind(this), this.stop = this.stop.bind(this), this._pageLoadPromise = null, this._onMousemove = this._onMousemove.bind(this), this._onMouseleave = this._onMouseleave.bind(this);
    }
    delete() {
      this.stop(), this._setDisplay(null);
    }
    setNeedsRedraw(e) {
      return w(typeof e == "string"), this.needsRedraw = this.needsRedraw || e, this;
    }
    setProps(e) {
      return "autoResizeViewport" in e && (this.autoResizeViewport = e.autoResizeViewport), "autoResizeDrawingBuffer" in e && (this.autoResizeDrawingBuffer = e.autoResizeDrawingBuffer), "useDevicePixels" in e && (this.useDevicePixels = e.useDevicePixels), this;
    }
    start(e = {}) {
      if (this._running)
        return this;
      this._running = true;
      let t = this._getPageLoadPromise().then(() => !this._running || this._initialized ? null : (this._createWebGLContext(e), this._createFramebuffer(), this._startEventHandling(), this._initializeCallbackData(), this._updateCallbackData(), this._resizeCanvasDrawingBuffer(), this._resizeViewport(), this._gpuTimeQuery = br.isSupported(this.gl, ["timers"]) ? new br(this.gl) : null, this._initialized = true, this.onInitialize(this.animationProps))).then((n) => {
        this._running && (this._addCallbackData(n || {}), n !== false && this._startLoop());
      });
      return this.props.onError && t.catch(this.props.onError), this;
    }
    redraw() {
      return this.isContextLost() ? this : (this._beginTimers(), this._setupFrame(), this._updateCallbackData(), this._renderFrame(this.animationProps), this._clearNeedsRedraw(), this.offScreen && this.gl.commit && this.gl.commit(), this._resolveNextFrame && (this._resolveNextFrame(this), this._nextFramePromise = null, this._resolveNextFrame = null), this._endTimers(), this);
    }
    stop() {
      return this._running && (this._finalizeCallbackData(), Eo(this._animationFrameId), this._nextFramePromise = null, this._resolveNextFrame = null, this._animationFrameId = null, this._running = false), this;
    }
    attachTimeline(e) {
      return this.timeline = e, this.timeline;
    }
    detachTimeline() {
      this.timeline = null;
    }
    waitForRender() {
      return this.setNeedsRedraw("waitForRender"), this._nextFramePromise || (this._nextFramePromise = new Promise((e) => {
        this._resolveNextFrame = e;
      })), this._nextFramePromise;
    }
    async toDataURL() {
      return this.setNeedsRedraw("toDataURL"), await this.waitForRender(), this.gl.canvas.toDataURL();
    }
    isContextLost() {
      return this.gl.isContextLost();
    }
    onCreateContext(...e) {
      return this.props.onCreateContext(...e);
    }
    onInitialize(...e) {
      return this.props.onInitialize(...e);
    }
    onRender(...e) {
      return this.props.onRender(...e);
    }
    onFinalize(...e) {
      return this.props.onFinalize(...e);
    }
    getHTMLControlValue(e, t = 1) {
      let n = document.getElementById(e);
      return n ? Number(n.value) : t;
    }
    setViewParameters() {
      return I.removed("AnimationLoop.setViewParameters", "AnimationLoop.setProps")(), this;
    }
    _startLoop() {
      let e = () => {
        !this._running || (this.redraw(), this._animationFrameId = this._requestAnimationFrame(e));
      };
      Eo(this._animationFrameId), this._animationFrameId = this._requestAnimationFrame(e);
    }
    _getPageLoadPromise() {
      return this._pageLoadPromise || (this._pageLoadPromise = Kd ? new Promise((e, t) => {
        if (Kd && document.readyState === "complete") {
          e(document);
          return;
        }
        window.addEventListener("load", () => {
          e(document);
        });
      }) : Promise.resolve({})), this._pageLoadPromise;
    }
    _setDisplay(e) {
      this.display && (this.display.delete(), this.display.animationLoop = null), e && (e.animationLoop = this), this.display = e;
    }
    _requestAnimationFrame(e) {
      this.display && this.display.requestAnimationFrame(e) || Rl(e);
    }
    _renderFrame(...e) {
      if (this.display) {
        this.display._renderFrame(...e);
        return;
      }
      this.onRender(...e);
    }
    _clearNeedsRedraw() {
      this.needsRedraw = null;
    }
    _setupFrame() {
      this._resizeCanvasDrawingBuffer(), this._resizeViewport(), this._resizeFramebuffer();
    }
    _initializeCallbackData() {
      this.animationProps = { gl: this.gl, stop: this.stop, canvas: this.gl.canvas, framebuffer: this.framebuffer, useDevicePixels: this.useDevicePixels, needsRedraw: null, startTime: Date.now(), engineTime: 0, tick: 0, tock: 0, time: 0, _timeline: this.timeline, _loop: this, _animationLoop: this, _mousePosition: null };
    }
    _updateCallbackData() {
      let { width: e, height: t, aspect: n } = this._getSizeAndAspect();
      (e !== this.animationProps.width || t !== this.animationProps.height) && this.setNeedsRedraw("drawing buffer resized"), n !== this.animationProps.aspect && this.setNeedsRedraw("drawing buffer aspect changed"), this.animationProps.width = e, this.animationProps.height = t, this.animationProps.aspect = n, this.animationProps.needsRedraw = this.needsRedraw, this.animationProps.engineTime = Date.now() - this.animationProps.startTime, this.timeline && this.timeline.update(this.animationProps.engineTime), this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60), this.animationProps.tock++, this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime, this.animationProps._offScreen = this.offScreen;
    }
    _finalizeCallbackData() {
      this.onFinalize(this.animationProps);
    }
    _addCallbackData(e) {
      typeof e == "object" && e !== null && (this.animationProps = Object.assign({}, this.animationProps, e));
    }
    _createWebGLContext(e) {
      if (this.offScreen = e.canvas && typeof OffscreenCanvas != "undefined" && e.canvas instanceof OffscreenCanvas, e = Object.assign({}, e, this.props.glOptions), this.gl = this.props.gl ? qr(this.props.gl, e) : this.onCreateContext(e), !Zt(this.gl))
        throw new Error("AnimationLoop.onCreateContext - illegal context returned");
      yo(this.gl), this._createInfoDiv();
    }
    _createInfoDiv() {
      if (this.gl.canvas && this.props.onAddHTML) {
        let e = document.createElement("div");
        document.body.appendChild(e), e.style.position = "relative";
        let t = document.createElement("div");
        t.style.position = "absolute", t.style.left = "10px", t.style.bottom = "10px", t.style.width = "300px", t.style.background = "white", e.appendChild(this.gl.canvas), e.appendChild(t);
        let n = this.props.onAddHTML(t);
        n && (t.innerHTML = n);
      }
    }
    _getSizeAndAspect() {
      let e = this.gl.drawingBufferWidth, t = this.gl.drawingBufferHeight, n = 1, { canvas: i } = this.gl;
      return i && i.clientHeight ? n = i.clientWidth / i.clientHeight : e > 0 && t > 0 && (n = e / t), { width: e, height: t, aspect: n };
    }
    _resizeViewport() {
      this.autoResizeViewport && this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
    }
    _resizeCanvasDrawingBuffer() {
      this.autoResizeDrawingBuffer && Cl(this.gl, { useDevicePixels: this.useDevicePixels });
    }
    _createFramebuffer() {
      this.props.createFramebuffer && (this.framebuffer = new Z(this.gl));
    }
    _resizeFramebuffer() {
      this.framebuffer && this.framebuffer.resize({ width: this.gl.drawingBufferWidth, height: this.gl.drawingBufferHeight });
    }
    _beginTimers() {
      this.frameRate.timeEnd(), this.frameRate.timeStart(), this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint() && this.stats.get("GPU Time").addTime(this._gpuTimeQuery.getTimerMilliseconds()), this._gpuTimeQuery && this._gpuTimeQuery.beginTimeElapsedQuery(), this.cpuTime.timeStart();
    }
    _endTimers() {
      this.cpuTime.timeEnd(), this._gpuTimeQuery && this._gpuTimeQuery.end();
    }
    _startEventHandling() {
      let { canvas: e } = this.gl;
      e && (e.addEventListener("mousemove", this._onMousemove), e.addEventListener("mouseleave", this._onMouseleave));
    }
    _onMousemove(e) {
      this.animationProps._mousePosition = [e.offsetX, e.offsetY];
    }
    _onMouseleave(e) {
      this.animationProps._mousePosition = null;
    }
  };
  var Kr = "vs";
  var qi = "fs";
  function fe(r2, e) {
    if (!r2)
      throw new Error(e || "shadertools: assertion failed.");
  }
  var Yl = { number: { validate(r2, e) {
    return Number.isFinite(r2) && (!("max" in e) || r2 <= e.max) && (!("min" in e) || r2 >= e.min);
  } }, array: { validate(r2, e) {
    return Array.isArray(r2) || ArrayBuffer.isView(r2);
  } } };
  function Qd(r2) {
    let e = {};
    for (let t in r2) {
      let n = r2[t], i = rT(n);
      e[t] = i;
    }
    return e;
  }
  function rT(r2) {
    let e = Jd(r2);
    return e === "object" ? r2 ? "type" in r2 ? Object.assign({}, r2, Yl[r2.type]) : "value" in r2 ? (e = Jd(r2.value), Object.assign({ type: e }, r2, Yl[e])) : { type: "object", value: r2 } : { type: "object", value: null } : Object.assign({ type: e, value: r2 }, Yl[e]);
  }
  function Jd(r2) {
    return Array.isArray(r2) || ArrayBuffer.isView(r2) ? "array" : typeof r2;
  }
  var nT = "vs";
  var iT = "fs";
  var Zi = class {
    constructor({ name: e, vs: t, fs: n, dependencies: i = [], uniforms: s, getUniforms: o, deprecations: a = [], defines: c = {}, inject: l = {}, vertexShader: f, fragmentShader: u }) {
      fe(typeof e == "string"), this.name = e, this.vs = t || f, this.fs = n || u, this.getModuleUniforms = o, this.dependencies = i, this.deprecations = this._parseDeprecationDefinitions(a), this.defines = c, this.injections = sT(l), s && (this.uniforms = Qd(s));
    }
    getModuleSource(e) {
      let t;
      switch (e) {
        case nT:
          t = this.vs || "";
          break;
        case iT:
          t = this.fs || "";
          break;
        default:
          fe(false);
      }
      return "#define MODULE_".concat(this.name.toUpperCase().replace(/[^0-9a-z]/gi, "_"), `
`).concat(t, "// END MODULE_").concat(this.name, `

`);
    }
    getUniforms(e, t) {
      return this.getModuleUniforms ? this.getModuleUniforms(e, t) : this.uniforms ? this._defaultGetUniforms(e) : {};
    }
    getDefines() {
      return this.defines;
    }
    checkDeprecations(e, t) {
      this.deprecations.forEach((n) => {
        n.regex.test(e) && (n.deprecated ? t.deprecated(n.old, n.new)() : t.removed(n.old, n.new)());
      });
    }
    _parseDeprecationDefinitions(e) {
      return e.forEach((t) => {
        switch (t.type) {
          case "function":
            t.regex = new RegExp("\\b".concat(t.old, "\\("));
            break;
          default:
            t.regex = new RegExp("".concat(t.type, " ").concat(t.old, ";"));
        }
      }), e;
    }
    _defaultGetUniforms(e = {}) {
      let t = {}, n = this.uniforms;
      for (let i in n) {
        let s = n[i];
        i in e && !s.private ? (s.validate && fe(s.validate(e[i], s), "".concat(this.name, ": invalid ").concat(i)), t[i] = e[i]) : t[i] = s.value;
      }
      return t;
    }
  };
  function sT(r2) {
    let e = { vs: {}, fs: {} };
    for (let t in r2) {
      let n = r2[t], i = t.slice(0, 2);
      typeof n == "string" && (n = { order: 0, injection: n }), e[i][t] = n;
    }
    return e;
  }
  function $d(r2) {
    return oT(tp(r2));
  }
  function oT(r2) {
    let e = {}, t = {};
    return ep({ modules: r2, level: 0, moduleMap: e, moduleDepth: t }), Object.keys(t).sort((n, i) => t[i] - t[n]).map((n) => e[n]);
  }
  function ep({ modules: r2, level: e, moduleMap: t, moduleDepth: n }) {
    if (e >= 5)
      throw new Error("Possible loop in shader dependency graph");
    for (let i of r2)
      t[i.name] = i, (n[i.name] === void 0 || n[i.name] < e) && (n[i.name] = e);
    for (let i of r2)
      i.dependencies && ep({ modules: i.dependencies, level: e + 1, moduleMap: t, moduleDepth: n });
  }
  function tp(r2, e) {
    return r2.map((t) => (t instanceof Zi || (fe(typeof t != "string", "Shader module use by name is deprecated. Import shader module '".concat(t, "' and use it directly.")), fe(t.name, "shader module has no name"), t = new Zi(t), t.dependencies = tp(t.dependencies)), t));
  }
  function ql(r2 = {}) {
    let e = typeof window != "undefined" ? window.navigator || {} : {}, t = r2.userAgent || e.userAgent || "", n = t.indexOf("MSIE ") !== -1, i = t.indexOf("Trident/") !== -1;
    return n || i;
  }
  var aT = 7936;
  var cT = 7937;
  var lT = 7938;
  var fT = 35724;
  var Zl = { GLSL_FRAG_DATA: ["WEBGL_draw_buffers", true], GLSL_FRAG_DEPTH: ["EXT_frag_depth", true], GLSL_DERIVATIVES: ["OES_standard_derivatives", true], GLSL_TEXTURE_LOD: ["EXT_shader_texture_lod", true] };
  var vr = {};
  Object.keys(Zl).forEach((r2) => {
    vr[r2] = r2;
  });
  function uT(r2) {
    return typeof WebGL2RenderingContext != "undefined" && r2 instanceof WebGL2RenderingContext ? true : Boolean(r2 && r2._version === 2);
  }
  function rp(r2) {
    let e = r2.getExtension("WEBGL_debug_renderer_info"), t = r2.getParameter(e && e.UNMASKED_VENDOR_WEBGL || aT), n = r2.getParameter(e && e.UNMASKED_RENDERER_WEBGL || cT);
    return { gpuVendor: hT(t, n), vendor: t, renderer: n, version: r2.getParameter(lT), shadingLanguageVersion: r2.getParameter(fT) };
  }
  function hT(r2, e) {
    return r2.match(/NVIDIA/i) || e.match(/NVIDIA/i) ? "NVIDIA" : r2.match(/INTEL/i) || e.match(/INTEL/i) ? "INTEL" : r2.match(/AMD/i) || e.match(/AMD/i) || r2.match(/ATI/i) || e.match(/ATI/i) ? "AMD" : "UNKNOWN GPU";
  }
  var Kl = {};
  function Ql(r2, e, t = {}) {
    let n = Zl[e];
    if (fe(n, e), !ql(t))
      return true;
    if (e in Kl)
      return Kl[e];
    let i = n[0], s = t.behavior || "enable", o = "#extension GL_".concat(i, " : ").concat(s, `
void main(void) {}`), a = r2.createShader(35633);
    r2.shaderSource(a, o), r2.compileShader(a);
    let c = r2.getShaderParameter(a, 35713);
    return r2.deleteShader(a), Kl[e] = c, c;
  }
  function dT(r2, e) {
    let t = Zl[e];
    fe(t, e);
    let n = uT(r2) && t[1] || t[0], i = typeof n == "string" ? Boolean(r2.getExtension(n)) : n;
    return fe(i === false || i === true), i;
  }
  function Ki(r2, e) {
    return e = Array.isArray(e) ? e : [e], e.every((t) => dT(r2, t));
  }
  function np(r2) {
    switch (rp(r2).gpuVendor.toLowerCase()) {
      case "nvidia":
        return `#define NVIDIA_GPU
// Nvidia optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`;
      case "intel":
        return `#define INTEL_GPU
// Intel optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
      case "amd":
        return `#define AMD_GPU
`;
      default:
        return `#define DEFAULT_GPU
// Prevent driver from optimizing away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
    }
  }
  function ip(r2, e, t) {
    let n = `#if (__VERSION__ > 120)

# define FEATURE_GLSL_DERIVATIVES
# define FEATURE_GLSL_DRAW_BUFFERS
# define FEATURE_GLSL_FRAG_DEPTH
# define FEATURE_GLSL_TEXTURE_LOD

// DEPRECATED FLAGS, remove in v9
# define FRAG_DEPTH
# define DERIVATIVES
# define DRAW_BUFFERS
# define TEXTURE_LOD

#endif // __VERSION
`;
    return Ki(r2, vr.GLSL_FRAG_DEPTH) && (n += `
// FRAG_DEPTH => gl_FragDepth is available
#ifdef GL_EXT_frag_depth
#extension GL_EXT_frag_depth : enable
# define FEATURE_GLSL_FRAG_DEPTH
# define FRAG_DEPTH
# define gl_FragDepth gl_FragDepthEXT
#endif
`), Ki(r2, vr.GLSL_DERIVATIVES) && Ql(r2, vr.GLSL_DERIVATIVES) && (n += `
// DERIVATIVES => dxdF, dxdY and fwidth are available
#ifdef GL_OES_standard_derivatives
#extension GL_OES_standard_derivatives : enable
# define FEATURE_GLSL_DERIVATIVES
# define DERIVATIVES
#endif
`), Ki(r2, vr.GLSL_FRAG_DATA) && Ql(r2, vr.GLSL_FRAG_DATA, { behavior: "require" }) && (n += `
// DRAW_BUFFERS => gl_FragData[] is available
#ifdef GL_EXT_draw_buffers
#extension GL_EXT_draw_buffers : require
#define FEATURE_GLSL_DRAW_BUFFERS
#define DRAW_BUFFERS
#endif
`), Ki(r2, vr.GLSL_TEXTURE_LOD) && (n += `// TEXTURE_LOD => texture2DLod etc are available
#ifdef GL_EXT_shader_texture_lod
#extension GL_EXT_shader_texture_lod : enable

# define FEATURE_GLSL_TEXTURE_LOD
# define TEXTURE_LOD

#endif
`), n;
  }
  var sp = `#ifdef MODULE_LOGDEPTH
  logdepth_adjustPosition(gl_Position);
#endif
`;
  var op = `#ifdef MODULE_MATERIAL
  gl_FragColor = material_filterColor(gl_FragColor);
#endif

#ifdef MODULE_LIGHTING
  gl_FragColor = lighting_filterColor(gl_FragColor);
#endif

#ifdef MODULE_FOG
  gl_FragColor = fog_filterColor(gl_FragColor);
#endif

#ifdef MODULE_PICKING
  gl_FragColor = picking_filterHighlightColor(gl_FragColor);
  gl_FragColor = picking_filterPickingColor(gl_FragColor);
#endif

#ifdef MODULE_LOGDEPTH
  logdepth_setFragDepth();
#endif
`;
  var pT = { [Kr]: sp, [qi]: op };
  var Qi = "__LUMA_INJECT_DECLARATIONS__";
  var ap = /void\s+main\s*\([^)]*\)\s*\{\n?/;
  var cp = /}\n?[^{}]*$/;
  var Jl = [];
  function Fo(r2, e, t, n = false) {
    let i = e === Kr;
    for (let s in t) {
      let o = t[s];
      o.sort((c, l) => c.order - l.order), Jl.length = o.length;
      for (let c = 0, l = o.length; c < l; ++c)
        Jl[c] = o[c].injection;
      let a = "".concat(Jl.join(`
`), `
`);
      switch (s) {
        case "vs:#decl":
          i && (r2 = r2.replace(Qi, a));
          break;
        case "vs:#main-start":
          i && (r2 = r2.replace(ap, (c) => c + a));
          break;
        case "vs:#main-end":
          i && (r2 = r2.replace(cp, (c) => a + c));
          break;
        case "fs:#decl":
          i || (r2 = r2.replace(Qi, a));
          break;
        case "fs:#main-start":
          i || (r2 = r2.replace(ap, (c) => c + a));
          break;
        case "fs:#main-end":
          i || (r2 = r2.replace(cp, (c) => a + c));
          break;
        default:
          r2 = r2.replace(s, (c) => c + a);
      }
    }
    return r2 = r2.replace(Qi, ""), n && (r2 = r2.replace(/\}\s*$/, (s) => s + pT[e])), r2;
  }
  function Cn(r2) {
    let e = {};
    return fe(Array.isArray(r2) && r2.length > 1), r2.forEach((t) => {
      for (let n in t)
        e[n] = e[n] ? "".concat(e[n], `
`).concat(t[n]) : t[n];
    }), e;
  }
  function Rn(r2) {
    return new RegExp("\\b".concat(r2, "[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)"), "g");
  }
  var lp = [[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, `#version 300 es
`], [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("], [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]];
  var mT = [...lp, [Rn("attribute"), "in $1"], [Rn("varying"), "out $1"]];
  var gT = [...lp, [Rn("varying"), "in $1"]];
  var fp = [[/^#version[ \t]+300[ \t]+es/, "#version 100"], [/\btexture(2D|2DProj|Cube)Lod\(/g, "texture$1LodEXT("], [/\btexture\(/g, "texture2D("], [/\btextureLod\(/g, "texture2DLodEXT("]];
  var _T = [...fp, [Rn("in"), "attribute $1"], [Rn("out"), "varying $1"]];
  var xT = [...fp, [Rn("in"), "varying $1"]];
  var $l = "gl_FragColor";
  var ef = /\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/;
  var yT = /void\s+main\s*\([^)]*\)\s*\{\n?/;
  function tf(r2, e, t) {
    switch (e) {
      case 300:
        return t ? Do(r2, mT) : ET(r2);
      case 100:
        return t ? Do(r2, _T) : bT(r2);
      default:
        throw new Error("unknown GLSL version ".concat(e));
    }
  }
  function Do(r2, e) {
    for (let [t, n] of e)
      r2 = r2.replace(t, n);
    return r2;
  }
  function ET(r2) {
    r2 = Do(r2, gT);
    let e = r2.match(ef);
    if (e) {
      let t = e[1];
      r2 = r2.replace(new RegExp("\\b".concat($l, "\\b"), "g"), t);
    } else {
      let t = "fragmentColor";
      r2 = r2.replace(yT, (n) => "out vec4 ".concat(t, `;
`).concat(n)).replace(new RegExp("\\b".concat($l, "\\b"), "g"), t);
    }
    return r2;
  }
  function bT(r2) {
    r2 = Do(r2, xT);
    let e = r2.match(ef);
    if (e) {
      let t = e[1];
      r2 = r2.replace(ef, "").replace(new RegExp("\\b".concat(t, "\\b"), "g"), $l);
    }
    return r2;
  }
  var TT = `

`.concat(Qi, `

`);
  var up = { [Kr]: "vertex", [qi]: "fragment" };
  var vT = `precision highp float;

`;
  function rf(r2, e) {
    let { vs: t, fs: n } = e, i = $d(e.modules || []);
    return { gl: r2, vs: hp(r2, Object.assign({}, e, { source: t, type: Kr, modules: i })), fs: hp(r2, Object.assign({}, e, { source: n, type: qi, modules: i })), getUniforms: AT(i) };
  }
  function hp(r2, { id: e, source: t, type: n, modules: i, defines: s = {}, hookFunctions: o = [], inject: a = {}, transpileToGLSL100: c = false, prologue: l = true, log: f }) {
    fe(typeof t == "string", "shader source must be a string");
    let u = n === Kr, h = t.split(`
`), d = 100, m = "", _ = t;
    h[0].indexOf("#version ") === 0 ? (d = 300, m = h[0], _ = h.slice(1).join(`
`)) : m = "#version ".concat(d);
    let E = {};
    i.forEach((R) => {
      Object.assign(E, R.getDefines());
    }), Object.assign(E, s);
    let b = l ? "".concat(m, `
`).concat(wT({ id: e, source: t, type: n }), `
`).concat(ST({ type: n }), `
`).concat(np(r2), `
`).concat(ip(r2, d, !u), `
`).concat(PT(E), `
`).concat(u ? "" : vT, `
`) : "".concat(m, `
`), T = CT(o), v = {}, C = {}, S = {};
    for (let R in a) {
      let D = typeof a[R] == "string" ? { injection: a[R], order: 0 } : a[R], B = R.match(/^(v|f)s:(#)?([\w-]+)$/);
      if (B) {
        let N = B[2], W = B[3];
        N ? W === "decl" ? C[R] = [D] : S[R] = [D] : v[R] = [D];
      } else
        S[R] = [D];
    }
    for (let R of i) {
      f && R.checkDeprecations(_, f), b += R.getModuleSource(n, d);
      let B = R.injections[n];
      for (let N in B) {
        let W = N.match(/^(v|f)s:#([\w-]+)$/);
        if (W) {
          let z = W[2] === "decl" ? C : S;
          z[N] = z[N] || [], z[N].push(B[N]);
        } else
          v[N] = v[N] || [], v[N].push(B[N]);
      }
    }
    return b += TT, b = Fo(b, n, C), b += LT(T[n], v), b += _, b = Fo(b, n, S), b = tf(b, c ? 100 : d, u), b;
  }
  function AT(r2) {
    return function(t) {
      let n = {};
      for (let i of r2) {
        let s = i.getUniforms(t, n);
        Object.assign(n, s);
      }
      return n;
    };
  }
  function ST({ type: r2 }) {
    return `
#define SHADER_TYPE_`.concat(up[r2].toUpperCase(), `
`);
  }
  function wT({ id: r2, source: e, type: t }) {
    return r2 && typeof r2 == "string" && e.indexOf("SHADER_NAME") === -1 ? `
#define SHADER_NAME `.concat(r2, "_").concat(up[t], `

`) : "";
  }
  function PT(r2 = {}) {
    let e = 0, t = "";
    for (let n in r2) {
      e === 0 && (t += `
// APPLICATION DEFINES
`), e++;
      let i = r2[n];
      (i || Number.isFinite(i)) && (t += "#define ".concat(n.toUpperCase(), " ").concat(r2[n], `
`));
    }
    return e === 0 && (t += `
`), t;
  }
  function LT(r2, e) {
    let t = "";
    for (let n in r2) {
      let i = r2[n];
      if (t += "void ".concat(i.signature, ` {
`), i.header && (t += "  ".concat(i.header)), e[n]) {
        let s = e[n];
        s.sort((o, a) => o.order - a.order);
        for (let o of s)
          t += "  ".concat(o.injection, `
`);
      }
      i.footer && (t += "  ".concat(i.footer)), t += `}
`;
    }
    return t;
  }
  function CT(r2) {
    let e = { vs: {}, fs: {} };
    return r2.forEach((t) => {
      let n;
      typeof t != "string" ? (n = t, t = n.hook) : n = {}, t = t.trim();
      let [i, s] = t.split(":"), o = t.replace(/\(.+/, "");
      e[i][o] = Object.assign(n, { signature: s });
    }), e;
  }
  var RT = "void main() {gl_FragColor = vec4(0);}";
  var dp = `out vec4 transform_output;
void main() {
  transform_output = vec4(0);
}`;
  var MT = `#version 300 es
`.concat(dp);
  function Bo(r2, e) {
    e = Array.isArray(e) ? e : [e];
    let t = r2.replace(/^\s+/, "").split(/\s+/), [n, i, s] = t;
    if (!e.includes(n) || !i || !s)
      return null;
    let o = s.split(";")[0];
    return { qualifier: n, type: i, name: o };
  }
  function Ji(r2 = {}) {
    let { version: e = 100, input: t, inputType: n, output: i } = r2;
    if (!t)
      return e === 300 ? MT : e > 300 ? "#version ".concat(e, `
`).concat(dp) : RT;
    let s = pp(t, n);
    return e >= 300 ? "#version ".concat(e, " ").concat(e === 300 ? "es" : "", `
in `).concat(n, " ").concat(t, `;
out vec4 `).concat(i, `;
void main() {
  `).concat(i, " = ").concat(s, `;
}`) : "varying ".concat(n, " ").concat(t, `;
void main() {
  gl_FragColor = `).concat(s, `;
}`);
  }
  function nf(r2) {
    switch (r2) {
      case "float":
        return "x";
      case "vec2":
        return "xy";
      case "vec3":
        return "xyz";
      case "vec4":
        return "xyzw";
      default:
        return fe(false), null;
    }
  }
  function sf(r2) {
    switch (r2) {
      case "float":
        return 1;
      case "vec2":
        return 2;
      case "vec3":
        return 3;
      case "vec4":
        return 4;
      default:
        return fe(false), null;
    }
  }
  function pp(r2, e) {
    switch (e) {
      case "float":
        return "vec4(".concat(r2, ", 0.0, 0.0, 1.0)");
      case "vec2":
        return "vec4(".concat(r2, ", 0.0, 1.0)");
      case "vec3":
        return "vec4(".concat(r2, ", 1.0)");
      case "vec4":
        return r2;
      default:
        return fe(false), null;
    }
  }
  var IT = `#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;

const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;

const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;

const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;

float sin_taylor_fp32(float a) {
  float r, s, t, x;

  if (a == 0.0) {
    return 0.0;
  }

  x = -a * a;
  s = a;
  r = a;

  r = r * x;
  t = r * INVERSE_FACTORIAL_3;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_5;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_7;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_9;
  s = s + t;

  return s;
}

void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
  if (a == 0.0) {
    sin_t = 0.0;
    cos_t = 1.0;
  }
  sin_t = sin_taylor_fp32(a);
  cos_t = sqrt(1.0 - sin_t * sin_t);
}

float tan_taylor_fp32(float a) {
    float sin_a;
    float cos_a;

    if (a == 0.0) {
        return 0.0;
    }
    float z = floor(a / TWO_PI);
    float r = a - TWO_PI * z;

    float t;
    float q = floor(r / PI_2 + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return 0.0 / 0.0;
    }

    t = r - PI_2 * q;

    q = floor(t / PI_16 + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return 0.0 / 0.0;
    } else {
        t = t - PI_16 * q;
    }

    float u = 0.0;
    float v = 0.0;

    float sin_t, cos_t;
    float s, c;
    sincos_taylor_fp32(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0;
            v = SIN_TABLE_0;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1;
            v = SIN_TABLE_1;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2;
            v = SIN_TABLE_2;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3;
            v = SIN_TABLE_3;
        }
        if (k > 0) {
            s = u * sin_t + v * cos_t;
            c = u * cos_t - v * sin_t;
        } else {
            s = u * sin_t - v * cos_t;
            c = u * cos_t + v * sin_t;
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return sin_a / cos_a;
}
#endif

float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
  return tan_taylor_fp32(a);
#else
  return tan(a);
#endif
}
`;
  var Uo = { name: "fp32", vs: IT, fs: null };
  function ue(r2, e) {
    if (!r2)
      throw new Error("math.gl assertion ".concat(e));
  }
  var ZF = 1 / Math.PI * 180;
  var KF = 1 / 180 * Math.PI;
  var ee = {};
  ee.EPSILON = 1e-12;
  ee.debug = false;
  ee.precision = 4;
  ee.printTypes = false;
  ee.printDegrees = false;
  ee.printRowMajor = true;
  function OT(r2) {
    return Math.round(r2 / ee.EPSILON) * ee.EPSILON;
  }
  function of(r2, { precision: e = ee.precision || 4 } = {}) {
    return r2 = OT(r2), "".concat(parseFloat(r2.toPrecision(e)));
  }
  function er(r2) {
    return Array.isArray(r2) || ArrayBuffer.isView(r2) && !(r2 instanceof DataView);
  }
  function NT(r2) {
    return r2.clone ? r2.clone() : new Array(r2.length);
  }
  function FT(r2, e, t) {
    if (er(r2)) {
      t = t || NT(r2);
      for (let n = 0; n < t.length && n < r2.length; ++n)
        t[n] = e(r2[n], n, t);
      return t;
    }
    return e(r2);
  }
  function Mn(r2, e, t) {
    return FT(r2, (n) => Math.max(e, Math.min(t, n)));
  }
  function Et(r2, e, t) {
    return er(r2) ? r2.map((n, i) => Et(n, e[i], t)) : t * e + (1 - t) * r2;
  }
  function Ke(r2, e, t) {
    let n = ee.EPSILON;
    t && (ee.EPSILON = t);
    try {
      if (r2 === e)
        return true;
      if (er(r2) && er(e)) {
        if (r2.length !== e.length)
          return false;
        for (let i = 0; i < r2.length; ++i)
          if (!Ke(r2[i], e[i]))
            return false;
        return true;
      }
      return r2 && r2.equals ? r2.equals(e) : e && e.equals ? e.equals(r2) : Number.isFinite(r2) && Number.isFinite(e) ? Math.abs(r2 - e) <= ee.EPSILON * Math.max(1, Math.abs(r2), Math.abs(e)) : false;
    } finally {
      ee.EPSILON = n;
    }
  }
  function DT(r2) {
    function e() {
      var t = Reflect.construct(r2, Array.from(arguments));
      return Object.setPrototypeOf(t, Object.getPrototypeOf(this)), t;
    }
    return e.prototype = Object.create(r2.prototype, { constructor: { value: r2, enumerable: false, writable: true, configurable: true } }), Object.setPrototypeOf ? Object.setPrototypeOf(e, r2) : e.__proto__ = r2, e;
  }
  var In = class extends DT(Array) {
    get ELEMENTS() {
      return ue(false), 0;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    from(e) {
      return Array.isArray(e) ? this.copy(e) : this.fromObject(e);
    }
    fromArray(e, t = 0) {
      for (let n = 0; n < this.ELEMENTS; ++n)
        this[n] = e[n + t];
      return this.check();
    }
    to(e) {
      return e === this ? this : er(e) ? this.toArray(e) : this.toObject(e);
    }
    toTarget(e) {
      return e ? this.to(e) : this;
    }
    toArray(e = [], t = 0) {
      for (let n = 0; n < this.ELEMENTS; ++n)
        e[t + n] = this[n];
      return e;
    }
    toFloat32Array() {
      return new Float32Array(this);
    }
    toString() {
      return this.formatString(ee);
    }
    formatString(e) {
      let t = "";
      for (let n = 0; n < this.ELEMENTS; ++n)
        t += (n > 0 ? ", " : "") + of(this[n], e);
      return "".concat(e.printTypes ? this.constructor.name : "", "[").concat(t, "]");
    }
    equals(e) {
      if (!e || this.length !== e.length)
        return false;
      for (let t = 0; t < this.ELEMENTS; ++t)
        if (!Ke(this[t], e[t]))
          return false;
      return true;
    }
    exactEquals(e) {
      if (!e || this.length !== e.length)
        return false;
      for (let t = 0; t < this.ELEMENTS; ++t)
        if (this[t] !== e[t])
          return false;
      return true;
    }
    negate() {
      for (let e = 0; e < this.ELEMENTS; ++e)
        this[e] = -this[e];
      return this.check();
    }
    lerp(e, t, n) {
      n === void 0 && (n = t, t = e, e = this);
      for (let i = 0; i < this.ELEMENTS; ++i) {
        let s = e[i];
        this[i] = s + n * (t[i] - s);
      }
      return this.check();
    }
    min(e) {
      for (let t = 0; t < this.ELEMENTS; ++t)
        this[t] = Math.min(e[t], this[t]);
      return this.check();
    }
    max(e) {
      for (let t = 0; t < this.ELEMENTS; ++t)
        this[t] = Math.max(e[t], this[t]);
      return this.check();
    }
    clamp(e, t) {
      for (let n = 0; n < this.ELEMENTS; ++n)
        this[n] = Math.min(Math.max(this[n], e[n]), t[n]);
      return this.check();
    }
    add(...e) {
      for (let t of e)
        for (let n = 0; n < this.ELEMENTS; ++n)
          this[n] += t[n];
      return this.check();
    }
    subtract(...e) {
      for (let t of e)
        for (let n = 0; n < this.ELEMENTS; ++n)
          this[n] -= t[n];
      return this.check();
    }
    scale(e) {
      if (Array.isArray(e))
        return this.multiply(e);
      for (let t = 0; t < this.ELEMENTS; ++t)
        this[t] *= e;
      return this.check();
    }
    sub(e) {
      return this.subtract(e);
    }
    setScalar(e) {
      for (let t = 0; t < this.ELEMENTS; ++t)
        this[t] = e;
      return this.check();
    }
    addScalar(e) {
      for (let t = 0; t < this.ELEMENTS; ++t)
        this[t] += e;
      return this.check();
    }
    subScalar(e) {
      return this.addScalar(-e);
    }
    multiplyScalar(e) {
      for (let t = 0; t < this.ELEMENTS; ++t)
        this[t] *= e;
      return this.check();
    }
    divideScalar(e) {
      return this.scale(1 / e);
    }
    clampScalar(e, t) {
      for (let n = 0; n < this.ELEMENTS; ++n)
        this[n] = Math.min(Math.max(this[n], e), t);
      return this.check();
    }
    multiplyByScalar(e) {
      return this.scale(e);
    }
    get elements() {
      return this;
    }
    check() {
      if (ee.debug && !this.validate())
        throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
      return this;
    }
    validate() {
      let e = this.length === this.ELEMENTS;
      for (let t = 0; t < this.ELEMENTS; ++t)
        e = e && Number.isFinite(this[t]);
      return e;
    }
  };
  function BT(r2, e) {
    if (r2.length !== e)
      return false;
    for (let t = 0; t < r2.length; ++t)
      if (!Number.isFinite(r2[t]))
        return false;
    return true;
  }
  function Re(r2) {
    if (!Number.isFinite(r2))
      throw new Error("Invalid number ".concat(r2));
    return r2;
  }
  function On(r2, e, t = "") {
    if (ee.debug && !BT(r2, e))
      throw new Error("math.gl: ".concat(t, " some fields set to invalid numbers'"));
    return r2;
  }
  var mp = {};
  function Ar(r2, e) {
    mp[r2] || (mp[r2] = true, console.warn("".concat(r2, " has been removed in version ").concat(e, ", see upgrade guide for more information")));
  }
  var ko = class extends In {
    get ELEMENTS() {
      return ue(false), 0;
    }
    copy(e) {
      return ue(false), this;
    }
    get x() {
      return this[0];
    }
    set x(e) {
      this[0] = Re(e);
    }
    get y() {
      return this[1];
    }
    set y(e) {
      this[1] = Re(e);
    }
    len() {
      return Math.sqrt(this.lengthSquared());
    }
    magnitude() {
      return this.len();
    }
    lengthSquared() {
      let e = 0;
      for (let t = 0; t < this.ELEMENTS; ++t)
        e += this[t] * this[t];
      return e;
    }
    magnitudeSquared() {
      return this.lengthSquared();
    }
    distance(e) {
      return Math.sqrt(this.distanceSquared(e));
    }
    distanceSquared(e) {
      let t = 0;
      for (let n = 0; n < this.ELEMENTS; ++n) {
        let i = this[n] - e[n];
        t += i * i;
      }
      return Re(t);
    }
    dot(e) {
      let t = 0;
      for (let n = 0; n < this.ELEMENTS; ++n)
        t += this[n] * e[n];
      return Re(t);
    }
    normalize() {
      let e = this.magnitude();
      if (e !== 0)
        for (let t = 0; t < this.ELEMENTS; ++t)
          this[t] /= e;
      return this.check();
    }
    multiply(...e) {
      for (let t of e)
        for (let n = 0; n < this.ELEMENTS; ++n)
          this[n] *= t[n];
      return this.check();
    }
    divide(...e) {
      for (let t of e)
        for (let n = 0; n < this.ELEMENTS; ++n)
          this[n] /= t[n];
      return this.check();
    }
    lengthSq() {
      return this.lengthSquared();
    }
    distanceTo(e) {
      return this.distance(e);
    }
    distanceToSquared(e) {
      return this.distanceSquared(e);
    }
    getComponent(e) {
      return ue(e >= 0 && e < this.ELEMENTS, "index is out of range"), Re(this[e]);
    }
    setComponent(e, t) {
      return ue(e >= 0 && e < this.ELEMENTS, "index is out of range"), this[e] = t, this.check();
    }
    addVectors(e, t) {
      return this.copy(e).add(t);
    }
    subVectors(e, t) {
      return this.copy(e).subtract(t);
    }
    multiplyVectors(e, t) {
      return this.copy(e).multiply(t);
    }
    addScaledVector(e, t) {
      return this.add(new this.constructor(e).multiplyScalar(t));
    }
  };
  var ne = 1e-6;
  var Ut = typeof Float32Array != "undefined" ? Float32Array : Array;
  var aD = Math.PI / 180;
  Math.hypot || (Math.hypot = function() {
    for (var r2 = 0, e = arguments.length; e--; )
      r2 += arguments[e] * arguments[e];
    return Math.sqrt(r2);
  });
  function UT() {
    var r2 = new Ut(2);
    return Ut != Float32Array && (r2[0] = 0, r2[1] = 0), r2;
  }
  function Nn(r2, e, t) {
    return r2[0] = e[0] + t[0], r2[1] = e[1] + t[1], r2;
  }
  function Vo(r2, e) {
    return r2[0] = -e[0], r2[1] = -e[1], r2;
  }
  function Go(r2, e, t, n) {
    var i = e[0], s = e[1];
    return r2[0] = i + n * (t[0] - i), r2[1] = s + n * (t[1] - s), r2;
  }
  function _p(r2, e, t) {
    var n = e[0], i = e[1];
    return r2[0] = t[0] * n + t[3] * i + t[6], r2[1] = t[1] * n + t[4] * i + t[7], r2;
  }
  function xp(r2, e, t) {
    var n = e[0], i = e[1];
    return r2[0] = t[0] * n + t[4] * i + t[12], r2[1] = t[1] * n + t[5] * i + t[13], r2;
  }
  var fD = function() {
    var r2 = UT();
    return function(e, t, n, i, s, o) {
      var a, c;
      for (t || (t = 2), n || (n = 0), i ? c = Math.min(i * t + n, e.length) : c = e.length, a = n; a < c; a += t)
        r2[0] = e[a], r2[1] = e[a + 1], s(r2, r2, o), e[a] = r2[0], e[a + 1] = r2[1];
      return e;
    };
  }();
  function yp(r2, e, t) {
    let n = e[0], i = e[1], s = t[3] * n + t[7] * i || 1;
    return r2[0] = (t[0] * n + t[4] * i) / s, r2[1] = (t[1] * n + t[5] * i) / s, r2;
  }
  function zo(r2, e, t) {
    let n = e[0], i = e[1], s = e[2], o = t[3] * n + t[7] * i + t[11] * s || 1;
    return r2[0] = (t[0] * n + t[4] * i + t[8] * s) / o, r2[1] = (t[1] * n + t[5] * i + t[9] * s) / o, r2[2] = (t[2] * n + t[6] * i + t[10] * s) / o, r2;
  }
  function Ep(r2, e, t) {
    let n = e[0], i = e[1];
    return r2[0] = t[0] * n + t[2] * i, r2[1] = t[1] * n + t[3] * i, r2[2] = e[2], r2;
  }
  function bp(r2, e, t) {
    let n = e[0], i = e[1], s = e[2];
    return r2[0] = t[0] * n + t[3] * i + t[6] * s, r2[1] = t[1] * n + t[4] * i + t[7] * s, r2[2] = t[2] * n + t[5] * i + t[8] * s, r2[3] = e[3], r2;
  }
  function kT() {
    var r2 = new Ut(3);
    return Ut != Float32Array && (r2[0] = 0, r2[1] = 0, r2[2] = 0), r2;
  }
  function Tp(r2, e, t) {
    return r2[0] = e[0] + t[0], r2[1] = e[1] + t[1], r2[2] = e[2] + t[2], r2;
  }
  function VT(r2, e, t) {
    return r2[0] = e[0] - t[0], r2[1] = e[1] - t[1], r2[2] = e[2] - t[2], r2;
  }
  function GT(r2, e, t) {
    return r2[0] = e[0] * t[0], r2[1] = e[1] * t[1], r2[2] = e[2] * t[2], r2;
  }
  function vp(r2, e) {
    return r2[0] = -e[0], r2[1] = -e[1], r2[2] = -e[2], r2;
  }
  function zT(r2, e) {
    return r2[0] * e[0] + r2[1] * e[1] + r2[2] * e[2];
  }
  function Ap(r2, e, t) {
    var n = e[0], i = e[1], s = e[2], o = t[0], a = t[1], c = t[2];
    return r2[0] = i * c - s * a, r2[1] = s * o - n * c, r2[2] = n * a - i * o, r2;
  }
  function jo(r2, e, t) {
    var n = e[0], i = e[1], s = e[2], o = t[3] * n + t[7] * i + t[11] * s + t[15];
    return o = o || 1, r2[0] = (t[0] * n + t[4] * i + t[8] * s + t[12]) / o, r2[1] = (t[1] * n + t[5] * i + t[9] * s + t[13]) / o, r2[2] = (t[2] * n + t[6] * i + t[10] * s + t[14]) / o, r2;
  }
  function Wo(r2, e, t) {
    var n = e[0], i = e[1], s = e[2];
    return r2[0] = n * t[0] + i * t[3] + s * t[6], r2[1] = n * t[1] + i * t[4] + s * t[7], r2[2] = n * t[2] + i * t[5] + s * t[8], r2;
  }
  function Sp(r2, e, t) {
    var n = t[0], i = t[1], s = t[2], o = t[3], a = e[0], c = e[1], l = e[2], f = i * l - s * c, u = s * a - n * l, h = n * c - i * a, d = i * h - s * u, m = s * f - n * h, _ = n * u - i * f, E = o * 2;
    return f *= E, u *= E, h *= E, d *= 2, m *= 2, _ *= 2, r2[0] = a + f + d, r2[1] = c + u + m, r2[2] = l + h + _, r2;
  }
  function wp(r2, e, t, n) {
    var i = [], s = [];
    return i[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], s[0] = i[0], s[1] = i[1] * Math.cos(n) - i[2] * Math.sin(n), s[2] = i[1] * Math.sin(n) + i[2] * Math.cos(n), r2[0] = s[0] + t[0], r2[1] = s[1] + t[1], r2[2] = s[2] + t[2], r2;
  }
  function Pp(r2, e, t, n) {
    var i = [], s = [];
    return i[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], s[0] = i[2] * Math.sin(n) + i[0] * Math.cos(n), s[1] = i[1], s[2] = i[2] * Math.cos(n) - i[0] * Math.sin(n), r2[0] = s[0] + t[0], r2[1] = s[1] + t[1], r2[2] = s[2] + t[2], r2;
  }
  function Lp(r2, e, t, n) {
    var i = [], s = [];
    return i[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], s[0] = i[0] * Math.cos(n) - i[1] * Math.sin(n), s[1] = i[0] * Math.sin(n) + i[1] * Math.cos(n), s[2] = i[2], r2[0] = s[0] + t[0], r2[1] = s[1] + t[1], r2[2] = s[2] + t[2], r2;
  }
  function Cp(r2, e) {
    var t = r2[0], n = r2[1], i = r2[2], s = e[0], o = e[1], a = e[2], c = Math.sqrt(t * t + n * n + i * i), l = Math.sqrt(s * s + o * o + a * a), f = c * l, u = f && zT(r2, e) / f;
    return Math.acos(Math.min(Math.max(u, -1), 1));
  }
  var Rp = VT;
  var Mp = GT;
  var pD = function() {
    var r2 = kT();
    return function(e, t, n, i, s, o) {
      var a, c;
      for (t || (t = 3), n || (n = 0), i ? c = Math.min(i * t + n, e.length) : c = e.length, a = n; a < c; a += t)
        r2[0] = e[a], r2[1] = e[a + 1], r2[2] = e[a + 2], s(r2, r2, o), e[a] = r2[0], e[a + 1] = r2[1], e[a + 2] = r2[2];
      return e;
    };
  }();
  var af = [0, 0, 0];
  var Ip = {};
  var M = class extends ko {
    static get ZERO() {
      return Ip.ZERO = Ip.ZERO || Object.freeze(new M(0, 0, 0, 0));
    }
    constructor(e = 0, t = 0, n = 0) {
      super(-0, -0, -0);
      arguments.length === 1 && er(e) ? this.copy(e) : (ee.debug && (Re(e), Re(t), Re(n)), this[0] = e, this[1] = t, this[2] = n);
    }
    set(e, t, n) {
      return this[0] = e, this[1] = t, this[2] = n, this.check();
    }
    copy(e) {
      return this[0] = e[0], this[1] = e[1], this[2] = e[2], this.check();
    }
    fromObject(e) {
      return ee.debug && (Re(e.x), Re(e.y), Re(e.z)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this.check();
    }
    toObject(e) {
      return e.x = this[0], e.y = this[1], e.z = this[2], e;
    }
    get ELEMENTS() {
      return 3;
    }
    get z() {
      return this[2];
    }
    set z(e) {
      this[2] = Re(e);
    }
    angle(e) {
      return Cp(this, e);
    }
    cross(e) {
      return Ap(this, this, e), this.check();
    }
    rotateX({ radians: e, origin: t = af }) {
      return wp(this, this, t, e), this.check();
    }
    rotateY({ radians: e, origin: t = af }) {
      return Pp(this, this, t, e), this.check();
    }
    rotateZ({ radians: e, origin: t = af }) {
      return Lp(this, this, t, e), this.check();
    }
    transform(e) {
      return this.transformAsPoint(e);
    }
    transformAsPoint(e) {
      return jo(this, this, e), this.check();
    }
    transformAsVector(e) {
      return zo(this, this, e), this.check();
    }
    transformByMatrix3(e) {
      return Wo(this, this, e), this.check();
    }
    transformByMatrix2(e) {
      return Ep(this, this, e), this.check();
    }
    transformByQuaternion(e) {
      return Sp(this, this, e), this.check();
    }
  };
  var Fn = class extends In {
    get ELEMENTS() {
      return ue(false), 0;
    }
    get RANK() {
      return ue(false), 0;
    }
    toString() {
      let e = "[";
      if (ee.printRowMajor) {
        e += "row-major:";
        for (let t = 0; t < this.RANK; ++t)
          for (let n = 0; n < this.RANK; ++n)
            e += " ".concat(this[n * this.RANK + t]);
      } else {
        e += "column-major:";
        for (let t = 0; t < this.ELEMENTS; ++t)
          e += " ".concat(this[t]);
      }
      return e += "]", e;
    }
    getElementIndex(e, t) {
      return t * this.RANK + e;
    }
    getElement(e, t) {
      return this[t * this.RANK + e];
    }
    setElement(e, t, n) {
      return this[t * this.RANK + e] = Re(n), this;
    }
    getColumn(e, t = new Array(this.RANK).fill(-0)) {
      let n = e * this.RANK;
      for (let i = 0; i < this.RANK; ++i)
        t[i] = this[n + i];
      return t;
    }
    setColumn(e, t) {
      let n = e * this.RANK;
      for (let i = 0; i < this.RANK; ++i)
        this[n + i] = t[i];
      return this;
    }
  };
  function Op(r2, e) {
    if (r2 === e) {
      var t = e[1], n = e[2], i = e[5];
      r2[1] = e[3], r2[2] = e[6], r2[3] = t, r2[5] = e[7], r2[6] = n, r2[7] = i;
    } else
      r2[0] = e[0], r2[1] = e[3], r2[2] = e[6], r2[3] = e[1], r2[4] = e[4], r2[5] = e[7], r2[6] = e[2], r2[7] = e[5], r2[8] = e[8];
    return r2;
  }
  function Np(r2, e) {
    var t = e[0], n = e[1], i = e[2], s = e[3], o = e[4], a = e[5], c = e[6], l = e[7], f = e[8], u = f * o - a * l, h = -f * s + a * c, d = l * s - o * c, m = t * u + n * h + i * d;
    return m ? (m = 1 / m, r2[0] = u * m, r2[1] = (-f * n + i * l) * m, r2[2] = (a * n - i * o) * m, r2[3] = h * m, r2[4] = (f * t - i * c) * m, r2[5] = (-a * t + i * s) * m, r2[6] = d * m, r2[7] = (-l * t + n * c) * m, r2[8] = (o * t - n * s) * m, r2) : null;
  }
  function Fp(r2) {
    var e = r2[0], t = r2[1], n = r2[2], i = r2[3], s = r2[4], o = r2[5], a = r2[6], c = r2[7], l = r2[8];
    return e * (l * s - o * c) + t * (-l * i + o * a) + n * (c * i - s * a);
  }
  function cf(r2, e, t) {
    var n = e[0], i = e[1], s = e[2], o = e[3], a = e[4], c = e[5], l = e[6], f = e[7], u = e[8], h = t[0], d = t[1], m = t[2], _ = t[3], E = t[4], b = t[5], T = t[6], v = t[7], C = t[8];
    return r2[0] = h * n + d * o + m * l, r2[1] = h * i + d * a + m * f, r2[2] = h * s + d * c + m * u, r2[3] = _ * n + E * o + b * l, r2[4] = _ * i + E * a + b * f, r2[5] = _ * s + E * c + b * u, r2[6] = T * n + v * o + C * l, r2[7] = T * i + v * a + C * f, r2[8] = T * s + v * c + C * u, r2;
  }
  function Dp(r2, e, t) {
    var n = e[0], i = e[1], s = e[2], o = e[3], a = e[4], c = e[5], l = e[6], f = e[7], u = e[8], h = t[0], d = t[1];
    return r2[0] = n, r2[1] = i, r2[2] = s, r2[3] = o, r2[4] = a, r2[5] = c, r2[6] = h * n + d * o + l, r2[7] = h * i + d * a + f, r2[8] = h * s + d * c + u, r2;
  }
  function Bp(r2, e, t) {
    var n = e[0], i = e[1], s = e[2], o = e[3], a = e[4], c = e[5], l = e[6], f = e[7], u = e[8], h = Math.sin(t), d = Math.cos(t);
    return r2[0] = d * n + h * o, r2[1] = d * i + h * a, r2[2] = d * s + h * c, r2[3] = d * o - h * n, r2[4] = d * a - h * i, r2[5] = d * c - h * s, r2[6] = l, r2[7] = f, r2[8] = u, r2;
  }
  function lf(r2, e, t) {
    var n = t[0], i = t[1];
    return r2[0] = n * e[0], r2[1] = n * e[1], r2[2] = n * e[2], r2[3] = i * e[3], r2[4] = i * e[4], r2[5] = i * e[5], r2[6] = e[6], r2[7] = e[7], r2[8] = e[8], r2;
  }
  function Up(r2, e) {
    var t = e[0], n = e[1], i = e[2], s = e[3], o = t + t, a = n + n, c = i + i, l = t * o, f = n * o, u = n * a, h = i * o, d = i * a, m = i * c, _ = s * o, E = s * a, b = s * c;
    return r2[0] = 1 - u - m, r2[3] = f - b, r2[6] = h + E, r2[1] = f + b, r2[4] = 1 - l - m, r2[7] = d - _, r2[2] = h - E, r2[5] = d + _, r2[8] = 1 - l - u, r2;
  }
  var kp = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
  var jT = Object.freeze([0, 0, 0, 0, 0, 0, 0, 0, 0]);
  var WT = Object.freeze({ COL0ROW0: 0, COL0ROW1: 1, COL0ROW2: 2, COL1ROW0: 3, COL1ROW1: 4, COL1ROW2: 5, COL2ROW0: 6, COL2ROW1: 7, COL2ROW2: 8 });
  var Dn = {};
  var Ae = class extends Fn {
    static get IDENTITY() {
      return Dn.IDENTITY = Dn.IDENTITY || Object.freeze(new Ae(kp)), Dn.IDENTITY;
    }
    static get ZERO() {
      return Dn.ZERO = Dn.ZERO || Object.freeze(new Ae(jT)), Dn.ZERO;
    }
    get ELEMENTS() {
      return 9;
    }
    get RANK() {
      return 3;
    }
    get INDICES() {
      return WT;
    }
    constructor(e) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0);
      arguments.length === 1 && Array.isArray(e) ? this.copy(e) : this.identity();
    }
    copy(e) {
      return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this.check();
    }
    set(e, t, n, i, s, o, a, c, l) {
      return this[0] = e, this[1] = t, this[2] = n, this[3] = i, this[4] = s, this[5] = o, this[6] = a, this[7] = c, this[8] = l, this.check();
    }
    setRowMajor(e, t, n, i, s, o, a, c, l) {
      return this[0] = e, this[1] = i, this[2] = a, this[3] = t, this[4] = s, this[5] = c, this[6] = n, this[7] = o, this[8] = l, this.check();
    }
    determinant() {
      return Fp(this);
    }
    identity() {
      return this.copy(kp);
    }
    fromQuaternion(e) {
      return Up(this, e), this.check();
    }
    transpose() {
      return Op(this, this), this.check();
    }
    invert() {
      return Np(this, this), this.check();
    }
    multiplyLeft(e) {
      return cf(this, e, this), this.check();
    }
    multiplyRight(e) {
      return cf(this, this, e), this.check();
    }
    rotate(e) {
      return Bp(this, this, e), this.check();
    }
    scale(e) {
      return Array.isArray(e) ? lf(this, this, e) : lf(this, this, [e, e, e]), this.check();
    }
    translate(e) {
      return Dp(this, this, e), this.check();
    }
    transform(e, t) {
      switch (e.length) {
        case 2:
          t = _p(t || [-0, -0], e, this);
          break;
        case 3:
          t = Wo(t || [-0, -0, -0], e, this);
          break;
        case 4:
          t = bp(t || [-0, -0, -0, -0], e, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      return On(t, e.length), t;
    }
    transformVector(e, t) {
      return Ar("Matrix3.transformVector"), this.transform(e, t);
    }
    transformVector2(e, t) {
      return Ar("Matrix3.transformVector"), this.transform(e, t);
    }
    transformVector3(e, t) {
      return Ar("Matrix3.transformVector"), this.transform(e, t);
    }
  };
  function HT(r2) {
    return r2[0] = 1, r2[1] = 0, r2[2] = 0, r2[3] = 0, r2[4] = 0, r2[5] = 1, r2[6] = 0, r2[7] = 0, r2[8] = 0, r2[9] = 0, r2[10] = 1, r2[11] = 0, r2[12] = 0, r2[13] = 0, r2[14] = 0, r2[15] = 1, r2;
  }
  function Vp(r2, e) {
    if (r2 === e) {
      var t = e[1], n = e[2], i = e[3], s = e[6], o = e[7], a = e[11];
      r2[1] = e[4], r2[2] = e[8], r2[3] = e[12], r2[4] = t, r2[6] = e[9], r2[7] = e[13], r2[8] = n, r2[9] = s, r2[11] = e[14], r2[12] = i, r2[13] = o, r2[14] = a;
    } else
      r2[0] = e[0], r2[1] = e[4], r2[2] = e[8], r2[3] = e[12], r2[4] = e[1], r2[5] = e[5], r2[6] = e[9], r2[7] = e[13], r2[8] = e[2], r2[9] = e[6], r2[10] = e[10], r2[11] = e[14], r2[12] = e[3], r2[13] = e[7], r2[14] = e[11], r2[15] = e[15];
    return r2;
  }
  function Qr(r2, e) {
    var t = e[0], n = e[1], i = e[2], s = e[3], o = e[4], a = e[5], c = e[6], l = e[7], f = e[8], u = e[9], h = e[10], d = e[11], m = e[12], _ = e[13], E = e[14], b = e[15], T = t * a - n * o, v = t * c - i * o, C = t * l - s * o, S = n * c - i * a, R = n * l - s * a, D = i * l - s * c, B = f * _ - u * m, N = f * E - h * m, W = f * b - d * m, q = u * E - h * _, z = u * b - d * _, V = h * b - d * E, Y = T * V - v * z + C * q + S * W - R * N + D * B;
    return Y ? (Y = 1 / Y, r2[0] = (a * V - c * z + l * q) * Y, r2[1] = (i * z - n * V - s * q) * Y, r2[2] = (_ * D - E * R + b * S) * Y, r2[3] = (h * R - u * D - d * S) * Y, r2[4] = (c * W - o * V - l * N) * Y, r2[5] = (t * V - i * W + s * N) * Y, r2[6] = (E * C - m * D - b * v) * Y, r2[7] = (f * D - h * C + d * v) * Y, r2[8] = (o * z - a * W + l * B) * Y, r2[9] = (n * W - t * z - s * B) * Y, r2[10] = (m * R - _ * C + b * T) * Y, r2[11] = (u * C - f * R - d * T) * Y, r2[12] = (a * N - o * q - c * B) * Y, r2[13] = (t * q - n * N + i * B) * Y, r2[14] = (_ * v - m * S - E * T) * Y, r2[15] = (f * S - u * v + h * T) * Y, r2) : null;
  }
  function Gp(r2) {
    var e = r2[0], t = r2[1], n = r2[2], i = r2[3], s = r2[4], o = r2[5], a = r2[6], c = r2[7], l = r2[8], f = r2[9], u = r2[10], h = r2[11], d = r2[12], m = r2[13], _ = r2[14], E = r2[15], b = e * o - t * s, T = e * a - n * s, v = e * c - i * s, C = t * a - n * o, S = t * c - i * o, R = n * c - i * a, D = l * m - f * d, B = l * _ - u * d, N = l * E - h * d, W = f * _ - u * m, q = f * E - h * m, z = u * E - h * _;
    return b * z - T * q + v * W + C * N - S * B + R * D;
  }
  function Ve(r2, e, t) {
    var n = e[0], i = e[1], s = e[2], o = e[3], a = e[4], c = e[5], l = e[6], f = e[7], u = e[8], h = e[9], d = e[10], m = e[11], _ = e[12], E = e[13], b = e[14], T = e[15], v = t[0], C = t[1], S = t[2], R = t[3];
    return r2[0] = v * n + C * a + S * u + R * _, r2[1] = v * i + C * c + S * h + R * E, r2[2] = v * s + C * l + S * d + R * b, r2[3] = v * o + C * f + S * m + R * T, v = t[4], C = t[5], S = t[6], R = t[7], r2[4] = v * n + C * a + S * u + R * _, r2[5] = v * i + C * c + S * h + R * E, r2[6] = v * s + C * l + S * d + R * b, r2[7] = v * o + C * f + S * m + R * T, v = t[8], C = t[9], S = t[10], R = t[11], r2[8] = v * n + C * a + S * u + R * _, r2[9] = v * i + C * c + S * h + R * E, r2[10] = v * s + C * l + S * d + R * b, r2[11] = v * o + C * f + S * m + R * T, v = t[12], C = t[13], S = t[14], R = t[15], r2[12] = v * n + C * a + S * u + R * _, r2[13] = v * i + C * c + S * h + R * E, r2[14] = v * s + C * l + S * d + R * b, r2[15] = v * o + C * f + S * m + R * T, r2;
  }
  function tr(r2, e, t) {
    var n = t[0], i = t[1], s = t[2], o, a, c, l, f, u, h, d, m, _, E, b;
    return e === r2 ? (r2[12] = e[0] * n + e[4] * i + e[8] * s + e[12], r2[13] = e[1] * n + e[5] * i + e[9] * s + e[13], r2[14] = e[2] * n + e[6] * i + e[10] * s + e[14], r2[15] = e[3] * n + e[7] * i + e[11] * s + e[15]) : (o = e[0], a = e[1], c = e[2], l = e[3], f = e[4], u = e[5], h = e[6], d = e[7], m = e[8], _ = e[9], E = e[10], b = e[11], r2[0] = o, r2[1] = a, r2[2] = c, r2[3] = l, r2[4] = f, r2[5] = u, r2[6] = h, r2[7] = d, r2[8] = m, r2[9] = _, r2[10] = E, r2[11] = b, r2[12] = o * n + f * i + m * s + e[12], r2[13] = a * n + u * i + _ * s + e[13], r2[14] = c * n + h * i + E * s + e[14], r2[15] = l * n + d * i + b * s + e[15]), r2;
  }
  function rr(r2, e, t) {
    var n = t[0], i = t[1], s = t[2];
    return r2[0] = e[0] * n, r2[1] = e[1] * n, r2[2] = e[2] * n, r2[3] = e[3] * n, r2[4] = e[4] * i, r2[5] = e[5] * i, r2[6] = e[6] * i, r2[7] = e[7] * i, r2[8] = e[8] * s, r2[9] = e[9] * s, r2[10] = e[10] * s, r2[11] = e[11] * s, r2[12] = e[12], r2[13] = e[13], r2[14] = e[14], r2[15] = e[15], r2;
  }
  function zp(r2, e, t, n) {
    var i = n[0], s = n[1], o = n[2], a = Math.hypot(i, s, o), c, l, f, u, h, d, m, _, E, b, T, v, C, S, R, D, B, N, W, q, z, V, Y, Se;
    return a < ne ? null : (a = 1 / a, i *= a, s *= a, o *= a, c = Math.sin(t), l = Math.cos(t), f = 1 - l, u = e[0], h = e[1], d = e[2], m = e[3], _ = e[4], E = e[5], b = e[6], T = e[7], v = e[8], C = e[9], S = e[10], R = e[11], D = i * i * f + l, B = s * i * f + o * c, N = o * i * f - s * c, W = i * s * f - o * c, q = s * s * f + l, z = o * s * f + i * c, V = i * o * f + s * c, Y = s * o * f - i * c, Se = o * o * f + l, r2[0] = u * D + _ * B + v * N, r2[1] = h * D + E * B + C * N, r2[2] = d * D + b * B + S * N, r2[3] = m * D + T * B + R * N, r2[4] = u * W + _ * q + v * z, r2[5] = h * W + E * q + C * z, r2[6] = d * W + b * q + S * z, r2[7] = m * W + T * q + R * z, r2[8] = u * V + _ * Y + v * Se, r2[9] = h * V + E * Y + C * Se, r2[10] = d * V + b * Y + S * Se, r2[11] = m * V + T * Y + R * Se, e !== r2 && (r2[12] = e[12], r2[13] = e[13], r2[14] = e[14], r2[15] = e[15]), r2);
  }
  function Ho(r2, e, t) {
    var n = Math.sin(t), i = Math.cos(t), s = e[4], o = e[5], a = e[6], c = e[7], l = e[8], f = e[9], u = e[10], h = e[11];
    return e !== r2 && (r2[0] = e[0], r2[1] = e[1], r2[2] = e[2], r2[3] = e[3], r2[12] = e[12], r2[13] = e[13], r2[14] = e[14], r2[15] = e[15]), r2[4] = s * i + l * n, r2[5] = o * i + f * n, r2[6] = a * i + u * n, r2[7] = c * i + h * n, r2[8] = l * i - s * n, r2[9] = f * i - o * n, r2[10] = u * i - a * n, r2[11] = h * i - c * n, r2;
  }
  function jp(r2, e, t) {
    var n = Math.sin(t), i = Math.cos(t), s = e[0], o = e[1], a = e[2], c = e[3], l = e[8], f = e[9], u = e[10], h = e[11];
    return e !== r2 && (r2[4] = e[4], r2[5] = e[5], r2[6] = e[6], r2[7] = e[7], r2[12] = e[12], r2[13] = e[13], r2[14] = e[14], r2[15] = e[15]), r2[0] = s * i - l * n, r2[1] = o * i - f * n, r2[2] = a * i - u * n, r2[3] = c * i - h * n, r2[8] = s * n + l * i, r2[9] = o * n + f * i, r2[10] = a * n + u * i, r2[11] = c * n + h * i, r2;
  }
  function Xo(r2, e, t) {
    var n = Math.sin(t), i = Math.cos(t), s = e[0], o = e[1], a = e[2], c = e[3], l = e[4], f = e[5], u = e[6], h = e[7];
    return e !== r2 && (r2[8] = e[8], r2[9] = e[9], r2[10] = e[10], r2[11] = e[11], r2[12] = e[12], r2[13] = e[13], r2[14] = e[14], r2[15] = e[15]), r2[0] = s * i + l * n, r2[1] = o * i + f * n, r2[2] = a * i + u * n, r2[3] = c * i + h * n, r2[4] = l * i - s * n, r2[5] = f * i - o * n, r2[6] = u * i - a * n, r2[7] = h * i - c * n, r2;
  }
  function Wp(r2, e) {
    var t = e[0], n = e[1], i = e[2], s = e[4], o = e[5], a = e[6], c = e[8], l = e[9], f = e[10];
    return r2[0] = Math.hypot(t, n, i), r2[1] = Math.hypot(s, o, a), r2[2] = Math.hypot(c, l, f), r2;
  }
  function Hp(r2, e) {
    var t = e[0], n = e[1], i = e[2], s = e[3], o = t + t, a = n + n, c = i + i, l = t * o, f = n * o, u = n * a, h = i * o, d = i * a, m = i * c, _ = s * o, E = s * a, b = s * c;
    return r2[0] = 1 - u - m, r2[1] = f + b, r2[2] = h - E, r2[3] = 0, r2[4] = f - b, r2[5] = 1 - l - m, r2[6] = d + _, r2[7] = 0, r2[8] = h + E, r2[9] = d - _, r2[10] = 1 - l - u, r2[11] = 0, r2[12] = 0, r2[13] = 0, r2[14] = 0, r2[15] = 1, r2;
  }
  function Xp(r2, e, t, n, i, s, o) {
    var a = 1 / (t - e), c = 1 / (i - n), l = 1 / (s - o);
    return r2[0] = s * 2 * a, r2[1] = 0, r2[2] = 0, r2[3] = 0, r2[4] = 0, r2[5] = s * 2 * c, r2[6] = 0, r2[7] = 0, r2[8] = (t + e) * a, r2[9] = (i + n) * c, r2[10] = (o + s) * l, r2[11] = -1, r2[12] = 0, r2[13] = 0, r2[14] = o * s * 2 * l, r2[15] = 0, r2;
  }
  function Yo(r2, e, t, n, i) {
    var s = 1 / Math.tan(e / 2), o;
    return r2[0] = s / t, r2[1] = 0, r2[2] = 0, r2[3] = 0, r2[4] = 0, r2[5] = s, r2[6] = 0, r2[7] = 0, r2[8] = 0, r2[9] = 0, r2[11] = -1, r2[12] = 0, r2[13] = 0, r2[15] = 0, i != null && i !== 1 / 0 ? (o = 1 / (n - i), r2[10] = (i + n) * o, r2[14] = 2 * i * n * o) : (r2[10] = -1, r2[14] = -2 * n), r2;
  }
  function Yp(r2, e, t, n, i, s, o) {
    var a = 1 / (e - t), c = 1 / (n - i), l = 1 / (s - o);
    return r2[0] = -2 * a, r2[1] = 0, r2[2] = 0, r2[3] = 0, r2[4] = 0, r2[5] = -2 * c, r2[6] = 0, r2[7] = 0, r2[8] = 0, r2[9] = 0, r2[10] = 2 * l, r2[11] = 0, r2[12] = (e + t) * a, r2[13] = (i + n) * c, r2[14] = (o + s) * l, r2[15] = 1, r2;
  }
  function qp(r2, e, t, n) {
    var i, s, o, a, c, l, f, u, h, d, m = e[0], _ = e[1], E = e[2], b = n[0], T = n[1], v = n[2], C = t[0], S = t[1], R = t[2];
    return Math.abs(m - C) < ne && Math.abs(_ - S) < ne && Math.abs(E - R) < ne ? HT(r2) : (f = m - C, u = _ - S, h = E - R, d = 1 / Math.hypot(f, u, h), f *= d, u *= d, h *= d, i = T * h - v * u, s = v * f - b * h, o = b * u - T * f, d = Math.hypot(i, s, o), d ? (d = 1 / d, i *= d, s *= d, o *= d) : (i = 0, s = 0, o = 0), a = u * o - h * s, c = h * i - f * o, l = f * s - u * i, d = Math.hypot(a, c, l), d ? (d = 1 / d, a *= d, c *= d, l *= d) : (a = 0, c = 0, l = 0), r2[0] = i, r2[1] = a, r2[2] = f, r2[3] = 0, r2[4] = s, r2[5] = c, r2[6] = u, r2[7] = 0, r2[8] = o, r2[9] = l, r2[10] = h, r2[11] = 0, r2[12] = -(i * m + s * _ + o * E), r2[13] = -(a * m + c * _ + l * E), r2[14] = -(f * m + u * _ + h * E), r2[15] = 1, r2);
  }
  function ff(r2, e) {
    var t = r2[0], n = r2[1], i = r2[2], s = r2[3], o = r2[4], a = r2[5], c = r2[6], l = r2[7], f = r2[8], u = r2[9], h = r2[10], d = r2[11], m = r2[12], _ = r2[13], E = r2[14], b = r2[15], T = e[0], v = e[1], C = e[2], S = e[3], R = e[4], D = e[5], B = e[6], N = e[7], W = e[8], q = e[9], z = e[10], V = e[11], Y = e[12], Se = e[13], jt = e[14], cr = e[15];
    return Math.abs(t - T) <= ne * Math.max(1, Math.abs(t), Math.abs(T)) && Math.abs(n - v) <= ne * Math.max(1, Math.abs(n), Math.abs(v)) && Math.abs(i - C) <= ne * Math.max(1, Math.abs(i), Math.abs(C)) && Math.abs(s - S) <= ne * Math.max(1, Math.abs(s), Math.abs(S)) && Math.abs(o - R) <= ne * Math.max(1, Math.abs(o), Math.abs(R)) && Math.abs(a - D) <= ne * Math.max(1, Math.abs(a), Math.abs(D)) && Math.abs(c - B) <= ne * Math.max(1, Math.abs(c), Math.abs(B)) && Math.abs(l - N) <= ne * Math.max(1, Math.abs(l), Math.abs(N)) && Math.abs(f - W) <= ne * Math.max(1, Math.abs(f), Math.abs(W)) && Math.abs(u - q) <= ne * Math.max(1, Math.abs(u), Math.abs(q)) && Math.abs(h - z) <= ne * Math.max(1, Math.abs(h), Math.abs(z)) && Math.abs(d - V) <= ne * Math.max(1, Math.abs(d), Math.abs(V)) && Math.abs(m - Y) <= ne * Math.max(1, Math.abs(m), Math.abs(Y)) && Math.abs(_ - Se) <= ne * Math.max(1, Math.abs(_), Math.abs(Se)) && Math.abs(E - jt) <= ne * Math.max(1, Math.abs(E), Math.abs(jt)) && Math.abs(b - cr) <= ne * Math.max(1, Math.abs(b), Math.abs(cr));
  }
  function XT() {
    var r2 = new Ut(4);
    return Ut != Float32Array && (r2[0] = 0, r2[1] = 0, r2[2] = 0, r2[3] = 0), r2;
  }
  function Zp(r2, e, t) {
    return r2[0] = e[0] * t, r2[1] = e[1] * t, r2[2] = e[2] * t, r2[3] = e[3] * t, r2;
  }
  function Sr(r2, e, t) {
    var n = e[0], i = e[1], s = e[2], o = e[3];
    return r2[0] = t[0] * n + t[4] * i + t[8] * s + t[12] * o, r2[1] = t[1] * n + t[5] * i + t[9] * s + t[13] * o, r2[2] = t[2] * n + t[6] * i + t[10] * s + t[14] * o, r2[3] = t[3] * n + t[7] * i + t[11] * s + t[15] * o, r2;
  }
  var UD = function() {
    var r2 = XT();
    return function(e, t, n, i, s, o) {
      var a, c;
      for (t || (t = 4), n || (n = 0), i ? c = Math.min(i * t + n, e.length) : c = e.length, a = n; a < c; a += t)
        r2[0] = e[a], r2[1] = e[a + 1], r2[2] = e[a + 2], r2[3] = e[a + 3], s(r2, r2, o), e[a] = r2[0], e[a + 1] = r2[1], e[a + 2] = r2[2], e[a + 3] = r2[3];
      return e;
    };
  }();
  var Kp = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  var YT = Object.freeze([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
  var qT = Object.freeze({ COL0ROW0: 0, COL0ROW1: 1, COL0ROW2: 2, COL0ROW3: 3, COL1ROW0: 4, COL1ROW1: 5, COL1ROW2: 6, COL1ROW3: 7, COL2ROW0: 8, COL2ROW1: 9, COL2ROW2: 10, COL2ROW3: 11, COL3ROW0: 12, COL3ROW1: 13, COL3ROW2: 14, COL3ROW3: 15 });
  var Bn = {};
  var ce = class extends Fn {
    static get IDENTITY() {
      return Bn.IDENTITY = Bn.IDENTITY || Object.freeze(new ce(Kp)), Bn.IDENTITY;
    }
    static get ZERO() {
      return Bn.ZERO = Bn.ZERO || Object.freeze(new ce(YT)), Bn.ZERO;
    }
    get INDICES() {
      return qT;
    }
    get ELEMENTS() {
      return 16;
    }
    get RANK() {
      return 4;
    }
    constructor(e) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
      arguments.length === 1 && Array.isArray(e) ? this.copy(e) : this.identity();
    }
    copy(e) {
      return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this[9] = e[9], this[10] = e[10], this[11] = e[11], this[12] = e[12], this[13] = e[13], this[14] = e[14], this[15] = e[15], this.check();
    }
    set(e, t, n, i, s, o, a, c, l, f, u, h, d, m, _, E) {
      return this[0] = e, this[1] = t, this[2] = n, this[3] = i, this[4] = s, this[5] = o, this[6] = a, this[7] = c, this[8] = l, this[9] = f, this[10] = u, this[11] = h, this[12] = d, this[13] = m, this[14] = _, this[15] = E, this.check();
    }
    setRowMajor(e, t, n, i, s, o, a, c, l, f, u, h, d, m, _, E) {
      return this[0] = e, this[1] = s, this[2] = l, this[3] = d, this[4] = t, this[5] = o, this[6] = f, this[7] = m, this[8] = n, this[9] = a, this[10] = u, this[11] = _, this[12] = i, this[13] = c, this[14] = h, this[15] = E, this.check();
    }
    toRowMajor(e) {
      return e[0] = this[0], e[1] = this[4], e[2] = this[8], e[3] = this[12], e[4] = this[1], e[5] = this[5], e[6] = this[9], e[7] = this[13], e[8] = this[2], e[9] = this[6], e[10] = this[10], e[11] = this[14], e[12] = this[3], e[13] = this[7], e[14] = this[11], e[15] = this[15], e;
    }
    identity() {
      return this.copy(Kp);
    }
    fromQuaternion(e) {
      return Hp(this, e), this.check();
    }
    frustum({ left: e, right: t, bottom: n, top: i, near: s, far: o }) {
      return o === 1 / 0 ? ce._computeInfinitePerspectiveOffCenter(this, e, t, n, i, s) : Xp(this, e, t, n, i, s, o), this.check();
    }
    static _computeInfinitePerspectiveOffCenter(e, t, n, i, s, o) {
      let a = 2 * o / (n - t), c = 2 * o / (s - i), l = (n + t) / (n - t), f = (s + i) / (s - i), u = -1, h = -1, d = -2 * o;
      return e[0] = a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = c, e[6] = 0, e[7] = 0, e[8] = l, e[9] = f, e[10] = u, e[11] = h, e[12] = 0, e[13] = 0, e[14] = d, e[15] = 0, e;
    }
    lookAt(e, t, n) {
      return arguments.length === 1 && ({ eye: e, center: t, up: n } = e), t = t || [0, 0, 0], n = n || [0, 1, 0], qp(this, e, t, n), this.check();
    }
    ortho({ left: e, right: t, bottom: n, top: i, near: s = 0.1, far: o = 500 }) {
      return Yp(this, e, t, n, i, s, o), this.check();
    }
    orthographic({ fovy: e = 45 * Math.PI / 180, aspect: t = 1, focalDistance: n = 1, near: i = 0.1, far: s = 500 }) {
      if (e > Math.PI * 2)
        throw Error("radians");
      let o = e / 2, a = n * Math.tan(o), c = a * t;
      return new ce().ortho({ left: -c, right: c, bottom: -a, top: a, near: i, far: s });
    }
    perspective({ fovy: e = void 0, fov: t = 45 * Math.PI / 180, aspect: n = 1, near: i = 0.1, far: s = 500 } = {}) {
      if (e = e || t, e > Math.PI * 2)
        throw Error("radians");
      return Yo(this, e, n, i, s), this.check();
    }
    determinant() {
      return Gp(this);
    }
    getScale(e = [-0, -0, -0]) {
      return e[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]), e[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]), e[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]), e;
    }
    getTranslation(e = [-0, -0, -0]) {
      return e[0] = this[12], e[1] = this[13], e[2] = this[14], e;
    }
    getRotation(e = [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], t = null) {
      let n = this.getScale(t || [-0, -0, -0]), i = 1 / n[0], s = 1 / n[1], o = 1 / n[2];
      return e[0] = this[0] * i, e[1] = this[1] * s, e[2] = this[2] * o, e[3] = 0, e[4] = this[4] * i, e[5] = this[5] * s, e[6] = this[6] * o, e[7] = 0, e[8] = this[8] * i, e[9] = this[9] * s, e[10] = this[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
    }
    getRotationMatrix3(e = [-0, -0, -0, -0, -0, -0, -0, -0, -0], t = null) {
      let n = this.getScale(t || [-0, -0, -0]), i = 1 / n[0], s = 1 / n[1], o = 1 / n[2];
      return e[0] = this[0] * i, e[1] = this[1] * s, e[2] = this[2] * o, e[3] = this[4] * i, e[4] = this[5] * s, e[5] = this[6] * o, e[6] = this[8] * i, e[7] = this[9] * s, e[8] = this[10] * o, e;
    }
    transpose() {
      return Vp(this, this), this.check();
    }
    invert() {
      return Qr(this, this), this.check();
    }
    multiplyLeft(e) {
      return Ve(this, e, this), this.check();
    }
    multiplyRight(e) {
      return Ve(this, this, e), this.check();
    }
    rotateX(e) {
      return Ho(this, this, e), this.check();
    }
    rotateY(e) {
      return jp(this, this, e), this.check();
    }
    rotateZ(e) {
      return Xo(this, this, e), this.check();
    }
    rotateXYZ([e, t, n]) {
      return this.rotateX(e).rotateY(t).rotateZ(n);
    }
    rotateAxis(e, t) {
      return zp(this, this, e, t), this.check();
    }
    scale(e) {
      return Array.isArray(e) ? rr(this, this, e) : rr(this, this, [e, e, e]), this.check();
    }
    translate(e) {
      return tr(this, this, e), this.check();
    }
    transform(e, t) {
      return e.length === 4 ? (t = Sr(t || [-0, -0, -0, -0], e, this), On(t, 4), t) : this.transformAsPoint(e, t);
    }
    transformAsPoint(e, t) {
      let { length: n } = e;
      switch (n) {
        case 2:
          t = xp(t || [-0, -0], e, this);
          break;
        case 3:
          t = jo(t || [-0, -0, -0], e, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      return On(t, e.length), t;
    }
    transformAsVector(e, t) {
      switch (e.length) {
        case 2:
          t = yp(t || [-0, -0], e, this);
          break;
        case 3:
          t = zo(t || [-0, -0, -0], e, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      return On(t, e.length), t;
    }
    makeRotationX(e) {
      return this.identity().rotateX(e);
    }
    makeTranslation(e, t, n) {
      return this.identity().translate([e, t, n]);
    }
    transformPoint(e, t) {
      return Ar("Matrix4.transformPoint", "3.0"), this.transformAsPoint(e, t);
    }
    transformVector(e, t) {
      return Ar("Matrix4.transformVector", "3.0"), this.transformAsPoint(e, t);
    }
    transformDirection(e, t) {
      return Ar("Matrix4.transformDirection", "3.0"), this.transformAsVector(e, t);
    }
  };
  var uf = { self: typeof self != "undefined" && self, window: typeof window != "undefined" && window, global: typeof global != "undefined" && global };
  var ZT = uf.global || uf.self || uf.window;
  ZT.mathgl = { config: ee };
  var hf = `#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))

struct AmbientLight {
 vec3 color;
};

struct PointLight {
 vec3 color;
 vec3 position;
 vec3 attenuation;
};

struct DirectionalLight {
  vec3 color;
  vec3 direction;
};

uniform AmbientLight lighting_uAmbientLight;
uniform PointLight lighting_uPointLight[MAX_LIGHTS];
uniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];
uniform int lighting_uPointLightCount;
uniform int lighting_uDirectionalLightCount;

uniform bool lighting_uEnabled;

float getPointLightAttenuation(PointLight pointLight, float distance) {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}

#endif
`;
  var KT = { lightSources: {} };
  function df({ color: r2 = [0, 0, 0], intensity: e = 1 } = {}) {
    return r2.map((t) => t * e / 255);
  }
  function QT({ ambientLight: r2, pointLights: e = [], directionalLights: t = [] }) {
    let n = {};
    return r2 ? n["lighting_uAmbientLight.color"] = df(r2) : n["lighting_uAmbientLight.color"] = [0, 0, 0], e.forEach((i, s) => {
      n["lighting_uPointLight[".concat(s, "].color")] = df(i), n["lighting_uPointLight[".concat(s, "].position")] = i.position, n["lighting_uPointLight[".concat(s, "].attenuation")] = i.attenuation || [1, 0, 0];
    }), n.lighting_uPointLightCount = e.length, t.forEach((i, s) => {
      n["lighting_uDirectionalLight[".concat(s, "].color")] = df(i), n["lighting_uDirectionalLight[".concat(s, "].direction")] = i.direction;
    }), n.lighting_uDirectionalLightCount = t.length, n;
  }
  function Qp(r2 = KT) {
    if ("lightSources" in r2) {
      let { ambientLight: e, pointLights: t, directionalLights: n } = r2.lightSources || {};
      return e || t && t.length > 0 || n && n.length > 0 ? Object.assign({}, QT({ ambientLight: e, pointLights: t, directionalLights: n }), { lighting_uEnabled: true }) : { lighting_uEnabled: false };
    }
    if ("lights" in r2) {
      let e = { pointLights: [], directionalLights: [] };
      for (let t of r2.lights || [])
        switch (t.type) {
          case "ambient":
            e.ambientLight = t;
            break;
          case "directional":
            e.directionalLights.push(t);
            break;
          case "point":
            e.pointLights.push(t);
            break;
          default:
        }
      return Qp({ lightSources: e });
    }
    return {};
  }
  var Jp = { name: "lights", vs: hf, fs: hf, getUniforms: Qp, defines: { MAX_LIGHTS: 3 } };
  var JT = new Uint8Array([0, 255, 255, 255]);
  var $T = { pickingSelectedColor: null, pickingHighlightColor: JT, pickingActive: false, pickingAttribute: false };
  function ev(r2 = $T) {
    let e = {};
    if (r2.pickingSelectedColor !== void 0)
      if (!r2.pickingSelectedColor)
        e.picking_uSelectedColorValid = 0;
      else {
        let t = r2.pickingSelectedColor.slice(0, 3);
        e.picking_uSelectedColorValid = 1, e.picking_uSelectedColor = t;
      }
    if (r2.pickingHighlightColor) {
      let t = Array.from(r2.pickingHighlightColor, (n) => n / 255);
      Number.isFinite(t[3]) || (t[3] = 1), e.picking_uHighlightColor = t;
    }
    return r2.pickingActive !== void 0 && (e.picking_uActive = Boolean(r2.pickingActive), e.picking_uAttribute = Boolean(r2.pickingAttribute)), e;
  }
  var tv = `uniform bool picking_uActive;
uniform bool picking_uAttribute;
uniform vec3 picking_uSelectedColor;
uniform bool picking_uSelectedColorValid;

out vec4 picking_vRGBcolor_Avalid;

const float COLOR_SCALE = 1. / 255.;

bool picking_isColorValid(vec3 color) {
  return dot(color, vec3(1.0)) > 0.001;
}

bool isVertexPicked(vec3 vertexColor) {
  return
    picking_uSelectedColorValid &&
    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));
}

void picking_setPickingColor(vec3 pickingColor) {
  if (picking_uActive) {
    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));

    if (!picking_uAttribute) {
      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;
    }
  } else {
    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));
  }
}

void picking_setPickingAttribute(float value) {
  if (picking_uAttribute) {
    picking_vRGBcolor_Avalid.r = value;
  }
}
void picking_setPickingAttribute(vec2 value) {
  if (picking_uAttribute) {
    picking_vRGBcolor_Avalid.rg = value;
  }
}
void picking_setPickingAttribute(vec3 value) {
  if (picking_uAttribute) {
    picking_vRGBcolor_Avalid.rgb = value;
  }
}
`;
  var rv = `uniform bool picking_uActive;
uniform vec3 picking_uSelectedColor;
uniform vec4 picking_uHighlightColor;

in vec4 picking_vRGBcolor_Avalid;
vec4 picking_filterHighlightColor(vec4 color) {
  if (picking_uActive) {
    return color;
  }
  bool selected = bool(picking_vRGBcolor_Avalid.a);

  if (selected) {
    float highLightAlpha = picking_uHighlightColor.a;
    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
    float highLightRatio = highLightAlpha / blendedAlpha;

    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);
    return vec4(blendedRGB, blendedAlpha);
  } else {
    return color;
  }
}
vec4 picking_filterPickingColor(vec4 color) {
  if (picking_uActive) {
    if (picking_vRGBcolor_Avalid.a == 0.0) {
      discard;
    }
    return picking_vRGBcolor_Avalid;
  }
  return color;
}
vec4 picking_filterColor(vec4 color) {
  vec4 highightColor = picking_filterHighlightColor(color);
  return picking_filterPickingColor(highightColor);
}

`;
  var qo = { name: "picking", vs: tv, fs: rv, getUniforms: ev };
  var $p = `
uniform float lighting_uAmbient;
uniform float lighting_uDiffuse;
uniform float lighting_uShininess;
uniform vec3  lighting_uSpecularColor;

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
    vec3 halfway_direction = normalize(light_direction + view_direction);
    float lambertian = dot(light_direction, normal_worldspace);
    float specular = 0.0;
    if (lambertian > 0.0) {
      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
      specular = pow(specular_angle, lighting_uShininess);
    }
    lambertian = max(lambertian, 0.0);
    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;
}

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = surfaceColor;

  if (lighting_uEnabled) {
    vec3 view_direction = normalize(cameraPosition - position_worldspace);
    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uPointLightCount) {
        break;
      }
      PointLight pointLight = lighting_uPointLight[i];
      vec3 light_position_worldspace = pointLight.position;
      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
    }

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uDirectionalLightCount) {
        break;
      }
      DirectionalLight directionalLight = lighting_uDirectionalLight[i];
      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
    }
  }
  return lightColor;
}

vec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = vec3(0, 0, 0);
  vec3 surfaceColor = vec3(0, 0, 0);

  if (lighting_uEnabled) {
    vec3 view_direction = normalize(cameraPosition - position_worldspace);

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uPointLightCount) {
        break;
      }
      PointLight pointLight = lighting_uPointLight[i];
      vec3 light_position_worldspace = pointLight.position;
      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
    }

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uDirectionalLightCount) {
        break;
      }
      DirectionalLight directionalLight = lighting_uDirectionalLight[i];
      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
    }
  }
  return lightColor;
}
`;
  var nv = {};
  function iv(r2) {
    let { ambient: e = 0.35, diffuse: t = 0.6, shininess: n = 32, specularColor: i = [30, 30, 30] } = r2;
    return { lighting_uAmbient: e, lighting_uDiffuse: t, lighting_uShininess: n, lighting_uSpecularColor: i.map((s) => s / 255) };
  }
  function sv(r2 = nv) {
    if (!("material" in r2))
      return {};
    let { material: e } = r2;
    return e ? iv(e) : { lighting_uEnabled: false };
  }
  var Un = { name: "gouraud-lighting", dependencies: [Jp], vs: $p, defines: { LIGHTING_VERTEX: 1 }, getUniforms: sv };
  var ov = `attribute float transform_elementID;
vec2 transform_getPixelSizeHalf(vec2 size) {
  return vec2(1.) / (2. * size);
}

vec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {
  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);
  float xIndex = transform_elementID - (yIndex * texSize[0]);
  return vec2(xIndex, yIndex);
}
vec2 transform_getTexCoord(vec2 size) {
  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);
  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);
  vec2 coord = indices / size + pixelSizeHalf;
  return coord;
}
vec2 transform_getPos(vec2 size) {
  vec2 texCoord = transform_getTexCoord(size);
  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);
  return pos;
}
vec4 transform_getInput(sampler2D texSampler, vec2 size) {
  vec2 texCoord = transform_getTexCoord(size);
  vec4 textureColor = texture2D(texSampler, texCoord);
  return textureColor;
}
`;
  var pf = { name: "transform", vs: ov, fs: null };
  var at = class {
    static getDefaultProgramManager(e) {
      return e.luma = e.luma || {}, e.luma.defaultProgramManager = e.luma.defaultProgramManager || new at(e), e.luma.defaultProgramManager;
    }
    constructor(e) {
      this.gl = e, this._programCache = {}, this._getUniforms = {}, this._registeredModules = {}, this._hookFunctions = [], this._defaultModules = [], this._hashes = {}, this._hashCounter = 0, this.stateHash = 0, this._useCounts = {};
    }
    addDefaultModule(e) {
      this._defaultModules.find((t) => t.name === e.name) || this._defaultModules.push(e), this.stateHash++;
    }
    removeDefaultModule(e) {
      let t = typeof e == "string" ? e : e.name;
      this._defaultModules = this._defaultModules.filter((n) => n.name !== t), this.stateHash++;
    }
    addShaderHook(e, t) {
      t && (e = Object.assign(t, { hook: e })), this._hookFunctions.push(e), this.stateHash++;
    }
    get(e = {}) {
      let { vs: t = "", fs: n = "", defines: i = {}, inject: s = {}, varyings: o = [], bufferMode: a = 35981, transpileToGLSL100: c = false } = e, l = this._getModuleList(e.modules), f = this._getHash(t), u = this._getHash(n), h = l.map((v) => this._getHash(v.name)).sort(), d = o.map((v) => this._getHash(v)), m = Object.keys(i).sort(), _ = Object.keys(s).sort(), E = [], b = [];
      for (let v of m)
        E.push(this._getHash(v)), E.push(this._getHash(i[v]));
      for (let v of _)
        b.push(this._getHash(v)), b.push(this._getHash(s[v]));
      let T = "".concat(f, "/").concat(u, "D").concat(E.join("/"), "M").concat(h.join("/"), "I").concat(b.join("/"), "V").concat(d.join("/"), "H").concat(this.stateHash, "B").concat(a).concat(c ? "T" : "");
      if (!this._programCache[T]) {
        let v = rf(this.gl, { vs: t, fs: n, modules: l, inject: s, defines: i, hookFunctions: this._hookFunctions, transpileToGLSL100: c });
        this._programCache[T] = new Er(this.gl, { hash: T, vs: v.vs, fs: v.fs, varyings: o, bufferMode: a }), this._getUniforms[T] = v.getUniforms || ((C) => {
        }), this._useCounts[T] = 0;
      }
      return this._useCounts[T]++, this._programCache[T];
    }
    getUniforms(e) {
      return this._getUniforms[e.hash] || null;
    }
    release(e) {
      let t = e.hash;
      this._useCounts[t]--, this._useCounts[t] === 0 && (this._programCache[t].delete(), delete this._programCache[t], delete this._getUniforms[t], delete this._useCounts[t]);
    }
    _getHash(e) {
      return this._hashes[e] === void 0 && (this._hashes[e] = this._hashCounter++), this._hashes[e];
    }
    _getModuleList(e = []) {
      let t = new Array(this._defaultModules.length + e.length), n = {}, i = 0;
      for (let s = 0, o = this._defaultModules.length; s < o; ++s) {
        let a = this._defaultModules[s], c = a.name;
        t[i++] = a, n[c] = true;
      }
      for (let s = 0, o = e.length; s < o; ++s) {
        let a = e[s], c = a.name;
        n[c] || (t[i++] = a, n[c] = true);
      }
      return t.length = i, t;
    }
  };
  var av = { POSITION: "positions", NORMAL: "normals", COLOR_0: "colors", TEXCOORD_0: "texCoords", TEXCOORD_1: "texCoords1", TEXCOORD_2: "texCoords2" };
  function em(r2, e, t) {
    let n = {}, i = e.indices;
    for (let s in e.attributes) {
      let o = e.attributes[s], a = cv(s, t);
      if (s === "indices")
        i = o;
      else if (o.constant)
        n[a] = o.value;
      else {
        let c = o.value, l = x({}, o);
        delete l.value, n[a] = [new k(r2, c), l], lv(s, l);
      }
    }
    if (i) {
      let s = i.value || i;
      w(s instanceof Uint16Array || s instanceof Uint32Array, 'attribute array for "indices" must be of integer type');
      let o = { size: 1, isIndexed: i.isIndexed === void 0 ? true : i.isIndexed };
      n.indices = [new k(r2, { data: s, target: 34963 }), o];
    }
    return n;
  }
  function cv(r2, e) {
    let { attributeMap: t = av } = e || {};
    return t && t[r2] || r2;
  }
  function lv(r2, e) {
    let t;
    switch (r2) {
      case "texCoords":
      case "texCoord1":
      case "texCoord2":
      case "texCoord3":
        t = "uvs";
        break;
      case "vertices":
      case "positions":
      case "normals":
      case "pickingColors":
        t = "vectors";
        break;
      default:
    }
    switch (t) {
      case "vectors":
        e.size = e.size || 3;
        break;
      case "uvs":
        e.size = e.size || 2;
        break;
      default:
    }
    w(Number.isFinite(e.size), "attribute ".concat(r2, " needs size"));
  }
  var kn = 2;
  var fv = 1e4;
  var uv = "Model needs drawMode and vertexCount";
  var tm = () => {
  };
  var hv = {};
  var xe = class {
    constructor(e, t = {}) {
      let { id: n = Pe("model") } = t;
      w(Zt(e)), this.id = n, this.gl = e, this.id = t.id || Pe("Model"), this.lastLogTime = 0, this.animated = false, this.initialize(t);
    }
    initialize(e) {
      this.props = {}, this.programManager = e.programManager || at.getDefaultProgramManager(this.gl), this._programManagerState = -1, this._managedProgram = false;
      let { program: t = null, vs: n, fs: i, modules: s, defines: o, inject: a, varyings: c, bufferMode: l, transpileToGLSL100: f } = e;
      this.programProps = { program: t, vs: n, fs: i, modules: s, defines: o, inject: a, varyings: c, bufferMode: l, transpileToGLSL100: f }, this.program = null, this.vertexArray = null, this._programDirty = true, this.userData = {}, this.needsRedraw = true, this._attributes = {}, this.attributes = {}, this.uniforms = {}, this.pickable = true, this._checkProgram(), this.setUniforms(Object.assign({}, this.getModuleUniforms(e.moduleSettings))), this.drawMode = e.drawMode !== void 0 ? e.drawMode : 4, this.vertexCount = e.vertexCount || 0, this.geometryBuffers = {}, this.isInstanced = e.isInstanced || e.instanced || e.instanceCount > 0, this._setModelProps(e), this.geometry = {}, w(this.drawMode !== void 0 && Number.isFinite(this.vertexCount), uv);
    }
    setProps(e) {
      this._setModelProps(e);
    }
    delete() {
      for (let e in this._attributes)
        this._attributes[e] !== this.attributes[e] && this._attributes[e].delete();
      this._managedProgram && (this.programManager.release(this.program), this._managedProgram = false), this.vertexArray.delete(), this._deleteGeometryBuffers();
    }
    getDrawMode() {
      return this.drawMode;
    }
    getVertexCount() {
      return this.vertexCount;
    }
    getInstanceCount() {
      return this.instanceCount;
    }
    getAttributes() {
      return this.attributes;
    }
    getProgram() {
      return this.program;
    }
    setProgram(e) {
      let { program: t, vs: n, fs: i, modules: s, defines: o, inject: a, varyings: c, bufferMode: l, transpileToGLSL100: f } = e;
      this.programProps = { program: t, vs: n, fs: i, modules: s, defines: o, inject: a, varyings: c, bufferMode: l, transpileToGLSL100: f }, this._programDirty = true;
    }
    getUniforms() {
      return this.uniforms;
    }
    setDrawMode(e) {
      return this.drawMode = e, this;
    }
    setVertexCount(e) {
      return w(Number.isFinite(e)), this.vertexCount = e, this;
    }
    setInstanceCount(e) {
      return w(Number.isFinite(e)), this.instanceCount = e, this;
    }
    setGeometry(e) {
      return this.drawMode = e.drawMode, this.vertexCount = e.getVertexCount(), this._deleteGeometryBuffers(), this.geometryBuffers = em(this.gl, e), this.vertexArray.setAttributes(this.geometryBuffers), this;
    }
    setAttributes(e = {}) {
      if (yt(e))
        return this;
      let t = {};
      for (let n in e) {
        let i = e[n];
        t[n] = i.getValue ? i.getValue() : i;
      }
      return this.vertexArray.setAttributes(t), this;
    }
    setUniforms(e = {}) {
      return Object.assign(this.uniforms, e), this;
    }
    getModuleUniforms(e) {
      this._checkProgram();
      let t = this.programManager.getUniforms(this.program);
      return t ? t(e) : {};
    }
    updateModuleSettings(e) {
      let t = this.getModuleUniforms(e || {});
      return this.setUniforms(t);
    }
    clear(e) {
      return gr(this.program.gl, e), this;
    }
    draw(e = {}) {
      this._checkProgram();
      let { moduleSettings: t = null, framebuffer: n, uniforms: i = {}, attributes: s = {}, transformFeedback: o = this.transformFeedback, parameters: a = {}, vertexArray: c = this.vertexArray } = e;
      this.setAttributes(s), this.updateModuleSettings(t), this.setUniforms(i);
      let l;
      I.priority >= kn && (l = this._logDrawCallStart(kn));
      let f = this.vertexArray.getDrawParams(), { isIndexed: u = f.isIndexed, indexType: h = f.indexType, indexOffset: d = f.indexOffset, vertexArrayInstanced: m = f.isInstanced } = this.props;
      m && !this.isInstanced && I.warn("Found instanced attributes on non-instanced model", this.id)();
      let { isInstanced: _, instanceCount: E } = this, { onBeforeRender: b = tm, onAfterRender: T = tm } = this.props;
      b(), this.program.setUniforms(this.uniforms);
      let v = this.program.draw(Object.assign(hv, e, { logPriority: l, uniforms: null, framebuffer: n, parameters: a, drawMode: this.getDrawMode(), vertexCount: this.getVertexCount(), vertexArray: c, transformFeedback: o, isIndexed: u, indexType: h, isInstanced: _, instanceCount: E, offset: u ? d : 0 }));
      return T(), I.priority >= kn && this._logDrawCallEnd(l, c, n), v;
    }
    transform(e = {}) {
      let { discard: t = true, feedbackBuffers: n, unbindModels: i = [] } = e, { parameters: s } = e;
      n && this._setFeedbackBuffers(n), t && (s = Object.assign({}, s, { [35977]: t })), i.forEach((o) => o.vertexArray.unbindBuffers());
      try {
        this.draw(Object.assign({}, e, { parameters: s }));
      } finally {
        i.forEach((o) => o.vertexArray.bindBuffers());
      }
      return this;
    }
    render(e = {}) {
      return I.warn("Model.render() is deprecated. Use Model.setUniforms() and Model.draw()")(), this.setUniforms(e).draw();
    }
    _setModelProps(e) {
      Object.assign(this.props, e), "uniforms" in e && this.setUniforms(e.uniforms), "pickable" in e && (this.pickable = e.pickable), "instanceCount" in e && (this.instanceCount = e.instanceCount), "geometry" in e && this.setGeometry(e.geometry), "attributes" in e && this.setAttributes(e.attributes), "_feedbackBuffers" in e && this._setFeedbackBuffers(e._feedbackBuffers);
    }
    _checkProgram() {
      if (!(this._programDirty || this.programManager.stateHash !== this._programManagerState))
        return;
      let { program: t } = this.programProps;
      if (t)
        this._managedProgram = false;
      else {
        let { vs: n, fs: i, modules: s, inject: o, defines: a, varyings: c, bufferMode: l, transpileToGLSL100: f } = this.programProps;
        t = this.programManager.get({ vs: n, fs: i, modules: s, inject: o, defines: a, varyings: c, bufferMode: l, transpileToGLSL100: f }), this.program && this._managedProgram && this.programManager.release(this.program), this._programManagerState = this.programManager.stateHash, this._managedProgram = true;
      }
      w(t instanceof Er, "Model needs a program"), this._programDirty = false, t !== this.program && (this.program = t, this.vertexArray ? this.vertexArray.setProps({ program: this.program, attributes: this.vertexArray.attributes }) : this.vertexArray = new Yi(this.gl, { program: this.program }), this.setUniforms(Object.assign({}, this.getModuleUniforms())));
    }
    _deleteGeometryBuffers() {
      for (let e in this.geometryBuffers) {
        let t = this.geometryBuffers[e][0] || this.geometryBuffers[e];
        t instanceof k && t.delete();
      }
    }
    _setAnimationProps(e) {
      this.animated && w(e, "Model.draw(): animated uniforms but no animationProps");
    }
    _setFeedbackBuffers(e = {}) {
      if (yt(e))
        return this;
      let { gl: t } = this.program;
      return this.transformFeedback = this.transformFeedback || new Tr(t, { program: this.program }), this.transformFeedback.setBuffers(e), this;
    }
    _logDrawCallStart(e) {
      let t = e > 3 ? 0 : fv;
      if (!(Date.now() - this.lastLogTime < t))
        return this.lastLogTime = Date.now(), I.group(kn, ">>> DRAWING MODEL ".concat(this.id), { collapsed: I.level <= 2 })(), e;
    }
    _logDrawCallEnd(e, t, n, i) {
      if (e === void 0)
        return;
      let s = Hl({ vertexArray: t, header: "".concat(this.id, " attributes"), attributes: this._attributes }), { table: o, unusedTable: a, unusedCount: c } = No({ header: "".concat(this.id, " uniforms"), program: this.program, uniforms: Object.assign({}, this.program.uniforms, n) }), { table: l, count: f } = No({ header: "".concat(this.id, " uniforms"), program: this.program, uniforms: Object.assign({}, this.program.uniforms, n), undefinedOnly: true });
      f > 0 && I.log("MISSING UNIFORMS", Object.keys(l))(), c > 0 && I.log("UNUSED UNIFORMS", Object.keys(a))();
      let u = Xl(this.vertexArray.configuration);
      I.table(e, s)(), I.table(e, o)(), I.table(e + 1, u)(), i && i.log({ logLevel: kn, message: "Rendered to ".concat(i.id) }), I.groupEnd(kn, ">>> DRAWING MODEL ".concat(this.id))();
    }
  };
  var Zo = class {
    constructor(e, t = {}) {
      this.gl = e, this.currentIndex = 0, this.feedbackMap = {}, this.varyings = null, this.bindings = [], this.resources = {}, this._initialize(t), Object.seal(this);
    }
    setupResources(e) {
      for (let t of this.bindings)
        this._setupTransformFeedback(t, e);
    }
    updateModelProps(e = {}) {
      let { varyings: t } = this;
      return t.length > 0 && (e = Object.assign({}, e, { varyings: t })), e;
    }
    getDrawOptions(e = {}) {
      let t = this.bindings[this.currentIndex], { sourceBuffers: n, transformFeedback: i } = t;
      return { attributes: Object.assign({}, n, e.attributes), transformFeedback: i };
    }
    swap() {
      return this.feedbackMap ? (this.currentIndex = this._getNextIndex(), true) : false;
    }
    update(e = {}) {
      this._setupBuffers(e);
    }
    getBuffer(e) {
      let { feedbackBuffers: t } = this.bindings[this.currentIndex], n = e ? t[e] : null;
      return n ? n instanceof k ? n : n.buffer : null;
    }
    getData(e = {}) {
      let { varyingName: t } = e, n = this.getBuffer(t);
      return n ? n.getData() : null;
    }
    delete() {
      for (let e in this.resources)
        this.resources[e].delete();
    }
    _initialize(e = {}) {
      this._setupBuffers(e), this.varyings = e.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers), this.varyings.length > 0 && w(U(this.gl));
    }
    _getFeedbackBuffers(e) {
      let { sourceBuffers: t = {} } = e, n = {};
      if (this.bindings[this.currentIndex] && Object.assign(n, this.bindings[this.currentIndex].feedbackBuffers), this.feedbackMap)
        for (let i in this.feedbackMap) {
          let s = this.feedbackMap[i];
          i in t && (n[s] = i);
        }
      Object.assign(n, e.feedbackBuffers);
      for (let i in n) {
        let s = n[i];
        if (typeof s == "string") {
          let o = t[s], { byteLength: a, usage: c, accessor: l } = o;
          n[i] = this._createNewBuffer(i, { byteLength: a, usage: c, accessor: l });
        }
      }
      return n;
    }
    _setupBuffers(e = {}) {
      let { sourceBuffers: t = null } = e;
      Object.assign(this.feedbackMap, e.feedbackMap);
      let n = this._getFeedbackBuffers(e);
      this._updateBindings({ sourceBuffers: t, feedbackBuffers: n });
    }
    _setupTransformFeedback(e, { model: t }) {
      let { program: n } = t;
      e.transformFeedback = new Tr(this.gl, { program: n, buffers: e.feedbackBuffers });
    }
    _updateBindings(e) {
      if (this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], e), this.feedbackMap) {
        let { sourceBuffers: t, feedbackBuffers: n } = this._swapBuffers(this.bindings[this.currentIndex]), i = this._getNextIndex();
        this.bindings[i] = this._updateBinding(this.bindings[i], { sourceBuffers: t, feedbackBuffers: n });
      }
    }
    _updateBinding(e, t) {
      return e ? (Object.assign(e.sourceBuffers, t.sourceBuffers), Object.assign(e.feedbackBuffers, t.feedbackBuffers), e.transformFeedback && e.transformFeedback.setBuffers(e.feedbackBuffers), e) : { sourceBuffers: Object.assign({}, t.sourceBuffers), feedbackBuffers: Object.assign({}, t.feedbackBuffers) };
    }
    _swapBuffers(e) {
      if (!this.feedbackMap)
        return null;
      let t = Object.assign({}, e.sourceBuffers), n = Object.assign({}, e.feedbackBuffers);
      for (let i in this.feedbackMap) {
        let s = this.feedbackMap[i];
        t[i] = e.feedbackBuffers[s], n[s] = e.sourceBuffers[i], w(n[s] instanceof k);
      }
      return { sourceBuffers: t, feedbackBuffers: n };
    }
    _createNewBuffer(e, t) {
      let n = new k(this.gl, t);
      return this.resources[e] && this.resources[e].delete(), this.resources[e] = n, n;
    }
    _getNextIndex() {
      return (this.currentIndex + 1) % 2;
    }
  };
  var dv = "transform_uSampler_";
  var Ko = "transform_uSize_";
  var rm = "transform_position";
  function nm({ vs: r2, sourceTextureMap: e, targetTextureVarying: t, targetTexture: n }) {
    let s = Object.keys(e).length, o = null, a = {}, c = r2, l = {};
    if (s > 0 || t) {
      let f = c.split(`
`), u = f.slice();
      if (f.forEach((h, d, m) => {
        if (s > 0) {
          let _ = _v(h, e);
          if (_) {
            let { updatedLine: E, inject: b } = _;
            u[d] = E, l = Cn([l, b]), Object.assign(a, _.samplerTextureMap), s--;
          }
        }
        t && !o && (o = gv(h, t));
      }), t) {
        w(n);
        let h = "".concat(Ko).concat(t), d = "uniform vec2 ".concat(h, `;
`), m = "     vec2 ".concat(rm, " = transform_getPos(").concat(h, `);
     gl_Position = vec4(`).concat(rm, `, 0, 1.);
`);
        l = Cn([l, { "vs:#decl": d, "vs:#main-start": m }]);
      }
      c = u.join(`
`);
    }
    return { vs: c, targetTextureType: o, inject: l, samplerTextureMap: a };
  }
  function im({ sourceTextureMap: r2, targetTextureVarying: e, targetTexture: t }) {
    let n = {}, i, s;
    e && ({ width: i, height: s } = t, n["".concat(Ko).concat(e)] = [i, s]);
    for (let o in r2)
      ({ width: i, height: s } = r2[o]), n["".concat(Ko).concat(o)] = [i, s];
    return n;
  }
  function pv(r2) {
    return Bo(r2, ["attribute", "in"]);
  }
  function mv(r2) {
    let e = "".concat(dv).concat(r2), t = "".concat(Ko).concat(r2), n = "  uniform sampler2D ".concat(e, `;
  uniform vec2 `).concat(t, ";");
    return { samplerName: e, sizeName: t, uniformDeclerations: n };
  }
  function gv(r2, e) {
    let t = Bo(r2, ["varying", "out"]);
    return t && t.name === e ? t.type : null;
  }
  function _v(r2, e) {
    let t = {}, n = pv(r2);
    if (!n)
      return null;
    let { type: i, name: s } = n;
    if (s && e[s]) {
      let o = "// ".concat(r2, " => Replaced by Transform with a sampler"), { samplerName: a, sizeName: c, uniformDeclerations: l } = mv(s), f = nf(i), u = "  ".concat(i, " ").concat(s, " = transform_getInput(").concat(a, ", ").concat(c, ").").concat(f, `;
`);
      return t[a] = s, { updatedLine: o, inject: { "vs:#decl": l, "vs:#main-start": u }, samplerTextureMap: t };
    }
    return null;
  }
  var xv = { [10241]: 9728, [10240]: 9728, [10242]: 33071, [10243]: 33071 };
  var yv = "transform_output";
  var Qo = class {
    constructor(e, t = {}) {
      this.gl = e, this.id = this.currentIndex = 0, this._swapTexture = null, this.targetTextureVarying = null, this.targetTextureType = null, this.samplerTextureMap = null, this.bindings = [], this.resources = {}, this._initialize(t), Object.seal(this);
    }
    updateModelProps(e = {}) {
      let t = this._processVertexShader(e);
      return Object.assign({}, e, t);
    }
    getDrawOptions(e = {}) {
      let { sourceBuffers: t, sourceTextures: n, framebuffer: i, targetTexture: s } = this.bindings[this.currentIndex], o = Object.assign({}, t, e.attributes), a = Object.assign({}, e.uniforms), c = Object.assign({}, e.parameters), l = e.discard;
      if (this.hasSourceTextures || this.hasTargetTexture) {
        o.transform_elementID = this.elementIDBuffer;
        for (let u in this.samplerTextureMap) {
          let h = this.samplerTextureMap[u];
          a[u] = n[h];
        }
        this._setSourceTextureParameters();
        let f = im({ sourceTextureMap: n, targetTextureVarying: this.targetTextureVarying, targetTexture: s });
        Object.assign(a, f);
      }
      return this.hasTargetTexture && (l = false, c.viewport = [0, 0, i.width, i.height]), { attributes: o, framebuffer: i, uniforms: a, discard: l, parameters: c };
    }
    swap() {
      return this._swapTexture ? (this.currentIndex = this._getNextIndex(), true) : false;
    }
    update(e = {}) {
      this._setupTextures(e);
    }
    getTargetTexture() {
      let { targetTexture: e } = this.bindings[this.currentIndex];
      return e;
    }
    getData({ packed: e = false } = {}) {
      let { framebuffer: t } = this.bindings[this.currentIndex], n = Jt(t);
      if (!e)
        return n;
      let i = n.constructor, s = sf(this.targetTextureType), o = new i(n.length * s / 4), a = 0;
      for (let c = 0; c < n.length; c += 4)
        for (let l = 0; l < s; l++)
          o[a++] = n[c + l];
      return o;
    }
    getFramebuffer() {
      return this.bindings[this.currentIndex].framebuffer;
    }
    delete() {
      this.ownTexture && this.ownTexture.delete(), this.elementIDBuffer && this.elementIDBuffer.delete();
    }
    _initialize(e = {}) {
      let { _targetTextureVarying: t, _swapTexture: n } = e;
      this._swapTexture = n, this.targetTextureVarying = t, this.hasTargetTexture = t, this._setupTextures(e);
    }
    _createTargetTexture(e) {
      let { sourceTextures: t, textureOrReference: n } = e;
      if (n instanceof Q)
        return n;
      let i = t[n];
      return i ? (this._targetRefTexName = n, this._createNewTexture(i)) : null;
    }
    _setupTextures(e = {}) {
      let { sourceBuffers: t, _sourceTextures: n = {}, _targetTexture: i } = e, s = this._createTargetTexture({ sourceTextures: n, textureOrReference: i });
      this.hasSourceTextures = this.hasSourceTextures || n && Object.keys(n).length > 0, this._updateBindings({ sourceBuffers: t, sourceTextures: n, targetTexture: s }), "elementCount" in e && this._updateElementIDBuffer(e.elementCount);
    }
    _updateElementIDBuffer(e) {
      if (typeof e != "number" || this.elementCount >= e)
        return;
      let t = new Float32Array(e);
      t.forEach((n, i, s) => {
        s[i] = i;
      }), this.elementIDBuffer ? this.elementIDBuffer.setData({ data: t }) : this.elementIDBuffer = new k(this.gl, { data: t, accessor: { size: 1 } }), this.elementCount = e;
    }
    _updateBindings(e) {
      if (this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], e), this._swapTexture) {
        let { sourceTextures: t, targetTexture: n } = this._swapTextures(this.bindings[this.currentIndex]), i = this._getNextIndex();
        this.bindings[i] = this._updateBinding(this.bindings[i], { sourceTextures: t, targetTexture: n });
      }
    }
    _updateBinding(e, t) {
      let { sourceBuffers: n, sourceTextures: i, targetTexture: s } = t;
      if (e || (e = { sourceBuffers: {}, sourceTextures: {}, targetTexture: null }), Object.assign(e.sourceTextures, i), Object.assign(e.sourceBuffers, n), s) {
        e.targetTexture = s;
        let { width: o, height: a } = s, { framebuffer: c } = e;
        c ? (c.update({ attachments: { [36064]: s }, resizeAttachments: false }), c.resize({ width: o, height: a })) : e.framebuffer = new Z(this.gl, { id: "transform-framebuffer", width: o, height: a, attachments: { [36064]: s } });
      }
      return e;
    }
    _setSourceTextureParameters() {
      let e = this.currentIndex, { sourceTextures: t } = this.bindings[e];
      for (let n in t)
        t[n].setParameters(xv);
    }
    _swapTextures(e) {
      if (!this._swapTexture)
        return null;
      let t = Object.assign({}, e.sourceTextures);
      t[this._swapTexture] = e.targetTexture;
      let n = e.sourceTextures[this._swapTexture];
      return { sourceTextures: t, targetTexture: n };
    }
    _createNewTexture(e) {
      let t = Sn(e, { parameters: { [10241]: 9728, [10240]: 9728, [10242]: 33071, [10243]: 33071 }, pixelStore: { [37440]: false } });
      return this.ownTexture && this.ownTexture.delete(), this.ownTexture = t, t;
    }
    _getNextIndex() {
      return (this.currentIndex + 1) % 2;
    }
    _processVertexShader(e = {}) {
      let { sourceTextures: t, targetTexture: n } = this.bindings[this.currentIndex], { vs: i, uniforms: s, targetTextureType: o, inject: a, samplerTextureMap: c } = nm({ vs: e.vs, sourceTextureMap: t, targetTextureVarying: this.targetTextureVarying, targetTexture: n }), l = Cn([e.inject || {}, a]);
      this.targetTextureType = o, this.samplerTextureMap = c;
      let f = e._fs || Ji({ version: wn(i), input: this.targetTextureVarying, inputType: o, output: yv }), u = this.hasSourceTextures || this.targetTextureVarying ? [pf].concat(e.modules || []) : e.modules;
      return { vs: i, fs: f, modules: u, uniforms: s, inject: l };
    }
  };
  var kt = class {
    static isSupported(e) {
      return U(e);
    }
    constructor(e, t = {}) {
      this.gl = e, this.model = null, this.elementCount = 0, this.bufferTransform = null, this.textureTransform = null, this.elementIDBuffer = null, this._initialize(t), Object.seal(this);
    }
    delete() {
      let { model: e, bufferTransform: t, textureTransform: n } = this;
      e && e.delete(), t && t.delete(), n && n.delete();
    }
    run(e = {}) {
      let { clearRenderTarget: t = true } = e, n = this._updateDrawOptions(e);
      t && n.framebuffer && n.framebuffer.clear({ color: true }), this.model.transform(n);
    }
    swap() {
      let e = false, t = [this.bufferTransform, this.textureTransform].filter(Boolean);
      for (let n of t)
        e = e || n.swap();
      w(e, "Nothing to swap");
    }
    getBuffer(e = null) {
      return this.bufferTransform && this.bufferTransform.getBuffer(e);
    }
    getData(e = {}) {
      let t = [this.bufferTransform, this.textureTransform].filter(Boolean);
      for (let n of t) {
        let i = n.getData(e);
        if (i)
          return i;
      }
      return null;
    }
    getFramebuffer() {
      return this.textureTransform && this.textureTransform.getFramebuffer();
    }
    update(e = {}) {
      "elementCount" in e && this.model.setVertexCount(e.elementCount);
      let t = [this.bufferTransform, this.textureTransform].filter(Boolean);
      for (let n of t)
        n.update(e);
    }
    _initialize(e = {}) {
      let { gl: t } = this;
      this._buildResourceTransforms(t, e), e = this._updateModelProps(e), this.model = new xe(t, Object.assign({}, e, { fs: e.fs || Ji({ version: wn(e.vs) }), id: e.id || "transform-model", drawMode: e.drawMode || 0, vertexCount: e.elementCount })), this.bufferTransform && this.bufferTransform.setupResources({ model: this.model });
    }
    _updateModelProps(e) {
      let t = Object.assign({}, e), n = [this.bufferTransform, this.textureTransform].filter(Boolean);
      for (let i of n)
        t = i.updateModelProps(t);
      return t;
    }
    _buildResourceTransforms(e, t) {
      Ev(t) && (this.bufferTransform = new Zo(e, t)), bv(t) && (this.textureTransform = new Qo(e, t)), w(this.bufferTransform || this.textureTransform, "must provide source/feedback buffers or source/target textures");
    }
    _updateDrawOptions(e) {
      let t = Object.assign({}, e), n = [this.bufferTransform, this.textureTransform].filter(Boolean);
      for (let i of n)
        t = Object.assign(t, i.getDrawOptions(t));
      return t;
    }
  };
  function Ev(r2) {
    return !!(!yt(r2.feedbackBuffers) || !yt(r2.feedbackMap) || r2.varyings && r2.varyings.length > 0);
  }
  function bv(r2) {
    return !!(!yt(r2._sourceTextures) || r2._targetTexture || r2._targetTextureVarying);
  }
  var sm = { POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6 };
  var Me = class {
    static get DRAW_MODE() {
      return sm;
    }
    constructor(e = {}) {
      let { id: t = Pe("geometry"), drawMode: n = sm.TRIANGLES, attributes: i = {}, indices: s = null, vertexCount: o = null } = e;
      this.id = t, this.drawMode = n | 0, this.attributes = {}, this.userData = {}, this._setAttributes(i, s), this.vertexCount = o || this._calculateVertexCount(this.attributes, this.indices);
    }
    get mode() {
      return this.drawMode;
    }
    getVertexCount() {
      return this.vertexCount;
    }
    getAttributes() {
      return this.indices ? x({ indices: this.indices }, this.attributes) : this.attributes;
    }
    _print(e) {
      return "Geometry ".concat(this.id, " attribute ").concat(e);
    }
    _setAttributes(e, t) {
      t && (this.indices = ArrayBuffer.isView(t) ? { value: t, size: 1 } : t);
      for (let n in e) {
        let i = e[n];
        i = ArrayBuffer.isView(i) ? { value: i } : i, w(ArrayBuffer.isView(i.value), "".concat(this._print(n), ": must be typed array or object with value as typed array")), (n === "POSITION" || n === "positions") && !i.size && (i.size = 3), n === "indices" ? (w(!this.indices), this.indices = i) : this.attributes[n] = i;
      }
      return this.indices && this.indices.isIndexed !== void 0 && (this.indices = Object.assign({}, this.indices), delete this.indices.isIndexed), this;
    }
    _calculateVertexCount(e, t) {
      if (t)
        return t.value.length;
      let n = 1 / 0;
      for (let i in e) {
        let s = e[i], { value: o, size: a, constant: c } = s;
        !c && o && a >= 1 && (n = Math.min(n, o.length / a));
      }
      return w(Number.isFinite(n)), n;
    }
  };
  var Tv = 1;
  var vv = 1;
  var Jr = class {
    constructor() {
      this.time = 0, this.channels = new Map(), this.animations = new Map(), this.playing = false, this.lastEngineTime = -1;
    }
    addChannel(e) {
      let { delay: t = 0, duration: n = Number.POSITIVE_INFINITY, rate: i = 1, repeat: s = 1 } = e, o = Tv++, a = { time: 0, delay: t, duration: n, rate: i, repeat: s };
      return this._setChannelTime(a, this.time), this.channels.set(o, a), o;
    }
    removeChannel(e) {
      this.channels.delete(e);
      for (let [t, n] of this.animations)
        n.channel === e && this.detachAnimation(t);
    }
    isFinished(e) {
      let t = this.channels.get(e);
      return t === void 0 ? false : this.time >= t.delay + t.duration * t.repeat;
    }
    getTime(e) {
      if (e === void 0)
        return this.time;
      let t = this.channels.get(e);
      return t === void 0 ? -1 : t.time;
    }
    setTime(e) {
      this.time = Math.max(0, e);
      let t = this.channels.values();
      for (let i of t)
        this._setChannelTime(i, this.time);
      let n = this.animations.values();
      for (let i of n) {
        let { animation: s, channel: o } = i;
        s.setTime(this.getTime(o));
      }
    }
    play() {
      this.playing = true;
    }
    pause() {
      this.playing = false, this.lastEngineTime = -1;
    }
    reset() {
      this.setTime(0);
    }
    attachAnimation(e, t) {
      let n = vv++;
      return this.animations.set(n, { animation: e, channel: t }), e.setTime(this.getTime(t)), n;
    }
    detachAnimation(e) {
      this.animations.delete(e);
    }
    update(e) {
      this.playing && (this.lastEngineTime === -1 && (this.lastEngineTime = e), this.setTime(this.time + (e - this.lastEngineTime)), this.lastEngineTime = e);
    }
    _setChannelTime(e, t) {
      let n = t - e.delay, i = e.duration * e.repeat;
      n >= i ? e.time = e.duration * e.rate : (e.time = Math.max(0, n) % e.duration, e.time *= e.rate);
    }
  };
  var Av = `
struct VertexGeometry {
  vec4 position;
  vec3 worldPosition;
  vec3 worldPositionAlt;
  vec3 normal;
  vec2 uv;
  vec3 pickingColor;
} geometry;
`;
  var Sv = `
#define SMOOTH_EDGE_RADIUS 0.5

struct FragmentGeometry {
  vec2 uv;
} geometry;

float smoothedge(float edge, float x) {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`;
  var om = { name: "geometry", vs: Av, fs: Sv };
  var j = { DEFAULT: -1, LNGLAT: 1, METER_OFFSETS: 2, LNGLAT_OFFSETS: 3, CARTESIAN: 0 };
  Object.defineProperty(j, "IDENTITY", { get: () => F.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")() || 0 });
  var Ge = { WEB_MERCATOR: 1, GLOBE: 2, WEB_MERCATOR_AUTO_OFFSET: 4, IDENTITY: 0 };
  var gf = { click: { handler: "onClick" }, panstart: { handler: "onDragStart" }, panmove: { handler: "onDrag" }, panend: { handler: "onDragEnd" } };
  var wv = Object.keys(j).map((r2) => "const int COORDINATE_SYSTEM_".concat(r2, " = ").concat(j[r2], ";")).join("");
  var Pv = Object.keys(Ge).map((r2) => "const int PROJECTION_MODE_".concat(r2, " = ").concat(Ge[r2], ";")).join("");
  var am = "".concat(wv, `
`).concat(Pv, `

uniform int project_uCoordinateSystem;
uniform int project_uProjectionMode;
uniform float project_uScale;
uniform bool project_uWrapLongitude;
uniform vec3 project_uCommonUnitsPerMeter;
uniform vec3 project_uCommonUnitsPerWorldUnit;
uniform vec3 project_uCommonUnitsPerWorldUnit2;
uniform vec4 project_uCenter;
uniform mat4 project_uModelMatrix;
uniform mat4 project_uViewProjectionMatrix;
uniform vec2 project_uViewportSize;
uniform float project_uDevicePixelRatio;
uniform float project_uFocalDistance;
uniform vec3 project_uCameraPosition;
uniform vec3 project_uCoordinateOrigin;

const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / (PI * 2.0);
const vec3 ZERO_64_LOW = vec3(0.0);
const float EARTH_RADIUS = 6370972.0;
const float GLOBE_RADIUS = 256.0;
float project_size(float meters) {
  return meters * project_uCommonUnitsPerMeter.z;
}

vec2 project_size(vec2 meters) {
  return meters * project_uCommonUnitsPerMeter.xy;
}

vec3 project_size(vec3 meters) {
  return meters * project_uCommonUnitsPerMeter;
}

vec4 project_size(vec4 meters) {
  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);
}
vec3 project_normal(vec3 vector) {
  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);
  return normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);
}

vec4 project_offset_(vec4 offset) {
  float dy = offset.y;
  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
    dy = clamp(dy, -1., 1.);
  }
  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;
  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}
vec2 project_mercator_(vec2 lnglat) {
  float x = lnglat.x;
  if (project_uWrapLongitude) {
    x = mod(x + 180., 360.0) - 180.;
  }
  float y = clamp(lnglat.y, -89.9, 89.9);
  return vec2(
    radians(x) + PI,
    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))
  );
}

vec3 project_globe_(vec3 lnglatz) {
  float lambda = radians(lnglatz.x);
  float phi = radians(lnglatz.y);
  float cosPhi = cos(phi);
  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;

  return vec3(
    sin(lambda) * cosPhi,
    -cos(lambda) * cosPhi,
    sin(phi)
  ) * D;
}
vec4 project_position(vec4 position, vec3 position64Low) {
  vec4 position_world = project_uModelMatrix * position;
  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4(
        project_mercator_(position_world.xy) * WORLD_SCALE,
        project_size(position_world.z),
        position_world.w
      );
    }
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
      position_world.xyz += project_uCoordinateOrigin;
    }
  }
  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4(
        project_globe_(position_world.xyz),
        position_world.w
      );
    }
  }
  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||
    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
    position_world.xyz -= project_uCoordinateOrigin;
  }
  return project_offset_(position_world + project_uModelMatrix * vec4(position64Low, 0.0));
}

vec4 project_position(vec4 position) {
  return project_position(position, ZERO_64_LOW);
}

vec3 project_position(vec3 position, vec3 position64Low) {
  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);
  return projected_position.xyz;
}

vec3 project_position(vec3 position) {
  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);
  return projected_position.xyz;
}

vec2 project_position(vec2 position) {
  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);
  return projected_position.xy;
}

vec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {
  return viewProjectionMatrix * position + center;
}
vec4 project_common_position_to_clipspace(vec4 position) {
  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);
}
vec2 project_pixel_size_to_clipspace(vec2 pixels) {
  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;
  return offset * project_uFocalDistance;
}

float project_size_to_pixel(float meters) {
  return project_size(meters) * project_uScale;
}
float project_pixel_size(float pixels) {
  return pixels / project_uScale;
}
vec2 project_pixel_size(vec2 pixels) {
  return pixels / project_uScale;
}
mat3 project_get_orientation_matrix(vec3 up) {
  vec3 uz = normalize(up);
  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));
  vec3 uy = cross(uz, ux);
  return mat3(ux, uy, uz);
}

bool project_needs_rotation(vec3 commonPosition, out mat3 transform) {
  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {
    transform = project_get_orientation_matrix(commonPosition);
    return true;
  }
  return false;
}
`);
  function Lv(r2, e) {
    if (r2 === e)
      return true;
    if (Array.isArray(r2)) {
      let t = r2.length;
      if (!e || e.length !== t)
        return false;
      for (let n = 0; n < t; n++)
        if (r2[n] !== e[n])
          return false;
      return true;
    }
    return false;
  }
  function wr(r2) {
    let e = {}, t;
    return (n) => {
      for (let i in n)
        if (!Lv(n[i], e[i])) {
          t = r2(n), e = n;
          break;
        }
      return t;
    };
  }
  var Cv = [0, 0, 0, 0];
  var Rv = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
  var Mv = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  var Iv = [0, 0, 0];
  var Ov = [0, 0, 0];
  var Nv = wr(Dv);
  function _f(r2, e, t = Ov) {
    let n = t, i, s = true;
    switch (e === j.LNGLAT_OFFSETS || e === j.METER_OFFSETS ? i = t : i = r2.isGeospatial ? [Math.fround(r2.longitude), Math.fround(r2.latitude), 0] : null, r2.projectionMode) {
      case Ge.WEB_MERCATOR:
        (e === j.LNGLAT || e === j.CARTESIAN) && (s = false);
        break;
      case Ge.WEB_MERCATOR_AUTO_OFFSET:
        e === j.LNGLAT ? n = i : e === j.CARTESIAN && (n = [Math.fround(r2.center[0]), Math.fround(r2.center[1]), 0], i = r2.unprojectPosition(n), n[0] -= t[0], n[1] -= t[1], n[2] -= t[2]);
        break;
      case Ge.IDENTITY:
        n = r2.position.map(Math.fround);
        break;
      case Ge.GLOBE:
        s = false, i = null;
        break;
      default:
        s = false;
    }
    return n[2] = n[2] || 0, { geospatialOrigin: i, shaderCoordinateOrigin: n, offsetMode: s };
  }
  function Fv(r2, e, t) {
    let { viewMatrixUncentered: n, projectionMatrix: i } = r2, { viewMatrix: s, viewProjectionMatrix: o } = r2, a = Cv, c = r2.cameraPosition, { geospatialOrigin: l, shaderCoordinateOrigin: f, offsetMode: u } = _f(r2, e, t);
    if (u) {
      let h = r2.projectPosition(l || f);
      c = [c[0] - h[0], c[1] - h[1], c[2] - h[2]], h[3] = 1, a = Sr([], h, o), s = n || s, o = Ve([], i, s), o = Ve([], o, Rv);
    }
    return { viewMatrix: s, viewProjectionMatrix: o, projectionCenter: a, cameraPosCommon: c, shaderCoordinateOrigin: f, geospatialOrigin: l };
  }
  function cm({ viewport: r2, devicePixelRatio: e = 1, modelMatrix: t = null, coordinateSystem: n = j.DEFAULT, coordinateOrigin: i, autoWrapLongitude: s = false } = {}) {
    n === j.DEFAULT && (n = r2.isGeospatial ? j.LNGLAT : j.CARTESIAN);
    let o = Nv({ viewport: r2, devicePixelRatio: e, coordinateSystem: n, coordinateOrigin: i });
    return o.project_uWrapLongitude = s, o.project_uModelMatrix = t || Mv, o;
  }
  function Dv({ viewport: r2, devicePixelRatio: e, coordinateSystem: t, coordinateOrigin: n }) {
    let { projectionCenter: i, viewProjectionMatrix: s, cameraPosCommon: o, shaderCoordinateOrigin: a, geospatialOrigin: c } = Fv(r2, t, n), l = r2.getDistanceScales(), f = [r2.width * e, r2.height * e], u = r2.projectionMatrix.transform([0, 0, -r2.focalDistance, 1])[3] || 1, h = { project_uCoordinateSystem: t, project_uProjectionMode: r2.projectionMode, project_uCoordinateOrigin: a, project_uCenter: i, project_uViewportSize: f, project_uDevicePixelRatio: e, project_uFocalDistance: u, project_uCommonUnitsPerMeter: l.unitsPerMeter, project_uCommonUnitsPerWorldUnit: l.unitsPerMeter, project_uCommonUnitsPerWorldUnit2: Iv, project_uScale: r2.scale, project_uViewProjectionMatrix: s, project_uCameraPosition: o };
    if (c) {
      let d = r2.getDistanceScales(c);
      switch (t) {
        case j.METER_OFFSETS:
          h.project_uCommonUnitsPerWorldUnit = d.unitsPerMeter, h.project_uCommonUnitsPerWorldUnit2 = d.unitsPerMeter2;
          break;
        case j.LNGLAT:
        case j.LNGLAT_OFFSETS:
          h.project_uCommonUnitsPerWorldUnit = d.unitsPerDegree, h.project_uCommonUnitsPerWorldUnit2 = d.unitsPerDegree2;
          break;
        case j.CARTESIAN:
          h.project_uCommonUnitsPerWorldUnit = [1, 1, d.unitsPerMeter[2]], h.project_uCommonUnitsPerWorldUnit2 = [0, 0, d.unitsPerMeter2[2]];
          break;
        default:
          break;
      }
    }
    return h;
  }
  var Bv = {};
  function Uv(r2 = Bv) {
    return r2.viewport ? cm(r2) : {};
  }
  var $r = { name: "project", dependencies: [Uo], vs: am, getUniforms: Uv };
  var kv = `
vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
) {
  vec3 projectedPosition = project_position(position, position64Low);
  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {
    // offset is specified as ENU
    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe
    mat3 rotation = project_get_orientation_matrix(projectedPosition);
    offset = rotation * offset;
  }
  commonPosition = vec4(projectedPosition + offset, 1.0);
  return project_common_position_to_clipspace(commonPosition);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(position, position64Low, offset, commonPosition);
}
`;
  var Ie = { name: "project32", dependencies: [$r], vs: kv };
  function Vn() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  function Pr(r2, e) {
    let t = Sr([], e, r2);
    return Zp(t, t, 1 / t[3]), t;
  }
  function xf(r2, e) {
    let t = r2 % e;
    return t < 0 ? e + t : t;
  }
  function Vv(r2) {
    return Math.log(r2) * Math.LOG2E;
  }
  var Gn = Math.log2 || Vv;
  function ct(r2, e) {
    if (!r2)
      throw new Error(e || "@math.gl/web-mercator: assertion failed.");
  }
  var bt = Math.PI;
  var lm = bt / 4;
  var Tt = bt / 180;
  var yf = 180 / bt;
  var $i = 512;
  var Ef = 4003e4;
  var bf = 1.5;
  function Jo(r2) {
    return Math.pow(2, r2);
  }
  function Tf(r2) {
    return Gn(r2);
  }
  function Qe([r2, e]) {
    ct(Number.isFinite(r2)), ct(Number.isFinite(e) && e >= -90 && e <= 90, "invalid latitude");
    let t = r2 * Tt, n = e * Tt, i = $i * (t + bt) / (2 * bt), s = $i * (bt + Math.log(Math.tan(lm + n * 0.5))) / (2 * bt);
    return [i, s];
  }
  function vt([r2, e]) {
    let t = r2 / $i * (2 * bt) - bt, n = 2 * (Math.atan(Math.exp(e / $i * (2 * bt) - bt)) - lm);
    return [t * yf, n * yf];
  }
  function vf({ latitude: r2 }) {
    ct(Number.isFinite(r2));
    let e = Math.cos(r2 * Tt);
    return Tf(Ef * e) - 9;
  }
  function en({ latitude: r2, longitude: e, highPrecision: t = false }) {
    ct(Number.isFinite(r2) && Number.isFinite(e));
    let n = {}, i = $i, s = Math.cos(r2 * Tt), o = i / 360, a = o / s, c = i / Ef / s;
    if (n.unitsPerMeter = [c, c, c], n.metersPerUnit = [1 / c, 1 / c, 1 / c], n.unitsPerDegree = [o, a, c], n.degreesPerUnit = [1 / o, 1 / a, 1 / c], t) {
      let l = Tt * Math.tan(r2 * Tt) / s, f = o * l / 2, u = i / Ef * l, h = u / a * c;
      n.unitsPerDegree2 = [0, f, u], n.unitsPerMeter2 = [h, 0, h];
    }
    return n;
  }
  function es(r2, e) {
    let [t, n, i] = r2, [s, o, a] = e, { unitsPerMeter: c, unitsPerMeter2: l } = en({ longitude: t, latitude: n, highPrecision: true }), f = Qe(r2);
    f[0] += s * (c[0] + l[0] * o), f[1] += o * (c[1] + l[1] * o);
    let u = vt(f), h = (i || 0) + (a || 0);
    return Number.isFinite(i) || Number.isFinite(a) ? [u[0], u[1], h] : u;
  }
  function ts({ height: r2, pitch: e, bearing: t, altitude: n, scale: i, center: s = null }) {
    let o = Vn();
    return tr(o, o, [0, 0, -n]), Ho(o, o, -e * Tt), Xo(o, o, t * Tt), i /= r2, rr(o, o, [i, i, i]), s && tr(o, o, vp([], s)), o;
  }
  function $o({ width: r2, height: e, fovy: t = zn(bf), altitude: n, pitch: i = 0, nearZMultiplier: s = 1, farZMultiplier: o = 1 }) {
    n !== void 0 && (t = zn(n));
    let a = 0.5 * t * Tt, c = ea(t), l = i * Tt, f = Math.sin(a) * c / Math.sin(Math.min(Math.max(Math.PI / 2 - l - a, 0.01), Math.PI - 0.01)), u = Math.sin(l) * f + c;
    return { fov: 2 * a, aspect: r2 / e, focalDistance: c, near: s, far: u * o };
  }
  function Af({ width: r2, height: e, pitch: t, altitude: n, fovy: i, nearZMultiplier: s, farZMultiplier: o }) {
    let { fov: a, aspect: c, near: l, far: f } = $o({ width: r2, height: e, altitude: n, fovy: i, pitch: t, nearZMultiplier: s, farZMultiplier: o });
    return Yo([], a, c, l, f);
  }
  function zn(r2) {
    return 2 * Math.atan(0.5 / r2) * yf;
  }
  function ea(r2) {
    return 0.5 / Math.tan(0.5 * r2 * Tt);
  }
  function tn(r2, e) {
    let [t, n, i = 0] = r2;
    return ct(Number.isFinite(t) && Number.isFinite(n) && Number.isFinite(i)), Pr(e, [t, n, i, 1]);
  }
  function Vt(r2, e, t = 0) {
    let [n, i, s] = r2;
    if (ct(Number.isFinite(n) && Number.isFinite(i), "invalid pixel coordinate"), Number.isFinite(s))
      return Pr(e, [n, i, s, 1]);
    let o = Pr(e, [n, i, 0, 1]), a = Pr(e, [n, i, 1, 1]), c = o[2], l = a[2], f = c === l ? 0 : ((t || 0) - c) / (l - c);
    return Go([], o, a, f);
  }
  function jn({ width: r2, height: e, bounds: t, minExtent: n = 0, maxZoom: i = 24, padding: s = 0, offset: o = [0, 0] }) {
    let [[a, c], [l, f]] = t;
    if (Number.isFinite(s)) {
      let D = s;
      s = { top: D, bottom: D, left: D, right: D };
    } else
      ct(Number.isFinite(s.top) && Number.isFinite(s.bottom) && Number.isFinite(s.left) && Number.isFinite(s.right));
    let u = new lt({ width: r2, height: e, longitude: 0, latitude: 0, zoom: 0 }), h = u.project([a, f]), d = u.project([l, c]), m = [Math.max(Math.abs(d[0] - h[0]), n), Math.max(Math.abs(d[1] - h[1]), n)], _ = [r2 - s.left - s.right - Math.abs(o[0]) * 2, e - s.top - s.bottom - Math.abs(o[1]) * 2];
    ct(_[0] > 0 && _[1] > 0);
    let E = _[0] / m[0], b = _[1] / m[1], T = (s.right - s.left) / 2 / E, v = (s.bottom - s.top) / 2 / b, C = [(d[0] + h[0]) / 2 + T, (d[1] + h[1]) / 2 + v], S = u.unproject(C), R = Math.min(i, u.zoom + Gn(Math.abs(Math.min(E, b))));
    return ct(Number.isFinite(R)), { longitude: S[0], latitude: S[1], zoom: R };
  }
  var fm = Math.PI / 180;
  function Wn(r2, e = 0) {
    let { width: t, height: n, unproject: i } = r2, s = { targetZ: e }, o = i([0, n], s), a = i([t, n], s), c, l, f = r2.fovy ? 0.5 * r2.fovy * fm : Math.atan(0.5 / r2.altitude), u = (90 - r2.pitch) * fm;
    return f > u - 0.01 ? (c = um(r2, 0, e), l = um(r2, t, e)) : (c = i([0, 0], s), l = i([t, 0], s)), [o, a, l, c];
  }
  function um(r2, e, t) {
    let { pixelUnprojectionMatrix: n } = r2, i = Pr(n, [e, 0, 1, 1]), s = Pr(n, [e, r2.height, 1, 1]), a = (t * r2.distanceScales.unitsPerMeter[2] - i[2]) / (s[2] - i[2]), c = Go([], i, s, a), l = vt(c);
    return l[2] = t, l;
  }
  var lt = class {
    constructor({ width: e, height: t, latitude: n = 0, longitude: i = 0, zoom: s = 0, pitch: o = 0, bearing: a = 0, altitude: c = null, fovy: l = null, position: f = null, nearZMultiplier: u = 0.02, farZMultiplier: h = 1.01 } = { width: 1, height: 1 }) {
      e = e || 1, t = t || 1, l === null && c === null ? (c = bf, l = zn(c)) : l === null ? l = zn(c) : c === null && (c = ea(l));
      let d = Jo(s);
      c = Math.max(0.75, c);
      let m = en({ longitude: i, latitude: n }), _ = Qe([i, n]);
      _[2] = 0, f && Tp(_, _, Mp([], f, m.unitsPerMeter)), this.projectionMatrix = Af({ width: e, height: t, pitch: o, fovy: l, nearZMultiplier: u, farZMultiplier: h }), this.viewMatrix = ts({ height: t, scale: d, center: _, pitch: o, bearing: a, altitude: c }), this.width = e, this.height = t, this.scale = d, this.latitude = n, this.longitude = i, this.zoom = s, this.pitch = o, this.bearing = a, this.altitude = c, this.fovy = l, this.center = _, this.meterOffset = f || [0, 0, 0], this.distanceScales = m, this._initMatrices(), this.equals = this.equals.bind(this), this.project = this.project.bind(this), this.unproject = this.unproject.bind(this), this.projectPosition = this.projectPosition.bind(this), this.unprojectPosition = this.unprojectPosition.bind(this), Object.freeze(this);
    }
    _initMatrices() {
      let { width: e, height: t, projectionMatrix: n, viewMatrix: i } = this, s = Vn();
      Ve(s, s, n), Ve(s, s, i), this.viewProjectionMatrix = s;
      let o = Vn();
      rr(o, o, [e / 2, -t / 2, 1]), tr(o, o, [1, -1, 0]), Ve(o, o, s);
      let a = Qr(Vn(), o);
      if (!a)
        throw new Error("Pixel project matrix not invertible");
      this.pixelProjectionMatrix = o, this.pixelUnprojectionMatrix = a;
    }
    equals(e) {
      return e instanceof lt ? e.width === this.width && e.height === this.height && ff(e.projectionMatrix, this.projectionMatrix) && ff(e.viewMatrix, this.viewMatrix) : false;
    }
    project(e, { topLeft: t = true } = {}) {
      let n = this.projectPosition(e), i = tn(n, this.pixelProjectionMatrix), [s, o] = i, a = t ? o : this.height - o;
      return e.length === 2 ? [s, a] : [s, a, i[2]];
    }
    unproject(e, { topLeft: t = true, targetZ: n = void 0 } = {}) {
      let [i, s, o] = e, a = t ? s : this.height - s, c = n && n * this.distanceScales.unitsPerMeter[2], l = Vt([i, a, o], this.pixelUnprojectionMatrix, c), [f, u, h] = this.unprojectPosition(l);
      return Number.isFinite(o) ? [f, u, h] : Number.isFinite(n) ? [f, u, n] : [f, u];
    }
    projectPosition(e) {
      let [t, n] = Qe(e), i = (e[2] || 0) * this.distanceScales.unitsPerMeter[2];
      return [t, n, i];
    }
    unprojectPosition(e) {
      let [t, n] = vt(e), i = (e[2] || 0) * this.distanceScales.metersPerUnit[2];
      return [t, n, i];
    }
    projectFlat(e) {
      return Qe(e);
    }
    unprojectFlat(e) {
      return vt(e);
    }
    getMapCenterByLngLatPosition({ lngLat: e, pos: t }) {
      let n = Vt(t, this.pixelUnprojectionMatrix), i = Qe(e), s = Nn([], i, Vo([], n)), o = Nn([], this.center, s);
      return vt(o);
    }
    getLocationAtPoint({ lngLat: e, pos: t }) {
      return this.getMapCenterByLngLatPosition({ lngLat: e, pos: t });
    }
    fitBounds(e, t = {}) {
      let { width: n, height: i } = this, { longitude: s, latitude: o, zoom: a } = jn(Object.assign({ width: n, height: i, bounds: e }, t));
      return new lt({ width: n, height: i, longitude: s, latitude: o, zoom: a });
    }
    getBounds(e) {
      let t = this.getBoundingRegion(e), n = Math.min(...t.map((a) => a[0])), i = Math.max(...t.map((a) => a[0])), s = Math.min(...t.map((a) => a[1])), o = Math.max(...t.map((a) => a[1]));
      return [[n, s], [i, o]];
    }
    getBoundingRegion(e = {}) {
      return Wn(this, e.z || 0);
    }
  };
  var hm = 85.05113;
  var dm = -85.05113;
  function ta({ width: r2, height: e, longitude: t, latitude: n, zoom: i, pitch: s = 0, bearing: o = 0 }) {
    (t < -180 || t > 180) && (t = xf(t + 180, 360) - 180), (o < -180 || o > 180) && (o = xf(o + 180, 360) - 180);
    let a = new lt({ width: r2, height: e, longitude: t, latitude: n, zoom: i }), c = a.project([t, hm])[1], l = a.project([t, dm])[1], f = 0;
    return l - c < e && (i += Gn(e / (l - c)), a = new lt({ width: r2, height: e, longitude: t, latitude: n, zoom: i }), c = a.project([t, hm])[1], l = a.project([t, dm])[1]), c > 0 ? f = c : l < e && (f = l - e), f && (n = a.unproject([r2 / 2, e / 2 + f])[1]), { width: r2, height: e, longitude: t, latitude: n, zoom: i, pitch: s, bearing: o };
  }
  var Gv = `
const int max_lights = 2;
uniform mat4 shadow_uViewProjectionMatrices[max_lights];
uniform vec4 shadow_uProjectCenters[max_lights];
uniform bool shadow_uDrawShadowMap;
uniform bool shadow_uUseShadowMap;
uniform int shadow_uLightId;
uniform float shadow_uLightCount;

varying vec3 shadow_vPosition[max_lights];

vec4 shadow_setVertexPosition(vec4 position_commonspace) {
  if (shadow_uDrawShadowMap) {
    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);
  }
  if (shadow_uUseShadowMap) {
    for (int i = 0; i < max_lights; i++) {
      if(i < int(shadow_uLightCount)) {
        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);
        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;
      }
    }
  }
  return gl_Position;
}
`;
  var zv = `
const int max_lights = 2;
uniform bool shadow_uDrawShadowMap;
uniform bool shadow_uUseShadowMap;
uniform sampler2D shadow_uShadowMap0;
uniform sampler2D shadow_uShadowMap1;
uniform vec4 shadow_uColor;
uniform float shadow_uLightCount;

varying vec3 shadow_vPosition[max_lights];

const vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);
const vec4 bitUnpackShift = 1.0 / bitPackShift;
const vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);

float shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {
  vec4 rgbaDepth = texture2D(shadowMap, position.xy);

  float z = dot(rgbaDepth, bitUnpackShift);
  return smoothstep(0.001, 0.01, position.z - z);
}

vec4 shadow_filterShadowColor(vec4 color) {
  if (shadow_uDrawShadowMap) {
    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);
    rgbaDepth -= rgbaDepth.gbaa * bitMask;
    return rgbaDepth;
  }
  if (shadow_uUseShadowMap) {
    float shadowAlpha = 0.0;
    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);
    if(shadow_uLightCount > 1.0) {
      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);
    }
    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;
    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);

    return vec4(
      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),
      blendedAlpha
    );
  }
  return color;
}
`;
  var jv = wr(qv);
  var Wv = wr(Zv);
  var Hv = [0, 0, 0, 1];
  var Xv = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
  function Yv(r2, e) {
    let [t, n, i] = r2, s = Vt([t, n, i], e);
    return Number.isFinite(i) ? s : [s[0], s[1], 0];
  }
  function qv({ viewport: r2, center: e }) {
    return new ce(r2.viewProjectionMatrix).invert().transform(e);
  }
  function Zv({ viewport: r2, shadowMatrices: e }) {
    let t = [], n = r2.pixelUnprojectionMatrix, i = r2.isGeospatial ? void 0 : 1, s = [[0, 0, i], [r2.width, 0, i], [0, r2.height, i], [r2.width, r2.height, i], [0, 0, -1], [r2.width, 0, -1], [0, r2.height, -1], [r2.width, r2.height, -1]].map((o) => Yv(o, n));
    for (let o of e) {
      let a = o.clone().translate(new M(r2.center).negate()), c = s.map((f) => a.transform(f)), l = new ce().ortho({ left: Math.min(...c.map((f) => f[0])), right: Math.max(...c.map((f) => f[0])), bottom: Math.min(...c.map((f) => f[1])), top: Math.max(...c.map((f) => f[1])), near: Math.min(...c.map((f) => -f[2])), far: Math.max(...c.map((f) => -f[2])) });
      t.push(l.multiplyRight(o));
    }
    return t;
  }
  function Kv(r2 = {}, e = {}) {
    let t = { shadow_uDrawShadowMap: Boolean(r2.drawToShadowMap), shadow_uUseShadowMap: r2.shadowMaps ? r2.shadowMaps.length > 0 : false, shadow_uColor: r2.shadowColor || Hv, shadow_uLightId: r2.shadowLightId || 0, shadow_uLightCount: r2.shadowMatrices.length }, n = jv({ viewport: r2.viewport, center: e.project_uCenter }), i = [], s = Wv({ shadowMatrices: r2.shadowMatrices, viewport: r2.viewport }).slice();
    for (let o = 0; o < r2.shadowMatrices.length; o++) {
      let a = s[o], c = a.clone().translate(new M(r2.viewport.center).negate());
      e.project_uCoordinateSystem === j.LNGLAT && e.project_uProjectionMode === Ge.WEB_MERCATOR ? (s[o] = c, i[o] = n) : (s[o] = a.clone().multiplyRight(Xv), i[o] = c.transform(n));
    }
    for (let o = 0; o < s.length; o++)
      t["shadow_uViewProjectionMatrices[".concat(o, "]")] = s[o], t["shadow_uProjectCenters[".concat(o, "]")] = i[o], r2.shadowMaps && r2.shadowMaps.length > 0 ? t["shadow_uShadowMap".concat(o)] = r2.shadowMaps[o] : t["shadow_uShadowMap".concat(o)] = r2.dummyShadowMap;
    return t;
  }
  var rs = { name: "shadow", dependencies: [$r], vs: Gv, fs: zv, inject: { "vs:DECKGL_FILTER_GL_POSITION": `
    position = shadow_setVertexPosition(geometry.position);
    `, "fs:DECKGL_FILTER_COLOR": `
    color = shadow_filterShadowColor(color);
    ` }, getUniforms: (r2 = {}, e = {}) => {
    if (r2.drawToShadowMap || r2.shadowMaps && r2.shadowMaps.length > 0) {
      let { shadowEnabled: t = true } = r2;
      return t && r2.shadowMatrices && r2.shadowMatrices.length > 0 ? Kv(r2, e) : { shadow_uDrawShadowMap: false, shadow_uUseShadowMap: false };
    }
    return {};
  } };
  var Oe = x({ inject: { "vs:DECKGL_FILTER_COLOR": `
  picking_setPickingColor(geometry.pickingColor);
  // for picking depth values
  picking_setPickingAttribute(geometry.position.z);
  `, "fs:DECKGL_FILTER_COLOR": { order: 99, injection: `
  // use highlight color if this fragment belongs to the selected object.
  color = picking_filterHighlightColor(color);

  // use picking color if rendering to picking FBO.
  color = picking_filterPickingColor(color);
    ` } } }, qo);
  var Qv = [om, $r];
  var Jv = ["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)", "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)", "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)", "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"];
  function pm(r2) {
    let e = at.getDefaultProgramManager(r2);
    for (let t of Qv)
      e.addDefaultModule(t);
    for (let t of Jv)
      e.addShaderHook(t);
    return e;
  }
  var $v = [255, 255, 255];
  var e1 = 1;
  var t1 = 0;
  var Sf = class {
    constructor(e = {}) {
      let { color: t = $v } = e, { intensity: n = e1 } = e;
      this.id = e.id || "ambient-".concat(t1++), this.color = t, this.intensity = n, this.type = "ambient";
    }
  };
  var r1 = [255, 255, 255];
  var n1 = 1;
  var i1 = [0, 0, -1];
  var s1 = 0;
  var ra = class {
    constructor(e = {}) {
      let { color: t = r1 } = e, { intensity: n = n1 } = e, { direction: i = i1 } = e, { _shadow: s = false } = e;
      this.id = e.id || "directional-".concat(s1++), this.color = t, this.intensity = n, this.type = "directional", this.direction = new M(i).normalize().toArray(), this.shadow = s;
    }
    getProjectedLight() {
      return this;
    }
  };
  var Hn = class {
    constructor(e = {}) {
      let { id: t = "effect" } = e;
      this.id = t, this.props = x({}, e);
    }
    preRender() {
    }
    getModuleParameters() {
    }
    cleanup() {
    }
  };
  var na = class {
    constructor(e, t = {}) {
      let { id: n = "pass" } = t;
      this.id = n, this.gl = e, this.props = x({}, t);
    }
    setProps(e) {
      Object.assign(this.props, e);
    }
    render() {
    }
    cleanup() {
    }
  };
  var Lr = class extends na {
    render(e) {
      let t = this.gl;
      return De(t, { framebuffer: e.target }), this._drawLayers(e);
    }
    _drawLayers(e) {
      let { viewports: t, views: n, onViewportActive: i, clearCanvas: s = true } = e;
      e.pass = e.pass || "unknown";
      let o = this.gl;
      s && a1(o);
      let a = [];
      for (let c of t) {
        let l = c.viewport || c, f = n && n[l.id];
        i(l);
        let u = this._getDrawLayerParams(l, e);
        e.view = f;
        let h = l.subViewports || [l];
        for (let d of h) {
          e.viewport = d;
          let m = this._drawLayersInViewport(o, e, u);
          a.push(m);
        }
      }
      return a;
    }
    _getDrawLayerParams(e, { layers: t, pass: n, layerFilter: i, effects: s, moduleParameters: o }) {
      let a = [], c = mm(), l = { viewport: e, isPicking: n.startsWith("picking"), renderPass: n };
      for (let f = 0; f < t.length; f++) {
        let u = t[f], h = this._shouldDrawLayer(u, l, i), d = c(u, h), m = { shouldDrawLayer: h, layerRenderIndex: d };
        h && (m.moduleParameters = this._getModuleParameters(u, s, n, o), m.layerParameters = this.getLayerParameters(u, f)), a[f] = m;
      }
      return a;
    }
    _drawLayersInViewport(e, { layers: t, pass: n, viewport: i, view: s }, o) {
      let a = o1(e, { viewport: i });
      if (s && s.props.clear) {
        let l = s.props.clear === true ? { color: true, depth: true } : s.props.clear;
        ae(e, { scissorTest: true, scissor: a }, () => gr(e, l));
      }
      let c = { totalCount: t.length, visibleCount: 0, compositeCount: 0, pickableCount: 0 };
      De(e, { viewport: a });
      for (let l = 0; l < t.length; l++) {
        let f = t[l], { shouldDrawLayer: u, layerRenderIndex: h, moduleParameters: d, layerParameters: m } = o[l];
        if (u && f.props.pickable && c.pickableCount++, f.isComposite)
          c.compositeCount++;
        else if (u) {
          c.visibleCount++, d.viewport = i;
          try {
            f.drawLayer({ moduleParameters: d, uniforms: { layerIndex: h }, parameters: m });
          } catch (_) {
            f.raiseError(_, "drawing ".concat(f, " to ").concat(n));
          }
        }
      }
      return c;
    }
    shouldDrawLayer(e) {
      return true;
    }
    getModuleParameters(e, t) {
      return null;
    }
    getLayerParameters(e, t) {
      return e.props.parameters;
    }
    _shouldDrawLayer(e, t, n) {
      if (!(this.shouldDrawLayer(e) && e.props.visible) || (t.layer = e, n && !n(t)))
        return false;
      let s = e.parent;
      for (; s; ) {
        if (!s.filterSubLayer(t))
          return false;
        t.layer = s, s = s.parent;
      }
      return e.activateViewport(t.viewport), true;
    }
    _getModuleParameters(e, t, n, i) {
      let s = Object.assign(Object.create(e.props), { autoWrapLongitude: e.wrapLongitude, viewport: e.context.viewport, mousePosition: e.context.mousePosition, pickingActive: 0, devicePixelRatio: xt(this.gl) });
      if (t)
        for (let o of t)
          Object.assign(s, o.getModuleParameters(e));
      return Object.assign(s, this.getModuleParameters(e, t), i);
    }
  };
  function mm(r2 = 0, e = {}) {
    let t = {}, n = (i, s) => {
      let o = i.props._offset, a = i.id, c = i.parent && i.parent.id, l;
      if (c && !(c in e) && n(i.parent, false), c in t) {
        let f = t[c] = t[c] || mm(e[c], e);
        l = f(i, s), t[a] = f;
      } else
        Number.isFinite(o) ? (l = o + (e[c] || 0), t[a] = null) : l = r2;
      return s && l >= r2 && (r2 = l + 1), e[a] = l, l;
    };
    return n;
  }
  function o1(r2, { viewport: e }) {
    let t = r2.canvas ? r2.canvas.clientHeight || r2.canvas.height : 100, n = e, i = xt(r2);
    return [n.x * i, (t - n.y - n.height) * i, n.width * i, n.height * i];
  }
  function a1(r2) {
    let e = r2.drawingBufferWidth, t = r2.drawingBufferHeight;
    De(r2, { viewport: [0, 0, e, t] }), r2.clear(16384 | 256);
  }
  var ia = class extends Lr {
    constructor(e, t) {
      super(e, t);
      this.shadowMap = new Q(e, { width: 1, height: 1, parameters: { [10241]: 9729, [10240]: 9729, [10242]: 33071, [10243]: 33071 } }), this.depthBuffer = new qe(e, { format: 33189, width: 1, height: 1 }), this.fbo = new Z(e, { id: "shadowmap", width: 1, height: 1, attachments: { [36064]: this.shadowMap, [36096]: this.depthBuffer } });
    }
    render(e) {
      let t = this.fbo;
      ae(this.gl, { depthRange: [0, 1], depthTest: true, blend: false, clearColor: [1, 1, 1, 1] }, () => {
        let n = e.viewports[0], i = xt(this.gl), s = n.width * i, o = n.height * i;
        (s !== t.width || o !== t.height) && t.resize({ width: s, height: o }), super.render(L(x({}, e), { target: t, pass: "shadow" }));
      });
    }
    shouldDrawLayer(e) {
      return e.props.shadowEnabled !== false;
    }
    getModuleParameters() {
      return { drawToShadowMap: true };
    }
    delete() {
      this.fbo && (this.fbo.delete(), this.fbo = null), this.shadowMap && (this.shadowMap.delete(), this.shadowMap = null), this.depthBuffer && (this.depthBuffer.delete(), this.depthBuffer = null);
    }
  };
  var c1 = { color: [255, 255, 255], intensity: 1 };
  var gm = [{ color: [255, 255, 255], intensity: 1, direction: [-1, 3, -1] }, { color: [255, 255, 255], intensity: 0.9, direction: [1, -8, -2.5] }];
  var l1 = [0, 0, 0, 200 / 255];
  var ns = class extends Hn {
    constructor(e) {
      super(e);
      this.ambientLight = null, this.directionalLights = [], this.pointLights = [], this.shadowColor = l1, this.shadowPasses = [], this.shadowMaps = [], this.dummyShadowMap = null, this.shadow = false, this.programManager = null;
      for (let t in e) {
        let n = e[t];
        switch (n.type) {
          case "ambient":
            this.ambientLight = n;
            break;
          case "directional":
            this.directionalLights.push(n);
            break;
          case "point":
            this.pointLights.push(n);
            break;
          default:
        }
      }
      this._applyDefaultLights(), this.shadow = this.directionalLights.some((t) => t.shadow);
    }
    preRender(e, { layers: t, layerFilter: n, viewports: i, onViewportActive: s, views: o }) {
      if (!!this.shadow) {
        this.shadowMatrices = this._createLightMatrix(), this.shadowPasses.length === 0 && this._createShadowPasses(e), this.programManager || (this.programManager = at.getDefaultProgramManager(e), rs && this.programManager.addDefaultModule(rs)), this.dummyShadowMap || (this.dummyShadowMap = new Q(e, { width: 1, height: 1 }));
        for (let a = 0; a < this.shadowPasses.length; a++)
          this.shadowPasses[a].render({ layers: t, layerFilter: n, viewports: i, onViewportActive: s, views: o, moduleParameters: { shadowLightId: a, dummyShadowMap: this.dummyShadowMap, shadowMatrices: this.shadowMatrices } });
      }
    }
    getModuleParameters(e) {
      let t = this.shadow ? { shadowMaps: this.shadowMaps, dummyShadowMap: this.dummyShadowMap, shadowColor: this.shadowColor, shadowMatrices: this.shadowMatrices } : {};
      return t.lightSources = { ambientLight: this.ambientLight, directionalLights: this.directionalLights.map((n) => n.getProjectedLight({ layer: e })), pointLights: this.pointLights.map((n) => n.getProjectedLight({ layer: e })) }, t;
    }
    cleanup() {
      for (let e of this.shadowPasses)
        e.delete();
      this.shadowPasses.length = 0, this.shadowMaps.length = 0, this.dummyShadowMap && (this.dummyShadowMap.delete(), this.dummyShadowMap = null), this.shadow && this.programManager && (this.programManager.removeDefaultModule(rs), this.programManager = null);
    }
    _createLightMatrix() {
      let e = [];
      for (let t of this.directionalLights) {
        let n = new ce().lookAt({ eye: new M(t.direction).negate() });
        e.push(n);
      }
      return e;
    }
    _createShadowPasses(e) {
      for (let t = 0; t < this.directionalLights.length; t++) {
        let n = new ia(e);
        this.shadowPasses[t] = n, this.shadowMaps[t] = n.shadowMap;
      }
    }
    _applyDefaultLights() {
      let { ambientLight: e, pointLights: t, directionalLights: n } = this;
      !e && t.length === 0 && n.length === 0 && (this.ambientLight = new Sf(c1), this.directionalLights.push(new ra(gm[0]), new ra(gm[1])));
    }
  };
  var _m = class {
    constructor(e) {
      this._pool = [], this.props = { overAlloc: 2, poolSize: 100 }, this.setProps(e);
    }
    setProps(e) {
      Object.assign(this.props, e);
    }
    allocate(e, t, { size: n = 1, type: i, padding: s = 0, copy: o = false, initialize: a = false, maxCount: c }) {
      let l = i || e && e.constructor || Float32Array, f = t * n + s;
      if (ArrayBuffer.isView(e)) {
        if (f <= e.length)
          return e;
        if (f * e.BYTES_PER_ELEMENT <= e.buffer.byteLength)
          return new l(e.buffer, 0, f);
      }
      let u;
      c && (u = c * n + s);
      let h = this._allocate(l, f, a, u);
      return e && o ? h.set(e) : a || h.fill(0, 0, 4), this._release(e), h;
    }
    release(e) {
      this._release(e);
    }
    _allocate(e, t, n, i) {
      let s = Math.max(Math.ceil(t * this.props.overAlloc), 1);
      s > i && (s = i);
      let o = this._pool, a = e.BYTES_PER_ELEMENT * s, c = o.findIndex((l) => l.byteLength >= a);
      if (c >= 0) {
        let l = new e(o.splice(c, 1)[0], 0, s);
        return n && l.fill(0), l;
      }
      return new e(s);
    }
    _release(e) {
      if (!ArrayBuffer.isView(e))
        return;
      let t = this._pool, { buffer: n } = e, { byteLength: i } = n, s = t.findIndex((o) => o.byteLength >= i);
      s < 0 ? t.push(n) : (s > 0 || t.length < this.props.poolSize) && t.splice(s, 0, n), t.length > this.props.poolSize && t.shift();
    }
  };
  var At = new _m();
  function Xn() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  function xm(r2) {
    return [r2[12], r2[13], r2[14]];
  }
  function ym(r2) {
    let e = {};
    return e.left = Yn(r2[3] + r2[0], r2[7] + r2[4], r2[11] + r2[8], r2[15] + r2[12]), e.right = Yn(r2[3] - r2[0], r2[7] - r2[4], r2[11] - r2[8], r2[15] - r2[12]), e.bottom = Yn(r2[3] + r2[1], r2[7] + r2[5], r2[11] + r2[9], r2[15] + r2[13]), e.top = Yn(r2[3] - r2[1], r2[7] - r2[5], r2[11] - r2[9], r2[15] - r2[13]), e.near = Yn(r2[3] + r2[2], r2[7] + r2[6], r2[11] + r2[10], r2[15] + r2[14]), e.far = Yn(r2[3] - r2[2], r2[7] - r2[6], r2[11] - r2[10], r2[15] - r2[14]), e;
  }
  var Em = new M();
  function Yn(r2, e, t, n) {
    Em.set(r2, e, t);
    let i = Em.len();
    return { distance: n / i, normal: new M(-r2 / i, -e / i, -t / i) };
  }
  function f1(r2) {
    return r2 - Math.fround(r2);
  }
  var is;
  function sa(r2, { size: e = 1, startIndex: t = 0, endIndex: n }) {
    Number.isFinite(n) || (n = r2.length);
    let i = (n - t) / e;
    is = At.allocate(is, i, { type: Float32Array, size: e * 2 });
    let s = t, o = 0;
    for (; s < n; ) {
      for (let a = 0; a < e; a++) {
        let c = r2[s++];
        is[o + a] = c, is[o + a + e] = f1(c);
      }
      o += e * 2;
    }
    return is.subarray(0, i * e * 2);
  }
  var u1 = Math.PI / 180;
  var h1 = Xn();
  var wf = [0, 0, 0];
  var d1 = 0;
  var p1 = { unitsPerMeter: [1, 1, 1], metersPerUnit: [1, 1, 1] };
  var ft = class {
    constructor(e = {}) {
      let { id: t = null, x: n = 0, y: i = 0, width: s = 1, height: o = 1 } = e;
      this.id = t || this.constructor.displayName || "viewport", this.x = n, this.y = i, this.width = s || 1, this.height = o || 1, this._frustumPlanes = {}, this._initViewMatrix(e), this._initProjectionMatrix(e), this._initPixelMatrices(), this.equals = this.equals.bind(this), this.project = this.project.bind(this), this.unproject = this.unproject.bind(this), this.projectPosition = this.projectPosition.bind(this), this.unprojectPosition = this.unprojectPosition.bind(this), this.projectFlat = this.projectFlat.bind(this), this.unprojectFlat = this.unprojectFlat.bind(this);
    }
    get metersPerPixel() {
      return this.distanceScales.metersPerUnit[2] / this.scale;
    }
    get projectionMode() {
      return this.isGeospatial ? this.zoom < 12 ? Ge.WEB_MERCATOR : Ge.WEB_MERCATOR_AUTO_OFFSET : Ge.IDENTITY;
    }
    equals(e) {
      return e instanceof ft ? this === e ? true : e.width === this.width && e.height === this.height && e.scale === this.scale && Ke(e.projectionMatrix, this.projectionMatrix) && Ke(e.viewMatrix, this.viewMatrix) : false;
    }
    project(e, { topLeft: t = true } = {}) {
      let n = this.projectPosition(e), i = tn(n, this.pixelProjectionMatrix), [s, o] = i, a = t ? o : this.height - o;
      return e.length === 2 ? [s, a] : [s, a, i[2]];
    }
    unproject(e, { topLeft: t = true, targetZ: n } = {}) {
      let [i, s, o] = e, a = t ? s : this.height - s, c = n && n * this.distanceScales.unitsPerMeter[2], l = Vt([i, a, o], this.pixelUnprojectionMatrix, c), [f, u, h] = this.unprojectPosition(l);
      return Number.isFinite(o) ? [f, u, h] : Number.isFinite(n) ? [f, u, n] : [f, u];
    }
    projectPosition(e) {
      let [t, n] = this.projectFlat(e), i = (e[2] || 0) * this.distanceScales.unitsPerMeter[2];
      return [t, n, i];
    }
    unprojectPosition(e) {
      let [t, n] = this.unprojectFlat(e), i = (e[2] || 0) * this.distanceScales.metersPerUnit[2];
      return [t, n, i];
    }
    projectFlat(e) {
      return this.isGeospatial ? Qe(e) : e;
    }
    unprojectFlat(e) {
      return this.isGeospatial ? vt(e) : e;
    }
    getBounds(e = {}) {
      let t = { targetZ: e.z || 0 }, n = this.unproject([0, 0], t), i = this.unproject([this.width, 0], t), s = this.unproject([0, this.height], t), o = this.unproject([this.width, this.height], t);
      return [Math.min(n[0], i[0], s[0], o[0]), Math.min(n[1], i[1], s[1], o[1]), Math.max(n[0], i[0], s[0], o[0]), Math.max(n[1], i[1], s[1], o[1])];
    }
    getDistanceScales(e = null) {
      return e ? en({ longitude: e[0], latitude: e[1], highPrecision: true }) : this.distanceScales;
    }
    containsPixel({ x: e, y: t, width: n = 1, height: i = 1 }) {
      return e < this.x + this.width && this.x < e + n && t < this.y + this.height && this.y < t + i;
    }
    getFrustumPlanes() {
      return this._frustumPlanes.near ? this._frustumPlanes : (Object.assign(this._frustumPlanes, ym(this.viewProjectionMatrix)), this._frustumPlanes);
    }
    panByPosition(e, t) {
      return null;
    }
    getCameraPosition() {
      return this.cameraPosition;
    }
    getCameraDirection() {
      return this.cameraDirection;
    }
    getCameraUp() {
      return this.cameraUp;
    }
    _createProjectionMatrix({ orthographic: e, fovyRadians: t, aspect: n, focalDistance: i, near: s, far: o }) {
      return e ? new ce().orthographic({ fovy: t, aspect: n, focalDistance: i, near: s, far: o }) : new ce().perspective({ fovy: t, aspect: n, near: s, far: o });
    }
    _initViewMatrix(e) {
      let { viewMatrix: t = h1, longitude: n = null, latitude: i = null, zoom: s = null, position: o = null, modelMatrix: a = null, focalDistance: c = 1, distanceScales: l = null } = e;
      this.isGeospatial = Number.isFinite(i) && Number.isFinite(n), this.zoom = s, Number.isFinite(this.zoom) || (this.zoom = this.isGeospatial ? vf({ latitude: i }) + Math.log2(c) : d1);
      let f = Math.pow(2, this.zoom);
      this.scale = f, this.distanceScales = this.isGeospatial ? en({ latitude: i, longitude: n }) : l || p1, this.focalDistance = c, this.distanceScales.metersPerUnit = new M(this.distanceScales.metersPerUnit), this.distanceScales.unitsPerMeter = new M(this.distanceScales.unitsPerMeter), this.position = wf, this.meterOffset = wf, o && (this.position = o, this.modelMatrix = a, this.meterOffset = a ? a.transformVector(o) : o), this.isGeospatial ? (this.longitude = n, this.latitude = i, this.center = this._getCenterInWorld({ longitude: n, latitude: i })) : this.center = o ? this.projectPosition(o) : [0, 0, 0], this.viewMatrixUncentered = t, this.viewMatrix = new ce().multiplyRight(this.viewMatrixUncentered).translate(new M(this.center || wf).negate());
    }
    _getCenterInWorld({ longitude: e, latitude: t }) {
      let { meterOffset: n, distanceScales: i } = this, s = new M(this.projectPosition([e, t, 0]));
      if (n) {
        let o = new M(n).scale(i.unitsPerMeter);
        s.add(o);
      }
      return s;
    }
    _initProjectionMatrix(e) {
      let { projectionMatrix: t = null, orthographic: n = false, fovyRadians: i, fovy: s = 75, near: o = 0.1, far: a = 1e3, focalDistance: c = 1 } = e;
      this.projectionMatrix = t || this._createProjectionMatrix({ orthographic: n, fovyRadians: i || s * u1, aspect: this.width / this.height, focalDistance: c, near: o, far: a });
    }
    _initPixelMatrices() {
      let e = Xn();
      Ve(e, e, this.projectionMatrix), Ve(e, e, this.viewMatrix), this.viewProjectionMatrix = e, this.viewMatrixInverse = Qr([], this.viewMatrix) || this.viewMatrix, this.cameraPosition = xm(this.viewMatrixInverse);
      let t = Xn(), n = Xn();
      rr(t, t, [this.width / 2, -this.height / 2, 1]), tr(t, t, [1, -1, 0]), Ve(n, t, this.viewProjectionMatrix), this.pixelProjectionMatrix = n, this.viewportMatrix = t, this.pixelUnprojectionMatrix = Qr(Xn(), this.pixelProjectionMatrix), this.pixelUnprojectionMatrix || F.warn("Pixel project matrix not invertible")();
    }
  };
  ft.displayName = "Viewport";
  var Je = class extends ft {
    constructor(e = {}) {
      let { latitude: t = 0, longitude: n = 0, zoom: i = 11, pitch: s = 0, bearing: o = 0, nearZMultiplier: a = 0.1, farZMultiplier: c = 1.01, orthographic: l = false, repeat: f = false, worldOffset: u = 0 } = e, { width: h, height: d, altitude: m = 1.5 } = e, _ = Math.pow(2, i);
      h = h || 1, d = d || 1, m = Math.max(0.75, m);
      let { fov: E, aspect: b, focalDistance: T, near: v, far: C } = $o({ width: h, height: d, pitch: s, altitude: m, nearZMultiplier: a, farZMultiplier: c }), S = ts({ height: d, pitch: s, bearing: o, scale: _, altitude: m });
      u && (S = new ce().translate([512 * u, 0, 0]).multiplyLeft(S));
      super(L(x({}, e), { width: h, height: d, viewMatrix: S, longitude: n, latitude: t, zoom: i, orthographic: l, fovyRadians: E, aspect: b, focalDistance: T, near: v, far: C }));
      this.latitude = t, this.longitude = n, this.zoom = i, this.pitch = s, this.bearing = o, this.altitude = m, this.orthographic = l, this._subViewports = f ? [] : null, Object.freeze(this);
    }
    get subViewports() {
      if (this._subViewports && !this._subViewports.length) {
        let e = this.getBounds(), t = Math.floor((e[0] + 180) / 360), n = Math.ceil((e[2] - 180) / 360);
        for (let i = t; i <= n; i++) {
          let s = i ? new Je(L(x({}, this), { worldOffset: i })) : this;
          this._subViewports.push(s);
        }
      }
      return this._subViewports;
    }
    addMetersToLngLat(e, t) {
      return es(e, t);
    }
    panByPosition(e, t) {
      let n = Vt(t, this.pixelUnprojectionMatrix), i = this.projectFlat(e), s = Nn([], i, Vo([], n)), o = Nn([], this.center, s), [a, c] = this.unprojectFlat(o);
      return { longitude: a, latitude: c };
    }
    getBounds(e = {}) {
      let t = Wn(this, e.z || 0);
      return [Math.min(t[0][0], t[1][0], t[2][0], t[3][0]), Math.min(t[0][1], t[1][1], t[2][1], t[3][1]), Math.max(t[0][0], t[1][0], t[2][0], t[3][0]), Math.max(t[0][1], t[1][1], t[2][1], t[3][1])];
    }
    fitBounds(e, t = {}) {
      let { width: n, height: i } = this, { longitude: s, latitude: o, zoom: a } = jn(x({ width: n, height: i, bounds: e }, t));
      return new Je({ width: n, height: i, longitude: s, latitude: o, zoom: a });
    }
  };
  Je.displayName = "WebMercatorViewport";
  function Pf(r2, e, t = false) {
    let n = e.projectPosition(r2);
    if (t && e instanceof Je) {
      let [i, s, o = 0] = r2, a = e.getDistanceScales([i, s]);
      n[2] = o * a.unitsPerMeter[2];
    }
    return n;
  }
  function m1(r2) {
    let e = x({}, r2), { coordinateSystem: t } = r2, { viewport: n, coordinateOrigin: i, fromCoordinateSystem: s, fromCoordinateOrigin: o } = r2;
    return t === j.DEFAULT && (t = n.isGeospatial ? j.LNGLAT : j.CARTESIAN), s === void 0 && (e.fromCoordinateSystem = t), o === void 0 && (e.fromCoordinateOrigin = i), e.coordinateSystem = t, e;
  }
  function Lf(r2, { viewport: e, modelMatrix: t, coordinateSystem: n, coordinateOrigin: i, offsetMode: s }) {
    let [o, a, c = 0] = r2;
    switch (t && ([o, a, c] = Sr([], [o, a, c, 1], t)), n) {
      case j.LNGLAT:
        return Pf([o, a, c], e, s);
      case j.LNGLAT_OFFSETS:
        return Pf([o + i[0], a + i[1], c + (i[2] || 0)], e, s);
      case j.METER_OFFSETS:
        return Pf(es(i, [o, a, c]), e, s);
      case j.CARTESIAN:
      default:
        return e.isGeospatial ? [o + i[0], a + i[1], c + i[2]] : e.projectPosition([o, a, c]);
    }
  }
  function bm(r2, e) {
    let { viewport: t, coordinateSystem: n, coordinateOrigin: i, modelMatrix: s, fromCoordinateSystem: o, fromCoordinateOrigin: a } = m1(e), { geospatialOrigin: c, shaderCoordinateOrigin: l, offsetMode: f } = _f(t, n, i), u = Lf(r2, { viewport: t, modelMatrix: s, coordinateSystem: o, coordinateOrigin: a, offsetMode: f });
    if (f) {
      let h = t.projectPosition(c || l);
      Rp(u, u, h);
    }
    return u;
  }
  var Cr = { NO_STATE: "Awaiting state", MATCHED: "Matched. State transferred from previous layer", INITIALIZED: "Initialized", AWAITING_GC: "Discarded. Awaiting garbage collection", AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection", FINALIZED: "Finalized! Awaiting garbage collection" };
  var Rr = { COMPONENT: Symbol.for("component"), ASYNC_DEFAULTS: Symbol.for("asyncPropDefaults"), ASYNC_ORIGINAL: Symbol.for("asyncPropOriginal"), ASYNC_RESOLVED: Symbol.for("asyncPropResolved") };
  function nr(r2, e = () => true) {
    return Array.isArray(r2) ? Tm(r2, e, []) : e(r2) ? [r2] : [];
  }
  function Tm(r2, e, t) {
    let n = -1;
    for (; ++n < r2.length; ) {
      let i = r2[n];
      Array.isArray(i) ? Tm(i, e, t) : e(i) && t.push(i);
    }
    return t;
  }
  function Cf({ target: r2, source: e, start: t = 0, count: n = 1 }) {
    let i = e.length, s = n * i, o = 0;
    for (let a = t; o < i; o++)
      r2[a++] = e[o];
    for (; o < s; )
      o < s - o ? (r2.copyWithin(t + o, t, t + o), o *= 2) : (r2.copyWithin(t + o, t, t + s - o), o = s);
    return r2;
  }
  var oa = class {
    constructor(e, t, n) {
      this.id = e, this.context = n, this._loadCount = 0, this._subscribers = new Set(), this.setData(t);
    }
    subscribe(e) {
      this._subscribers.add(e);
    }
    unsubscribe(e) {
      this._subscribers.delete(e);
    }
    inUse() {
      return this._subscribers.size > 0;
    }
    delete() {
    }
    getData() {
      return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
    }
    setData(e, t) {
      if (e === this._data && !t)
        return;
      this._data = e;
      let n = ++this._loadCount, i = e;
      typeof e == "string" && (i = hr(e)), i instanceof Promise ? (this.isLoaded = false, this._loader = i.then((s) => {
        this._loadCount === n && (this.isLoaded = true, this._error = null, this._content = s);
      }).catch((s) => {
        this._loadCount === n && (this.isLoaded = true, this._error = s || true);
      })) : (this.isLoaded = true, this._error = null, this._content = e);
      for (let s of this._subscribers)
        s.onChange(this.getData());
    }
  };
  var aa = class {
    constructor({ gl: e, protocol: t }) {
      this.protocol = t || "resource://", this._context = { gl: e, resourceManager: this }, this._resources = {}, this._consumers = {}, this._pruneRequest = null;
    }
    contains(e) {
      return e.startsWith(this.protocol) ? true : e in this._resources;
    }
    add({ resourceId: e, data: t, forceUpdate: n = false, persistent: i = true }) {
      let s = this._resources[e];
      s ? s.setData(t, n) : (s = new oa(e, t, this._context), this._resources[e] = s), s.persistent = i;
    }
    remove(e) {
      let t = this._resources[e];
      t && (t.delete(), delete this._resources[e]);
    }
    unsubscribe({ consumerId: e }) {
      let t = this._consumers[e];
      if (t) {
        for (let n in t) {
          let i = t[n];
          i.resource && i.resource.unsubscribe(i);
        }
        delete this._consumers[e], this.prune();
      }
    }
    subscribe({ resourceId: e, onChange: t, consumerId: n, requestId: i = "default" }) {
      let { _resources: s, protocol: o } = this;
      e.startsWith(o) && (e = e.replace(o, ""), s[e] || this.add({ resourceId: e, data: null, persistent: false }));
      let a = s[e];
      if (this._track(n, i, a, t), a)
        return a.getData();
    }
    prune() {
      this._pruneRequest || (this._pruneRequest = setTimeout(() => this._prune(), 0));
    }
    finalize() {
      for (let e in this._resources)
        this._resources[e].delete();
    }
    _track(e, t, n, i) {
      let s = this._consumers, o = s[e] = s[e] || {}, a = o[t] || {};
      a.resource && (a.resource.unsubscribe(a), a.resource = null, this.prune()), n && (o[t] = a, a.onChange = i, a.resource = n, n.subscribe(a));
    }
    _prune() {
      this._pruneRequest = null;
      for (let e of Object.keys(this._resources)) {
        let t = this._resources[e];
        !t.persistent && !t.inUse() && (t.delete(), delete this._resources[e]);
      }
    }
  };
  var g1 = "layerManager.setLayers";
  var _1 = "layerManager.activateViewport";
  var x1 = Object.seal({ layerManager: null, resourceManager: null, deck: null, gl: null, stats: null, shaderCache: null, pickingFBO: null, mousePosition: null, userData: {} });
  var ca = class {
    constructor(e, { deck: t, stats: n, viewport: i, timeline: s } = {}) {
      this.lastRenderedLayers = [], this.layers = [], this.resourceManager = new aa({ gl: e, protocol: "deck://" }), this.context = L(x({}, x1), { layerManager: this, gl: e, deck: t, programManager: e && pm(e), stats: n || new nt({ id: "deck.gl" }), viewport: i || new ft({ id: "DEFAULT-INITIAL-VIEWPORT" }), timeline: s || new Jr(), resourceManager: this.resourceManager }), this._nextLayers = null, this._needsRedraw = "Initial render", this._needsUpdate = false, this._debug = false, this.activateViewport = this.activateViewport.bind(this), Object.seal(this);
    }
    finalize() {
      this.resourceManager.finalize();
      for (let e of this.layers)
        this._finalizeLayer(e);
    }
    needsRedraw(e = { clearRedrawFlags: false }) {
      let t = this._needsRedraw;
      e.clearRedrawFlags && (this._needsRedraw = false);
      for (let n of this.layers) {
        let i = n.getNeedsRedraw(e);
        t = t || i;
      }
      return t;
    }
    needsUpdate() {
      return this._nextLayers && this._nextLayers !== this.lastRenderedLayers ? "layers changed" : this._needsUpdate;
    }
    setNeedsRedraw(e) {
      this._needsRedraw = this._needsRedraw || e;
    }
    setNeedsUpdate(e) {
      this._needsUpdate = this._needsUpdate || e;
    }
    getLayers({ layerIds: e = null } = {}) {
      return e ? this.layers.filter((t) => e.find((n) => t.id.indexOf(n) === 0)) : this.layers;
    }
    setProps(e) {
      "debug" in e && (this._debug = e.debug), "userData" in e && (this.context.userData = e.userData), "layers" in e && (this._nextLayers = e.layers), "onError" in e && (this.context.onError = e.onError);
    }
    setLayers(e, t) {
      se(g1, this, t, e), this.lastRenderedLayers = e, e = nr(e, Boolean);
      for (let n of e)
        n.context = this.context;
      return this._updateLayers(this.layers, e), this;
    }
    updateLayers() {
      let e = this.needsUpdate();
      e && (this.setNeedsRedraw("updating layers: ".concat(e)), this.setLayers(this._nextLayers || this.lastRenderedLayers, e)), this._nextLayers = null;
    }
    activateViewport(e) {
      return se(_1, this, e), e && (this.context.viewport = e), this;
    }
    _handleError(e, t, n) {
      n.raiseError(t, "".concat(e, " of ").concat(n));
    }
    _updateLayers(e, t) {
      let n = {};
      for (let o of e)
        n[o.id] ? F.warn("Multiple old layers with same id ".concat(o.id))() : n[o.id] = o;
      let i = [];
      this._updateSublayersRecursively(t, n, i), this._finalizeOldLayers(n);
      let s = false;
      for (let o of i)
        if (o.hasUniformTransition()) {
          s = true;
          break;
        }
      this._needsUpdate = s, this.layers = i;
    }
    _updateSublayersRecursively(e, t, n) {
      for (let i of e) {
        i.context = this.context;
        let s = t[i.id];
        s === null && F.warn("Multiple new layers with same id ".concat(i.id))(), t[i.id] = null;
        let o = null;
        try {
          this._debug && s !== i && i.validateProps(), s ? (this._transferLayerState(s, i), this._updateLayer(i)) : this._initializeLayer(i), n.push(i), o = i.isComposite && i.getSubLayers();
        } catch (a) {
          this._handleError("matching", a, i);
        }
        o && this._updateSublayersRecursively(o, t, n);
      }
    }
    _finalizeOldLayers(e) {
      for (let t in e) {
        let n = e[t];
        n && this._finalizeLayer(n);
      }
    }
    _initializeLayer(e) {
      try {
        e._initialize(), e.lifecycle = Cr.INITIALIZED;
      } catch (t) {
        this._handleError("initialization", t, e);
      }
    }
    _transferLayerState(e, t) {
      t._transferState(e), t.lifecycle = Cr.MATCHED, t !== e && (e.lifecycle = Cr.AWAITING_GC);
    }
    _updateLayer(e) {
      try {
        e._update();
      } catch (t) {
        this._handleError("update", t, e);
      }
    }
    _finalizeLayer(e) {
      this._needsRedraw = this._needsRedraw || "finalized ".concat(e), e.lifecycle = Cr.AWAITING_FINALIZATION;
      try {
        e._finalize(), e.lifecycle = Cr.FINALIZED;
      } catch (t) {
        this._handleError("finalization", t, e);
      }
    }
  };
  function ir(r2, e) {
    if (r2 === e)
      return true;
    if (!r2 || !e)
      return false;
    for (let t in r2) {
      let n = r2[t], i = e[t];
      if (!(n === i || Array.isArray(n) && Array.isArray(i) && ir(n, i)))
        return false;
    }
    return true;
  }
  var la = class {
    constructor(e = {}) {
      this.views = [], this.width = 100, this.height = 100, this.viewState = {}, this.controllers = {}, this.timeline = e.timeline, this._viewports = [], this._viewportMap = {}, this._isUpdating = false, this._needsRedraw = "Initial render", this._needsUpdate = true, this._eventManager = e.eventManager, this._eventCallbacks = { onViewStateChange: e.onViewStateChange, onInteractionStateChange: e.onInteractionStateChange }, Object.seal(this), this.setProps(e);
    }
    finalize() {
      for (let e in this.controllers)
        this.controllers[e] && this.controllers[e].finalize();
      this.controllers = {};
    }
    needsRedraw(e = { clearRedrawFlags: false }) {
      let t = this._needsRedraw;
      return e.clearRedrawFlags && (this._needsRedraw = false), t;
    }
    setNeedsUpdate(e) {
      this._needsUpdate = this._needsUpdate || e, this._needsRedraw = this._needsRedraw || e;
    }
    updateViewStates() {
      for (let e in this.controllers) {
        let t = this.controllers[e];
        t && t.updateTransition();
      }
    }
    getViewports(e) {
      return e ? this._viewports.filter((t) => t.containsPixel(e)) : this._viewports;
    }
    getViews() {
      let e = {};
      return this.views.forEach((t) => {
        e[t.id] = t;
      }), e;
    }
    getView(e) {
      return typeof e == "string" ? this.views.find((t) => t.id === e) : e;
    }
    getViewState(e) {
      let t = this.getView(e), n = t && this.viewState[t.getViewStateId()] || this.viewState;
      return t ? t.filterViewState(n) : n;
    }
    getViewport(e) {
      return this._viewportMap[e];
    }
    unproject(e, t) {
      let n = this.getViewports(), i = { x: e[0], y: e[1] };
      for (let s = n.length - 1; s >= 0; --s) {
        let o = n[s];
        if (o.containsPixel(i)) {
          let a = e.slice();
          return a[0] -= o.x, a[1] -= o.y, o.unproject(a, t);
        }
      }
      return null;
    }
    setProps(e) {
      "views" in e && this._setViews(e.views), "viewState" in e && this._setViewState(e.viewState), ("width" in e || "height" in e) && this._setSize(e.width, e.height), this._isUpdating || this._update();
    }
    _update() {
      this._isUpdating = true, this._needsUpdate && (this._needsUpdate = false, this._rebuildViewports()), this._needsUpdate && (this._needsUpdate = false, this._rebuildViewports()), this._isUpdating = false;
    }
    _setSize(e, t) {
      (e !== this.width || t !== this.height) && (this.width = e, this.height = t, this.setNeedsUpdate("Size changed"));
    }
    _setViews(e) {
      e = nr(e, Boolean), this._diffViews(e, this.views) && this.setNeedsUpdate("views changed"), this.views = e;
    }
    _setViewState(e) {
      e ? (!ir(e, this.viewState) && this.setNeedsUpdate("viewState changed"), this.viewState = e) : F.warn("missing `viewState` or `initialViewState`")();
    }
    _onViewStateChange(e, t) {
      t.viewId = e, this._eventCallbacks.onViewStateChange && this._eventCallbacks.onViewStateChange(t);
    }
    _createController(e, t) {
      let n = t.type;
      return new n(x({ timeline: this.timeline, eventManager: this._eventManager, onViewStateChange: this._onViewStateChange.bind(this, t.id), onStateChange: this._eventCallbacks.onInteractionStateChange, makeViewport: (s) => e._getViewport(s, { width: s.width, height: s.height }) }, t));
    }
    _updateController(e, t, n, i) {
      let s = e.controller;
      return s ? (s = L(x(x(x({}, t), e.props), s), { id: e.id, x: n.x, y: n.y, width: n.width, height: n.height }), i ? i.setProps(s) : i = this._createController(e, s), i) : null;
    }
    _rebuildViewports() {
      let { width: e, height: t, views: n } = this, i = this.controllers;
      this._viewports = [], this.controllers = {};
      let s = false;
      for (let o = n.length; o--; ) {
        let a = n[o], c = this.getViewState(a), l = a.makeViewport({ width: e, height: t, viewState: c }), f = i[a.id];
        a.controller && !f && (s = true), (s || !a.controller) && f && (f.finalize(), f = null), this.controllers[a.id] = this._updateController(a, c, l, f), this._viewports.unshift(l);
      }
      for (let o in i)
        i[o] && !this.controllers[o] && i[o].finalize();
      this._buildViewportMap();
    }
    _buildViewportMap() {
      this._viewportMap = {}, this._viewports.forEach((e) => {
        e.id && (this._viewportMap[e.id] = this._viewportMap[e.id] || e);
      });
    }
    _diffViews(e, t) {
      return e.length !== t.length ? true : e.some((n, i) => !e[i].equals(t[i]));
    }
  };
  var y1 = /([0-9]+\.?[0-9]*)(%|px)/;
  function ss(r2) {
    switch (typeof r2) {
      case "number":
        return { position: r2, relative: false };
      case "string":
        let e = r2.match(y1);
        if (e && e.length >= 3) {
          let t = e[2] === "%", n = parseFloat(e[1]);
          return { position: t ? n / 100 : n, relative: t };
        }
      default:
        throw new Error("Could not parse position string ".concat(r2));
    }
  }
  function os(r2, e) {
    return r2.relative ? Math.round(r2.position * e) : r2.position;
  }
  function he(r2, e) {
    if (!r2)
      throw new Error(e || "deck.gl: assertion failed.");
  }
  var fa = class {
    constructor(e = {}) {
      let { id: t = null, x: n = 0, y: i = 0, width: s = "100%", height: o = "100%", projectionMatrix: a = null, fovy: c = 50, near: l = 0.1, far: f = 1e3, modelMatrix: u = null, viewportInstance: h = null, type: d = ft } = e;
      he(!h || h instanceof ft), this.viewportInstance = h, this.id = t || this.constructor.displayName || "view", this.type = d, this.props = L(x({}, e), { id: this.id, projectionMatrix: a, fovy: c, near: l, far: f, modelMatrix: u }), this._parseDimensions({ x: n, y: i, width: s, height: o }), this.equals = this.equals.bind(this), Object.seal(this);
    }
    equals(e) {
      return this === e ? true : this.viewportInstance ? e.viewportInstance && this.viewportInstance.equals(e.viewportInstance) : ir(this.props, e.props);
    }
    makeViewport({ width: e, height: t, viewState: n }) {
      if (this.viewportInstance)
        return this.viewportInstance;
      n = this.filterViewState(n);
      let i = this.getDimensions({ width: e, height: t });
      return this._getViewport(n, i);
    }
    getViewStateId() {
      switch (typeof this.props.viewState) {
        case "string":
          return this.props.viewState;
        case "object":
          return this.props.viewState && this.props.viewState.id;
        default:
          return this.id;
      }
    }
    filterViewState(e) {
      if (this.props.viewState && typeof this.props.viewState == "object") {
        if (!this.props.viewState.id)
          return this.props.viewState;
        let t = x({}, e);
        for (let n in this.props.viewState)
          n !== "id" && (t[n] = this.props.viewState[n]);
        return t;
      }
      return e;
    }
    getDimensions({ width: e, height: t }) {
      return { x: os(this._x, e), y: os(this._y, t), width: os(this._width, e), height: os(this._height, t) };
    }
    _getControllerProps(e) {
      let t = this.props.controller;
      return t ? t === true ? e : (typeof t == "function" && (t = { type: t }), x(x({}, e), t)) : null;
    }
    _getViewport(e, t) {
      let { type: n } = this;
      return new n(x(x(x({}, e), this.props), t));
    }
    _parseDimensions({ x: e, y: t, width: n, height: i }) {
      this._x = ss(e), this._y = ss(t), this._width = ss(n), this._height = ss(i);
    }
  };
  function ua() {
  }
  var E1 = { onStart: ua, onUpdate: ua, onInterrupt: ua, onEnd: ua };
  var ut = class {
    constructor(e) {
      this._inProgress = false, this._handle = null, this.timeline = e, this.settings = {};
    }
    get inProgress() {
      return this._inProgress;
    }
    start(e) {
      this.cancel(), this.settings = x(x({}, E1), e), this._inProgress = true, this.settings.onStart(this);
    }
    end() {
      this._inProgress && (this.timeline.removeChannel(this._handle), this._handle = null, this._inProgress = false, this.settings.onEnd(this));
    }
    cancel() {
      this._inProgress && (this.settings.onInterrupt(this), this.timeline.removeChannel(this._handle), this._handle = null, this._inProgress = false);
    }
    update() {
      if (!this._inProgress)
        return false;
      if (this._handle === null) {
        let { timeline: e, settings: t } = this;
        this._handle = e.addChannel({ delay: e.getTime(), duration: t.duration });
      }
      return this.time = this.timeline.getTime(this._handle), this._onUpdate(), this.settings.onUpdate(this), this.timeline.isFinished(this._handle) && this.end(), true;
    }
    _onUpdate() {
    }
  };
  var as = () => {
  };
  var cs = { BREAK: 1, SNAP_TO_END: 2, IGNORE: 3 };
  var vm = { transitionEasing: (r2) => r2, transitionInterruption: cs.BREAK, onTransitionStart: as, onTransitionInterrupt: as, onTransitionEnd: as };
  var ha = class {
    constructor(e, t = {}) {
      this.ControllerState = e, this.props = x(x({}, vm), t), this.propsInTransition = null, this.transition = new ut(t.timeline), this.onViewStateChange = t.onViewStateChange || as, this.onStateChange = t.onStateChange || as, this._onTransitionUpdate = this._onTransitionUpdate.bind(this);
    }
    finalize() {
      this.transition.cancel();
    }
    getViewportInTransition() {
      return this.propsInTransition;
    }
    processViewStateChange(e) {
      let t = false, n = this.props;
      if (e = x(x({}, vm), e), this.props = e, this._shouldIgnoreViewportChange(n, e))
        return t;
      if (this._isTransitionEnabled(e)) {
        let { interruption: i, endProps: s } = this.transition.settings, o = x(x({}, n), i === cs.SNAP_TO_END ? s : this.propsInTransition || n);
        this._triggerTransition(o, e), t = true;
      } else
        this.transition.cancel();
      return t;
    }
    updateTransition() {
      this.transition.update();
    }
    _isTransitionEnabled(e) {
      let { transitionDuration: t, transitionInterpolator: n } = e;
      return (t > 0 || t === "auto") && Boolean(n);
    }
    _isUpdateDueToCurrentTransition(e) {
      return this.transition.inProgress ? this.transition.settings.interpolator.arePropsEqual(e, this.propsInTransition) : false;
    }
    _shouldIgnoreViewportChange(e, t) {
      return this.transition.inProgress ? this.transition.settings.interruption === cs.IGNORE || this._isUpdateDueToCurrentTransition(t) : this._isTransitionEnabled(t) ? t.transitionInterpolator.arePropsEqual(e, t) : true;
    }
    _triggerTransition(e, t) {
      let n = new this.ControllerState(e), i = new this.ControllerState(t).shortestPathFrom(n), { transitionInterpolator: s } = t, o = s.getDuration ? s.getDuration(e, t) : t.transitionDuration;
      if (o === 0)
        return;
      let a = t.transitionInterpolator.initializeProps(e, i);
      this.propsInTransition = {}, this.duration = o, this.transition.start({ duration: o, easing: t.transitionEasing, interpolator: t.transitionInterpolator, interruption: t.transitionInterruption, startProps: a.start, endProps: a.end, onStart: t.onTransitionStart, onUpdate: this._onTransitionUpdate, onInterrupt: this._onTransitionEnd(t.onTransitionInterrupt), onEnd: this._onTransitionEnd(t.onTransitionEnd) }), this.onStateChange({ inTransition: true }), this.updateTransition();
    }
    _onTransitionEnd(e) {
      return (t) => {
        this.propsInTransition = null, this.onStateChange({ inTransition: false, isZooming: false, isPanning: false, isRotating: false }), e(t);
      };
    }
    _onTransitionUpdate(e) {
      let { time: t, settings: { interpolator: n, startProps: i, endProps: s, duration: o, easing: a } } = e, c = a(t / o), l = n.interpolateProps(i, s, c);
      this.propsInTransition = new this.ControllerState(x(x({}, this.props), l)).getViewportProps(), this.onViewStateChange({ viewState: this.propsInTransition, oldViewState: this.props });
    }
  };
  var da = class {
    constructor(e = {}) {
      Array.isArray(e) && (e = { compare: e, extract: e, required: e });
      let { compare: t, extract: n, required: i } = e;
      this._propsToCompare = t, this._propsToExtract = n, this._requiredProps = i;
    }
    arePropsEqual(e, t) {
      for (let n of this._propsToCompare || Object.keys(t))
        if (!(n in e) || !(n in t) || !Ke(e[n], t[n]))
          return false;
      return true;
    }
    initializeProps(e, t) {
      let n;
      if (this._propsToExtract) {
        let i = {}, s = {};
        for (let o of this._propsToExtract)
          i[o] = e[o], s[o] = t[o];
        n = { start: i, end: s };
      } else
        n = { start: e, end: t };
      return this._checkRequiredProps(n.start), this._checkRequiredProps(n.end), n;
    }
    interpolateProps(e, t, n) {
      return t;
    }
    getDuration(e, t) {
      return t.transitionDuration;
    }
    _checkRequiredProps(e) {
      !this._requiredProps || this._requiredProps.forEach((t) => {
        let n = e[t];
        he(Number.isFinite(n) || Array.isArray(n), "".concat(t, " is required for transition"));
      });
    }
  };
  var Am = ["longitude", "latitude", "zoom", "bearing", "pitch"];
  var b1 = ["longitude", "latitude", "zoom"];
  var ls = class extends da {
    constructor(e = {}) {
      let t = Array.isArray(e) ? e : e.transitionProps;
      super(t || { compare: Am, extract: Am, required: b1 });
      this.opts = e;
    }
    initializeProps(e, t) {
      let n = super.initializeProps(e, t), { makeViewport: i, around: s } = this.opts;
      if (i && s) {
        let o = i(e), a = i(t), c = o.unproject(s);
        n.start.around = s, Object.assign(n.end, { around: a.project(c), aroundPosition: c, width: t.width, height: t.height });
      }
      return n;
    }
    interpolateProps(e, t, n) {
      let i = {};
      for (let s of this._propsToExtract)
        i[s] = Et(e[s] || 0, t[s] || 0, n);
      if (t.aroundPosition) {
        let s = this.opts.makeViewport(x(x({}, t), i));
        Object.assign(i, s.panByPosition(t.aroundPosition, Et(e.around, t.around, n)));
      }
      return i;
    }
  };
  var Mr = { transitionDuration: 0 };
  var T1 = { transitionDuration: 300, transitionEasing: (r2) => r2, transitionInterruption: cs.BREAK };
  var v1 = 300;
  var pa = (r2) => 1 - (1 - r2) * (1 - r2);
  var qn = { WHEEL: ["wheel"], PAN: ["panstart", "panmove", "panend"], PINCH: ["pinchstart", "pinchmove", "pinchend"], TRIPLE_PAN: ["tripanstart", "tripanmove", "tripanend"], DOUBLE_TAP: ["doubletap"], KEYBOARD: ["keydown"] };
  var ma = class {
    constructor(e, t = {}) {
      this.ControllerState = e, this.controllerState = null, this.controllerStateProps = null, this.eventManager = null, this.transitionManager = new ha(e, L(x({}, t), { onViewStateChange: this._onTransition.bind(this), onStateChange: this._setInteractionState.bind(this) }));
      let n = this.linearTransitionProps;
      this._transition = n && L(x({}, T1), { transitionInterpolator: new ls({ transitionProps: n }) }), this._events = null, this._interactionState = { isDragging: false }, this._customEvents = [], this.onViewStateChange = null, this.onStateChange = null, this.handleEvent = this.handleEvent.bind(this), this.setProps(t);
    }
    get linearTransitionProps() {
      return null;
    }
    set events(e) {
      this.toggleEvents(this._customEvents, false), this.toggleEvents(e, true), this._customEvents = e, this.setProps(this.controllerStateProps);
    }
    finalize() {
      for (let e in this._events)
        this._events[e] && this.eventManager.off(e, this.handleEvent);
      this.transitionManager.finalize();
    }
    handleEvent(e) {
      let { ControllerState: t } = this;
      this.controllerState = new t(x(x({ makeViewport: this.makeViewport }, this.controllerStateProps), this._state));
      let n = this._eventStartBlocked;
      switch (e.type) {
        case "panstart":
          return n ? false : this._onPanStart(e);
        case "panmove":
          return this._onPan(e);
        case "panend":
          return this._onPanEnd(e);
        case "pinchstart":
          return n ? false : this._onPinchStart(e);
        case "pinchmove":
          return this._onPinch(e);
        case "pinchend":
          return this._onPinchEnd(e);
        case "tripanstart":
          return n ? false : this._onTriplePanStart(e);
        case "tripanmove":
          return this._onTriplePan(e);
        case "tripanend":
          return this._onTriplePanEnd(e);
        case "doubletap":
          return this._onDoubleTap(e);
        case "wheel":
          return this._onWheel(e);
        case "keydown":
          return this._onKeyDown(e);
        default:
          return false;
      }
    }
    getCenter(e) {
      let { x: t, y: n } = this.controllerStateProps, { offsetCenter: i } = e;
      return [i.x - t, i.y - n];
    }
    isPointInBounds(e, t) {
      let { width: n, height: i } = this.controllerStateProps;
      if (t && t.handled)
        return false;
      let s = e[0] >= 0 && e[0] <= n && e[1] >= 0 && e[1] <= i;
      return s && t && t.stopPropagation(), s;
    }
    isFunctionKeyPressed(e) {
      let { srcEvent: t } = e;
      return Boolean(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey);
    }
    isDragging() {
      return this._interactionState.isDragging;
    }
    blockEvents(e) {
      let t = setTimeout(() => {
        this._eventStartBlocked === t && (this._eventStartBlocked = null);
      }, e);
      this._eventStartBlocked = t;
    }
    setProps(e) {
      "onViewStateChange" in e && (this.onViewStateChange = e.onViewStateChange), "onStateChange" in e && (this.onStateChange = e.onStateChange), "makeViewport" in e && (this.makeViewport = e.makeViewport), "dragMode" in e && (this.dragMode = e.dragMode), this.controllerStateProps = e, "eventManager" in e && this.eventManager !== e.eventManager && (this.eventManager = e.eventManager, this._events = {}, this.toggleEvents(this._customEvents, true)), "transitionInterpolator" in e || (e.transitionInterpolator = this._getTransitionProps().transitionInterpolator), this.transitionManager.processViewStateChange(e);
      let { inertia: t } = e;
      t === true && (t = v1), this.inertia = t;
      let { scrollZoom: n = true, dragPan: i = true, dragRotate: s = true, doubleClickZoom: o = true, touchZoom: a = true, touchRotate: c = false, keyboard: l = true } = e, f = Boolean(this.onViewStateChange);
      this.toggleEvents(qn.WHEEL, f && n), this.toggleEvents(qn.PAN, f && (i || s)), this.toggleEvents(qn.PINCH, f && (a || c)), this.toggleEvents(qn.TRIPLE_PAN, f && c), this.toggleEvents(qn.DOUBLE_TAP, f && o), this.toggleEvents(qn.KEYBOARD, f && l), this.scrollZoom = n, this.dragPan = i, this.dragRotate = s, this.doubleClickZoom = o, this.touchZoom = a, this.touchRotate = c, this.keyboard = l;
    }
    updateTransition() {
      this.transitionManager.updateTransition();
    }
    toggleEvents(e, t) {
      this.eventManager && e.forEach((n) => {
        this._events[n] !== t && (this._events[n] = t, t ? this.eventManager.on(n, this.handleEvent) : this.eventManager.off(n, this.handleEvent));
      });
    }
    updateViewport(e, t = {}, n = {}) {
      let i = x(x({}, e.getViewportProps()), t), s = this.controllerState !== e;
      if (this._state = e.getState(), this._setInteractionState(n), s) {
        let o = this.controllerState ? this.controllerState.getViewportProps() : null;
        this.onViewStateChange && this.onViewStateChange({ viewState: i, interactionState: this._interactionState, oldViewState: o });
      }
    }
    _onTransition(e) {
      this.onViewStateChange && (e.interactionState = this._interactionState, this.onViewStateChange(e));
    }
    _setInteractionState(e) {
      Object.assign(this._interactionState, e), this.onStateChange && this.onStateChange(this._interactionState);
    }
    _onPanStart(e) {
      let t = this.getCenter(e);
      if (!this.isPointInBounds(t, e))
        return false;
      let n = this.isFunctionKeyPressed(e) || e.rightButton;
      (this.invertPan || this.dragMode === "pan") && (n = !n);
      let i = this.controllerState[n ? "panStart" : "rotateStart"]({ pos: t });
      return this._panMove = n, this.updateViewport(i, Mr, { isDragging: true }), true;
    }
    _onPan(e) {
      return this.isDragging() ? this._panMove ? this._onPanMove(e) : this._onPanRotate(e) : false;
    }
    _onPanEnd(e) {
      return this.isDragging() ? this._panMove ? this._onPanMoveEnd(e) : this._onPanRotateEnd(e) : false;
    }
    _onPanMove(e) {
      if (!this.dragPan)
        return false;
      let t = this.getCenter(e), n = this.controllerState.pan({ pos: t });
      return this.updateViewport(n, Mr, { isDragging: true, isPanning: true }), true;
    }
    _onPanMoveEnd(e) {
      let { inertia: t } = this;
      if (this.dragPan && t && e.velocity) {
        let n = this.getCenter(e), i = [n[0] + e.velocityX * t / 2, n[1] + e.velocityY * t / 2], s = this.controllerState.pan({ pos: i }).panEnd();
        this.updateViewport(s, L(x({}, this._getTransitionProps()), { transitionDuration: t, transitionEasing: pa }), { isDragging: false, isPanning: true });
      } else {
        let n = this.controllerState.panEnd();
        this.updateViewport(n, null, { isDragging: false, isPanning: false });
      }
      return true;
    }
    _onPanRotate(e) {
      if (!this.dragRotate)
        return false;
      let t = this.getCenter(e), n = this.controllerState.rotate({ pos: t });
      return this.updateViewport(n, Mr, { isDragging: true, isRotating: true }), true;
    }
    _onPanRotateEnd(e) {
      let { inertia: t } = this;
      if (this.dragRotate && t && e.velocity) {
        let n = this.getCenter(e), i = [n[0] + e.velocityX * t / 2, n[1] + e.velocityY * t / 2], s = this.controllerState.rotate({ pos: i }).rotateEnd();
        this.updateViewport(s, L(x({}, this._getTransitionProps()), { transitionDuration: t, transitionEasing: pa }), { isDragging: false, isRotating: true });
      } else {
        let n = this.controllerState.rotateEnd();
        this.updateViewport(n, null, { isDragging: false, isRotating: false });
      }
      return true;
    }
    _onWheel(e) {
      if (!this.scrollZoom)
        return false;
      e.preventDefault();
      let t = this.getCenter(e);
      if (!this.isPointInBounds(t, e))
        return false;
      let { speed: n = 0.01, smooth: i = false } = this.scrollZoom, { delta: s } = e, o = 2 / (1 + Math.exp(-Math.abs(s * n)));
      s < 0 && o !== 0 && (o = 1 / o);
      let a = this.controllerState.zoom({ pos: t, scale: o });
      return this.updateViewport(a, L(x({}, this._getTransitionProps({ around: t })), { transitionDuration: i ? 250 : 1 }), { isZooming: true, isPanning: true }), true;
    }
    _onTriplePanStart(e) {
      let t = this.getCenter(e);
      if (!this.isPointInBounds(t, e))
        return false;
      let n = this.controllerState.rotateStart({ pos: t });
      return this.updateViewport(n, Mr, { isDragging: true }), true;
    }
    _onTriplePan(e) {
      if (!this.touchRotate || !this.isDragging())
        return false;
      let t = this.getCenter(e);
      t[0] -= e.deltaX;
      let n = this.controllerState.rotate({ pos: t });
      return this.updateViewport(n, Mr, { isDragging: true, isRotating: true }), true;
    }
    _onTriplePanEnd(e) {
      if (!this.isDragging())
        return false;
      let { inertia: t } = this;
      if (this.touchRotate && t && e.velocityY) {
        let n = this.getCenter(e), i = [n[0], n[1] += e.velocityY * t / 2], s = this.controllerState.rotate({ pos: i });
        this.updateViewport(s, L(x({}, this._getTransitionProps()), { transitionDuration: t, transitionEasing: pa }), { isDragging: false, isRotating: true }), this.blockEvents(t);
      } else {
        let n = this.controllerState.rotateEnd();
        this.updateViewport(n, null, { isDragging: false, isRotating: false });
      }
      return true;
    }
    _onPinchStart(e) {
      let t = this.getCenter(e);
      if (!this.isPointInBounds(t, e))
        return false;
      let n = this.controllerState.zoomStart({ pos: t }).rotateStart({ pos: t });
      return this._startPinchRotation = e.rotation, this._lastPinchEvent = e, this.updateViewport(n, Mr, { isDragging: true }), true;
    }
    _onPinch(e) {
      if (!this.touchZoom && !this.touchRotate || !this.isDragging())
        return false;
      let t = this.controllerState;
      if (this.touchZoom) {
        let { scale: n } = e, i = this.getCenter(e);
        t = t.zoom({ pos: i, scale: n });
      }
      if (this.touchRotate) {
        let { rotation: n } = e;
        t = t.rotate({ deltaAngleX: this._startPinchRotation - n });
      }
      return this.updateViewport(t, Mr, { isDragging: true, isPanning: this.touchZoom, isZooming: this.touchZoom, isRotating: this.touchRotate }), this._lastPinchEvent = e, true;
    }
    _onPinchEnd(e) {
      if (!this.isDragging())
        return false;
      let { inertia: t, _lastPinchEvent: n } = this;
      if (this.touchZoom && t && n && e.scale !== n.scale) {
        let i = this.getCenter(e), s = this.controllerState.rotateEnd(), o = Math.log2(e.scale), a = (o - Math.log2(n.scale)) / (e.deltaTime - n.deltaTime), c = Math.pow(2, o + a * t / 2);
        s = s.zoom({ pos: i, scale: c }).zoomEnd(), this.updateViewport(s, L(x({}, this._getTransitionProps({ around: i })), { transitionDuration: t, transitionEasing: pa }), { isDragging: false, isPanning: this.touchZoom, isZooming: this.touchZoom, isRotating: false }), this.blockEvents(t);
      } else {
        let i = this.controllerState.zoomEnd().rotateEnd();
        this.updateViewport(i, null, { isDragging: false, isPanning: false, isZooming: false, isRotating: false });
      }
      return this._startPinchRotation = null, this._lastPinchEvent = null, true;
    }
    _onDoubleTap(e) {
      if (!this.doubleClickZoom)
        return false;
      let t = this.getCenter(e);
      if (!this.isPointInBounds(t, e))
        return false;
      let n = this.isFunctionKeyPressed(e), i = this.controllerState.zoom({ pos: t, scale: n ? 0.5 : 2 });
      return this.updateViewport(i, this._getTransitionProps({ around: t }), { isZooming: true, isPanning: true }), this.blockEvents(100), true;
    }
    _onKeyDown(e) {
      if (!this.keyboard)
        return false;
      let t = this.isFunctionKeyPressed(e), { zoomSpeed: n, moveSpeed: i, rotateSpeedX: s, rotateSpeedY: o } = this.keyboard, { controllerState: a } = this, c, l = {};
      switch (e.srcEvent.code) {
        case "Minus":
          c = t ? a.zoomOut(n).zoomOut(n) : a.zoomOut(n), l.isZooming = true;
          break;
        case "Equal":
          c = t ? a.zoomIn(n).zoomIn(n) : a.zoomIn(n), l.isZooming = true;
          break;
        case "ArrowLeft":
          t ? (c = a.rotateLeft(s), l.isRotating = true) : (c = a.moveLeft(i), l.isPanning = true);
          break;
        case "ArrowRight":
          t ? (c = a.rotateRight(s), l.isRotating = true) : (c = a.moveRight(i), l.isPanning = true);
          break;
        case "ArrowUp":
          t ? (c = a.rotateUp(o), l.isRotating = true) : (c = a.moveUp(i), l.isPanning = true);
          break;
        case "ArrowDown":
          t ? (c = a.rotateDown(o), l.isRotating = true) : (c = a.moveDown(i), l.isPanning = true);
          break;
        default:
          return false;
      }
      return this.updateViewport(c, this._getTransitionProps(), l), true;
    }
    _getTransitionProps(e) {
      let { _transition: t } = this;
      return t ? e ? L(x({}, t), { transitionInterpolator: new ls(L(x({}, e), { transitionProps: this.linearTransitionProps, makeViewport: this.controllerState.makeViewport })) }) : t : Mr;
    }
  };
  var ga = class {
    constructor(e) {
      this._viewportProps = this._applyConstraints(e);
    }
    getViewportProps() {
      return this._viewportProps;
    }
    getState() {
      return this._state;
    }
    shortestPathFrom(e) {
      return this._viewportProps;
    }
    _applyConstraints(e) {
      return e;
    }
  };
  var Sm = 5;
  var A1 = 1.2;
  var rn = { pitch: 0, bearing: 0, altitude: 1.5, minZoom: 0, maxZoom: 20, minPitch: 0, maxPitch: 60 };
  var wm = class extends ga {
    constructor({ makeViewport: e, width: t, height: n, latitude: i, longitude: s, zoom: o, bearing: a = rn.bearing, pitch: c = rn.pitch, altitude: l = rn.altitude, maxZoom: f = rn.maxZoom, minZoom: u = rn.minZoom, maxPitch: h = rn.maxPitch, minPitch: d = rn.minPitch, startPanLngLat: m, startZoomLngLat: _, startRotatePos: E, startBearing: b, startPitch: T, startZoom: v, normalize: C } = {}) {
      he(Number.isFinite(s)), he(Number.isFinite(i)), he(Number.isFinite(o));
      super({ width: t, height: n, latitude: i, longitude: s, zoom: o, bearing: a, pitch: c, altitude: l, maxZoom: f, minZoom: u, maxPitch: h, minPitch: d, normalize: C });
      this._state = { startPanLngLat: m, startZoomLngLat: _, startRotatePos: E, startBearing: b, startPitch: T, startZoom: v }, this.makeViewport = e;
    }
    panStart({ pos: e }) {
      return this._getUpdatedState({ startPanLngLat: this._unproject(e) });
    }
    pan({ pos: e, startPos: t }) {
      let n = this._state.startPanLngLat || this._unproject(t);
      if (!n)
        return this;
      let s = this.makeViewport(this._viewportProps).panByPosition(n, e);
      return this._getUpdatedState(s);
    }
    panEnd() {
      return this._getUpdatedState({ startPanLngLat: null });
    }
    rotateStart({ pos: e }) {
      return this._getUpdatedState({ startRotatePos: e, startBearing: this._viewportProps.bearing, startPitch: this._viewportProps.pitch });
    }
    rotate({ pos: e, deltaAngleX: t = 0, deltaAngleY: n = 0 }) {
      let { startRotatePos: i, startBearing: s, startPitch: o } = this._state;
      if (!i || !Number.isFinite(s) || !Number.isFinite(o))
        return this;
      let a;
      return e ? a = this._calculateNewPitchAndBearing(L(x({}, this._getRotationParams(e, i)), { startBearing: s, startPitch: o })) : a = { bearing: s + t, pitch: o + n }, this._getUpdatedState(a);
    }
    rotateEnd() {
      return this._getUpdatedState({ startBearing: null, startPitch: null });
    }
    zoomStart({ pos: e }) {
      return this._getUpdatedState({ startZoomLngLat: this._unproject(e), startZoom: this._viewportProps.zoom });
    }
    zoom({ pos: e, startPos: t, scale: n }) {
      let { startZoom: i, startZoomLngLat: s } = this._state;
      Number.isFinite(i) || (i = this._viewportProps.zoom, s = this._unproject(t) || this._unproject(e));
      let o = this._calculateNewZoom({ scale: n, startZoom: i }), a = this.makeViewport(L(x({}, this._viewportProps), { zoom: o }));
      return this._getUpdatedState(x({ zoom: o }, a.panByPosition(s, e)));
    }
    zoomEnd() {
      return this._getUpdatedState({ startZoomLngLat: null, startZoom: null });
    }
    zoomIn(e = 2) {
      return this._zoomFromCenter(e);
    }
    zoomOut(e = 2) {
      return this._zoomFromCenter(1 / e);
    }
    moveLeft(e = 100) {
      return this._panFromCenter([e, 0]);
    }
    moveRight(e = 100) {
      return this._panFromCenter([-e, 0]);
    }
    moveUp(e = 100) {
      return this._panFromCenter([0, e]);
    }
    moveDown(e = 100) {
      return this._panFromCenter([0, -e]);
    }
    rotateLeft(e = 15) {
      return this._getUpdatedState({ bearing: this._viewportProps.bearing - e });
    }
    rotateRight(e = 15) {
      return this._getUpdatedState({ bearing: this._viewportProps.bearing + e });
    }
    rotateUp(e = 10) {
      return this._getUpdatedState({ pitch: this._viewportProps.pitch + e });
    }
    rotateDown(e = 10) {
      return this._getUpdatedState({ pitch: this._viewportProps.pitch - e });
    }
    shortestPathFrom(e) {
      let t = e.getViewportProps(), n = x({}, this._viewportProps), { bearing: i, longitude: s } = n;
      return Math.abs(i - t.bearing) > 180 && (n.bearing = i < 0 ? i + 360 : i - 360), Math.abs(s - t.longitude) > 180 && (n.longitude = s < 0 ? s + 360 : s - 360), n;
    }
    _zoomFromCenter(e) {
      let { width: t, height: n } = this._viewportProps;
      return this.zoom({ pos: [t / 2, n / 2], scale: e });
    }
    _panFromCenter(e) {
      let { width: t, height: n } = this._viewportProps;
      return this.pan({ startPos: [t / 2, n / 2], pos: [t / 2 + e[0], n / 2 + e[1]] });
    }
    _getUpdatedState(e) {
      return new this.constructor(x(x(x({ makeViewport: this.makeViewport }, this._viewportProps), this._state), e));
    }
    _applyConstraints(e) {
      let { maxZoom: t, minZoom: n, zoom: i } = e;
      e.zoom = Mn(i, n, t);
      let { maxPitch: s, minPitch: o, pitch: a } = e;
      e.pitch = Mn(a, o, s);
      let { normalize: c = true } = e;
      return c && Object.assign(e, ta(e)), e;
    }
    _unproject(e) {
      let t = this.makeViewport(this._viewportProps);
      return e && t.unproject(e);
    }
    _calculateNewZoom({ scale: e, startZoom: t }) {
      let { maxZoom: n, minZoom: i } = this._viewportProps, s = t + Math.log2(e);
      return Mn(s, i, n);
    }
    _calculateNewPitchAndBearing({ deltaScaleX: e, deltaScaleY: t, startBearing: n, startPitch: i }) {
      t = Mn(t, -1, 1);
      let { minPitch: s, maxPitch: o } = this._viewportProps, a = n + 180 * e, c = i;
      return t > 0 ? c = i + t * (o - i) : t < 0 && (c = i - t * (s - i)), { pitch: c, bearing: a };
    }
    _getRotationParams(e, t) {
      let n = e[0] - t[0], i = e[1] - t[1], s = e[1], o = t[1], { width: a, height: c } = this._viewportProps, l = n / a, f = 0;
      return i > 0 ? Math.abs(c - o) > Sm && (f = i / (o - c) * A1) : i < 0 && o > Sm && (f = 1 - s / o), f = Math.min(1, Math.max(-1, f)), { deltaScaleX: l, deltaScaleY: f };
    }
  };
  var _a = class extends ma {
    constructor(e) {
      e.dragMode = e.dragMode || "pan";
      super(wm, e);
    }
    setProps(e) {
      let t = this.controllerStateProps;
      super.setProps(e), (!t || t.height !== e.height) && this.updateViewport(new this.ControllerState(x(x({ makeViewport: this.makeViewport }, this.controllerStateProps), this._state)));
    }
    get linearTransitionProps() {
      return ["longitude", "latitude", "zoom", "bearing", "pitch"];
    }
  };
  var fs = class extends fa {
    constructor(e) {
      super(L(x({}, e), { type: Je }));
    }
    get controller() {
      return this._getControllerProps({ type: _a });
    }
  };
  fs.displayName = "MapView";
  var S1 = new ns();
  var xa = class {
    constructor() {
      this.effects = [], this._internalEffects = [], this._needsRedraw = "Initial render", this.setEffects();
    }
    setProps(e) {
      "effects" in e && (e.effects.length !== this.effects.length || !ir(e.effects, this.effects)) && (this.setEffects(e.effects), this._needsRedraw = "effects changed");
    }
    needsRedraw(e = { clearRedrawFlags: false }) {
      let t = this._needsRedraw;
      return e.clearRedrawFlags && (this._needsRedraw = false), t;
    }
    getEffects() {
      return this._internalEffects;
    }
    finalize() {
      this.cleanup();
    }
    setEffects(e = []) {
      this.cleanup(), this.effects = e, this._createInternalEffects();
    }
    cleanup() {
      for (let e of this.effects)
        e.cleanup();
      for (let e of this._internalEffects)
        e.cleanup();
      this.effects.length = 0, this._internalEffects.length = 0;
    }
    _createInternalEffects() {
      this._internalEffects = this.effects.slice(), this.effects.some((e) => e instanceof ns) || this._internalEffects.push(S1);
    }
  };
  var ya = class extends Lr {
  };
  var Pm = { blendFunc: [1, 0, 32771, 0], blendEquation: 32774 };
  var Zn = class extends Lr {
    render(e) {
      e.pickingFBO ? (this.useAlpha = true, this._drawPickingBuffer(e)) : (this.useAlpha = false, super.render(e));
    }
    _drawPickingBuffer({ layers: e, layerFilter: t, views: n, viewports: i, onViewportActive: s, pickingFBO: o, deviceRect: { x: a, y: c, width: l, height: f }, pass: u = "picking", redrawReason: h, pickZ: d }) {
      let m = this.gl;
      return this.pickZ = d, ae(m, L(x({ scissorTest: true, scissor: [a, c, l, f], clearColor: [0, 0, 0, 0], depthMask: true, depthTest: true, depthRange: [0, 1], colorMask: [true, true, true, true] }, Pm), { blend: !d }), () => {
        super.render({ target: o, layers: e, layerFilter: t, views: n, viewports: i, onViewportActive: s, pass: u, redrawReason: h });
      });
    }
    shouldDrawLayer(e) {
      return e.props.pickable;
    }
    getModuleParameters() {
      return { pickingActive: 1, pickingAttribute: this.pickZ, lightSources: {} };
    }
    getLayerParameters(e, t) {
      let n = this.pickZ ? { blend: false } : L(x({}, Pm), { blend: true, blendColor: [0, 0, 0, this.useAlpha ? (t + 1) / 255 : 1] });
      return x(x({}, e.props.parameters), n);
    }
  };
  var w1 = "deckRenderer.renderLayers";
  var Ea = class {
    constructor(e) {
      this.gl = e, this.layerFilter = null, this.drawPickingColors = false, this.drawLayersPass = new ya(e), this.pickLayersPass = new Zn(e), this.renderCount = 0, this._needsRedraw = "Initial render", this.renderBuffers = [], this.lastPostProcessEffect = null;
    }
    setProps(e) {
      "layerFilter" in e && this.layerFilter !== e.layerFilter && (this.layerFilter = e.layerFilter, this._needsRedraw = "layerFilter changed"), "drawPickingColors" in e && this.drawPickingColors !== e.drawPickingColors && (this.drawPickingColors = e.drawPickingColors, this._needsRedraw = "drawPickingColors changed");
    }
    renderLayers(e) {
      let t = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;
      e.layerFilter = this.layerFilter, e.effects = e.effects || [], e.target = e.target || Z.getDefaultFramebuffer(this.gl), this._preRender(e.effects, e);
      let n = this.lastPostProcessEffect ? this.renderBuffers[0] : e.target, i = t.render(L(x({}, e), { target: n }));
      this._postRender(e.effects, e), this.renderCount++, se(w1, this, i, e);
    }
    needsRedraw(e = { clearRedrawFlags: false }) {
      let t = this._needsRedraw;
      return e.clearRedrawFlags && (this._needsRedraw = false), t;
    }
    finalize() {
      let { renderBuffers: e } = this;
      for (let t of e)
        t.delete();
      e.length = 0;
    }
    _preRender(e, t) {
      let n = null;
      for (let i of e)
        i.preRender(this.gl, t), i.postRender && (n = i);
      n && this._resizeRenderBuffers(), this.lastPostProcessEffect = n;
    }
    _resizeRenderBuffers() {
      let { renderBuffers: e } = this;
      e.length === 0 && e.push(new Z(this.gl), new Z(this.gl));
      for (let t of e)
        t.resize();
    }
    _postRender(e, t) {
      let { renderBuffers: n } = this, i = { inputBuffer: n[0], swapBuffer: n[1], target: null };
      for (let s of e)
        if (s.postRender) {
          if (s === this.lastPostProcessEffect) {
            i.target = t.target, s.postRender(this.gl, i);
            break;
          }
          let o = s.postRender(this.gl, i);
          i.inputBuffer = o, i.swapBuffer = o === n[0] ? n[1] : n[0];
        }
    }
  };
  var P1 = { pickedColor: null, pickedLayer: null, pickedObjectIndex: -1 };
  function Lm({ pickedColors: r2, layers: e, deviceX: t, deviceY: n, deviceRadius: i, deviceRect: s }) {
    if (r2) {
      let { x: o, y: a, width: c, height: l } = s, f = i * i, u = -1, h = 0;
      for (let d = 0; d < l; d++) {
        let m = d + a - n, _ = m * m;
        if (_ > f)
          h += 4 * c;
        else
          for (let E = 0; E < c; E++) {
            if (r2[h + 3] - 1 >= 0) {
              let T = E + o - t, v = T * T + _;
              v <= f && (f = v, u = h);
            }
            h += 4;
          }
      }
      if (u >= 0) {
        let d = r2[u + 3] - 1, m = r2.slice(u, u + 4), _ = e[d];
        if (_) {
          let E = _.decodePickingColor(m), b = Math.floor(u / 4 / c), T = u / 4 - b * c;
          return { pickedColor: m, pickedLayer: _, pickedObjectIndex: E, pickedX: o + T, pickedY: a + b };
        }
        F.error("Picked non-existent layer. Is picking buffer corrupt?")();
      }
    }
    return P1;
  }
  function Cm({ pickedColors: r2, layers: e }) {
    let t = new Map();
    if (r2)
      for (let n = 0; n < r2.length; n += 4) {
        let i = r2[n + 3] - 1;
        if (i >= 0) {
          let s = r2.slice(n, n + 4), o = s.join(",");
          if (!t.has(o)) {
            let a = e[i];
            a ? t.set(o, { pickedColor: s, pickedLayer: a, pickedObjectIndex: a.decodePickingColor(s) }) : F.error("Picked non-existent layer. Is picking buffer corrupt?")();
          }
        }
      }
    return Array.from(t.values());
  }
  function Rf({ pickInfo: r2, mode: e, viewports: t, layerFilter: n, pixelRatio: i, x: s, y: o, z: a }) {
    let c = r2 && r2.pickedLayer, f = L1(t, { x: s, y: o }, n && c && ((h) => n({ layer: c, viewport: h, isPicking: true, renderPass: "picking:".concat(e) }))), u = f && f.unproject([s - f.x, o - f.y], { targetZ: a });
    return { color: null, layer: null, viewport: f, index: -1, picked: false, x: s, y: o, pixel: [s, o], coordinate: u, devicePixel: r2 && [r2.pickedX, r2.pickedY], pixelRatio: i };
  }
  function Rm(r2) {
    let { pickInfo: e, lastPickedInfo: t, mode: n, layers: i } = r2, { pickedColor: s, pickedLayer: o, pickedObjectIndex: a } = e, c = o ? [o] : [];
    if (n === "hover") {
      let u = t.index, h = t.layerId, d = o && o.props.id;
      if (d !== h || a !== u) {
        if (d !== h) {
          let m = i.find((_) => _.props.id === h);
          m && c.unshift(m);
        }
        t.layerId = d, t.index = a, t.info = null;
      }
    }
    let l = Rf(r2), f = new Map();
    return f.set(null, l), c.forEach((u) => {
      let h = x({}, l);
      u === o && (h.color = s, h.index = a, h.picked = true), h = Mf({ layer: u, info: h, mode: n }), u === o && n === "hover" && (t.info = h), f.set(h.layer.id, h), n === "hover" && h.layer.updateAutoHighlight(h);
    }), f;
  }
  function Mf({ layer: r2, info: e, mode: t }) {
    for (; r2 && e; ) {
      let n = e.layer || null;
      e.sourceLayer = n, e.layer = r2, e = r2.getPickingInfo({ info: e, mode: t, sourceLayer: n }), r2 = r2.parent;
    }
    return e;
  }
  function L1(r2, e, t) {
    for (let n = r2.length - 1; n >= 0; n--) {
      let i = r2[n];
      if (i.containsPixel(e) && (!t || t(i)))
        return i;
    }
    return r2[0];
  }
  var ba = class {
    constructor(e) {
      this.gl = e, this.pickingFBO = null, this.pickLayersPass = new Zn(e), this.layerFilter = null, this.lastPickedInfo = { index: -1, layerId: null, info: null };
    }
    setProps(e) {
      "layerFilter" in e && (this.layerFilter = e.layerFilter), "_pickable" in e && (this._pickable = e._pickable);
    }
    finalize() {
      this.pickingFBO && this.pickingFBO.delete(), this.depthFBO && (this.depthFBO.color.delete(), this.depthFBO.delete());
    }
    pickObject(e) {
      return this._pickClosestObject(e);
    }
    pickObjects(e) {
      return this._pickVisibleObjects(e);
    }
    getLastPickedObject({ x: e, y: t, layers: n, viewports: i }, s = this.lastPickedInfo.info) {
      let o = s && s.layer && s.layer.id, a = s && s.viewport && s.viewport.id, c = o ? n.find((h) => h.id === o) : null, l = a && i.find((h) => h.id === a) || i[0], f = l && l.unproject([e - l.x, t - l.y]), u = { x: e, y: t, viewport: l, coordinate: f, layer: c };
      return c ? x(x({}, s), u) : Object.assign(u, { color: null, object: null, index: -1 });
    }
    _resizeBuffer() {
      let { gl: e } = this;
      return this.pickingFBO || (this.pickingFBO = new Z(e), Z.isSupported(e, { colorBufferFloat: true }) && (this.depthFBO = new Z(e), this.depthFBO.attach({ [36064]: new Q(e, { format: U(e) ? 34836 : 6408, type: 5126 }) }))), this.pickingFBO.resize({ width: e.canvas.width, height: e.canvas.height }), this.depthFBO && this.depthFBO.resize({ width: e.canvas.width, height: e.canvas.height }), this.pickingFBO;
    }
    _getPickable(e) {
      if (this._pickable === false)
        return null;
      let t = e.filter((n) => n.isPickable() && !n.isComposite);
      return t.length > 255 ? (F.warn("Too many pickable layers, only picking the first 255")(), t.slice(0, 255)) : t.length ? t : null;
    }
    _pickClosestObject({ layers: e, views: t, viewports: n, x: i, y: s, radius: o = 0, depth: a = 1, mode: c = "query", unproject3D: l, onViewportActive: f }) {
      if (e = this._getPickable(e), !e)
        return { result: [], emptyInfo: Rf({ viewports: n, x: i, y: s }) };
      this._resizeBuffer();
      let u = xt(this.gl), h = yn(this.gl, [i, s], true), d = [h.x + Math.floor(h.width / 2), h.y + Math.floor(h.height / 2)], m = Math.round(o * u), { width: _, height: E } = this.pickingFBO, b = this._getPickingRect({ deviceX: d[0], deviceY: d[1], deviceRadius: m, deviceWidth: _, deviceHeight: E }), T, v = [], C = {};
      for (let S = 0; S < a; S++) {
        let R = b && this._drawAndSample({ layers: e, views: t, viewports: n, onViewportActive: f, deviceRect: b, pass: "picking:".concat(c), redrawReason: c }), D = Lm({ pickedColors: R, layers: e, deviceX: d[0], deviceY: d[1], deviceRadius: m, deviceRect: b }), B;
        if (D.pickedLayer && l && this.depthFBO && (B = this._drawAndSample({ layers: [D.pickedLayer], views: t, viewports: n, onViewportActive: f, deviceRect: { x: D.pickedX, y: D.pickedY, width: 1, height: 1 }, pass: "picking:".concat(c), redrawReason: "pick-z", pickZ: true })[0] * n[0].distanceScales.metersPerUnit[2] + n[0].position[2]), D.pickedColor && S + 1 < a) {
          let N = D.pickedColor[3] - 1;
          C[N] = true, e[N].disablePickingIndex(D.pickedObjectIndex);
        }
        T = Rm({ pickInfo: D, lastPickedInfo: this.lastPickedInfo, mode: c, layers: e, layerFilter: this.layerFilter, viewports: n, x: i, y: s, z: B, pixelRatio: u });
        for (let N of T.values())
          N.layer && v.push(N);
        if (!D.pickedColor)
          break;
      }
      for (let S in C)
        e[S].restorePickingColors();
      return { result: v, emptyInfo: T && T.get(null) };
    }
    _pickVisibleObjects({ layers: e, views: t, viewports: n, x: i, y: s, width: o = 1, height: a = 1, mode: c = "query", maxObjects: l = null, onViewportActive: f }) {
      if (e = this._getPickable(e), !e)
        return [];
      this._resizeBuffer();
      let u = xt(this.gl), h = yn(this.gl, [i, s], true), d = h.x, m = h.y + h.height, _ = yn(this.gl, [i + o, s + a], true), E = _.x + _.width, b = _.y, T = { x: d, y: b, width: E - d, height: m - b }, v = this._drawAndSample({ layers: e, views: t, viewports: n, onViewportActive: f, deviceRect: T, pass: "picking:".concat(c), redrawReason: c }), C = Cm({ pickedColors: v, layers: e }), S = new Map(), R = Number.isFinite(l);
      for (let D = 0; D < C.length && !(R && S.size >= l); D++) {
        let B = C[D], N = { color: B.pickedColor, layer: null, index: B.pickedObjectIndex, picked: true, x: i, y: s, width: o, height: a, pixelRatio: u };
        N = Mf({ layer: B.pickedLayer, info: N, mode: c }), S.has(N.object) || S.set(N.object, N);
      }
      return Array.from(S.values());
    }
    _drawAndSample({ layers: e, views: t, viewports: n, onViewportActive: i, deviceRect: s, pass: o, redrawReason: a, pickZ: c }) {
      if (e.length < 1)
        return null;
      let l = c ? this.depthFBO : this.pickingFBO;
      this.pickLayersPass.render({ layers: e, layerFilter: this.layerFilter, views: t, viewports: n, onViewportActive: i, pickingFBO: l, deviceRect: s, pass: o, redrawReason: a, pickZ: c });
      let { x: f, y: u, width: h, height: d } = s, m = new (c ? Float32Array : Uint8Array)(h * d * 4);
      return Jt(l, { sourceX: f, sourceY: u, sourceWidth: h, sourceHeight: d, target: m }), m;
    }
    _getPickingRect({ deviceX: e, deviceY: t, deviceRadius: n, deviceWidth: i, deviceHeight: s }) {
      let o = Math.max(0, e - n), a = Math.max(0, t - n), c = Math.min(i, e + n + 1) - o, l = Math.min(s, t + n + 1) - a;
      return c <= 0 || l <= 0 ? null : { x: o, y: a, width: c, height: l };
    }
  };
  var C1 = { zIndex: 1, position: "absolute", pointerEvents: "none", color: "#a0a7b4", backgroundColor: "#29323c", padding: "10px", top: 0, left: 0, display: "none" };
  var Ta = class {
    constructor(e) {
      let t = e.parentElement;
      t && (this.el = document.createElement("div"), this.el.className = "deck-tooltip", Object.assign(this.el.style, C1), t.appendChild(this.el)), this.isVisible = false;
    }
    setTooltip(e, t, n) {
      let i = this.el;
      if (typeof e == "string")
        i.innerText = e;
      else if (e)
        "text" in e && (i.innerText = e.text), "html" in e && (i.innerHTML = e.html), "className" in e && (i.className = e.className), Object.assign(i.style, e.style);
      else {
        this.isVisible = false, i.style.display = "none";
        return;
      }
      this.isVisible = true, i.style.display = "block", i.style.transform = "translate(".concat(t, "px, ").concat(n, "px)");
    }
    remove() {
      this.el && this.el.remove();
    }
  };
  var eg = Mt(dr());
  var us = Mt(Mm());
  var Im = 1;
  var Om = 2;
  var If = 4;
  var R1 = { mousedown: Im, mousemove: Om, mouseup: If };
  function M1(r2, e) {
    for (let t = 0; t < r2.length; t++)
      if (e(r2[t]))
        return true;
    return false;
  }
  function Nm(r2) {
    let e = r2.prototype.handler;
    r2.prototype.handler = function(n) {
      let i = this.store;
      n.button > 0 && n.type === "pointerdown" && (M1(i, (s) => s.pointerId === n.pointerId) || i.push(n)), e.call(this, n);
    };
  }
  function Fm(r2) {
    r2.prototype.handler = function(t) {
      let n = R1[t.type];
      n & Im && t.button >= 0 && (this.pressed = true), n & Om && t.which === 0 && (n = If), !!this.pressed && (n & If && (this.pressed = false), this.callback(this.manager, n, { pointers: [t], changedPointers: [t], pointerType: "mouse", srcEvent: t }));
    };
  }
  Nm(us.default.PointerEventInput);
  Fm(us.default.MouseInput);
  var Dm = us.default.Manager;
  var St = us.default;
  var Bm = St ? [[St.Pan, { event: "tripan", pointers: 3, threshold: 0, enable: false }], [St.Rotate, { enable: false }], [St.Pinch, { enable: false }], [St.Swipe, { enable: false }], [St.Pan, { threshold: 0, enable: false }], [St.Press, { enable: false }], [St.Tap, { event: "doubletap", taps: 2, enable: false }], [St.Tap, { event: "anytap", enable: false }], [St.Tap, { enable: false }]] : null;
  var Of = { tripan: ["rotate", "pinch", "pan"], rotate: ["pinch"], pinch: ["pan"], pan: ["press", "doubletap", "anytap", "tap"], doubletap: ["anytap"], anytap: ["tap"] };
  var Um = { doubletap: ["tap"] };
  var km = { pointerdown: "pointerdown", pointermove: "pointermove", pointerup: "pointerup", touchstart: "pointerdown", touchmove: "pointermove", touchend: "pointerup", mousedown: "pointerdown", mousemove: "pointermove", mouseup: "pointerup" };
  var Kn = { KEY_EVENTS: ["keydown", "keyup"], MOUSE_EVENTS: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"], WHEEL_EVENTS: ["wheel", "mousewheel"] };
  var Vm = { tap: "tap", anytap: "anytap", doubletap: "doubletap", press: "press", pinch: "pinch", pinchin: "pinch", pinchout: "pinch", pinchstart: "pinch", pinchmove: "pinch", pinchend: "pinch", pinchcancel: "pinch", rotate: "rotate", rotatestart: "rotate", rotatemove: "rotate", rotateend: "rotate", rotatecancel: "rotate", tripan: "tripan", tripanstart: "tripan", tripanmove: "tripan", tripanup: "tripan", tripandown: "tripan", tripanleft: "tripan", tripanright: "tripan", tripanend: "tripan", tripancancel: "tripan", pan: "pan", panstart: "pan", panmove: "pan", panup: "pan", pandown: "pan", panleft: "pan", panright: "pan", panend: "pan", pancancel: "pan", swipe: "swipe", swipeleft: "swipe", swiperight: "swipe", swipeup: "swipe", swipedown: "swipe" };
  var Nf = { click: "tap", anyclick: "anytap", dblclick: "doubletap", mousedown: "pointerdown", mousemove: "pointermove", mouseup: "pointerup", mouseover: "pointerover", mouseout: "pointerout", mouseleave: "pointerleave" };
  var Gm = typeof navigator != "undefined" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "";
  var nn = typeof window != "undefined" ? window : global;
  var y5 = typeof global != "undefined" ? global : window;
  var E5 = typeof document != "undefined" ? document : {};
  var Ff = false;
  try {
    let r2 = { get passive() {
      return Ff = true, true;
    } };
    nn.addEventListener("test", r2, r2), nn.removeEventListener("test", r2, r2);
  } catch (r2) {
  }
  var I1 = Gm.indexOf("firefox") !== -1;
  var { WHEEL_EVENTS: O1 } = Kn;
  var zm = "wheel";
  var jm = 4.000244140625;
  var N1 = 40;
  var F1 = 0.25;
  var Aa = class {
    constructor(e, t, n = {}) {
      this.element = e, this.callback = t, this.options = Object.assign({ enable: true }, n), this.events = O1.concat(n.events || []), this.handleEvent = this.handleEvent.bind(this), this.events.forEach((i) => e.addEventListener(i, this.handleEvent, Ff ? { passive: false } : false));
    }
    destroy() {
      this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
    }
    enableEventType(e, t) {
      e === zm && (this.options.enable = t);
    }
    handleEvent(e) {
      if (!this.options.enable)
        return;
      let t = e.deltaY;
      nn.WheelEvent && (I1 && e.deltaMode === nn.WheelEvent.DOM_DELTA_PIXEL && (t /= nn.devicePixelRatio), e.deltaMode === nn.WheelEvent.DOM_DELTA_LINE && (t *= N1));
      let n = { x: e.clientX, y: e.clientY };
      t !== 0 && t % jm == 0 && (t = Math.floor(t / jm)), e.shiftKey && t && (t = t * F1), this._onWheel(e, -t, n);
    }
    _onWheel(e, t, n) {
      this.callback({ type: zm, center: n, delta: t, srcEvent: e, pointerType: "mouse", target: e.target });
    }
  };
  var { MOUSE_EVENTS: D1 } = Kn;
  var Wm = "pointermove";
  var Hm = "pointerover";
  var Xm = "pointerout";
  var Ym = "pointerleave";
  var Sa = class {
    constructor(e, t, n = {}) {
      this.element = e, this.callback = t, this.pressed = false, this.options = Object.assign({ enable: true }, n), this.enableMoveEvent = this.options.enable, this.enableLeaveEvent = this.options.enable, this.enableOutEvent = this.options.enable, this.enableOverEvent = this.options.enable, this.events = D1.concat(n.events || []), this.handleEvent = this.handleEvent.bind(this), this.events.forEach((i) => e.addEventListener(i, this.handleEvent));
    }
    destroy() {
      this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
    }
    enableEventType(e, t) {
      e === Wm && (this.enableMoveEvent = t), e === Hm && (this.enableOverEvent = t), e === Xm && (this.enableOutEvent = t), e === Ym && (this.enableLeaveEvent = t);
    }
    handleEvent(e) {
      this.handleOverEvent(e), this.handleOutEvent(e), this.handleLeaveEvent(e), this.handleMoveEvent(e);
    }
    handleOverEvent(e) {
      this.enableOverEvent && e.type === "mouseover" && this.callback({ type: Hm, srcEvent: e, pointerType: "mouse", target: e.target });
    }
    handleOutEvent(e) {
      this.enableOutEvent && e.type === "mouseout" && this.callback({ type: Xm, srcEvent: e, pointerType: "mouse", target: e.target });
    }
    handleLeaveEvent(e) {
      this.enableLeaveEvent && e.type === "mouseleave" && this.callback({ type: Ym, srcEvent: e, pointerType: "mouse", target: e.target });
    }
    handleMoveEvent(e) {
      if (this.enableMoveEvent)
        switch (e.type) {
          case "mousedown":
            e.button >= 0 && (this.pressed = true);
            break;
          case "mousemove":
            e.which === 0 && (this.pressed = false), this.pressed || this.callback({ type: Wm, srcEvent: e, pointerType: "mouse", target: e.target });
            break;
          case "mouseup":
            this.pressed = false;
            break;
          default:
        }
    }
  };
  var { KEY_EVENTS: B1 } = Kn;
  var qm = "keydown";
  var Zm = "keyup";
  var wa = class {
    constructor(e, t, n = {}) {
      this.element = e, this.callback = t, this.options = Object.assign({ enable: true }, n), this.enableDownEvent = this.options.enable, this.enableUpEvent = this.options.enable, this.events = B1.concat(n.events || []), this.handleEvent = this.handleEvent.bind(this), e.tabIndex = n.tabIndex || 0, e.style.outline = "none", this.events.forEach((i) => e.addEventListener(i, this.handleEvent));
    }
    destroy() {
      this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
    }
    enableEventType(e, t) {
      e === qm && (this.enableDownEvent = t), e === Zm && (this.enableUpEvent = t);
    }
    handleEvent(e) {
      let t = e.target || e.srcElement;
      t.tagName === "INPUT" && t.type === "text" || t.tagName === "TEXTAREA" || (this.enableDownEvent && e.type === "keydown" && this.callback({ type: qm, srcEvent: e, key: e.key, target: e.target }), this.enableUpEvent && e.type === "keyup" && this.callback({ type: Zm, srcEvent: e, key: e.key, target: e.target }));
    }
  };
  var Km = "contextmenu";
  var Pa = class {
    constructor(e, t, n = {}) {
      this.element = e, this.callback = t, this.options = Object.assign({ enable: true }, n), this.handleEvent = this.handleEvent.bind(this), e.addEventListener("contextmenu", this.handleEvent);
    }
    destroy() {
      this.element.removeEventListener("contextmenu", this.handleEvent);
    }
    enableEventType(e, t) {
      e === Km && (this.options.enable = t);
    }
    handleEvent(e) {
      !this.options.enable || this.callback({ type: Km, center: { x: e.clientX, y: e.clientY }, srcEvent: e, pointerType: "mouse", target: e.target });
    }
  };
  var Df = 1;
  var La = 2;
  var Bf = 4;
  var U1 = { pointerdown: Df, pointermove: La, pointerup: Bf, mousedown: Df, mousemove: La, mouseup: Bf };
  var k1 = 1;
  var V1 = 2;
  var G1 = 3;
  var z1 = 0;
  var j1 = 1;
  var W1 = 2;
  var H1 = 1;
  var X1 = 2;
  var Y1 = 4;
  function Qm(r2) {
    let e = U1[r2.srcEvent.type];
    if (!e)
      return null;
    let { buttons: t, button: n, which: i } = r2.srcEvent, s = false, o = false, a = false;
    return e === Bf || e === La && !Number.isFinite(t) ? (s = i === k1, o = i === V1, a = i === G1) : e === La ? (s = Boolean(t & H1), o = Boolean(t & Y1), a = Boolean(t & X1)) : e === Df && (s = n === z1, o = n === j1, a = n === W1), { leftButton: s, middleButton: o, rightButton: a };
  }
  function Jm(r2, e) {
    let { srcEvent: t } = r2;
    if (!r2.center && !Number.isFinite(t.clientX))
      return null;
    let n = r2.center || { x: t.clientX, y: t.clientY }, i = e.getBoundingClientRect(), s = i.width / e.offsetWidth || 1, o = i.height / e.offsetHeight || 1, a = { x: (n.x - i.left - e.clientLeft) / s, y: (n.y - i.top - e.clientTop) / o };
    return { center: n, offsetCenter: a };
  }
  var $m = { srcElement: "root", priority: 0 };
  var Ca = class {
    constructor(e) {
      this.eventManager = e, this.handlers = [], this.handlersByElement = new Map(), this.handleEvent = this.handleEvent.bind(this), this._active = false;
    }
    isEmpty() {
      return !this._active;
    }
    add(e, t, n, i = false, s = false) {
      let { handlers: o, handlersByElement: a } = this;
      n && (typeof n != "object" || n.addEventListener) && (n = { srcElement: n }), n = n ? Object.assign({}, $m, n) : $m;
      let c = a.get(n.srcElement);
      c || (c = [], a.set(n.srcElement, c));
      let l = { type: e, handler: t, srcElement: n.srcElement, priority: n.priority };
      i && (l.once = true), s && (l.passive = true), o.push(l), this._active = this._active || !l.passive;
      let f = c.length - 1;
      for (; f >= 0 && !(c[f].priority >= l.priority); )
        f--;
      c.splice(f + 1, 0, l);
    }
    remove(e, t) {
      let { handlers: n, handlersByElement: i } = this;
      for (let s = n.length - 1; s >= 0; s--) {
        let o = n[s];
        if (o.type === e && o.handler === t) {
          n.splice(s, 1);
          let a = i.get(o.srcElement);
          a.splice(a.indexOf(o), 1), a.length === 0 && i.delete(o.srcElement);
        }
      }
      this._active = n.some((s) => !s.passive);
    }
    handleEvent(e) {
      if (this.isEmpty())
        return;
      let t = this._normalizeEvent(e), n = e.srcEvent.target;
      for (; n && n !== t.rootElement; ) {
        if (this._emit(t, n), t.handled)
          return;
        n = n.parentNode;
      }
      this._emit(t, "root");
    }
    _emit(e, t) {
      let n = this.handlersByElement.get(t);
      if (n) {
        let i = false, s = () => {
          e.handled = true;
        }, o = () => {
          e.handled = true, i = true;
        }, a = [];
        for (let c = 0; c < n.length; c++) {
          let { type: l, handler: f, once: u } = n[c];
          if (f(Object.assign({}, e, { type: l, stopPropagation: s, stopImmediatePropagation: o })), u && a.push(n[c]), i)
            break;
        }
        for (let c = 0; c < a.length; c++) {
          let { type: l, handler: f } = a[c];
          this.remove(l, f);
        }
      }
    }
    _normalizeEvent(e) {
      let t = this.eventManager.element;
      return Object.assign({}, e, Qm(e), Jm(e, t), { handled: false, rootElement: t });
    }
  };
  var q1 = { events: null, recognizers: null, recognizerOptions: {}, Manager: Dm, touchAction: "none", tabIndex: 0 };
  var hs = class {
    constructor(e = null, t = {}) {
      this.options = Object.assign({}, q1, t), this.events = new Map(), this._onBasicInput = this._onBasicInput.bind(this), this._onOtherEvent = this._onOtherEvent.bind(this), this.setElement(e);
      let { events: n } = t;
      n && this.on(n);
    }
    setElement(e) {
      if (this.element && this.destroy(), this.element = e, !e)
        return;
      let { options: t } = this, n = t.Manager;
      this.manager = new n(e, { touchAction: t.touchAction, recognizers: t.recognizers || Bm }).on("hammer.input", this._onBasicInput), t.recognizers || Object.keys(Of).forEach((i) => {
        let s = this.manager.get(i);
        s && Of[i].forEach((o) => {
          s.recognizeWith(o);
        });
      });
      for (let i in t.recognizerOptions) {
        let s = this.manager.get(i);
        if (s) {
          let o = t.recognizerOptions[i];
          delete o.enable, s.set(o);
        }
      }
      this.wheelInput = new Aa(e, this._onOtherEvent, { enable: false }), this.moveInput = new Sa(e, this._onOtherEvent, { enable: false }), this.keyInput = new wa(e, this._onOtherEvent, { enable: false, tabIndex: t.tabIndex }), this.contextmenuInput = new Pa(e, this._onOtherEvent, { enable: false });
      for (let [i, s] of this.events)
        s.isEmpty() || (this._toggleRecognizer(s.recognizerName, true), this.manager.on(i, s.handleEvent));
    }
    destroy() {
      this.element && (this.wheelInput.destroy(), this.moveInput.destroy(), this.keyInput.destroy(), this.contextmenuInput.destroy(), this.manager.destroy(), this.wheelInput = null, this.moveInput = null, this.keyInput = null, this.contextmenuInput = null, this.manager = null, this.element = null);
    }
    on(e, t, n) {
      this._addEventHandler(e, t, n, false);
    }
    once(e, t, n) {
      this._addEventHandler(e, t, n, true);
    }
    watch(e, t, n) {
      this._addEventHandler(e, t, n, false, true);
    }
    off(e, t) {
      this._removeEventHandler(e, t);
    }
    _toggleRecognizer(e, t) {
      let { manager: n } = this;
      if (!n)
        return;
      let i = n.get(e);
      if (i && i.options.enable !== t) {
        i.set({ enable: t });
        let s = Um[e];
        s && !this.options.recognizers && s.forEach((o) => {
          let a = n.get(o);
          t ? (a.requireFailure(e), i.dropRequireFailure(o)) : a.dropRequireFailure(e);
        });
      }
      this.wheelInput.enableEventType(e, t), this.moveInput.enableEventType(e, t), this.keyInput.enableEventType(e, t), this.contextmenuInput.enableEventType(e, t);
    }
    _addEventHandler(e, t, n, i, s) {
      if (typeof e != "string") {
        n = t;
        for (let f in e)
          this._addEventHandler(f, e[f], n, i, s);
        return;
      }
      let { manager: o, events: a } = this, c = Nf[e] || e, l = a.get(c);
      l || (l = new Ca(this), a.set(c, l), l.recognizerName = Vm[c] || c, o && o.on(c, l.handleEvent)), l.add(e, t, n, i, s), l.isEmpty() || this._toggleRecognizer(l.recognizerName, true);
    }
    _removeEventHandler(e, t) {
      if (typeof e != "string") {
        for (let o in e)
          this._removeEventHandler(o, e[o]);
        return;
      }
      let { events: n } = this, i = Nf[e] || e, s = n.get(i);
      if (!!s && (s.remove(e, t), s.isEmpty())) {
        let { recognizerName: o } = s, a = false;
        for (let c of n.values())
          if (c.recognizerName === o && !c.isEmpty()) {
            a = true;
            break;
          }
        a || this._toggleRecognizer(o, false);
      }
    }
    _onBasicInput(e) {
      let { srcEvent: t } = e, n = km[t.type];
      n && this.manager.emit(n, e);
    }
    _onOtherEvent(e) {
      this.manager.emit(e.type, e);
    }
  };
  function sn() {
  }
  var Z1 = ({ isDragging: r2 }) => r2 ? "grabbing" : "grab";
  function K1(r2) {
    return { id: r2.string, width: r2.oneOfType([r2.number, r2.string]), height: r2.oneOfType([r2.number, r2.string]), layers: r2.oneOfType([r2.object, r2.array]), layerFilter: r2.func, views: r2.oneOfType([r2.object, r2.array]), viewState: r2.object, effects: r2.arrayOf(r2.instanceOf(Hn)), controller: r2.oneOfType([r2.func, r2.bool, r2.object]), gl: r2.object, glOptions: r2.object, parameters: r2.object, pickingRadius: r2.number, useDevicePixels: r2.oneOfType([r2.bool, r2.number]), touchAction: r2.string, eventRecognizerOptions: r2.object, onWebGLInitialized: r2.func, onResize: r2.func, onViewStateChange: r2.func, onInteractionStateChange: r2.func, onBeforeRender: r2.func, onAfterRender: r2.func, onLoad: r2.func, onError: r2.func, debug: r2.bool, drawPickingColors: r2.bool, _framebuffer: r2.object, _animate: r2.bool, _pickable: r2.bool, _typedArrayManagerProps: r2.object };
  }
  var tg = { id: "", width: "100%", height: "100%", pickingRadius: 0, layerFilter: null, glOptions: {}, gl: null, layers: [], effects: [], views: null, controller: null, useDevicePixels: true, touchAction: "none", eventRecognizerOptions: {}, _framebuffer: null, _animate: false, _pickable: true, _typedArrayManagerProps: {}, onWebGLInitialized: sn, onResize: sn, onViewStateChange: sn, onInteractionStateChange: sn, onBeforeRender: sn, onAfterRender: sn, onLoad: sn, onError: (r2, e) => F.error(r2)(), _onMetrics: null, getCursor: Z1, debug: false, drawPickingColors: false };
  var Ir = class {
    constructor(e) {
      e = x(x({}, tg), e), this.props = {}, this.width = 0, this.height = 0, this.viewManager = null, this.layerManager = null, this.effectManager = null, this.deckRenderer = null, this.deckPicker = null, this._needsRedraw = true, this._pickRequest = {}, this._lastPointerDownInfo = null, this.viewState = null, this.interactiveState = { isHovering: false, isDragging: false }, this._onEvent = this._onEvent.bind(this), this._onPointerDown = this._onPointerDown.bind(this), this._onPointerMove = this._onPointerMove.bind(this), e.viewState && e.initialViewState && F.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(), (0, eg.getBrowser)() === "IE" && F.warn("IE 11 support will be deprecated in v8.0")(), e.gl || typeof document != "undefined" && (this.canvas = this._createCanvas(e)), this.animationLoop = this._createAnimationLoop(e), this.stats = new nt({ id: "deck.gl" }), this.metrics = { fps: 0, setPropsTime: 0, updateAttributesTime: 0, framesRedrawn: 0, pickTime: 0, pickCount: 0, gpuTime: 0, gpuTimePerFrame: 0, cpuTime: 0, cpuTimePerFrame: 0, bufferMemory: 0, textureMemory: 0, renderbufferMemory: 0, gpuMemory: 0 }, this._metricsCounter = 0, this.setProps(e), e._typedArrayManagerProps && At.setProps(e._typedArrayManagerProps), this.animationLoop.start();
    }
    finalize() {
      this.animationLoop.stop(), this.animationLoop = null, this._lastPointerDownInfo = null, this.layerManager && (this.layerManager.finalize(), this.layerManager = null, this.viewManager.finalize(), this.viewManager = null, this.effectManager.finalize(), this.effectManager = null, this.deckRenderer.finalize(), this.deckRenderer = null, this.deckPicker.finalize(), this.deckPicker = null, this.eventManager.destroy(), this.eventManager = null, this.tooltip.remove(), this.tooltip = null), !this.props.canvas && !this.props.gl && this.canvas && (this.canvas.parentElement.removeChild(this.canvas), this.canvas = null);
    }
    setProps(e) {
      this.stats.get("setProps Time").timeStart(), "onLayerHover" in e && F.removed("onLayerHover", "onHover")(), "onLayerClick" in e && F.removed("onLayerClick", "onClick")(), e.initialViewState && !ir(this.props.initialViewState, e.initialViewState) && (this.viewState = e.initialViewState), Object.assign(this.props, e), this._setCanvasSize(this.props);
      let t = Object.create(this.props);
      Object.assign(t, { views: this._getViews(), width: this.width, height: this.height, viewState: this._getViewState() }), this.animationLoop.setProps(t), this.layerManager && (this.viewManager.setProps(t), this.layerManager.activateViewport(this.getViewports()[0]), this.layerManager.setProps(t), this.effectManager.setProps(t), this.deckRenderer.setProps(t), this.deckPicker.setProps(t)), this.stats.get("setProps Time").timeEnd();
    }
    needsRedraw(e = { clearRedrawFlags: false }) {
      if (this.props._animate)
        return "Deck._animate";
      let t = this._needsRedraw;
      e.clearRedrawFlags && (this._needsRedraw = false);
      let n = this.viewManager.needsRedraw(e), i = this.layerManager.needsRedraw(e), s = this.effectManager.needsRedraw(e), o = this.deckRenderer.needsRedraw(e);
      return t = t || n || i || s || o, t;
    }
    redraw(e) {
      if (!this.layerManager)
        return;
      let t = e || this.needsRedraw({ clearRedrawFlags: true });
      !t || (this.stats.get("Redraw Count").incrementCount(), this.props._customRender ? this.props._customRender(t) : this._drawLayers(t));
    }
    getViews() {
      return this.viewManager.views;
    }
    getViewports(e) {
      return this.viewManager.getViewports(e);
    }
    pickObject(e) {
      let t = this._pick("pickObject", "pickObject Time", e).result;
      return t.length ? t[0] : null;
    }
    pickMultipleObjects(e) {
      return e.depth = e.depth || 10, this._pick("pickObject", "pickMultipleObjects Time", e).result;
    }
    pickObjects(e) {
      return this._pick("pickObjects", "pickObjects Time", e);
    }
    _addResources(e, t = false) {
      for (let n in e)
        this.layerManager.resourceManager.add({ resourceId: n, data: e[n], forceUpdate: t });
    }
    _removeResources(e) {
      for (let t of e)
        this.layerManager.resourceManager.remove(t);
    }
    _pick(e, t, n) {
      let { stats: i } = this;
      i.get("Pick Count").incrementCount(), i.get(t).timeStart();
      let s = this.deckPicker[e](x({ layers: this.layerManager.getLayers(n), views: this.viewManager.getViews(), viewports: this.getViewports(n), onViewportActive: this.layerManager.activateViewport }, n));
      return i.get(t).timeEnd(), s;
    }
    _createCanvas(e) {
      let t = e.canvas;
      return typeof t == "string" && (t = document.getElementById(t), he(t)), t || (t = document.createElement("canvas"), t.id = e.id || "deckgl-overlay", (e.parent || document.body).appendChild(t)), Object.assign(t.style, e.style), t;
    }
    _setCanvasSize(e) {
      if (!this.canvas)
        return;
      let { width: t, height: n } = e;
      (t || t === 0) && (t = Number.isFinite(t) ? "".concat(t, "px") : t, this.canvas.style.width = t), (n || n === 0) && (n = Number.isFinite(n) ? "".concat(n, "px") : n, this.canvas.style.position = "absolute", this.canvas.style.height = n);
    }
    _updateCanvasSize() {
      if (this._checkForCanvasSizeChange()) {
        let { width: e, height: t } = this;
        this.viewManager.setProps({ width: e, height: t }), this.props.onResize({ width: this.width, height: this.height });
      }
    }
    _checkForCanvasSizeChange() {
      let { canvas: e } = this;
      if (!e)
        return false;
      let t = e.clientWidth || e.width, n = e.clientHeight || e.height;
      return t !== this.width || n !== this.height ? (this.width = t, this.height = n, true) : false;
    }
    _createAnimationLoop(e) {
      let { width: t, height: n, gl: i, glOptions: s, debug: o, onError: a, onBeforeRender: c, onAfterRender: l, useDevicePixels: f, autoResizeDrawingBuffer: u } = e;
      return new Ln({ width: t, height: n, useDevicePixels: f, autoResizeDrawingBuffer: u, autoResizeViewport: false, gl: i, onCreateContext: (h) => En(L(x(x({}, s), h), { canvas: this.canvas, debug: o, onContextLost: () => this._onContextLost() })), onInitialize: (h) => this._setGLContext(h.gl), onRender: this._onRenderFrame.bind(this), onBeforeRender: c, onAfterRender: l, onError: a });
    }
    _getViewState() {
      return this.props.viewState || this.viewState;
    }
    _getViews() {
      let e = this.props.views || [new fs({ id: "default-view" })];
      return e = Array.isArray(e) ? e : [e], e.length && this.props.controller && (e[0].props.controller = this.props.controller), e;
    }
    _onContextLost() {
      let { onError: e } = this.props;
      this.animationLoop && e && e(new Error("WebGL context is lost"));
    }
    _onPointerMove(e) {
      let { _pickRequest: t } = this;
      if (e.type === "pointerleave")
        t.x = -1, t.y = -1, t.radius = 0;
      else {
        if (e.leftButton || e.rightButton)
          return;
        {
          let n = e.offsetCenter;
          if (!n)
            return;
          t.x = n.x, t.y = n.y, t.radius = this.props.pickingRadius;
        }
      }
      this.layerManager && (this.layerManager.context.mousePosition = { x: t.x, y: t.y }), t.event = e, t.mode = "hover";
    }
    _pickAndCallback() {
      let { _pickRequest: e } = this;
      if (e.event) {
        let { result: t, emptyInfo: n } = this._pick("pickObject", "pickObject Time", e);
        this.interactiveState.isHovering = t.length > 0;
        let i = n, s = false;
        for (let o of t)
          i = o, s = o.layer.onHover(o, e.event);
        if (!s && this.props.onHover && this.props.onHover(i, e.event), this.props.getTooltip) {
          let o = this.props.getTooltip(i);
          this.tooltip.setTooltip(o, i.x, i.y);
        }
        e.event = null;
      }
    }
    _updateCursor() {
      let e = this.props.parent || this.canvas;
      e && (e.style.cursor = this.props.getCursor(this.interactiveState));
    }
    _setGLContext(e) {
      if (this.layerManager)
        return;
      this.canvas || (this.canvas = e.canvas, qr(e, { enable: true, copyState: true })), this.tooltip = new Ta(this.canvas), De(e, { blend: true, blendFunc: [770, 771, 1, 771], polygonOffsetFill: true, depthTest: true, depthFunc: 515 }), this.props.onWebGLInitialized(e);
      let t = new Jr();
      t.play(), this.animationLoop.attachTimeline(t), this.eventManager = new hs(this.props.parent || e.canvas, { touchAction: this.props.touchAction, recognizerOptions: this.props.eventRecognizerOptions, events: { pointerdown: this._onPointerDown, pointermove: this._onPointerMove, pointerleave: this._onPointerMove } });
      for (let i in gf)
        this.eventManager.on(i, this._onEvent);
      this.viewManager = new la({ timeline: t, eventManager: this.eventManager, onViewStateChange: this._onViewStateChange.bind(this), onInteractionStateChange: this._onInteractionStateChange.bind(this), views: this._getViews(), viewState: this._getViewState(), width: this.width, height: this.height });
      let n = this.viewManager.getViewports()[0];
      this.layerManager = new ca(e, { deck: this, stats: this.stats, viewport: n, timeline: t }), this.effectManager = new xa(), this.deckRenderer = new Ea(e), this.deckPicker = new ba(e), this.setProps(this.props), this._updateCanvasSize(), this.props.onLoad();
    }
    _drawLayers(e, t) {
      let { gl: n } = this.layerManager.context;
      De(n, this.props.parameters), this.props.onBeforeRender({ gl: n }), this.deckRenderer.renderLayers(x({ target: this.props._framebuffer, layers: this.layerManager.getLayers(), viewports: this.viewManager.getViewports(), onViewportActive: this.layerManager.activateViewport, views: this.viewManager.getViews(), pass: "screen", redrawReason: e, effects: this.effectManager.getEffects() }, t)), this.props.onAfterRender({ gl: n });
    }
    _onRenderFrame(e) {
      this._getFrameStats(), this._metricsCounter++ % 60 == 0 && (this._getMetrics(), this.stats.reset(), F.table(4, this.metrics)(), this.props._onMetrics && this.props._onMetrics(this.metrics)), this._updateCanvasSize(), this._updateCursor(), this.tooltip.isVisible && this.viewManager.needsRedraw() && this.tooltip.setTooltip(null), this.layerManager.updateLayers(), this._pickAndCallback(), this.redraw(false), this.viewManager && this.viewManager.updateViewStates();
    }
    _onViewStateChange(e) {
      let t = this.props.onViewStateChange(e) || e.viewState;
      this.viewState && (this.viewState = L(x({}, this.viewState), { [e.viewId]: t }), this.props.viewState || this.viewManager && this.viewManager.setProps({ viewState: this.viewState }));
    }
    _onInteractionStateChange(e) {
      this.interactiveState.isDragging = e.isDragging, this.props.onInteractionStateChange(e);
    }
    _onEvent(e) {
      let t = gf[e.type], n = e.offsetCenter;
      if (!t || !n)
        return;
      let i = this.layerManager.getLayers(), s = this.deckPicker.getLastPickedObject({ x: n.x, y: n.y, layers: i, viewports: this.getViewports(n) }, this._lastPointerDownInfo), { layer: o } = s, a = o && (o[t.handler] || o.props[t.handler]), c = this.props[t.handler], l = false;
      a && (l = a.call(o, s, e)), !l && c && c(s, e);
    }
    _onPointerDown(e) {
      let t = e.offsetCenter;
      this._lastPointerDownInfo = this.pickObject({ x: t.x, y: t.y, radius: this.props.pickingRadius });
    }
    _getFrameStats() {
      let { stats: e } = this;
      e.get("frameRate").timeEnd(), e.get("frameRate").timeStart();
      let t = this.animationLoop.stats;
      e.get("GPU Time").addTime(t.get("GPU Time").lastTiming), e.get("CPU Time").addTime(t.get("CPU Time").lastTiming);
    }
    _getMetrics() {
      let { metrics: e, stats: t } = this;
      e.fps = t.get("frameRate").getHz(), e.setPropsTime = t.get("setProps Time").time, e.updateAttributesTime = t.get("Update Attributes").time, e.framesRedrawn = t.get("Redraw Count").count, e.pickTime = t.get("pickObject Time").time + t.get("pickMultipleObjects Time").time + t.get("pickObjects Time").time, e.pickCount = t.get("Pick Count").count, e.gpuTime = t.get("GPU Time").time, e.cpuTime = t.get("CPU Time").time, e.gpuTimePerFrame = t.get("GPU Time").getAverageTime(), e.cpuTimePerFrame = t.get("CPU Time").getAverageTime();
      let n = ot.get("Memory Usage");
      e.bufferMemory = n.get("Buffer Memory").count, e.textureMemory = n.get("Texture Memory").count, e.renderbufferMemory = n.get("Renderbuffer Memory").count, e.gpuMemory = n.get("GPU Memory").count;
    }
  };
  Ir.getPropTypes = K1;
  Ir.defaultProps = tg;
  Ir.VERSION = $h.VERSION;
  var Qn = class {
    constructor(e, t) {
      this.opts = t, this.source = e;
    }
    get value() {
      return this.source.value;
    }
    getValue() {
      let e = this.source.getBuffer(), t = this.getAccessor();
      if (e)
        return [e, t];
      let { value: n } = this.source, { size: i } = t, s = n;
      if (n && n.length !== i) {
        s = new Float32Array(i);
        let o = t.elementOffset || 0;
        for (let a = 0; a < i; ++a)
          s[a] = n[o + a];
      }
      return s;
    }
    getAccessor() {
      return x(x({}, this.source.getAccessor()), this.opts);
    }
  };
  function rg(r2) {
    switch (r2) {
      case 5126:
        return Float32Array;
      case 5130:
        return Float64Array;
      case 5123:
      case 33635:
      case 32819:
      case 32820:
        return Uint16Array;
      case 5125:
        return Uint32Array;
      case 5121:
        return Uint8ClampedArray;
      case 5120:
        return Int8Array;
      case 5122:
        return Int16Array;
      case 5124:
        return Int32Array;
      default:
        throw new Error("Unknown GL type");
    }
  }
  function Ra(r2) {
    return r2.stride || r2.size * r2.bytesPerElement;
  }
  function ng(r2, e) {
    e.offset && F.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
    let t = Ra(r2), n = "vertexOffset" in e ? e.vertexOffset : r2.vertexOffset || 0, i = e.elementOffset || 0, s = n * t + i * r2.bytesPerElement + (r2.offset || 0);
    return L(x({}, e), { offset: s, stride: t });
  }
  function Q1(r2, e) {
    let t = ng(r2, e);
    return { high: t, low: L(x({}, t), { offset: t.offset + r2.size * 4 }) };
  }
  var Ma = class {
    constructor(e, t) {
      this.gl = e, this.id = t.id, this.size = t.size;
      let n = t.logicalType || t.type, i = n === 5130, { defaultValue: s } = t;
      s = Number.isFinite(s) ? [s] : s || new Array(this.size).fill(0), t.defaultValue = s;
      let o = n;
      i ? o = 5126 : !o && t.isIndexed ? o = e && zi(e, K.ELEMENT_INDEX_UINT32) ? 5125 : 5123 : o || (o = 5126), t.logicalType = n, t.type = o;
      let a = rg(n || o || 5126);
      this.shaderAttributes = {}, this.doublePrecision = i, i && t.fp64 === false && (a = Float32Array), t.bytesPerElement = a.BYTES_PER_ELEMENT, this.defaultType = a, this.value = null, this.settings = t, this.state = { externalBuffer: null, bufferAccessor: t, allocatedValue: null, constant: false }, this._buffer = null, this.setData(t);
    }
    get buffer() {
      if (!this._buffer) {
        let { isIndexed: e, type: t } = this.settings;
        this._buffer = new k(this.gl, { id: this.id, target: e ? 34963 : 34962, accessor: { type: t } });
      }
      return this._buffer;
    }
    get byteOffset() {
      let e = this.getAccessor();
      return e.vertexOffset ? e.vertexOffset * Ra(e) : 0;
    }
    delete() {
      this._buffer && (this._buffer.delete(), this._buffer = null), At.release(this.state.allocatedValue);
    }
    getShaderAttributes(e, t) {
      if (this.doublePrecision) {
        let n = {}, i = this.value instanceof Float64Array, s = Q1(this.getAccessor(), t || {});
        return n[e] = new Qn(this, s.high), n["".concat(e, "64Low")] = i ? new Qn(this, s.low) : new Float32Array(this.size), n;
      }
      if (t) {
        let n = ng(this.getAccessor(), t);
        return { [e]: new Qn(this, n) };
      }
      return { [e]: this };
    }
    getBuffer() {
      return this.state.constant ? null : this.state.externalBuffer || this._buffer;
    }
    getValue() {
      return this.state.constant ? this.value : [this.getBuffer(), this.getAccessor()];
    }
    getAccessor() {
      return this.state.bufferAccessor;
    }
    setData(e) {
      let { state: t } = this;
      ArrayBuffer.isView(e) ? e = { value: e } : e instanceof k && (e = { buffer: e });
      let n = x(x({}, this.settings), e);
      if (t.bufferAccessor = n, e.constant) {
        let i = e.value;
        if (i = this._normalizeValue(i, [], 0), this.settings.normalized && (i = this._normalizeConstant(i)), !(!t.constant || !this._areValuesEqual(i, this.value)))
          return false;
        t.externalBuffer = null, t.constant = true, this.value = i;
      } else if (e.buffer) {
        let i = e.buffer;
        t.externalBuffer = i, t.constant = false, this.value = e.value;
        let s = e.value instanceof Float64Array;
        n.type = e.type || i.accessor.type, n.bytesPerElement = i.accessor.BYTES_PER_ELEMENT * (s ? 2 : 1), n.stride = Ra(n);
      } else if (e.value) {
        this._checkExternalBuffer(e);
        let i = e.value;
        t.externalBuffer = null, t.constant = false, this.value = i, n.bytesPerElement = i.BYTES_PER_ELEMENT, n.stride = Ra(n);
        let { buffer: s, byteOffset: o } = this;
        this.doublePrecision && i instanceof Float64Array && (i = sa(i, n));
        let a = i.byteLength + o + n.stride * 2;
        s.byteLength < a && s.reallocate(a), s.setAccessor(null), s.subData({ data: i, offset: o }), n.type = e.type || s.accessor.type;
      }
      return true;
    }
    updateSubBuffer(e = {}) {
      let { value: t } = this, { startOffset: n = 0, endOffset: i } = e;
      this.buffer.subData({ data: this.doublePrecision && t instanceof Float64Array ? sa(t, { size: this.size, startIndex: n, endIndex: i }) : t.subarray(n, i), offset: n * t.BYTES_PER_ELEMENT + this.byteOffset });
    }
    allocate({ numInstances: e, copy: t = false }) {
      let { state: n } = this, i = n.allocatedValue, s = At.allocate(i, e + 1, { size: this.size, type: this.defaultType, copy: t });
      this.value = s;
      let { buffer: o, byteOffset: a } = this;
      return o.byteLength < s.byteLength + a && (o.reallocate(s.byteLength + a), t && i && o.subData({ data: i instanceof Float64Array ? sa(i, this) : i, offset: a })), n.allocatedValue = s, n.constant = false, n.externalBuffer = null, n.bufferAccessor = this.settings, true;
    }
    _checkExternalBuffer(e) {
      let { value: t } = e;
      if (!e.constant && t) {
        let n = this.defaultType, i = false;
        if (this.doublePrecision && (i = t.BYTES_PER_ELEMENT < 4), i)
          throw new Error("Attribute ".concat(this.id, " does not support ").concat(t.constructor.name));
        !(t instanceof n) && this.settings.normalized && !("normalized" in e) && F.warn("Attribute ".concat(this.id, " is normalized"))();
      }
    }
    _normalizeConstant(e) {
      switch (this.settings.type) {
        case 5120:
          return new Float32Array(e).map((t) => (t + 128) / 255 * 2 - 1);
        case 5122:
          return new Float32Array(e).map((t) => (t + 32768) / 65535 * 2 - 1);
        case 5121:
          return new Float32Array(e).map((t) => t / 255);
        case 5123:
          return new Float32Array(e).map((t) => t / 65535);
        default:
          return e;
      }
    }
    _normalizeValue(e, t, n) {
      let { defaultValue: i, size: s } = this.settings;
      if (Number.isFinite(e))
        return t[n] = e, t;
      if (!e)
        return t[n] = i[0], t;
      switch (s) {
        case 4:
          t[n + 3] = Number.isFinite(e[3]) ? e[3] : i[3];
        case 3:
          t[n + 2] = Number.isFinite(e[2]) ? e[2] : i[2];
        case 2:
          t[n + 1] = Number.isFinite(e[1]) ? e[1] : i[1];
        case 1:
          t[n + 0] = Number.isFinite(e[0]) ? e[0] : i[0];
          break;
        default:
          let o = s;
          for (; --o >= 0; )
            t[n + o] = Number.isFinite(e[o]) ? e[o] : i[o];
      }
      return t;
    }
    _areValuesEqual(e, t) {
      if (!e || !t)
        return false;
      let { size: n } = this;
      for (let i = 0; i < n; i++)
        if (e[i] !== t[i])
          return false;
      return true;
    }
  };
  var ig = [];
  var sg = [];
  function sr(r2, e = 0, t = 1 / 0) {
    let n = ig, i = { index: -1, data: r2, target: [] };
    return r2 ? typeof r2[Symbol.iterator] == "function" ? n = r2 : r2.length > 0 && (sg.length = r2.length, n = sg) : n = ig, (e > 0 || Number.isFinite(t)) && (n = (Array.isArray(n) ? n : Array.from(n)).slice(e, t), i.index = e - 1), { iterable: n, objectInfo: i };
  }
  function Ia(r2) {
    return r2 && r2[Symbol.asyncIterator];
  }
  function Oa(r2, { size: e, stride: t, offset: n, startIndices: i, nested: s }) {
    let o = r2.BYTES_PER_ELEMENT, a = t ? t / o : e, c = n ? n / o : 0, l = Math.floor((r2.length - c) / a);
    return (f, { index: u, target: h }) => {
      if (!i) {
        let E = u * a + c;
        for (let b = 0; b < e; b++)
          h[b] = r2[E + b];
        return h;
      }
      let d = i[u], m = i[u + 1] || l, _;
      if (s) {
        _ = new Array(m - d);
        for (let E = d; E < m; E++) {
          let b = E * a + c;
          h = new Array(e);
          for (let T = 0; T < e; T++)
            h[T] = r2[b + T];
          _[E - d] = h;
        }
      } else if (a === e)
        _ = r2.subarray(d * e + c, m * e + c);
      else {
        _ = new r2.constructor((m - d) * e);
        let E = 0;
        for (let b = d; b < m; b++) {
          let T = b * a + c;
          for (let v = 0; v < e; v++)
            _[E++] = r2[T + v];
        }
      }
      return _;
    };
  }
  var og = [];
  var ds = [[0, 1 / 0]];
  function ag(r2, e) {
    if (r2 === ds || (e[0] < 0 && (e[0] = 0), e[0] >= e[1]))
      return r2;
    let t = [], n = r2.length, i = 0;
    for (let s = 0; s < n; s++) {
      let o = r2[s];
      o[1] < e[0] ? (t.push(o), i = s + 1) : o[0] > e[1] ? t.push(o) : e = [Math.min(o[0], e[0]), Math.max(o[1], e[1])];
    }
    return t.splice(i, 0, e), t;
  }
  function Uf({ source: r2, target: e, start: t = 0, end: n, size: i, getData: s }) {
    n = n || e.length;
    let o = r2.length, a = n - t;
    if (o > a) {
      e.set(r2.subarray(0, a), t);
      return;
    }
    if (e.set(r2, t), !s)
      return;
    let c = o;
    for (; c < a; ) {
      let l = s(c, r2);
      for (let f = 0; f < i; f++)
        e[t + c] = l[f] || 0, c++;
    }
  }
  function cg({ source: r2, target: e, size: t, getData: n, sourceStartIndices: i, targetStartIndices: s }) {
    if (!Array.isArray(s))
      return Uf({ source: r2, target: e, size: t, getData: n }), e;
    let o = 0, a = 0, c = n && ((f, u) => n(f + a, u)), l = Math.min(i.length, s.length);
    for (let f = 1; f < l; f++) {
      let u = i[f] * t, h = s[f] * t;
      Uf({ source: r2.subarray(o, u), target: e, start: a, end: h, size: t, getData: c }), o = u, a = h;
    }
    return a < e.length && Uf({ source: [], target: e, start: a, size: t, getData: c }), e;
  }
  var J1 = { interpolation: { duration: 0, easing: (r2) => r2 }, spring: { stiffness: 0.05, damping: 0.5 } };
  function Na(r2, e) {
    return r2 ? (Number.isFinite(r2) && (r2 = { duration: r2 }), r2.type = r2.type || "interpolation", x(x(x({}, J1[r2.type]), e), r2)) : null;
  }
  function Fa(r2, e) {
    return e.getBuffer() ? [e.getBuffer(), { divisor: 0, size: e.size, normalized: e.settings.normalized }] : e.value;
  }
  function Da(r2) {
    switch (r2) {
      case 1:
        return "float";
      case 2:
        return "vec2";
      case 3:
        return "vec3";
      case 4:
        return "vec4";
      default:
        throw new Error('No defined attribute type for size "'.concat(r2, '"'));
    }
  }
  function Ba(r2) {
    r2.push(r2.shift());
  }
  function ps(r2, e) {
    let { doublePrecision: t, settings: n, value: i, size: s } = r2, o = t && i instanceof Float64Array ? 2 : 1;
    return (n.noAlloc ? i.length : e * s) * o;
  }
  function Ua({ buffer: r2, numInstances: e, attribute: t, fromLength: n, fromStartIndices: i, getData: s = (o) => o }) {
    let o = t.doublePrecision && t.value instanceof Float64Array ? 2 : 1, a = t.size * o, c = t.byteOffset, l = t.startIndices, f = i && l, u = ps(t, e), h = t.state.constant;
    if (!f && n >= u)
      return;
    let d = h ? t.value : t.getBuffer().getData({ srcByteOffset: c });
    if (t.settings.normalized && !h) {
      let b = s;
      s = (T, v) => t._normalizeConstant(b(T, v));
    }
    let m = h ? (b, T) => s(d, T) : (b, T) => s(d.subarray(b, b + a), T), _ = r2.getData({ length: n }), E = new Float32Array(u);
    cg({ source: _, target: E, sourceStartIndices: i, targetStartIndices: l, size: a, getData: m }), r2.byteLength < E.byteLength + c && r2.reallocate(E.byteLength + c), r2.subData({ data: E, offset: c });
  }
  var Or = class extends Ma {
    constructor(e, t = {}) {
      super(e, t);
      let { transition: n = false, noAlloc: i = false, update: s = null, accessor: o = null, transform: a = null, startIndices: c = null } = t;
      Object.assign(this.settings, { transition: n, noAlloc: i, update: s || o && this._autoUpdater, accessor: o, transform: a }), Object.assign(this.state, { lastExternalBuffer: null, binaryValue: null, binaryAccessor: null, needsUpdate: true, needsRedraw: false, updateRanges: ds, startIndices: c }), Object.seal(this.settings), Object.seal(this.state), this._validateAttributeUpdaters();
    }
    get startIndices() {
      return this.state.startIndices;
    }
    set startIndices(e) {
      this.state.startIndices = e;
    }
    needsUpdate() {
      return this.state.needsUpdate;
    }
    needsRedraw({ clearChangedFlags: e = false } = {}) {
      let t = this.state.needsRedraw;
      return this.state.needsRedraw = t && !e, t;
    }
    getUpdateTriggers() {
      let { accessor: e } = this.settings;
      return [this.id].concat(typeof e != "function" && e || []);
    }
    supportsTransition() {
      return Boolean(this.settings.transition);
    }
    getTransitionSetting(e) {
      if (!e || !this.supportsTransition())
        return null;
      let { accessor: t } = this.settings, n = this.settings.transition, i = Array.isArray(t) ? e[t.find((s) => e[s])] : e[t];
      return Na(i, n);
    }
    setNeedsUpdate(e = this.id, t) {
      if (this.state.needsUpdate = this.state.needsUpdate || e, this.setNeedsRedraw(e), t) {
        let { startRow: n = 0, endRow: i = 1 / 0 } = t;
        this.state.updateRanges = ag(this.state.updateRanges, [n, i]);
      } else
        this.state.updateRanges = ds;
    }
    clearNeedsUpdate() {
      this.state.needsUpdate = false, this.state.updateRanges = og;
    }
    setNeedsRedraw(e = this.id) {
      this.state.needsRedraw = this.state.needsRedraw || e;
    }
    update(e) {
      this.setData(e);
    }
    allocate(e) {
      let { state: t, settings: n } = this;
      return n.noAlloc ? false : n.update ? (super.allocate({ numInstances: e, copy: t.updateRanges !== ds }), true) : false;
    }
    updateBuffer({ numInstances: e, data: t, props: n, context: i }) {
      if (!this.needsUpdate())
        return false;
      let { state: { updateRanges: s }, settings: { update: o, noAlloc: a } } = this, c = true;
      if (o) {
        for (let [l, f] of s)
          o.call(i, this, { data: t, startRow: l, endRow: f, props: n, numInstances: e });
        if (this.value)
          if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset)
            this.setData({ value: this.value, constant: this.constant });
          else
            for (let [l, f] of s) {
              let u = Number.isFinite(l) ? this.getVertexOffset(l) : 0, h = Number.isFinite(f) ? this.getVertexOffset(f) : a || !Number.isFinite(e) ? this.value.length : e * this.size;
              super.updateSubBuffer({ startOffset: u, endOffset: h });
            }
        this._checkAttributeArray();
      } else
        c = false;
      return this.clearNeedsUpdate(), this.setNeedsRedraw(), c;
    }
    setConstantValue(e) {
      return e === void 0 || typeof e == "function" ? false : (this.setData({ constant: true, value: e }) && this.setNeedsRedraw(), this.clearNeedsUpdate(), true);
    }
    setExternalBuffer(e) {
      let { state: t } = this;
      return e ? (this.clearNeedsUpdate(), t.lastExternalBuffer === e || (t.lastExternalBuffer = e, this.setNeedsRedraw(), this.setData(e)), true) : (t.lastExternalBuffer = null, false);
    }
    setBinaryValue(e, t = null) {
      let { state: n, settings: i } = this;
      if (!e)
        return n.binaryValue = null, n.binaryAccessor = null, false;
      if (i.noAlloc)
        return false;
      if (n.binaryValue === e)
        return this.clearNeedsUpdate(), true;
      if (n.binaryValue = e, this.setNeedsRedraw(), ArrayBuffer.isView(e) && (e = { value: e }), i.transform || t !== this.startIndices) {
        he(ArrayBuffer.isView(e.value), "invalid ".concat(i.accessor));
        let o = e.size && e.size !== this.size;
        return n.binaryAccessor = Oa(e.value, { size: e.size || this.size, stride: e.stride, offset: e.offset, startIndices: t, nested: o }), false;
      }
      return this.clearNeedsUpdate(), this.setData(e), true;
    }
    getVertexOffset(e) {
      let { startIndices: t } = this;
      return (t ? t[e] : e) * this.size;
    }
    getShaderAttributes() {
      let e = this.settings.shaderAttributes || { [this.id]: null }, t = {};
      for (let n in e)
        Object.assign(t, super.getShaderAttributes(n, e[n]));
      return t;
    }
    _autoUpdater(e, { data: t, startRow: n, endRow: i, props: s, numInstances: o }) {
      if (e.constant)
        return;
      let { settings: a, state: c, value: l, size: f, startIndices: u } = e, { accessor: h, transform: d } = a, m = c.binaryAccessor || (typeof h == "function" ? h : s[h]);
      he(typeof m == "function", 'accessor "'.concat(h, '" is not a function'));
      let _ = e.getVertexOffset(n), { iterable: E, objectInfo: b } = sr(t, n, i);
      for (let T of E) {
        b.index++;
        let v = m(T, b);
        if (d && (v = d.call(this, v)), u) {
          let C = (b.index < u.length - 1 ? u[b.index + 1] : o) - u[b.index];
          if (v && Array.isArray(v[0])) {
            let S = _;
            for (let R of v)
              e._normalizeValue(R, l, S), S += f;
          } else
            v && v.length > f ? l.set(v, _) : (e._normalizeValue(v, b.target, 0), Cf({ target: l, source: b.target, start: _, count: C }));
          _ += C * f;
        } else
          e._normalizeValue(v, l, _), _ += f;
      }
    }
    _validateAttributeUpdaters() {
      let { settings: e } = this;
      if (!(e.noAlloc || typeof e.update == "function"))
        throw new Error("Attribute ".concat(this.id, " missing update or accessor"));
    }
    _checkAttributeArray() {
      let { value: e } = this, t = Math.min(4, this.size);
      if (e && e.length >= t) {
        let n = true;
        switch (t) {
          case 4:
            n = n && Number.isFinite(e[3]);
          case 3:
            n = n && Number.isFinite(e[2]);
          case 2:
            n = n && Number.isFinite(e[1]);
          case 1:
            n = n && Number.isFinite(e[0]);
            break;
          default:
            n = false;
        }
        if (!n)
          throw new Error("Illegal attribute generated for ".concat(this.id));
      }
    }
  };
  var ka = class {
    constructor({ gl: e, attribute: t, timeline: n }) {
      this.gl = e, this.type = "interpolation", this.transition = new ut(n), this.attribute = t, this.attributeInTransition = new Or(e, t.settings), this.currentStartIndices = t.startIndices, this.currentLength = 0, this.transform = eA(e, t);
      let i = { byteLength: 0, usage: 35050 };
      this.buffers = [new k(e, i), new k(e, i)];
    }
    get inProgress() {
      return this.transition.inProgress;
    }
    start(e, t) {
      if (e.duration <= 0) {
        this.transition.cancel();
        return;
      }
      let { gl: n, buffers: i, attribute: s } = this;
      Ba(i);
      let o = { numInstances: t, attribute: s, fromLength: this.currentLength, fromStartIndices: this.currentStartIndices, getData: e.enter };
      for (let a of i)
        Ua(x({ buffer: a }, o));
      this.currentStartIndices = s.startIndices, this.currentLength = ps(s, t), this.attributeInTransition.update({ buffer: i[1], value: s.value }), this.transition.start(e), this.transform.update({ elementCount: Math.floor(this.currentLength / s.size), sourceBuffers: { aFrom: i[0], aTo: Fa(n, s) }, feedbackBuffers: { vCurrent: i[1] } });
    }
    update() {
      let e = this.transition.update();
      if (e) {
        let { time: t, settings: { duration: n, easing: i } } = this.transition, s = i(t / n);
        this.transform.run({ uniforms: { time: s } });
      }
      return e;
    }
    cancel() {
      for (this.transition.cancel(), this.transform.delete(); this.buffers.length; )
        this.buffers.pop().delete();
    }
  };
  var $1 = `
#define SHADER_NAME interpolation-transition-vertex-shader

uniform float time;
attribute ATTRIBUTE_TYPE aFrom;
attribute ATTRIBUTE_TYPE aTo;
varying ATTRIBUTE_TYPE vCurrent;

void main(void) {
  vCurrent = mix(aFrom, aTo, time);
  gl_Position = vec4(0.0);
}
`;
  function eA(r2, e) {
    let t = Da(e.size);
    return new kt(r2, { vs: $1, defines: { ATTRIBUTE_TYPE: t }, varyings: ["vCurrent"] });
  }
  var Va = class {
    constructor({ gl: e, attribute: t, timeline: n }) {
      this.gl = e, this.type = "spring", this.transition = new ut(n), this.attribute = t, this.attributeInTransition = new Or(e, L(x({}, t.settings), { normalized: false })), this.currentStartIndices = t.startIndices, this.currentLength = 0, this.texture = rA(e), this.framebuffer = nA(e, this.texture), this.transform = tA(e, t, this.framebuffer);
      let i = { byteLength: 0, usage: 35050 };
      this.buffers = [new k(e, i), new k(e, i), new k(e, i)];
    }
    get inProgress() {
      return this.transition.inProgress;
    }
    start(e, t) {
      let { gl: n, buffers: i, attribute: s } = this, o = { numInstances: t, attribute: s, fromLength: this.currentLength, fromStartIndices: this.currentStartIndices, getData: e.enter };
      for (let a of i)
        Ua(x({ buffer: a }, o));
      this.currentStartIndices = s.startIndices, this.currentLength = ps(s, t), this.attributeInTransition.update({ buffer: i[1], value: s.value }), this.transition.start(e), this.transform.update({ elementCount: Math.floor(this.currentLength / s.size), sourceBuffers: { aTo: Fa(n, s) } });
    }
    update() {
      let { buffers: e, transform: t, framebuffer: n, transition: i } = this;
      return i.update() ? (t.update({ sourceBuffers: { aPrev: e[0], aCur: e[1] }, feedbackBuffers: { vNext: e[2] } }), t.run({ framebuffer: n, discard: false, clearRenderTarget: true, uniforms: { stiffness: i.settings.stiffness, damping: i.settings.damping }, parameters: { depthTest: false, blend: true, viewport: [0, 0, 1, 1], blendFunc: [1, 1], blendEquation: [32776, 32776] } }), Ba(e), this.attributeInTransition.update({ buffer: e[1], value: this.attribute.value }), Jt(n)[0] > 0 || i.end(), true) : false;
    }
    cancel() {
      for (this.transition.cancel(), this.transform.delete(); this.buffers.length; )
        this.buffers.pop().delete();
      this.texture.delete(), this.texture = null, this.framebuffer.delete(), this.framebuffer = null;
    }
  };
  function tA(r2, e, t) {
    let n = Da(e.size);
    return new kt(r2, { framebuffer: t, vs: `
#define SHADER_NAME spring-transition-vertex-shader

#define EPSILON 0.00001

uniform float stiffness;
uniform float damping;
attribute ATTRIBUTE_TYPE aPrev;
attribute ATTRIBUTE_TYPE aCur;
attribute ATTRIBUTE_TYPE aTo;
varying ATTRIBUTE_TYPE vNext;
varying float vIsTransitioningFlag;

ATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {
  ATTRIBUTE_TYPE velocity = cur - prev;
  ATTRIBUTE_TYPE delta = dest - cur;
  ATTRIBUTE_TYPE spring = delta * stiffness;
  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;
  return spring + damper + velocity + cur;
}

void main(void) {
  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;
  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;

  vNext = getNextValue(aCur, aPrev, aTo);
  gl_Position = vec4(0, 0, 0, 1);
  gl_PointSize = 100.0;
}
`, fs: `
#define SHADER_NAME spring-transition-is-transitioning-fragment-shader

varying float vIsTransitioningFlag;

void main(void) {
  if (vIsTransitioningFlag == 0.0) {
    discard;
  }
  gl_FragColor = vec4(1.0);
}`, defines: { ATTRIBUTE_TYPE: n }, varyings: ["vNext"] });
  }
  function rA(r2) {
    return new Q(r2, { data: new Uint8Array(4), format: 6408, type: 5121, border: 0, mipmaps: false, dataFormat: 6408, width: 1, height: 1 });
  }
  function nA(r2, e) {
    return new Z(r2, { id: "spring-transition-is-transitioning-framebuffer", width: 1, height: 1, attachments: { [36064]: e } });
  }
  var iA = { interpolation: ka, spring: Va };
  var Ga = class {
    constructor(e, { id: t, timeline: n }) {
      this.id = t, this.gl = e, this.timeline = n, this.transitions = {}, this.needsRedraw = false, this.numInstances = 1, this.isSupported = kt.isSupported(e);
    }
    finalize() {
      for (let e in this.transitions)
        this._removeTransition(e);
    }
    update({ attributes: e, transitions: t, numInstances: n }) {
      this.numInstances = n || 1;
      for (let i in e) {
        let s = e[i], o = s.getTransitionSetting(t);
        !o || this._updateAttribute(i, s, o);
      }
      for (let i in this.transitions) {
        let s = e[i];
        (!s || !s.getTransitionSetting(t)) && this._removeTransition(i);
      }
    }
    hasAttribute(e) {
      let t = this.transitions[e];
      return t && t.inProgress;
    }
    getAttributes() {
      let e = {};
      for (let t in this.transitions) {
        let n = this.transitions[t];
        n.inProgress && (e[t] = n.attributeInTransition);
      }
      return e;
    }
    run() {
      if (!this.isSupported || this.numInstances === 0)
        return false;
      for (let t in this.transitions)
        this.transitions[t].update() && (this.needsRedraw = true);
      let e = this.needsRedraw;
      return this.needsRedraw = false, e;
    }
    _removeTransition(e) {
      this.transitions[e].cancel(), delete this.transitions[e];
    }
    _updateAttribute(e, t, n) {
      let i = this.transitions[e], s = !i || i.type !== n.type;
      if (s) {
        if (!this.isSupported) {
          F.warn("WebGL2 not supported by this browser. Transition for ".concat(e, " is disabled."))();
          return;
        }
        i && this._removeTransition(e);
        let o = iA[n.type];
        o ? this.transitions[e] = new o({ attribute: t, timeline: this.timeline, gl: this.gl }) : (F.error("unsupported transition type '".concat(n.type, "'"))(), s = false);
      }
      (s || t.needsRedraw()) && (this.needsRedraw = true, this.transitions[e].start(n, this.numInstances));
    }
  };
  var lg = "attributeManager.invalidate";
  var sA = "attributeManager.updateStart";
  var oA = "attributeManager.updateEnd";
  var aA = "attribute.updateStart";
  var cA = "attribute.allocate";
  var lA = "attribute.updateEnd";
  var za = class {
    constructor(e, { id: t = "attribute-manager", stats: n, timeline: i } = {}) {
      this.id = t, this.gl = e, this.attributes = {}, this.updateTriggers = {}, this.accessors = {}, this.needsRedraw = true, this.userData = {}, this.stats = n, this.attributeTransitionManager = new Ga(e, { id: "".concat(t, "-transitions"), timeline: i }), Object.seal(this);
    }
    finalize() {
      for (let e in this.attributes)
        this.attributes[e].delete();
      this.attributeTransitionManager.finalize();
    }
    getNeedsRedraw(e = { clearRedrawFlags: false }) {
      let t = this.needsRedraw;
      return this.needsRedraw = this.needsRedraw && !e.clearRedrawFlags, t && this.id;
    }
    setNeedsRedraw(e = true) {
      return this.needsRedraw = true, this;
    }
    add(e, t) {
      this._add(e, t);
    }
    addInstanced(e, t) {
      this._add(e, t, { instanced: 1 });
    }
    remove(e) {
      for (let t = 0; t < e.length; t++) {
        let n = e[t];
        this.attributes[n] !== void 0 && (this.attributes[n].delete(), delete this.attributes[n]);
      }
    }
    invalidate(e, t) {
      let n = this._invalidateTrigger(e, t);
      se(lg, this, e, n);
    }
    invalidateAll(e) {
      for (let t in this.attributes)
        this.attributes[t].setNeedsUpdate(t, e);
      se(lg, this, "all");
    }
    update({ data: e, numInstances: t, startIndices: n = null, transitions: i, props: s = {}, buffers: o = {}, context: a = {} } = {}) {
      let c = false;
      se(sA, this), this.stats && this.stats.get("Update Attributes").timeStart();
      for (let l in this.attributes) {
        let f = this.attributes[l], u = f.settings.accessor;
        f.startIndices = n, s[l] && F.removed("props.".concat(l), "data.attributes.".concat(l))(), f.setExternalBuffer(o[l]) || f.setBinaryValue(o[u], e.startIndices) || !o[u] && f.setConstantValue(s[u]) || f.needsUpdate() && (c = true, this._updateAttribute({ attribute: f, numInstances: t, data: e, props: s, context: a })), this.needsRedraw |= f.needsRedraw();
      }
      c && se(oA, this, t), this.stats && this.stats.get("Update Attributes").timeEnd(), this.attributeTransitionManager.update({ attributes: this.attributes, numInstances: t, transitions: i });
    }
    updateTransition() {
      let { attributeTransitionManager: e } = this, t = e.run();
      return this.needsRedraw = this.needsRedraw || t, t;
    }
    getAttributes() {
      return this.attributes;
    }
    getChangedAttributes(e = { clearChangedFlags: false }) {
      let { attributes: t, attributeTransitionManager: n } = this, i = x({}, n.getAttributes());
      for (let s in t) {
        let o = t[s];
        o.needsRedraw(e) && !n.hasAttribute(s) && (i[s] = o);
      }
      return i;
    }
    getShaderAttributes(e, t = {}) {
      e || (e = this.getAttributes());
      let n = {};
      for (let i in e)
        t[i] || Object.assign(n, e[i].getShaderAttributes());
      return n;
    }
    getAccessors() {
      return this.updateTriggers;
    }
    _add(e, t, n = {}) {
      t && F.warn("AttributeManager.add({updaters}) - updater map no longer supported")();
      for (let i in e) {
        let s = e[i];
        this.attributes[i] = this._createAttribute(i, s, n);
      }
      this._mapUpdateTriggersToAttributes();
    }
    _createAttribute(e, t, n) {
      let i = L(x({}, t), { id: e, constant: t.constant || false, isIndexed: t.isIndexed || t.elements, size: t.elements && 1 || t.size, value: t.value || null, divisor: t.instanced || n.instanced ? 1 : t.divisor });
      return new Or(this.gl, i);
    }
    _mapUpdateTriggersToAttributes() {
      let e = {};
      for (let t in this.attributes)
        this.attributes[t].getUpdateTriggers().forEach((i) => {
          e[i] || (e[i] = []), e[i].push(t);
        });
      this.updateTriggers = e;
    }
    _invalidateTrigger(e, t) {
      let { attributes: n, updateTriggers: i } = this, s = i[e];
      return s && s.forEach((o) => {
        let a = n[o];
        a && a.setNeedsUpdate(a.id, t);
      }), s;
    }
    _updateAttribute(e) {
      let { attribute: t, numInstances: n } = e;
      se(aA, t), t.allocate(n) && se(cA, t, n), t.updateBuffer(e) && (this.needsRedraw = true, se(lA, t, n));
    }
  };
  var ja = class extends ut {
    get value() {
      return this._value;
    }
    _onUpdate() {
      let { time: e, settings: { fromValue: t, toValue: n, duration: i, easing: s } } = this, o = s(e / i);
      this._value = Et(t, n, o);
    }
  };
  var fg = 1e-5;
  function ug(r2, e, t, n, i) {
    let s = e - r2, a = (t - e) * i, c = -s * n;
    return a + c + s + e;
  }
  function fA(r2, e, t, n, i) {
    if (Array.isArray(t)) {
      let s = [];
      for (let o = 0; o < t.length; o++)
        s[o] = ug(r2[o], e[o], t[o], n, i);
      return s;
    }
    return ug(r2, e, t, n, i);
  }
  function hg(r2, e) {
    if (Array.isArray(r2)) {
      let t = 0;
      for (let n = 0; n < r2.length; n++) {
        let i = r2[n] - e[n];
        t += i * i;
      }
      return Math.sqrt(t);
    }
    return Math.abs(r2 - e);
  }
  var Wa = class extends ut {
    get value() {
      return this._currValue;
    }
    _onUpdate() {
      let { fromValue: e, toValue: t, damping: n, stiffness: i } = this.settings, { _prevValue: s = e, _currValue: o = e } = this, a = fA(s, o, t, n, i), c = hg(a, t), l = hg(a, o);
      c < fg && l < fg && (a = t, this.end()), this._prevValue = o, this._currValue = a;
    }
  };
  var uA = { interpolation: ja, spring: Wa };
  var Ha = class {
    constructor(e) {
      this.transitions = new Map(), this.timeline = e;
    }
    get active() {
      return this.transitions.size > 0;
    }
    add(e, t, n, i) {
      let { transitions: s } = this;
      if (s.has(e)) {
        let c = s.get(e), { value: l = c.settings.fromValue } = c;
        t = l, this.remove(e);
      }
      if (i = Na(i), !i)
        return;
      let o = uA[i.type];
      if (!o) {
        F.error("unsupported transition type '".concat(i.type, "'"))();
        return;
      }
      let a = new o(this.timeline);
      a.start(L(x({}, i), { fromValue: t, toValue: n })), s.set(e, a);
    }
    remove(e) {
      let { transitions: t } = this;
      t.has(e) && (t.get(e).cancel(), t.delete(e));
    }
    update() {
      let e = {};
      for (let [t, n] of this.transitions)
        n.update(), e[t] = n.value, n.inProgress || this.remove(t);
      return e;
    }
    clear() {
      for (let e of this.transitions.keys())
        this.remove(e);
    }
  };
  var { COMPONENT: hA } = Rr;
  function dg(r2) {
    let e = Vf(r2);
    for (let t in e) {
      let n = e[t], { validate: i } = n;
      if (i && !i(r2[t], n))
        throw new Error("Invalid prop ".concat(t, ": ").concat(r2[t]));
    }
  }
  function pg(r2, e) {
    let t = mg({ newProps: r2, oldProps: e, propTypes: Vf(r2), ignoreProps: { data: null, updateTriggers: null, extensions: null, transitions: null } }), n = pA(r2, e), i = false;
    return n || (i = mA(r2, e)), { dataChanged: n, propsChanged: t, updateTriggersChanged: i, extensionsChanged: gA(r2, e), transitionsChanged: dA(r2, e) };
  }
  function dA(r2, e) {
    if (!r2.transitions)
      return null;
    let t = {}, n = Vf(r2);
    for (let i in r2.transitions) {
      let s = n[i], o = s && s.type;
      (o === "number" || o === "color" || o === "array") && kf(r2[i], e[i], s) && (t[i] = true);
    }
    return t;
  }
  function mg({ newProps: r2, oldProps: e, ignoreProps: t = {}, propTypes: n = {}, triggerName: i = "props" } = {}) {
    if (e === r2)
      return null;
    if (typeof r2 != "object" || r2 === null || typeof e != "object" || e === null)
      return "".concat(i, " changed shallowly");
    for (let s of Object.keys(r2))
      if (!(s in t)) {
        if (!(s in e))
          return "".concat(i, ".").concat(s, " added");
        let o = kf(r2[s], e[s], n[s]);
        if (o)
          return "".concat(i, ".").concat(s, " ").concat(o);
      }
    for (let s of Object.keys(e))
      if (!(s in t)) {
        if (!(s in r2))
          return "".concat(i, ".").concat(s, " dropped");
        if (!Object.hasOwnProperty.call(r2, s)) {
          let o = kf(r2[s], e[s], n[s]);
          if (o)
            return "".concat(i, ".").concat(s, " ").concat(o);
        }
      }
    return null;
  }
  function kf(r2, e, t) {
    let n = t && t.equal;
    return n && !n(r2, e, t) || !n && (n = r2 && e && r2.equals, n && !n.call(r2, e)) ? "changed deeply" : !n && e !== r2 ? "changed shallowly" : null;
  }
  function pA(r2, e) {
    if (e === null)
      return "oldProps is null, initial diff";
    let t = null, { dataComparator: n, _dataDiff: i } = r2;
    return n ? n(r2.data, e.data) || (t = "Data comparator detected a change") : r2.data !== e.data && (t = "A new data container was supplied"), t && i && (t = i(r2.data, e.data) || t), t;
  }
  function mA(r2, e) {
    if (e === null)
      return "oldProps is null, initial diff";
    if ("all" in r2.updateTriggers && gg(r2, e, "all"))
      return { all: true };
    let t = {}, n = false;
    for (let i in r2.updateTriggers)
      i !== "all" && gg(r2, e, i) && (t[i] = true, n = t);
    return n;
  }
  function gA(r2, e) {
    if (e === null)
      return "oldProps is null, initial diff";
    let t = e.extensions, { extensions: n } = r2;
    if (n === t)
      return false;
    if (n.length !== t.length)
      return true;
    for (let i = 0; i < n.length; i++)
      if (!n[i].equals(t[i]))
        return true;
    return false;
  }
  function gg(r2, e, t) {
    let n = r2.updateTriggers[t];
    n = n == null ? {} : n;
    let i = e.updateTriggers[t];
    return i = i == null ? {} : i, mg({ oldProps: i, newProps: n, triggerName: t });
  }
  function Vf(r2) {
    let e = r2[hA], t = e && e.constructor;
    return t ? t._propTypes : {};
  }
  var _A = "count(): argument not an object";
  var xA = "count(): argument not a container";
  function _g(r2) {
    if (!EA(r2))
      throw new Error(_A);
    if (typeof r2.count == "function")
      return r2.count();
    if (Number.isFinite(r2.size))
      return r2.size;
    if (Number.isFinite(r2.length))
      return r2.length;
    if (yA(r2))
      return Object.keys(r2).length;
    throw new Error(xA);
  }
  function yA(r2) {
    return r2 !== null && typeof r2 == "object" && r2.constructor === Object;
  }
  function EA(r2) {
    return r2 !== null && typeof r2 == "object";
  }
  function xg(r2, e) {
    if (!e)
      return r2;
    let t = x(x({}, r2), e);
    if ("defines" in e && (t.defines = x(x({}, r2.defines), e.defines)), "modules" in e && (t.modules = (r2.modules || []).concat(e.modules), e.modules.some((n) => n.name === "project64"))) {
      let n = t.modules.findIndex((i) => i.name === "project32");
      n >= 0 && t.modules.splice(n, 1);
    }
    if ("inject" in e)
      if (!r2.inject)
        t.inject = e.inject;
      else {
        let n = x({}, r2.inject);
        for (let i in e.inject)
          n[i] = (n[i] || "") + e.inject[i];
        t.inject = n;
      }
    return t;
  }
  var bA = { [10241]: 9987, [10240]: 9729, [10242]: 33071, [10243]: 33071 };
  var Gf = {};
  function yg(r2, e) {
    let t = r2.context && r2.context.gl;
    if (!t || !e)
      return null;
    if (e instanceof Q)
      return e;
    e.constructor && e.constructor.name !== "Object" && (e = { data: e });
    let n = null;
    e.compressed && (n = { [10241]: e.data.length > 1 ? 9985 : 9729 });
    let i = new Q(t, L(x({}, e), { parameters: x(x(x({}, bA), n), r2.props.textureParameters) }));
    return Gf[i.id] = true, i;
  }
  function Eg(r2) {
    !r2 || !(r2 instanceof Q) || Gf[r2.id] && (r2.delete(), delete Gf[r2.id]);
  }
  var TA = { boolean: { validate(r2, e) {
    return true;
  }, equal(r2, e, t) {
    return Boolean(r2) === Boolean(e);
  } }, number: { validate(r2, e) {
    return Number.isFinite(r2) && (!("max" in e) || r2 <= e.max) && (!("min" in e) || r2 >= e.min);
  } }, color: { validate(r2, e) {
    return e.optional && !r2 || gs(r2) && (r2.length === 3 || r2.length === 4);
  }, equal(r2, e, t) {
    return zf(r2, e);
  } }, accessor: { validate(r2, e) {
    let t = Xa(r2);
    return t === "function" || t === Xa(e.value);
  }, equal(r2, e, t) {
    return typeof e == "function" ? true : zf(r2, e);
  } }, array: { validate(r2, e) {
    return e.optional && !r2 || gs(r2);
  }, equal(r2, e, t) {
    return t.compare ? zf(r2, e) : r2 === e;
  } }, function: { validate(r2, e) {
    return e.optional && !r2 || typeof r2 == "function";
  }, equal(r2, e, t) {
    return !t.compare || r2 === e;
  } }, data: { transform: (r2, e, t) => {
    let { dataTransform: n } = t ? t.props : {};
    return n && r2 ? n(r2) : r2;
  } }, image: { transform: (r2, e, t) => yg(t, r2), release: (r2) => {
    Eg(r2);
  } } };
  function zf(r2, e) {
    if (r2 === e)
      return true;
    if (!gs(r2) || !gs(e))
      return false;
    let t = r2.length;
    if (t !== e.length)
      return false;
    for (let n = 0; n < t; n++)
      if (r2[n] !== e[n])
        return false;
    return true;
  }
  function bg(r2) {
    let e = {}, t = {}, n = {};
    for (let [i, s] of Object.entries(r2))
      if (s && s.deprecatedFor)
        n[i] = Array.isArray(s.deprecatedFor) ? s.deprecatedFor : [s.deprecatedFor];
      else {
        let o = vA(i, s);
        e[i] = o, t[i] = o.value;
      }
    return { propTypes: e, defaultProps: t, deprecatedProps: n };
  }
  function vA(r2, e) {
    switch (Xa(e)) {
      case "object":
        return ms(r2, e);
      case "array":
        return ms(r2, { type: "array", value: e, compare: false });
      case "boolean":
        return ms(r2, { type: "boolean", value: e });
      case "number":
        return ms(r2, { type: "number", value: e });
      case "function":
        return ms(r2, { type: "function", value: e, compare: true });
      default:
        return { name: r2, type: "unknown", value: e };
    }
  }
  function ms(r2, e) {
    return "type" in e ? x(x({ name: r2 }, TA[e.type]), e) : "value" in e ? x({ name: r2, type: Xa(e.value) }, e) : { name: r2, type: "object", value: e };
  }
  function gs(r2) {
    return Array.isArray(r2) || ArrayBuffer.isView(r2);
  }
  function Xa(r2) {
    return gs(r2) ? "array" : r2 === null ? "null" : typeof r2;
  }
  var { COMPONENT: jf, ASYNC_ORIGINAL: Ya, ASYNC_RESOLVED: _s, ASYNC_DEFAULTS: qa } = Rr;
  function Tg() {
    let r2 = this, e = vg(r2.constructor), t = Object.create(e);
    t[jf] = r2, t[Ya] = {}, t[_s] = {};
    for (let n = 0; n < arguments.length; ++n) {
      let i = arguments[n];
      for (let s in i)
        t[s] = i[s];
    }
    return Object.freeze(t), t;
  }
  function vg(r2) {
    let e = Za(r2, "_mergedDefaultProps");
    return e || (AA(r2), r2._mergedDefaultProps);
  }
  function AA(r2) {
    if (!r2.prototype)
      return;
    let t = Object.getPrototypeOf(r2), n = vg(t), i = Za(r2, "defaultProps") || {}, s = bg(i), o = SA(s.defaultProps, n, r2), a = x(x({}, t._propTypes), s.propTypes);
    PA(o, a);
    let c = x(x({}, t._deprecatedProps), s.deprecatedProps);
    wA(o, c), r2._mergedDefaultProps = o, r2._propTypes = a, r2._deprecatedProps = c;
  }
  function SA(r2, e, t) {
    let n = Object.create(null);
    Object.assign(n, e, r2);
    let i = CA(t);
    return delete r2.id, Object.defineProperties(n, { id: { writable: true, value: i } }), n;
  }
  function wA(r2, e) {
    for (let t in e)
      Object.defineProperty(r2, t, { enumerable: false, set(n) {
        let i = "".concat(this.id, ": ").concat(t);
        for (let s of e[t])
          Ag(this, s) || (this[s] = n);
        F.deprecated(i, e[t].join("/"))();
      } });
  }
  function PA(r2, e) {
    let t = {}, n = {};
    for (let i in e) {
      let s = e[i], { name: o, value: a } = s;
      s.async && (t[o] = a, n[o] = LA(o, a));
    }
    r2[qa] = t, r2[Ya] = {}, Object.defineProperties(r2, n);
  }
  function LA(r2) {
    return { enumerable: true, set(e) {
      typeof e == "string" || e instanceof Promise || Ia(e) ? this[Ya][r2] = e : this[_s][r2] = e;
    }, get() {
      if (this[_s]) {
        if (r2 in this[_s])
          return this[_s][r2] || this[qa][r2];
        if (r2 in this[Ya]) {
          let e = this[jf] && this[jf].internalState;
          if (e && e.hasAsyncProp(r2))
            return e.getAsyncProp(r2) || this[qa][r2];
        }
      }
      return this[qa][r2];
    } };
  }
  function Ag(r2, e) {
    return Object.prototype.hasOwnProperty.call(r2, e);
  }
  function Za(r2, e) {
    return Ag(r2, e) && r2[e];
  }
  function CA(r2) {
    let e = Za(r2, "layerName") || Za(r2, "componentName");
    return e || F.once(0, "".concat(r2.name, ".componentName not specified"))(), e || r2.name;
  }
  var { ASYNC_ORIGINAL: RA, ASYNC_RESOLVED: MA, ASYNC_DEFAULTS: IA } = Rr;
  var OA = Object.freeze({});
  var Jn = class {
    constructor(e = null) {
      this.component = e, this.asyncProps = {}, this.onAsyncPropUpdated = () => {
      }, this.oldProps = OA, this.oldAsyncProps = null;
    }
    finalize() {
      for (let e in this.asyncProps) {
        let t = this.asyncProps[e];
        t.type && t.type.release && t.type.release(t.resolvedValue, t.type, this.component);
      }
    }
    getOldProps() {
      return this.oldAsyncProps || this.oldProps;
    }
    resetOldProps() {
      this.oldAsyncProps = null, this.oldProps = this.component.props;
    }
    freezeAsyncOldProps() {
      if (!this.oldAsyncProps) {
        this.oldProps = this.oldProps || this.component.props, this.oldAsyncProps = Object.create(this.oldProps);
        for (let e in this.asyncProps)
          Object.defineProperty(this.oldAsyncProps, e, { enumerable: true, value: this.oldProps[e] });
      }
    }
    hasAsyncProp(e) {
      return e in this.asyncProps;
    }
    getAsyncProp(e) {
      let t = this.asyncProps[e];
      return t && t.resolvedValue;
    }
    isAsyncPropLoading(e) {
      if (e) {
        let t = this.asyncProps[e];
        return Boolean(t && t.pendingLoadCount > 0 && t.pendingLoadCount !== t.resolvedLoadCount);
      }
      for (let t in this.asyncProps)
        if (this.isAsyncPropLoading(t))
          return true;
      return false;
    }
    reloadAsyncProp(e, t) {
      this._watchPromise(e, Promise.resolve(t));
    }
    setAsyncProps(e) {
      let t = e[MA] || {}, n = e[RA] || e, i = e[IA] || {};
      for (let s in t) {
        let o = t[s];
        this._createAsyncPropData(s, i[s]), this._updateAsyncProp(s, o), t[s] = this.getAsyncProp(s);
      }
      for (let s in n) {
        let o = n[s];
        this._createAsyncPropData(s, i[s]), this._updateAsyncProp(s, o);
      }
    }
    _updateAsyncProp(e, t) {
      if (!!this._didAsyncInputValueChange(e, t)) {
        if (typeof t == "string") {
          var n;
          let i = (n = this.layer) === null || n === void 0 ? void 0 : n.props.fetch;
          i && (t = i(t, { propName: e, layer: this.layer }));
        }
        if (t instanceof Promise) {
          this._watchPromise(e, t);
          return;
        }
        if (Ia(t)) {
          this._resolveAsyncIterable(e, t);
          return;
        }
        this._setPropValue(e, t);
      }
    }
    _didAsyncInputValueChange(e, t) {
      let n = this.asyncProps[e];
      return t === n.resolvedValue || t === n.lastValue ? false : (n.lastValue = t, true);
    }
    _setPropValue(e, t) {
      let n = this.asyncProps[e];
      t = this._postProcessValue(n, t), n.resolvedValue = t, n.pendingLoadCount++, n.resolvedLoadCount = n.pendingLoadCount;
    }
    _setAsyncPropValue(e, t, n) {
      let i = this.asyncProps[e];
      i && n >= i.resolvedLoadCount && t !== void 0 && (this.freezeAsyncOldProps(), i.resolvedValue = t, i.resolvedLoadCount = n, this.onAsyncPropUpdated(e, t));
    }
    _watchPromise(e, t) {
      let n = this.asyncProps[e];
      n.pendingLoadCount++;
      let i = n.pendingLoadCount;
      t.then((s) => {
        var o;
        s = this._postProcessValue(n, s), this._setAsyncPropValue(e, s, i);
        let a = (o = this.layer) === null || o === void 0 ? void 0 : o.props.onDataLoad;
        e === "data" && a && a(s, { propName: e, layer: this.layer });
      }).catch((s) => {
        var o;
        (o = this.layer) === null || o === void 0 || o.raiseError(s, "loading ".concat(e, " of ").concat(this.layer));
      });
    }
    async _resolveAsyncIterable(e, t) {
      var n;
      e !== "data" && this._setPropValue(e, t);
      let i = this.asyncProps[e];
      i.pendingLoadCount++;
      let s = i.pendingLoadCount, o = [], a = 0;
      for await (let l of t) {
        let { dataTransform: f } = this.component ? this.component.props : {};
        f ? o = f(l, o) : o = o.concat(l), Object.defineProperty(o, "__diff", { enumerable: false, value: [{ startRow: a, endRow: o.length }] }), a = o.length, this._setAsyncPropValue(e, o, s);
      }
      let c = (n = this.layer) === null || n === void 0 ? void 0 : n.props.onDataLoad;
      c && c(o, { propName: e, layer: this.layer });
    }
    _postProcessValue(e, t) {
      let n = e.type;
      return n && (n.release && n.release(e.resolvedValue, n, this.component), n.transform) ? n.transform(t, n, this.component) : t;
    }
    _createAsyncPropData(e, t) {
      if (!this.asyncProps[e]) {
        let i = this.component && this.component.constructor._propTypes;
        this.asyncProps[e] = { type: i && i[e], lastValue: null, resolvedValue: t, pendingLoadCount: 0, resolvedLoadCount: 0 };
      }
    }
  };
  var { ASYNC_ORIGINAL: Sg, ASYNC_RESOLVED: wg, ASYNC_DEFAULTS: NA } = Rr;
  var FA = {};
  var DA = 0;
  var $n = class {
    constructor() {
      this.props = Tg.apply(this, arguments), this.id = this.props.id, this.count = DA++, this.lifecycle = Cr.NO_STATE, this.parent = null, this.context = null, this.state = null, this.internalState = null, Object.seal(this);
    }
    clone(e) {
      let { props: t } = this, n = {};
      for (let i in t[NA])
        i in t[wg] ? n[i] = t[wg][i] : i in t[Sg] && (n[i] = t[Sg][i]);
      return new this.constructor(x(x(x({}, t), n), e));
    }
    get stats() {
      return this.internalState.stats;
    }
    _initState() {
      this.internalState = new Jn({});
    }
  };
  $n.componentName = "Component";
  $n.defaultProps = FA;
  var Ka = class extends Jn {
    constructor({ attributeManager: e, layer: t }) {
      super(t);
      this.attributeManager = e, this.model = null, this.needsRedraw = true, this.subLayers = null, this.usesPickingColorCache = false;
    }
    get layer() {
      return this.component;
    }
    set layer(e) {
      this.component = e;
    }
  };
  var BA = "layer.changeFlag";
  var UA = "layer.initialize";
  var kA = "layer.update";
  var VA = "layer.finalize";
  var GA = "layer.matched";
  var Pg = 2 ** 24 - 1;
  var zA = Object.freeze([]);
  var jA = wr(({ oldViewport: r2, viewport: e }) => r2.equals(e));
  var Gt = new Uint8ClampedArray(0);
  var WA = { data: { type: "data", value: zA, async: true }, dataComparator: null, _dataDiff: { type: "function", value: (r2) => r2 && r2.__diff, compare: false, optional: true }, dataTransform: { type: "function", value: null, compare: false, optional: true }, onDataLoad: { type: "function", value: null, compare: false, optional: true }, onError: { type: "function", value: null, compare: false, optional: true }, fetch: { type: "function", value: (r2, { propName: e, layer: t, loaders: n, loadOptions: i, signal: s }) => {
    let { resourceManager: o } = t.context;
    if (i = i || t.getLoadOptions(), n = n || t.props.loaders, s) {
      var a;
      i = L(x({}, i), { fetch: L(x({}, (a = i) === null || a === void 0 ? void 0 : a.fetch), { signal: s }) });
    }
    let c = o.contains(r2);
    return !c && !i && (o.add({ resourceId: r2, data: hr(r2, n), persistent: false }), c = true), c ? o.subscribe({ resourceId: r2, onChange: (l) => t.internalState.reloadAsyncProp(e, l), consumerId: t.id, requestId: e }) : hr(r2, n, i);
  }, compare: false }, updateTriggers: {}, visible: true, pickable: false, opacity: { type: "number", min: 0, max: 1, value: 1 }, onHover: { type: "function", value: null, compare: false, optional: true }, onClick: { type: "function", value: null, compare: false, optional: true }, onDragStart: { type: "function", value: null, compare: false, optional: true }, onDrag: { type: "function", value: null, compare: false, optional: true }, onDragEnd: { type: "function", value: null, compare: false, optional: true }, coordinateSystem: j.DEFAULT, coordinateOrigin: { type: "array", value: [0, 0, 0], compare: true }, modelMatrix: { type: "array", value: null, compare: true, optional: true }, wrapLongitude: false, positionFormat: "XYZ", colorFormat: "RGBA", parameters: {}, transitions: null, extensions: [], loaders: { type: "array", value: [], optional: true, compare: true }, getPolygonOffset: { type: "function", value: ({ layerIndex: r2 }) => [0, -r2 * 100], compare: false }, highlightedObjectIndex: -1, autoHighlight: false, highlightColor: { type: "accessor", value: [0, 0, 128, 128] } };
  var ye = class extends $n {
    toString() {
      let e = this.constructor.layerName || this.constructor.name;
      return "".concat(e, "({id: '").concat(this.props.id, "'})");
    }
    raiseError(e, t) {
      var n, i;
      if (t && (e.message = "".concat(t, ": ").concat(e.message)), !((n = (i = this.props).onError) === null || n === void 0 ? void 0 : n.call(i, e))) {
        var s, o;
        (s = this.context) === null || s === void 0 || (o = s.onError) === null || o === void 0 || o.call(s, e, this);
      }
    }
    setState(e) {
      this.setChangeFlags({ stateChanged: true }), Object.assign(this.state, e), this.setNeedsRedraw();
    }
    setNeedsRedraw(e = true) {
      this.internalState && (this.internalState.needsRedraw = e);
    }
    setNeedsUpdate() {
      this.context.layerManager.setNeedsUpdate(String(this)), this.internalState.needsUpdate = true;
    }
    getNeedsRedraw(e = { clearRedrawFlags: false }) {
      return this._getNeedsRedraw(e);
    }
    needsUpdate() {
      return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());
    }
    hasUniformTransition() {
      return this.internalState.uniformTransitions.active;
    }
    get isLoaded() {
      return this.internalState && !this.internalState.isAsyncPropLoading();
    }
    get wrapLongitude() {
      return this.props.wrapLongitude;
    }
    isPickable() {
      return this.props.pickable && this.props.visible;
    }
    getModels() {
      return this.state && (this.state.models || (this.state.model ? [this.state.model] : []));
    }
    getAttributeManager() {
      return this.internalState && this.internalState.attributeManager;
    }
    getCurrentLayer() {
      return this.internalState && this.internalState.layer;
    }
    getLoadOptions() {
      return this.props.loadOptions;
    }
    project(e) {
      let { viewport: t } = this.context, n = Lf(e, { viewport: t, modelMatrix: this.props.modelMatrix, coordinateOrigin: this.props.coordinateOrigin, coordinateSystem: this.props.coordinateSystem }), [i, s, o] = tn(n, t.pixelProjectionMatrix);
      return e.length === 2 ? [i, s] : [i, s, o];
    }
    unproject(e) {
      let { viewport: t } = this.context;
      return t.unproject(e);
    }
    projectPosition(e) {
      return bm(e, { viewport: this.context.viewport, modelMatrix: this.props.modelMatrix, coordinateOrigin: this.props.coordinateOrigin, coordinateSystem: this.props.coordinateSystem });
    }
    use64bitPositions() {
      let { coordinateSystem: e } = this.props;
      return e === j.DEFAULT || e === j.LNGLAT || e === j.CARTESIAN;
    }
    onHover(e, t) {
      return this.props.onHover ? this.props.onHover(e, t) : false;
    }
    onClick(e, t) {
      return this.props.onClick ? this.props.onClick(e, t) : false;
    }
    nullPickingColor() {
      return [0, 0, 0];
    }
    encodePickingColor(e, t = []) {
      return t[0] = e + 1 & 255, t[1] = e + 1 >> 8 & 255, t[2] = e + 1 >> 8 >> 8 & 255, t;
    }
    decodePickingColor(e) {
      he(e instanceof Uint8Array);
      let [t, n, i] = e;
      return t + n * 256 + i * 65536 - 1;
    }
    initializeState() {
      throw new Error("Layer ".concat(this, " has not defined initializeState"));
    }
    getShaders(e) {
      for (let t of this.props.extensions)
        e = xg(e, t.getShaders.call(this, t));
      return e;
    }
    shouldUpdateState({ oldProps: e, props: t, context: n, changeFlags: i }) {
      return i.propsOrDataChanged;
    }
    updateState({ oldProps: e, props: t, context: n, changeFlags: i }) {
      let s = this.getAttributeManager();
      if (i.dataChanged && s) {
        let { dataChanged: c } = i;
        if (Array.isArray(c))
          for (let l of c)
            s.invalidateAll(l);
        else
          s.invalidateAll();
      }
      let o = e.highlightedObjectIndex >= 0 || e.pickable, a = t.highlightedObjectIndex >= 0 || t.pickable;
      if (o !== a && s) {
        let { pickingColors: c, instancePickingColors: l } = s.attributes, f = c || l;
        f && (a && f.constant && (f.constant = false, s.invalidate(f.id)), !f.value && !a && (f.constant = true, f.value = [0, 0, 0]));
      }
    }
    finalizeState() {
      for (let t of this.getModels())
        t.delete();
      let e = this.getAttributeManager();
      e && e.finalize(), this.context.resourceManager.unsubscribe({ consumerId: this.id }), this.internalState.uniformTransitions.clear(), this.internalState.finalize();
    }
    draw(e) {
      for (let t of this.getModels())
        t.draw(e);
    }
    getPickingInfo({ info: e, mode: t }) {
      let { index: n } = e;
      return n >= 0 && Array.isArray(this.props.data) && (e.object = this.props.data[n]), e;
    }
    activateViewport(e) {
      let t = this.internalState.viewport;
      this.internalState.viewport = e, (!t || !jA({ oldViewport: t, viewport: e })) && (this.setChangeFlags({ viewportChanged: true }), this.isComposite ? this.needsUpdate() && this.setNeedsUpdate() : this._update());
    }
    invalidateAttribute(e = "all", t = "") {
      let n = this.getAttributeManager();
      !n || (e === "all" ? n.invalidateAll() : n.invalidate(e));
    }
    updateAttributes(e) {
      for (let t of this.getModels())
        this._setModelAttributes(t, e);
    }
    _updateAttributes(e) {
      let t = this.getAttributeManager();
      if (!t)
        return;
      let n = this.getNumInstances(e), i = this.getStartIndices(e);
      t.update({ data: e.data, numInstances: n, startIndices: i, props: e, transitions: e.transitions, buffers: e.data.attributes, context: this, ignoreUnknownAttributes: true });
      let s = t.getChangedAttributes({ clearChangedFlags: true });
      this.updateAttributes(s);
    }
    _updateAttributeTransition() {
      let e = this.getAttributeManager();
      e && e.updateTransition();
    }
    _updateUniformTransition() {
      let { uniformTransitions: e } = this.internalState;
      if (e.active) {
        let t = e.update(), n = Object.create(this.props);
        for (let i in t)
          Object.defineProperty(n, i, { value: t[i] });
        return n;
      }
      return this.props;
    }
    calculateInstancePickingColors(e, { numInstances: t }) {
      if (e.constant)
        return;
      let n = Math.floor(Gt.length / 3);
      if (this.internalState.usesPickingColorCache = true, n < t) {
        t > Pg && F.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")(), Gt = At.allocate(Gt, t, { size: 3, copy: true, maxCount: Math.max(t, Pg) });
        let i = Math.floor(Gt.length / 3), s = [];
        for (let o = n; o < i; o++)
          this.encodePickingColor(o, s), Gt[o * 3 + 0] = s[0], Gt[o * 3 + 1] = s[1], Gt[o * 3 + 2] = s[2];
      }
      e.value = Gt.subarray(0, t * 3);
    }
    _setModelAttributes(e, t) {
      let n = this.getAttributeManager(), i = e.userData.excludeAttributes || {}, s = n.getShaderAttributes(t, i);
      e.setAttributes(s);
    }
    disablePickingIndex(e) {
      this._disablePickingIndex(e);
    }
    _disablePickingIndex(e) {
      let { pickingColors: t, instancePickingColors: n } = this.getAttributeManager().attributes, i = t || n, s = i.getVertexOffset(e), o = i.getVertexOffset(e + 1);
      i.buffer.subData({ data: new Uint8Array(o - s), offset: s });
    }
    restorePickingColors() {
      let { pickingColors: e, instancePickingColors: t } = this.getAttributeManager().attributes, n = e || t;
      this.internalState.usesPickingColorCache && n.value.buffer !== Gt.buffer && (n.value = Gt.subarray(0, n.value.length)), n.updateSubBuffer({ startOffset: 0 });
    }
    getNumInstances(e) {
      return e = e || this.props, e.numInstances !== void 0 ? e.numInstances : this.state && this.state.numInstances !== void 0 ? this.state.numInstances : _g(e.data);
    }
    getStartIndices(e) {
      return e = e || this.props, e.startIndices !== void 0 ? e.startIndices : this.state && this.state.startIndices ? this.state.startIndices : null;
    }
    _initialize() {
      se(UA, this), this._initState(), this.initializeState(this.context);
      for (let e of this.props.extensions)
        e.initializeState.call(this, this.context, e);
      this.setChangeFlags({ dataChanged: true, propsChanged: true, viewportChanged: true, extensionsChanged: true }), this._updateState();
    }
    _update() {
      let e = this.needsUpdate();
      se(kA, this, e), e && this._updateState();
    }
    _updateState() {
      let e = this.props, t = this.context.viewport, n = this._updateUniformTransition();
      this.internalState.propsInTransition = n, this.context.viewport = this.internalState.viewport || t, this.props = n;
      try {
        let i = this._getUpdateParams(), s = this.getModels();
        if (this.context.gl)
          this.updateState(i);
        else
          try {
            this.updateState(i);
          } catch (a) {
          }
        for (let a of this.props.extensions)
          a.updateState.call(this, i, a);
        let o = this.getModels()[0] !== s[0];
        this._updateModules(i, o), this.isComposite ? this._renderLayers(i) : (this.setNeedsRedraw(), this._updateAttributes(this.props), this.state.model && this.state.model.setInstanceCount(this.getNumInstances()));
      } finally {
        this.context.viewport = t, this.props = e, this.clearChangeFlags(), this.internalState.needsUpdate = false, this.internalState.resetOldProps();
      }
    }
    _finalize() {
      se(VA, this), this.finalizeState(this.context);
      for (let e of this.props.extensions)
        e.finalizeState.call(this, e);
    }
    drawLayer({ moduleParameters: e = null, uniforms: t = {}, parameters: n = {} }) {
      this._updateAttributeTransition();
      let i = this.props;
      this.props = this.internalState.propsInTransition || i;
      let { opacity: s } = this.props;
      t.opacity = Math.pow(s, 1 / 2.2);
      try {
        e && this.setModuleParameters(e);
        let { getPolygonOffset: o } = this.props, a = o && o(t) || [0, 0];
        De(this.context.gl, { polygonOffset: a }), ae(this.context.gl, n, () => {
          let c = { moduleParameters: e, uniforms: t, parameters: n, context: this.context };
          for (let l of this.props.extensions)
            l.draw.call(this, c, l);
          this.draw(c);
        });
      } finally {
        this.props = i;
      }
    }
    getChangeFlags() {
      return this.internalState.changeFlags;
    }
    setChangeFlags(e) {
      let { changeFlags: t } = this.internalState;
      for (let i in e)
        if (e[i]) {
          let s = false;
          switch (i) {
            case "dataChanged":
              Array.isArray(t[i]) && (t[i] = Array.isArray(e[i]) ? t[i].concat(e[i]) : e[i], s = true);
            default:
              t[i] || (t[i] = e[i], s = true);
          }
          s && se(BA, this, i, e);
        }
      let n = t.dataChanged || t.updateTriggersChanged || t.propsChanged || t.extensionsChanged;
      t.propsOrDataChanged = n, t.somethingChanged = n || e.viewportChanged || e.stateChanged;
    }
    clearChangeFlags() {
      this.internalState.changeFlags = { dataChanged: false, propsChanged: false, updateTriggersChanged: false, viewportChanged: false, stateChanged: false, extensionsChanged: false, propsOrDataChanged: false, somethingChanged: false };
    }
    diffProps(e, t) {
      let n = pg(e, t);
      if (n.updateTriggersChanged)
        for (let i in n.updateTriggersChanged)
          n.updateTriggersChanged[i] && this.invalidateAttribute(i);
      if (n.transitionsChanged)
        for (let i in n.transitionsChanged)
          this.internalState.uniformTransitions.add(i, t[i], e[i], e.transitions[i]);
      return this.setChangeFlags(n);
    }
    validateProps() {
      dg(this.props);
    }
    setModuleParameters(e) {
      for (let t of this.getModels())
        t.updateModuleSettings(e);
    }
    updateAutoHighlight(e) {
      this.props.autoHighlight && this._updateAutoHighlight(e);
    }
    _updateAutoHighlight(e) {
      let t = { pickingSelectedColor: e.picked ? e.color : null }, { highlightColor: n } = this.props;
      e.picked && typeof n == "function" && (t.pickingHighlightColor = n(e)), this.setModuleParameters(t), this.setNeedsRedraw();
    }
    _updateModules({ props: e, oldProps: t }, n) {
      let { autoHighlight: i, highlightedObjectIndex: s, highlightColor: o } = e;
      if (n || t.autoHighlight !== i || t.highlightedObjectIndex !== s || t.highlightColor !== o) {
        let a = {};
        i || (a.pickingSelectedColor = null), Array.isArray(o) && (a.pickingHighlightColor = o), Number.isInteger(s) && (a.pickingSelectedColor = s >= 0 ? this.encodePickingColor(s) : null), this.setModuleParameters(a);
      }
    }
    _getUpdateParams() {
      return { props: this.props, oldProps: this.internalState.getOldProps(), context: this.context, changeFlags: this.internalState.changeFlags };
    }
    _getNeedsRedraw(e) {
      if (!this.internalState)
        return false;
      let t = false;
      t = t || this.internalState.needsRedraw && this.id, this.internalState.needsRedraw = this.internalState.needsRedraw && !e.clearRedrawFlags;
      let n = this.getAttributeManager(), i = n && n.getNeedsRedraw(e);
      return t = t || i, t;
    }
    _getAttributeManager() {
      return new za(this.context.gl, { id: this.props.id, stats: this.context.stats, timeline: this.context.timeline });
    }
    _initState() {
      he(!this.internalState && !this.state), he(isFinite(this.props.coordinateSystem));
      let e = this._getAttributeManager();
      e && e.addInstanced({ instancePickingColors: { type: 5121, size: 3, noAlloc: true, update: this.calculateInstancePickingColors } }), this.internalState = new Ka({ attributeManager: e, layer: this }), this.clearChangeFlags(), this.state = {}, Object.defineProperty(this.state, "attributeManager", { get: () => (F.deprecated("layer.state.attributeManager", "layer.getAttributeManager()"), e) }), this.internalState.layer = this, this.internalState.uniformTransitions = new Ha(this.context.timeline), this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this), this.internalState.setAsyncProps(this.props);
    }
    _transferState(e) {
      se(GA, this, this === e);
      let { state: t, internalState: n } = e;
      this !== e && (this.internalState = n, this.internalState.layer = this, this.state = t, this.internalState.setAsyncProps(this.props), this.diffProps(this.props, this.internalState.getOldProps()));
    }
    _onAsyncPropUpdated() {
      this.diffProps(this.props, this.internalState.getOldProps()), this.setNeedsUpdate();
    }
  };
  ye.layerName = "Layer";
  ye.defaultProps = WA;
  var HA = "compositeLayer.renderLayers";
  var zt = class extends ye {
    get isComposite() {
      return true;
    }
    get isLoaded() {
      return super.isLoaded && this.getSubLayers().every((e) => e.isLoaded);
    }
    getSubLayers() {
      return this.internalState && this.internalState.subLayers || [];
    }
    initializeState() {
    }
    setState(e) {
      super.setState(e), this.setNeedsUpdate();
    }
    getPickingInfo({ info: e }) {
      let { object: t } = e;
      return t && t.__source && t.__source.parent && t.__source.parent.id === this.id && (e.object = t.__source.object, e.index = t.__source.index), e;
    }
    renderLayers() {
      return null;
    }
    filterSubLayer(e) {
      return true;
    }
    shouldRenderSubLayer(e, t) {
      let { _subLayerProps: n } = this.props;
      return t && t.length || n && n[e];
    }
    getSubLayerClass(e, t) {
      let { _subLayerProps: n } = this.props;
      return n && n[e] && n[e].type || t;
    }
    getSubLayerRow(e, t, n) {
      return e.__source = { parent: this, object: t, index: n }, e;
    }
    getSubLayerAccessor(e) {
      if (typeof e == "function") {
        let t = { data: this.props.data, target: [] };
        return (n, i) => n && n.__source ? (t.index = n.__source.index, e(n.__source.object, t)) : e(n, i);
      }
      return e;
    }
    getSubLayerProps(e = {}) {
      let { opacity: t, pickable: n, visible: i, parameters: s, getPolygonOffset: o, highlightedObjectIndex: a, autoHighlight: c, highlightColor: l, coordinateSystem: f, coordinateOrigin: u, wrapLongitude: h, positionFormat: d, modelMatrix: m, extensions: _, fetch: E, _subLayerProps: b } = this.props, T = { opacity: t, pickable: n, visible: i, parameters: s, getPolygonOffset: o, highlightedObjectIndex: a, autoHighlight: c, highlightColor: l, coordinateSystem: f, coordinateOrigin: u, wrapLongitude: h, positionFormat: d, modelMatrix: m, extensions: _, fetch: E }, v = b && b[e.id], C = v && v.updateTriggers, S = e.id || "sublayer";
      if (v) {
        let R = this.constructor._propTypes, D = e.type ? e.type._propTypes : {};
        for (let B in v) {
          let N = D[B] || R[B];
          N && N.type === "accessor" && (v[B] = this.getSubLayerAccessor(v[B]));
        }
      }
      Object.assign(T, e, v), T.id = "".concat(this.props.id, "-").concat(S), T.updateTriggers = x(x({ all: this.props.updateTriggers.all }, e.updateTriggers), C);
      for (let R of _) {
        let D = R.getSubLayerProps.call(this, R);
        D && Object.assign(T, D, { updateTriggers: Object.assign(T.updateTriggers, D.updateTriggers) });
      }
      return T;
    }
    _updateAutoHighlight(e) {
      for (let t of this.getSubLayers())
        t.updateAutoHighlight(e);
    }
    _getAttributeManager() {
      return null;
    }
    _renderLayers() {
      let { subLayers: e } = this.internalState, t = !e || this.needsUpdate();
      t && (e = this.renderLayers(), e = nr(e, Boolean), this.internalState.subLayers = e), se(HA, this, t, e);
      for (let n of e)
        n.parent = this;
    }
  };
  zt.layerName = "CompositeLayer";
  var on = class {
    constructor(e = {}) {
      let { attributes: t = {} } = e;
      this.typedArrayManager = At, this.indexStarts = null, this.vertexStarts = null, this.vertexCount = 0, this.instanceCount = 0, this.attributes = {}, this._attributeDefs = t, this.opts = e, this.updateGeometry(e), Object.seal(this);
    }
    updateGeometry(e) {
      Object.assign(this.opts, e);
      let { data: t, buffers: n = {}, getGeometry: i, geometryBuffer: s, positionFormat: o, dataChanged: a, normalize: c = true } = this.opts;
      if (this.data = t, this.getGeometry = i, this.positionSize = s && s.size || (o === "XY" ? 2 : 3), this.buffers = n, this.normalize = c, s && (he(t.startIndices), this.getGeometry = this.getGeometryFromBuffer(s), c || (n.positions = s)), this.geometryBuffer = n.positions, Array.isArray(a))
        for (let l of a)
          this._rebuildGeometry(l);
      else
        this._rebuildGeometry();
    }
    updatePartialGeometry({ startRow: e, endRow: t }) {
      this._rebuildGeometry({ startRow: e, endRow: t });
    }
    normalizeGeometry(e) {
      return e;
    }
    updateGeometryAttributes(e, t, n) {
      throw new Error("Not implemented");
    }
    getGeometrySize(e) {
      throw new Error("Not implemented");
    }
    getGeometryFromBuffer(e) {
      let t = e.value || e;
      return he(ArrayBuffer.isView(t)), Oa(t, { size: this.positionSize, offset: e.offset, stride: e.stride, startIndices: this.data.startIndices });
    }
    _allocate(e, t) {
      let { attributes: n, buffers: i, _attributeDefs: s, typedArrayManager: o } = this;
      for (let a in s)
        if (a in i)
          o.release(n[a]), n[a] = null;
        else {
          let c = s[a];
          c.copy = t, n[a] = o.allocate(n[a], e, c);
        }
    }
    _forEachGeometry(e, t, n) {
      let { data: i, getGeometry: s } = this, { iterable: o, objectInfo: a } = sr(i, t, n);
      for (let c of o) {
        a.index++;
        let l = s(c, a);
        e(l, a.index);
      }
    }
    _rebuildGeometry(e) {
      if (!this.data || !this.getGeometry)
        return;
      let { indexStarts: t, vertexStarts: n, instanceCount: i } = this, { data: s, geometryBuffer: o } = this, { startRow: a = 0, endRow: c = 1 / 0 } = e || {}, l = {};
      if (e || (t = [0], n = [0]), this.normalize || !o)
        this._forEachGeometry((u, h) => {
          u = this.normalizeGeometry(u), l[h] = u, n[h + 1] = n[h] + this.getGeometrySize(u);
        }, a, c), i = n[n.length - 1];
      else if (o.buffer instanceof k) {
        let u = o.stride || this.positionSize * 4;
        n = s.startIndices, i = n[s.length] || o.buffer.byteLength / u;
      } else {
        let u = o.value || o, h = o.stride / u.BYTES_PER_ELEMENT || this.positionSize;
        n = s.startIndices, i = n[s.length] || u.length / h;
      }
      this._allocate(i, Boolean(e)), this.indexStarts = t, this.vertexStarts = n, this.instanceCount = i;
      let f = {};
      this._forEachGeometry((u, h) => {
        u = l[h] || u, f.vertexStart = n[h], f.indexStart = t[h];
        let d = h < n.length - 1 ? n[h + 1] : i;
        f.geometrySize = d - n[h], f.geometryIndex = h, this.updateGeometryAttributes(u, f);
      }, a, c), this.vertexCount = t[t.length - 1];
    }
  };
  var XA = new Uint16Array([0, 2, 1, 0, 3, 2]);
  var YA = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);
  function Wf(r2, e) {
    if (!e)
      return qA(r2);
    let t = Math.max(Math.abs(r2[0][0] - r2[3][0]), Math.abs(r2[1][0] - r2[2][0])), n = Math.max(Math.abs(r2[1][1] - r2[0][1]), Math.abs(r2[2][1] - r2[3][1])), i = Math.ceil(t / e) + 1, s = Math.ceil(n / e) + 1, o = (i - 1) * (s - 1) * 6, a = new Uint32Array(o), c = new Float32Array(i * s * 2), l = new Float64Array(i * s * 3), f = 0, u = 0;
    for (let h = 0; h < i; h++) {
      let d = h / (i - 1);
      for (let m = 0; m < s; m++) {
        let _ = m / (s - 1), E = ZA(r2, d, _);
        l[f * 3 + 0] = E[0], l[f * 3 + 1] = E[1], l[f * 3 + 2] = E[2] || 0, c[f * 2 + 0] = d, c[f * 2 + 1] = 1 - _, h > 0 && m > 0 && (a[u++] = f - s, a[u++] = f - s - 1, a[u++] = f - 1, a[u++] = f - s, a[u++] = f - 1, a[u++] = f), f++;
      }
    }
    return { vertexCount: o, positions: l, indices: a, texCoords: c };
  }
  function qA(r2) {
    let e = new Float64Array(12);
    for (let t = 0; t < r2.length; t++)
      e[t * 3 + 0] = r2[t][0], e[t * 3 + 1] = r2[t][1], e[t * 3 + 2] = r2[t][2] || 0;
    return { vertexCount: 6, positions: e, indices: XA, texCoords: YA };
  }
  function ZA(r2, e, t) {
    return Et(Et(r2[0], r2[1], t), Et(r2[3], r2[2], t), e);
  }
  var Lg = `
#define SHADER_NAME bitmap-layer-vertex-shader

attribute vec2 texCoords;
attribute vec3 positions;
attribute vec3 positions64Low;

varying vec2 vTexCoord;
varying vec2 vTexPos;

uniform float coordinateConversion;

const vec3 pickingColor = vec3(1.0, 0.0, 0.0);

void main(void) {
  geometry.worldPosition = positions;
  geometry.uv = texCoords;
  geometry.pickingColor = pickingColor;

  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  vTexCoord = texCoords;

  if (coordinateConversion < -0.5) {
    vTexPos = geometry.position.xy;
  } else if (coordinateConversion > 0.5) {
    vTexPos = geometry.worldPosition.xy;
  }

  vec4 color = vec4(0.0);
  DECKGL_FILTER_COLOR(color, geometry);
}
`;
  var KA = `
vec3 packUVsIntoRGB(vec2 uv) {
  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction
  vec2 uv8bit = floor(uv * 256.);

  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits
  // Scale and clamp to 0-1 range
  vec2 uvFraction = fract(uv * 256.);
  vec2 uvFraction4bit = floor(uvFraction * 16.);

  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates
  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;

  return vec3(uv8bit, fractions) / 255.;
}
`;
  var Cg = `
#define SHADER_NAME bitmap-layer-fragment-shader

#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D bitmapTexture;

varying vec2 vTexCoord;
varying vec2 vTexPos;

uniform float desaturate;
uniform vec4 transparentColor;
uniform vec3 tintColor;
uniform float opacity;

uniform float coordinateConversion;
uniform vec4 bounds;

/* projection utils */
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / PI / 2.0;

// from degrees to Web Mercator
vec2 lnglat_to_mercator(vec2 lnglat) {
  float x = lnglat.x;
  float y = clamp(lnglat.y, -89.9, 89.9);
  return vec2(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// from Web Mercator to degrees
vec2 mercator_to_lnglat(vec2 xy) {
  xy /= WORLD_SCALE;
  return degrees(vec2(
    xy.x - PI,
    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5
  ));
}
/* End projection utils */

// apply desaturation
vec3 color_desaturate(vec3 color) {
  float luminance = (color.r + color.g + color.b) * 0.333333333;
  return mix(color, vec3(luminance), desaturate);
}

// apply tint
vec3 color_tint(vec3 color) {
  return color * tintColor;
}

// blend with background color
vec4 apply_opacity(vec3 color, float alpha) {
  return mix(transparentColor, vec4(color, 1.0), alpha);
}

vec2 getUV(vec2 pos) {
  return vec2(
    (pos.x - bounds[0]) / (bounds[2] - bounds[0]),
    (pos.y - bounds[3]) / (bounds[1] - bounds[3])
  );
}

`.concat(KA, `

void main(void) {
  vec2 uv = vTexCoord;
  if (coordinateConversion < -0.5) {
    vec2 lnglat = mercator_to_lnglat(vTexPos);
    uv = getUV(lnglat);
  } else if (coordinateConversion > 0.5) {
    vec2 commonPos = lnglat_to_mercator(vTexPos);
    uv = getUV(commonPos);
  }
  vec4 bitmapColor = texture2D(bitmapTexture, uv);

  gl_FragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * opacity);

  geometry.uv = uv;
  DECKGL_FILTER_COLOR(gl_FragColor, geometry);

  if (picking_uActive) {
    // Since instance information is not used, we can use picking color for pixel index
    gl_FragColor.rgb = packUVsIntoRGB(uv);
  }
}
`);
  var QA = { image: { type: "image", value: null, async: true }, bounds: { type: "array", value: [1, 0, 0, 1], compare: true }, _imageCoordinateSystem: j.DEFAULT, desaturate: { type: "number", min: 0, max: 1, value: 0 }, transparentColor: { type: "color", value: [0, 0, 0, 0] }, tintColor: { type: "color", value: [255, 255, 255] } };
  var an = class extends ye {
    getShaders() {
      return super.getShaders({ vs: Lg, fs: Cg, modules: [Ie, Oe] });
    }
    initializeState() {
      let e = this.getAttributeManager();
      e.remove(["instancePickingColors"]);
      let t = true;
      e.add({ indices: { size: 1, isIndexed: true, update: (n) => n.value = this.state.mesh.indices, noAlloc: t }, positions: { size: 3, type: 5130, fp64: this.use64bitPositions(), update: (n) => n.value = this.state.mesh.positions, noAlloc: t }, texCoords: { size: 2, update: (n) => n.value = this.state.mesh.texCoords, noAlloc: t } });
    }
    updateState({ props: e, oldProps: t, changeFlags: n }) {
      if (n.extensionsChanged) {
        var i;
        let { gl: o } = this.context;
        (i = this.state.model) === null || i === void 0 || i.delete(), this.state.model = this._getModel(o), this.getAttributeManager().invalidateAll();
      }
      let s = this.getAttributeManager();
      if (e.bounds !== t.bounds) {
        let o = this.state.mesh, a = this._createMesh();
        this.state.model.setVertexCount(a.vertexCount);
        for (let c in a)
          o && o[c] !== a[c] && s.invalidate(c);
        this.setState(x({ mesh: a }, this._getCoordinateUniforms()));
      } else
        e._imageCoordinateSystem !== t._imageCoordinateSystem && this.setState(this._getCoordinateUniforms());
    }
    getPickingInfo({ info: e }) {
      let { image: t } = this.props;
      if (!e.color || !t)
        return e.bitmap = null, e;
      let { width: n, height: i } = t;
      e.index = 0;
      let s = JA(e.color), o = [Math.floor(s[0] * n), Math.floor(s[1] * i)];
      return e.bitmap = { size: { width: n, height: i }, uv: s, pixel: o }, e;
    }
    disablePickingIndex() {
      this.setState({ disablePicking: true });
    }
    restorePickingColors() {
      this.setState({ disablePicking: false });
    }
    _updateAutoHighlight(e) {
      super._updateAutoHighlight(L(x({}, e), { color: this.encodePickingColor(0) }));
    }
    _createMesh() {
      let { bounds: e } = this.props, t = e;
      return Number.isFinite(e[0]) && (t = [[e[0], e[1]], [e[0], e[3]], [e[2], e[3]], [e[2], e[1]]]), Wf(t, this.context.viewport.resolution);
    }
    _getModel(e) {
      return e ? new xe(e, L(x({}, this.getShaders()), { id: this.props.id, geometry: new Me({ drawMode: 4, vertexCount: 6 }), isInstanced: false })) : null;
    }
    draw(e) {
      let { uniforms: t, moduleParameters: n } = e, { model: i, coordinateConversion: s, bounds: o, disablePicking: a } = this.state, { image: c, desaturate: l, transparentColor: f, tintColor: u } = this.props;
      n.pickingActive && a || c && i && i.setUniforms(t).setUniforms({ bitmapTexture: c, desaturate: l, transparentColor: f.map((h) => h / 255), tintColor: u.slice(0, 3).map((h) => h / 255), coordinateConversion: s, bounds: o }).draw();
    }
    _getCoordinateUniforms() {
      let { LNGLAT: e, CARTESIAN: t, DEFAULT: n } = j, { _imageCoordinateSystem: i } = this.props;
      if (i !== n) {
        let { bounds: s } = this.props;
        if (!Number.isFinite(s[0]))
          throw new Error("_imageCoordinateSystem only supports rectangular bounds");
        let o = this.context.viewport.resolution ? e : t;
        if (i = i === e ? e : t, i === e && o === t)
          return { coordinateConversion: -1, bounds: s };
        if (i === t && o === e) {
          let a = Qe([s[0], s[1]]), c = Qe([s[2], s[3]]);
          return { coordinateConversion: 1, bounds: [a[0], a[1], c[0], c[1]] };
        }
      }
      return { coordinateConversion: 0, bounds: [0, 0, 0, 0] };
    }
  };
  an.layerName = "BitmapLayer";
  an.defaultProps = QA;
  function JA(r2) {
    let [e, t, n] = r2, i = (n & 240) / 256, s = (n & 15) / 16;
    return [(e + s) / 256, (t + i) / 256];
  }
  var Rg = `#define SHADER_NAME icon-layer-vertex-shader

attribute vec2 positions;

attribute vec3 instancePositions;
attribute vec3 instancePositions64Low;
attribute float instanceSizes;
attribute float instanceAngles;
attribute vec4 instanceColors;
attribute vec3 instancePickingColors;
attribute vec4 instanceIconFrames;
attribute float instanceColorModes;
attribute vec2 instanceOffsets;
attribute vec2 instancePixelOffset;

uniform float sizeScale;
uniform vec2 iconsTextureDim;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform bool billboard;

varying float vColorMode;
varying vec4 vColor;
varying vec2 vTextureCoords;
varying vec2 uv;

vec2 rotate_by_angle(vec2 vertex, float angle) {
  float angle_radian = angle * PI / 180.0;
  float cos_angle = cos(angle_radian);
  float sin_angle = sin(angle_radian);
  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
  return rotationMatrix * vertex;
}

void main(void) {
  geometry.worldPosition = instancePositions;
  geometry.uv = positions;
  geometry.pickingColor = instancePickingColors;
  uv = positions;

  vec2 iconSize = instanceIconFrames.zw;
  float sizePixels = clamp(
    project_size_to_pixel(instanceSizes * sizeScale), 
    sizeMinPixels, sizeMaxPixels
  );
  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;
  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;
  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;
  pixelOffset += instancePixelOffset;
  pixelOffset.y *= -1.0;

  if (billboard)  {
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
    vec3 offset = vec3(pixelOffset, 0.0);
    DECKGL_FILTER_SIZE(offset, geometry);
    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);

  } else {
    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
    DECKGL_FILTER_SIZE(offset_common, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); 
  }
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  vTextureCoords = mix(
    instanceIconFrames.xy,
    instanceIconFrames.xy + iconSize,
    (positions.xy + 1.0) / 2.0
  ) / iconsTextureDim;

  vColor = instanceColors;
  DECKGL_FILTER_COLOR(vColor, geometry);

  vColorMode = instanceColorModes;
}
`;
  var Mg = `#define SHADER_NAME icon-layer-fragment-shader

precision highp float;

uniform float opacity;
uniform sampler2D iconsTexture;
uniform float alphaCutoff;

varying float vColorMode;
varying vec4 vColor;
varying vec2 vTextureCoords;
varying vec2 uv;

void main(void) {
  geometry.uv = uv;

  vec4 texColor = texture2D(iconsTexture, vTextureCoords);
  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);
  float a = texColor.a * opacity * vColor.a;

  if (a < alphaCutoff) {
    discard;
  }

  gl_FragColor = vec4(color, a);
  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`;
  var $A = 1024;
  var eS = 4;
  var Ig = () => {
  };
  var tS = { [10241]: 9987, [10240]: 9729, [10242]: 33071, [10243]: 33071 };
  function rS(r2) {
    return Math.pow(2, Math.ceil(Math.log2(r2)));
  }
  function nS(r2, e, t, n) {
    return t === e.width && n === e.height ? e : (r2.canvas.height = n, r2.canvas.width = t, r2.clearRect(0, 0, r2.canvas.width, r2.canvas.height), r2.drawImage(e, 0, 0, e.width, e.height, 0, 0, t, n), r2.canvas);
  }
  function xs(r2) {
    return r2 && (r2.id || r2.url);
  }
  function iS(r2, e, t, n) {
    let i = e.width, s = e.height, o = Sn(e, { width: t, height: n });
    return wo(e, o, { targetY: 0, width: i, height: s }), e.delete(), o;
  }
  function Og(r2, e, t) {
    for (let n = 0; n < e.length; n++) {
      let { icon: i, xOffset: s } = e[n], o = xs(i);
      r2[o] = L(x({}, i), { x: s, y: t });
    }
  }
  function sS({ icons: r2, buffer: e, mapping: t = {}, xOffset: n = 0, yOffset: i = 0, rowHeight: s = 0, canvasWidth: o }) {
    let a = [];
    for (let c = 0; c < r2.length; c++) {
      let l = r2[c], f = xs(l);
      if (!t[f]) {
        let { height: u, width: h } = l;
        n + h + e > o && (Og(t, a, i), n = 0, i = s + i + e, s = 0, a = []), a.push({ icon: l, xOffset: n }), n = n + h + e, s = Math.max(s, u);
      }
    }
    return a.length > 0 && Og(t, a, i), { mapping: t, rowHeight: s, xOffset: n, yOffset: i, canvasWidth: o, canvasHeight: rS(s + i + e) };
  }
  function oS(r2, e, t) {
    if (!r2 || !e)
      return null;
    t = t || {};
    let n = {}, { iterable: i, objectInfo: s } = sr(r2);
    for (let o of i) {
      s.index++;
      let a = e(o, s), c = xs(a);
      if (!a)
        throw new Error("Icon is missing.");
      if (!a.url)
        throw new Error("Icon url is missing.");
      !n[c] && (!t[c] || a.url !== t[c].url) && (n[c] = L(x({}, a), { source: o, sourceIndex: s.index }));
    }
    return n;
  }
  var Qa = class {
    constructor(e, { onUpdate: t = Ig, onError: n = Ig }) {
      this.gl = e, this.onUpdate = t, this.onError = n, this._loadOptions = null, this._getIcon = null, this._texture = null, this._externalTexture = null, this._mapping = {}, this._pendingCount = 0, this._autoPacking = false, this._xOffset = 0, this._yOffset = 0, this._rowHeight = 0, this._buffer = eS, this._canvasWidth = $A, this._canvasHeight = 0, this._canvas = null;
    }
    finalize() {
      var e;
      (e = this._texture) === null || e === void 0 || e.delete();
    }
    getTexture() {
      return this._texture || this._externalTexture;
    }
    getIconMapping(e) {
      let t = this._autoPacking ? xs(e) : e;
      return this._mapping[t] || {};
    }
    setProps({ loadOptions: e, autoPacking: t, iconAtlas: n, iconMapping: i, data: s, getIcon: o }) {
      e && (this._loadOptions = e), t !== void 0 && (this._autoPacking = t), o && (this._getIcon = o), i && (this._mapping = i), n && this._updateIconAtlas(n), this._autoPacking && (s || o) && typeof document != "undefined" && (this._canvas = this._canvas || document.createElement("canvas"), this._updateAutoPacking(s));
    }
    get isLoaded() {
      return this._pendingCount === 0;
    }
    _updateIconAtlas(e) {
      var t;
      (t = this._texture) === null || t === void 0 || t.delete(), this._texture = null, this._externalTexture = e, this.onUpdate();
    }
    _updateAutoPacking(e) {
      let t = Object.values(oS(e, this._getIcon, this._mapping) || {});
      if (t.length > 0) {
        let { mapping: n, xOffset: i, yOffset: s, rowHeight: o, canvasHeight: a } = sS({ icons: t, buffer: this._buffer, canvasWidth: this._canvasWidth, mapping: this._mapping, rowHeight: this._rowHeight, xOffset: this._xOffset, yOffset: this._yOffset });
        this._rowHeight = o, this._mapping = n, this._xOffset = i, this._yOffset = s, this._canvasHeight = a, this._texture || (this._texture = new Q(this.gl, { width: this._canvasWidth, height: this._canvasHeight, parameters: tS })), this._texture.height !== this._canvasHeight && (this._texture = iS(this.gl, this._texture, this._canvasWidth, this._canvasHeight)), this.onUpdate(), this._loadIcons(t);
      }
    }
    _loadIcons(e) {
      let t = this._canvas.getContext("2d");
      for (let n of e)
        this._pendingCount++, hr(n.url, Ci, this._loadOptions).then((i) => {
          let s = xs(n), { x: o, y: a, width: c, height: l } = this._mapping[s], f = nS(t, i, c, l);
          this._texture.setSubImageData({ data: f, x: o, y: a, width: c, height: l }), this._texture.generateMipmap(), this.onUpdate();
        }).catch((i) => {
          this.onError({ url: n.url, source: n.source, sourceIndex: n.sourceIndex, loadOptions: this._loadOptions, error: i });
        }).finally(() => {
          this._pendingCount--;
        });
    }
  };
  var Ng = [0, 0, 0, 255];
  var aS = { iconAtlas: { type: "image", value: null, async: true }, iconMapping: { type: "object", value: {}, async: true }, sizeScale: { type: "number", value: 1, min: 0 }, billboard: true, sizeUnits: "pixels", sizeMinPixels: { type: "number", min: 0, value: 0 }, sizeMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER }, alphaCutoff: { type: "number", value: 0.05, min: 0, max: 1 }, getPosition: { type: "accessor", value: (r2) => r2.position }, getIcon: { type: "accessor", value: (r2) => r2.icon }, getColor: { type: "accessor", value: Ng }, getSize: { type: "accessor", value: 1 }, getAngle: { type: "accessor", value: 0 }, getPixelOffset: { type: "accessor", value: [0, 0] }, onIconError: { type: "function", value: null, compare: false, optional: true } };
  var Nr = class extends ye {
    getShaders() {
      return super.getShaders({ vs: Rg, fs: Mg, modules: [Ie, Oe] });
    }
    initializeState() {
      this.state = { iconManager: new Qa(this.context.gl, { onUpdate: this._onUpdate.bind(this), onError: this._onError.bind(this) }) }, this.getAttributeManager().addInstanced({ instancePositions: { size: 3, type: 5130, fp64: this.use64bitPositions(), transition: true, accessor: "getPosition" }, instanceSizes: { size: 1, transition: true, accessor: "getSize", defaultValue: 1 }, instanceOffsets: { size: 2, accessor: "getIcon", transform: this.getInstanceOffset }, instanceIconFrames: { size: 4, accessor: "getIcon", transform: this.getInstanceIconFrame }, instanceColorModes: { size: 1, type: 5121, accessor: "getIcon", transform: this.getInstanceColorMode }, instanceColors: { size: this.props.colorFormat.length, type: 5121, normalized: true, transition: true, accessor: "getColor", defaultValue: Ng }, instanceAngles: { size: 1, transition: true, accessor: "getAngle" }, instancePixelOffset: { size: 2, transition: true, accessor: "getPixelOffset" } });
    }
    updateState({ oldProps: e, props: t, changeFlags: n }) {
      super.updateState({ props: t, oldProps: e, changeFlags: n });
      let i = this.getAttributeManager(), { iconAtlas: s, iconMapping: o, data: a, getIcon: c } = t, { iconManager: l } = this.state;
      l.setProps({ loadOptions: t.loadOptions });
      let f = false;
      if (s || this.internalState.isAsyncPropLoading("iconAtlas") ? (e.iconAtlas !== t.iconAtlas && l.setProps({ iconAtlas: s, autoPacking: false }), e.iconMapping !== t.iconMapping && (l.setProps({ iconMapping: o }), f = true)) : l.setProps({ autoPacking: true }), (n.dataChanged || n.updateTriggersChanged && (n.updateTriggersChanged.all || n.updateTriggersChanged.getIcon)) && l.setProps({ data: a, getIcon: c }), f && (i.invalidate("instanceOffsets"), i.invalidate("instanceIconFrames"), i.invalidate("instanceColorModes")), n.extensionsChanged) {
        var h;
        let { gl: d } = this.context;
        (h = this.state.model) === null || h === void 0 || h.delete(), this.state.model = this._getModel(d), i.invalidateAll();
      }
    }
    get isLoaded() {
      return super.isLoaded && this.state.iconManager.isLoaded;
    }
    finalizeState() {
      super.finalizeState(), this.state.iconManager.finalize();
    }
    draw({ uniforms: e }) {
      let { sizeScale: t, sizeMinPixels: n, sizeMaxPixels: i, sizeUnits: s, billboard: o, alphaCutoff: a } = this.props, { iconManager: c } = this.state, { viewport: l } = this.context, f = c.getTexture();
      f && this.state.model.setUniforms(e).setUniforms({ iconsTexture: f, iconsTextureDim: [f.width, f.height], sizeScale: t * (s === "pixels" ? l.metersPerPixel : 1), sizeMinPixels: n, sizeMaxPixels: i, billboard: o, alphaCutoff: a }).draw();
    }
    _getModel(e) {
      let t = [-1, -1, -1, 1, 1, 1, 1, -1];
      return new xe(e, L(x({}, this.getShaders()), { id: this.props.id, geometry: new Me({ drawMode: 6, attributes: { positions: { size: 2, value: new Float32Array(t) } } }), isInstanced: true }));
    }
    _onUpdate() {
      this.setNeedsRedraw();
    }
    _onError(e) {
      let { onIconError: t } = this.getCurrentLayer().props;
      t ? t(e) : F.error(e.error)();
    }
    getInstanceOffset(e) {
      let t = this.state.iconManager.getIconMapping(e);
      return [t.width / 2 - t.anchorX || 0, t.height / 2 - t.anchorY || 0];
    }
    getInstanceColorMode(e) {
      return this.state.iconManager.getIconMapping(e).mask ? 1 : 0;
    }
    getInstanceIconFrame(e) {
      let t = this.state.iconManager.getIconMapping(e);
      return [t.x || 0, t.y || 0, t.width || 0, t.height || 0];
    }
  };
  Nr.layerName = "IconLayer";
  Nr.defaultProps = aS;
  var Fg = `#define SHADER_NAME scatterplot-layer-vertex-shader

attribute vec3 positions;

attribute vec3 instancePositions;
attribute vec3 instancePositions64Low;
attribute float instanceRadius;
attribute float instanceLineWidths;
attribute vec4 instanceFillColors;
attribute vec4 instanceLineColors;
attribute vec3 instancePickingColors;

uniform float opacity;
uniform float radiusScale;
uniform float radiusMinPixels;
uniform float radiusMaxPixels;
uniform float lineWidthScale;
uniform float lineWidthMinPixels;
uniform float lineWidthMaxPixels;
uniform float stroked;
uniform bool filled;
uniform bool billboard;

varying vec4 vFillColor;
varying vec4 vLineColor;
varying vec2 unitPosition;
varying float innerUnitRadius;
varying float outerRadiusPixels;

void main(void) {
  geometry.worldPosition = instancePositions;
  outerRadiusPixels = clamp(
    project_size_to_pixel(radiusScale * instanceRadius),
    radiusMinPixels, radiusMaxPixels
  );
  float lineWidthPixels = clamp(
    project_size_to_pixel(lineWidthScale * instanceLineWidths),
    lineWidthMinPixels, lineWidthMaxPixels
  );
  outerRadiusPixels += stroked * lineWidthPixels / 2.0;
  unitPosition = positions.xy;
  geometry.uv = unitPosition;
  geometry.pickingColor = instancePickingColors;

  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;
  
  if (billboard) {
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
    vec3 offset = positions * outerRadiusPixels;
    DECKGL_FILTER_SIZE(offset, geometry);
    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
  } else {
    vec3 offset = positions * project_pixel_size(outerRadiusPixels);
    DECKGL_FILTER_SIZE(offset, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);
  }

  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);
  DECKGL_FILTER_COLOR(vFillColor, geometry);
  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);
  DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`;
  var Dg = `#define SHADER_NAME scatterplot-layer-fragment-shader

precision highp float;

uniform bool filled;
uniform float stroked;

varying vec4 vFillColor;
varying vec4 vLineColor;
varying vec2 unitPosition;
varying float innerUnitRadius;
varying float outerRadiusPixels;

void main(void) {
  geometry.uv = unitPosition;

  float distToCenter = length(unitPosition) * outerRadiusPixels;
  float inCircle = smoothedge(distToCenter, outerRadiusPixels);

  if (inCircle == 0.0) {
    discard;
  }

  if (stroked > 0.5) {
    float isLine = smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter);
    if (filled) {
      gl_FragColor = mix(vFillColor, vLineColor, isLine);
    } else {
      if (isLine == 0.0) {
        discard;
      }
      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);
    }
  } else if (filled) {
    gl_FragColor = vFillColor;
  } else {
    discard;
  }

  gl_FragColor.a *= inCircle;
  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`;
  var Bg = [0, 0, 0, 255];
  var cS = { radiusUnits: "meters", radiusScale: { type: "number", min: 0, value: 1 }, radiusMinPixels: { type: "number", min: 0, value: 0 }, radiusMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER }, lineWidthUnits: "meters", lineWidthScale: { type: "number", min: 0, value: 1 }, lineWidthMinPixels: { type: "number", min: 0, value: 0 }, lineWidthMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER }, stroked: false, filled: true, billboard: false, getPosition: { type: "accessor", value: (r2) => r2.position }, getRadius: { type: "accessor", value: 1 }, getFillColor: { type: "accessor", value: Bg }, getLineColor: { type: "accessor", value: Bg }, getLineWidth: { type: "accessor", value: 1 }, strokeWidth: { deprecatedFor: "getLineWidth" }, outline: { deprecatedFor: "stroked" }, getColor: { deprecatedFor: ["getFillColor", "getLineColor"] } };
  var ei = class extends ye {
    getShaders() {
      return super.getShaders({ vs: Fg, fs: Dg, modules: [Ie, Oe] });
    }
    initializeState() {
      this.getAttributeManager().addInstanced({ instancePositions: { size: 3, type: 5130, fp64: this.use64bitPositions(), transition: true, accessor: "getPosition" }, instanceRadius: { size: 1, transition: true, accessor: "getRadius", defaultValue: 1 }, instanceFillColors: { size: this.props.colorFormat.length, transition: true, normalized: true, type: 5121, accessor: "getFillColor", defaultValue: [0, 0, 0, 255] }, instanceLineColors: { size: this.props.colorFormat.length, transition: true, normalized: true, type: 5121, accessor: "getLineColor", defaultValue: [0, 0, 0, 255] }, instanceLineWidths: { size: 1, transition: true, accessor: "getLineWidth", defaultValue: 1 } });
    }
    updateState({ props: e, oldProps: t, changeFlags: n }) {
      if (super.updateState({ props: e, oldProps: t, changeFlags: n }), n.extensionsChanged) {
        var i;
        let { gl: s } = this.context;
        (i = this.state.model) === null || i === void 0 || i.delete(), this.state.model = this._getModel(s), this.getAttributeManager().invalidateAll();
      }
    }
    draw({ uniforms: e }) {
      let { viewport: t } = this.context, { radiusUnits: n, radiusScale: i, radiusMinPixels: s, radiusMaxPixels: o, stroked: a, filled: c, billboard: l, lineWidthUnits: f, lineWidthScale: u, lineWidthMinPixels: h, lineWidthMaxPixels: d } = this.props, m = n === "pixels" ? t.metersPerPixel : 1, _ = f === "pixels" ? t.metersPerPixel : 1;
      this.state.model.setUniforms(e).setUniforms({ stroked: a ? 1 : 0, filled: c, billboard: l, radiusScale: i * m, radiusMinPixels: s, radiusMaxPixels: o, lineWidthScale: u * _, lineWidthMinPixels: h, lineWidthMaxPixels: d }).draw();
    }
    _getModel(e) {
      let t = [-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0];
      return new xe(e, L(x({}, this.getShaders()), { id: this.props.id, geometry: new Me({ drawMode: 6, vertexCount: 4, attributes: { positions: { size: 3, value: new Float32Array(t) } } }), isInstanced: true }));
    }
  };
  ei.layerName = "ScatterplotLayer";
  ei.defaultProps = cS;
  var Ja = { CLOCKWISE: 1, COUNTER_CLOCKWISE: -1 };
  function ys(r2, e, t = {}) {
    return Ug(r2, t) !== e ? (lS(r2, t), true) : false;
  }
  function Ug(r2, e = {}) {
    return Math.sign($a(r2, e));
  }
  function $a(r2, e = {}) {
    let { start: t = 0, end: n = r2.length } = e, i = e.size || 2, s = 0;
    for (let o = t, a = n - i; o < n; o += i)
      s += (r2[o] - r2[a]) * (r2[o + 1] + r2[a + 1]), a = o;
    return s / 2;
  }
  function lS(r2, e) {
    let { start: t = 0, end: n = r2.length, size: i = 2 } = e, s = (n - t) / i, o = Math.floor(s / 2);
    for (let a = 0; a < o; ++a) {
      let c = t + a * i, l = t + (s - 1 - a) * i;
      for (let f = 0; f < i; ++f) {
        let u = r2[c + f];
        r2[c + f] = r2[l + f], r2[l + f] = u;
      }
    }
  }
  function ze(r2, e) {
    let t = e.length, n = r2.length;
    if (n > 0) {
      let i = true;
      for (let s = 0; s < t; s++)
        if (r2[n - t + s] !== e[s]) {
          i = false;
          break;
        }
      if (i)
        return false;
    }
    for (let i = 0; i < t; i++)
      r2[n + i] = e[i];
    return true;
  }
  function Es(r2, e) {
    let t = e.length;
    for (let n = 0; n < t; n++)
      r2[n] = e[n];
  }
  function Fr(r2, e, t, n, i = []) {
    let s = n + e * t;
    for (let o = 0; o < t; o++)
      i[o] = r2[s + o];
    return i;
  }
  function ec(r2, e, t, n, i = []) {
    let s, o;
    if (t & 8)
      s = (n[3] - r2[1]) / (e[1] - r2[1]), o = 3;
    else if (t & 4)
      s = (n[1] - r2[1]) / (e[1] - r2[1]), o = 1;
    else if (t & 2)
      s = (n[2] - r2[0]) / (e[0] - r2[0]), o = 2;
    else if (t & 1)
      s = (n[0] - r2[0]) / (e[0] - r2[0]), o = 0;
    else
      return null;
    for (let a = 0; a < r2.length; a++)
      i[a] = (o & 1) === a ? n[o] : s * (e[a] - r2[a]) + r2[a];
    return i;
  }
  function bs(r2, e) {
    let t = 0;
    return r2[0] < e[0] ? t |= 1 : r2[0] > e[2] && (t |= 2), r2[1] < e[1] ? t |= 4 : r2[1] > e[3] && (t |= 8), t;
  }
  function Ts(r2, e = {}) {
    let { size: t = 2, broken: n = false, gridResolution: i = 10, gridOffset: s = [0, 0], startIndex: o = 0, endIndex: a = r2.length } = e, c = (a - o) / t, l = [], f = [l], u = Fr(r2, 0, t, o), h, d, m = Gg(u, i, s, []), _ = [];
    ze(l, u);
    for (let E = 1; E < c; E++) {
      for (h = Fr(r2, E, t, o, h), d = bs(h, m); d; ) {
        ec(u, h, d, m, _);
        let b = bs(_, m);
        b && (ec(u, _, b, m, _), d = b), ze(l, _), Es(u, _), hS(m, i, d), n && l.length > t && (l = [], f.push(l), ze(l, u)), d = bs(h, m);
      }
      ze(l, h), Es(u, h);
    }
    return n ? f : f[0];
  }
  var kg = 0;
  var uS = 1;
  function tc(r2, e) {
    for (let t = 0; t < e.length; t++)
      r2.push(e[t]);
    return r2;
  }
  function vs(r2, e, t = {}) {
    if (!r2.length)
      return [];
    let { size: n = 2, gridResolution: i = 10, gridOffset: s = [0, 0], edgeTypes: o = false } = t, a = [], c = [{ pos: r2, types: o && new Array(r2.length / n).fill(uS), holes: e || [] }], l = [[], []], f = [];
    for (; c.length; ) {
      let { pos: u, types: h, holes: d } = c.shift();
      dS(u, n, d[0] || u.length, l), f = Gg(l[0], i, s, f);
      let m = bs(l[1], f);
      if (m) {
        let _ = Vg(u, h, n, 0, d[0] || u.length, f, m), E = { pos: _[0].pos, types: _[0].types, holes: [] }, b = { pos: _[1].pos, types: _[1].types, holes: [] };
        c.push(E, b);
        for (let T = 0; T < d.length; T++)
          _ = Vg(u, h, n, d[T], d[T + 1] || u.length, f, m), _[0] && (E.holes.push(E.pos.length), E.pos = tc(E.pos, _[0].pos), o && (E.types = tc(E.types, _[0].types))), _[1] && (b.holes.push(b.pos.length), b.pos = tc(b.pos, _[1].pos), o && (b.types = tc(b.types, _[1].types)));
      } else {
        let _ = { positions: u };
        o && (_.edgeTypes = h), d.length && (_.holeIndices = d), a.push(_);
      }
    }
    return a;
  }
  function Vg(r2, e, t, n, i, s, o) {
    let a = (i - n) / t, c = [], l = [], f = [], u = [], h = [], d, m, _, E = Fr(r2, a - 1, t, n), b = Math.sign(o & 8 ? E[1] - s[3] : E[0] - s[2]), T = e && e[a - 1], v = 0, C = 0;
    for (let S = 0; S < a; S++)
      d = Fr(r2, S, t, n, d), m = Math.sign(o & 8 ? d[1] - s[3] : d[0] - s[2]), _ = e && e[n / t + S], m && b && b !== m && (ec(E, d, o, s, h), ze(c, h) && f.push(T), ze(l, h) && u.push(T)), m <= 0 ? (ze(c, d) && f.push(_), v -= m) : f.length && (f[f.length - 1] = kg), m >= 0 ? (ze(l, d) && u.push(_), C += m) : u.length && (u[u.length - 1] = kg), Es(E, d), b = m, T = _;
    return [v ? { pos: c, types: e && f } : null, C ? { pos: l, types: e && u } : null];
  }
  function Gg(r2, e, t, n) {
    let i = Math.floor((r2[0] - t[0]) / e) * e + t[0], s = Math.floor((r2[1] - t[1]) / e) * e + t[1];
    return n[0] = i, n[1] = s, n[2] = i + e, n[3] = s + e, n;
  }
  function hS(r2, e, t) {
    t & 8 ? (r2[1] += e, r2[3] += e) : t & 4 ? (r2[1] -= e, r2[3] -= e) : t & 2 ? (r2[0] += e, r2[2] += e) : t & 1 && (r2[0] -= e, r2[2] -= e);
  }
  function dS(r2, e, t, n) {
    let i = 1 / 0, s = -1 / 0, o = 1 / 0, a = -1 / 0;
    for (let c = 0; c < t; c += e) {
      let l = r2[c], f = r2[c + 1];
      i = l < i ? l : i, s = l > s ? l : s, o = f < o ? f : o, a = f > a ? f : a;
    }
    return n[0][0] = i, n[0][1] = o, n[1][0] = s, n[1][1] = a, n;
  }
  var pS = 85.051129;
  function Hf(r2, e = {}) {
    let { size: t = 2, startIndex: n = 0, endIndex: i = r2.length, normalize: s = true } = e, o = r2.slice(n, i);
    zg(o, t, 0, i - n);
    let a = Ts(o, { size: t, broken: true, gridResolution: 360, gridOffset: [-180, -180] });
    if (s)
      for (let c of a)
        jg(c, t);
    return a;
  }
  function Xf(r2, e, t = {}) {
    let { size: n = 2, normalize: i = true, edgeTypes: s = false } = t;
    e = e || [];
    let o = [], a = [], c = 0, l = 0;
    for (let u = 0; u <= e.length; u++) {
      let h = e[u] || r2.length, d = l, m = mS(r2, n, c, h);
      for (let _ = m; _ < h; _++)
        o[l++] = r2[_];
      for (let _ = c; _ < m; _++)
        o[l++] = r2[_];
      zg(o, n, d, l), gS(o, n, d, l, t.maxLatitude), c = h, a[u] = l;
    }
    a.pop();
    let f = vs(o, a, { size: n, gridResolution: 360, gridOffset: [-180, -180], edgeTypes: s });
    if (i)
      for (let u of f)
        jg(u.positions, n);
    return f;
  }
  function mS(r2, e, t, n) {
    let i = -1, s = -1;
    for (let o = t + 1; o < n; o += e) {
      let a = Math.abs(r2[o]);
      a > i && (i = a, s = o - 1);
    }
    return s;
  }
  function gS(r2, e, t, n, i = pS) {
    let s = r2[t], o = r2[n - e];
    if (Math.abs(s - o) > 180) {
      let a = Fr(r2, 0, e, t);
      a[0] += Math.round((o - s) / 360) * 360, ze(r2, a), a[1] = Math.sign(a[1]) * i, ze(r2, a), a[0] = s, ze(r2, a);
    }
  }
  function zg(r2, e, t, n) {
    let i = r2[0], s;
    for (let o = t; o < n; o += e) {
      s = r2[o];
      let a = s - i;
      (a > 180 || a < -180) && (s -= Math.round(a / 360) * 360), r2[o] = i = s;
    }
  }
  function jg(r2, e) {
    let t, n = r2.length / e;
    for (let s = 0; s < n && (t = r2[s * e], (t + 180) % 360 == 0); s++)
      ;
    let i = -Math.round(t / 360) * 360;
    if (i !== 0)
      for (let s = 0; s < n; s++)
        r2[s * e] += i;
  }
  function Wg(r2, e, t, n) {
    let i = r2;
    if (Array.isArray(r2[0])) {
      let s = r2.length * e;
      i = new Array(s);
      for (let o = 0; o < r2.length; o++)
        for (let a = 0; a < e; a++)
          i[o * e + a] = r2[o][a] || 0;
    }
    return t ? Ts(i, { size: e, gridResolution: t }) : n ? Hf(i, { size: e }) : i;
  }
  var xS = 1;
  var yS = 2;
  var Yf = 4;
  var rc = class extends on {
    constructor(e) {
      super(L(x({}, e), { attributes: { positions: { size: 3, padding: 18, initialize: true, type: e.fp64 ? Float64Array : Float32Array }, segmentTypes: { size: 1, type: Uint8ClampedArray } } }));
    }
    getGeometryFromBuffer(e) {
      return this.normalize ? super.getGeometryFromBuffer(e) : () => null;
    }
    normalizeGeometry(e) {
      return this.normalize ? Wg(e, this.positionSize, this.opts.resolution, this.opts.wrapLongitude) : e;
    }
    get(e) {
      return this.attributes[e];
    }
    getGeometrySize(e) {
      if (Array.isArray(e[0])) {
        let n = 0;
        for (let i of e)
          n += this.getGeometrySize(i);
        return n;
      }
      let t = this.getPathLength(e);
      return t < 2 ? 0 : this.isClosed(e) ? t < 3 ? 0 : t + 2 : t;
    }
    updateGeometryAttributes(e, t) {
      if (t.geometrySize !== 0)
        if (e && Array.isArray(e[0]))
          for (let n of e) {
            let i = this.getGeometrySize(n);
            t.geometrySize = i, this.updateGeometryAttributes(n, t), t.vertexStart += i;
          }
        else
          this._updateSegmentTypes(e, t), this._updatePositions(e, t);
    }
    _updateSegmentTypes(e, t) {
      let { segmentTypes: n } = this.attributes, i = this.isClosed(e), { vertexStart: s, geometrySize: o } = t;
      n.fill(0, s, s + o), i ? (n[s] = Yf, n[s + o - 2] = Yf) : (n[s] += xS, n[s + o - 2] += yS), n[s + o - 1] = Yf;
    }
    _updatePositions(e, t) {
      let { positions: n } = this.attributes;
      if (!n)
        return;
      let { vertexStart: i, geometrySize: s } = t, o = new Array(3);
      for (let a = i, c = 0; c < s; a++, c++)
        this.getPointOnPath(e, c, o), n[a * 3] = o[0], n[a * 3 + 1] = o[1], n[a * 3 + 2] = o[2];
    }
    getPathLength(e) {
      return e.length / this.positionSize;
    }
    getPointOnPath(e, t, n = []) {
      let { positionSize: i } = this;
      t * i >= e.length && (t += 1 - e.length / i);
      let s = t * i;
      return n[0] = e[s], n[1] = e[s + 1], n[2] = i === 3 && e[s + 2] || 0, n;
    }
    isClosed(e) {
      if (!this.normalize)
        return this.opts.loop;
      let { positionSize: t } = this, n = e.length - t;
      return e[0] === e[n] && e[1] === e[n + 1] && (t === 2 || e[2] === e[n + 2]);
    }
  };
  var Hg = `#define SHADER_NAME path-layer-vertex-shader

attribute vec2 positions;

attribute float instanceTypes;
attribute vec3 instanceStartPositions;
attribute vec3 instanceEndPositions;
attribute vec3 instanceLeftPositions;
attribute vec3 instanceRightPositions;
attribute vec3 instanceLeftPositions64Low;
attribute vec3 instanceStartPositions64Low;
attribute vec3 instanceEndPositions64Low;
attribute vec3 instanceRightPositions64Low;
attribute float instanceStrokeWidths;
attribute vec4 instanceColors;
attribute vec3 instancePickingColors;

uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform float jointType;
uniform float capType;
uniform float miterLimit;
uniform bool billboard;

uniform float opacity;

varying vec4 vColor;
varying vec2 vCornerOffset;
varying float vMiterLength;
varying vec2 vPathPosition;
varying float vPathLength;
varying float vJointType;

const float EPSILON = 0.001;
const vec3 ZERO_OFFSET = vec3(0.0);

float flipIfTrue(bool flag) {
  return -(float(flag) * 2. - 1.);
}
vec3 lineJoin(
  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,
  vec2 width
) {
  bool isEnd = positions.x > 0.0;
  float sideOfPath = positions.y;
  float isJoint = float(sideOfPath == 0.0);

  vec3 deltaA3 = (currPoint - prevPoint);
  vec3 deltaB3 = (nextPoint - currPoint);

  mat3 rotationMatrix;
  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);
  if (needsRotation) {
    deltaA3 = deltaA3 * rotationMatrix;
    deltaB3 = deltaB3 * rotationMatrix;
  }
  vec2 deltaA = deltaA3.xy / width;
  vec2 deltaB = deltaB3.xy / width;

  float lenA = length(deltaA);
  float lenB = length(deltaB);

  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);
  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);

  vec2 perpA = vec2(-dirA.y, dirA.x);
  vec2 perpB = vec2(-dirB.y, dirB.x);
  vec2 tangent = dirA + dirB;
  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;
  vec2 miterVec = vec2(-tangent.y, tangent.x);
  vec2 dir = isEnd ? dirA : dirB;
  vec2 perp = isEnd ? perpA : perpB;
  float L = isEnd ? lenA : lenB;
  float sinHalfA = abs(dot(miterVec, perp));
  float cosHalfA = abs(dot(dirA, miterVec));
  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);
  float cornerPosition = sideOfPath * turnDirection;

  float miterSize = 1.0 / max(sinHalfA, EPSILON);
  miterSize = mix(
    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),
    miterSize,
    step(0.0, cornerPosition)
  );

  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))
    * (sideOfPath + isJoint * turnDirection);
  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));
  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));
  bool isCap = isStartCap || isEndCap;
  if (isCap) {
    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);
    vJointType = capType;
  } else {
    vJointType = jointType;
  }
  vPathLength = L;
  vCornerOffset = offsetVec;
  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);
  vMiterLength = isCap ? isJoint : vMiterLength;

  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);
  vPathPosition = vec2(
    dot(offsetFromStartOfPath, perp),
    dot(offsetFromStartOfPath, dir)
  );
  geometry.uv = vPathPosition;

  float isValid = step(instanceTypes, 3.5);
  vec3 offset = vec3(offsetVec * width * isValid, 0.0);

  if (needsRotation) {
    offset = rotationMatrix * offset;
  }
  return currPoint + offset;
}
void clipLine(inout vec4 position, vec4 refPosition) {
  if (position.w < EPSILON) {
    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);
    position = refPosition + (position - refPosition) * r;
  }
}

void main() {
  geometry.worldPosition = instanceStartPositions;
  geometry.worldPositionAlt = instanceEndPositions;
  geometry.pickingColor = instancePickingColors;

  vec2 widthPixels = vec2(clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),
    widthMinPixels, widthMaxPixels) / 2.0);
  vec3 width;

  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);

  float isEnd = positions.x;

  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);
  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);

  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);
  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);

  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);
  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);

  if (billboard) {
    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);
    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);
    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);

    clipLine(prevPositionScreen, currPositionScreen);
    clipLine(nextPositionScreen, currPositionScreen);
    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));

    width = vec3(widthPixels, 0.0);
    DECKGL_FILTER_SIZE(width, geometry);

    vec3 pos = lineJoin(
      prevPositionScreen.xyz / prevPositionScreen.w,
      currPositionScreen.xyz / currPositionScreen.w,
      nextPositionScreen.xyz / nextPositionScreen.w,
      project_pixel_size_to_clipspace(width.xy)
    );

    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);
  } else {
    prevPosition = project_position(prevPosition, prevPosition64Low);
    currPosition = project_position(currPosition, currPosition64Low);
    nextPosition = project_position(nextPosition, nextPosition64Low);

    width = vec3(project_pixel_size(widthPixels), 0.0);
    DECKGL_FILTER_SIZE(width, geometry);

    vec4 pos = vec4(
      lineJoin(prevPosition, currPosition, nextPosition, width.xy),
      1.0);
    geometry.position = pos;
    gl_Position = project_common_position_to_clipspace(pos);
  }
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;
  var Xg = `#define SHADER_NAME path-layer-fragment-shader

precision highp float;

uniform float miterLimit;

varying vec4 vColor;
varying vec2 vCornerOffset;
varying float vMiterLength;
varying vec2 vPathPosition;
varying float vPathLength;
varying float vJointType;

void main(void) {
  geometry.uv = vPathPosition;

  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {
    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {
      discard;
    }
    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {
      discard;
    }
  }
  gl_FragColor = vColor;

  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`;
  var Yg = [0, 0, 0, 255];
  var ES = { widthUnits: "meters", widthScale: { type: "number", min: 0, value: 1 }, widthMinPixels: { type: "number", min: 0, value: 0 }, widthMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER }, jointRounded: false, capRounded: false, miterLimit: { type: "number", min: 0, value: 4 }, billboard: false, _pathType: null, getPath: { type: "accessor", value: (r2) => r2.path }, getColor: { type: "accessor", value: Yg }, getWidth: { type: "accessor", value: 1 }, rounded: { deprecatedFor: ["jointRounded", "capRounded"] } };
  var qf = { enter: (r2, e) => e.length ? e.subarray(e.length - r2.length) : r2 };
  var ti = class extends ye {
    getShaders() {
      return super.getShaders({ vs: Hg, fs: Xg, modules: [Ie, Oe] });
    }
    get wrapLongitude() {
      return false;
    }
    initializeState() {
      let e = true;
      this.getAttributeManager().addInstanced({ positions: { size: 3, vertexOffset: 1, type: 5130, fp64: this.use64bitPositions(), transition: qf, accessor: "getPath", update: this.calculatePositions, noAlloc: e, shaderAttributes: { instanceLeftPositions: { vertexOffset: 0 }, instanceStartPositions: { vertexOffset: 1 }, instanceEndPositions: { vertexOffset: 2 }, instanceRightPositions: { vertexOffset: 3 } } }, instanceTypes: { size: 1, type: 5121, update: this.calculateSegmentTypes, noAlloc: e }, instanceStrokeWidths: { size: 1, accessor: "getWidth", transition: qf, defaultValue: 1 }, instanceColors: { size: this.props.colorFormat.length, type: 5121, normalized: true, accessor: "getColor", transition: qf, defaultValue: Yg }, instancePickingColors: { size: 3, type: 5121, accessor: (n, { index: i, target: s }) => this.encodePickingColor(n && n.__source ? n.__source.index : i, s) } }), this.setState({ pathTesselator: new rc({ fp64: this.use64bitPositions() }) }), this.props.getDashArray && !this.props.extensions.length && F.removed("getDashArray", "PathStyleExtension")();
    }
    updateState({ oldProps: e, props: t, changeFlags: n }) {
      super.updateState({ props: t, oldProps: e, changeFlags: n });
      let i = this.getAttributeManager();
      if (n.dataChanged || n.updateTriggersChanged && (n.updateTriggersChanged.all || n.updateTriggersChanged.getPath)) {
        let { pathTesselator: a } = this.state, c = t.data.attributes || {};
        a.updateGeometry({ data: t.data, geometryBuffer: c.getPath, buffers: c, normalize: !t._pathType, loop: t._pathType === "loop", getGeometry: t.getPath, positionFormat: t.positionFormat, wrapLongitude: t.wrapLongitude, resolution: this.context.viewport.resolution, dataChanged: n.dataChanged }), this.setState({ numInstances: a.instanceCount, startIndices: a.vertexStarts }), n.dataChanged || i.invalidateAll();
      }
      if (n.extensionsChanged) {
        var o;
        let { gl: a } = this.context;
        (o = this.state.model) === null || o === void 0 || o.delete(), this.state.model = this._getModel(a), i.invalidateAll();
      }
    }
    getPickingInfo(e) {
      let t = super.getPickingInfo(e), { index: n } = t, { data: i } = this.props;
      return i[0] && i[0].__source && (t.object = i.find((s) => s.__source.index === n)), t;
    }
    disablePickingIndex(e) {
      let { data: t } = this.props;
      if (t[0] && t[0].__source)
        for (let n = 0; n < t.length; n++)
          t[n].__source.index === e && this._disablePickingIndex(n);
      else
        this._disablePickingIndex(e);
    }
    draw({ uniforms: e }) {
      let { viewport: t } = this.context, { jointRounded: n, capRounded: i, billboard: s, miterLimit: o, widthUnits: a, widthScale: c, widthMinPixels: l, widthMaxPixels: f } = this.props, u = a === "pixels" ? t.metersPerPixel : 1;
      this.state.model.setUniforms(e).setUniforms({ jointType: Number(n), capType: Number(i), billboard: s, widthScale: c * u, miterLimit: o, widthMinPixels: l, widthMaxPixels: f }).draw();
    }
    _getModel(e) {
      let t = [0, 1, 2, 1, 4, 2, 1, 3, 4, 3, 5, 4], n = [0, 0, 0, -1, 0, 1, 1, -1, 1, 1, 1, 0];
      return new xe(e, L(x({}, this.getShaders()), { id: this.props.id, geometry: new Me({ drawMode: 4, attributes: { indices: new Uint16Array(t), positions: { value: new Float32Array(n), size: 2 } } }), isInstanced: true }));
    }
    calculatePositions(e) {
      let { pathTesselator: t } = this.state;
      e.startIndices = t.vertexStarts, e.value = t.get("positions");
    }
    calculateSegmentTypes(e) {
      let { pathTesselator: t } = this.state;
      e.startIndices = t.vertexStarts, e.value = t.get("segmentTypes");
    }
  };
  ti.layerName = "PathLayer";
  ti.defaultProps = ES;
  var $g = Mt(Jg());
  var ac = Ja.CLOCKWISE;
  var e0 = Ja.COUNTER_CLOCKWISE;
  var Br = { isClosed: true };
  function DS(r2) {
    if (r2 = r2 && r2.positions || r2, !Array.isArray(r2) && !ArrayBuffer.isView(r2))
      throw new Error("invalid polygon");
  }
  function BS(r2) {
    return r2.length >= 1 && r2[0].length >= 2 && Number.isFinite(r2[0][0]);
  }
  function US(r2) {
    let e = r2[0], t = r2[r2.length - 1];
    return e[0] === t[0] && e[1] === t[1] && e[2] === t[2];
  }
  function kS(r2, e, t, n) {
    for (let i = 0; i < e; i++)
      if (r2[t + i] !== r2[n - e + i])
        return false;
    return true;
  }
  function t0(r2, e, t, n, i) {
    let s = e, o = t.length;
    for (let a = 0; a < o; a++)
      for (let c = 0; c < n; c++)
        r2[s++] = t[a][c] || 0;
    if (!US(t))
      for (let a = 0; a < n; a++)
        r2[s++] = t[0][a] || 0;
    return Br.start = e, Br.end = s, Br.size = n, ys(r2, i, Br), s;
  }
  function r0(r2, e, t, n, i = 0, s, o) {
    s = s || t.length;
    let a = s - i;
    if (a <= 0)
      return e;
    let c = e;
    for (let l = 0; l < a; l++)
      r2[c++] = t[i + l];
    if (!kS(t, n, i, s))
      for (let l = 0; l < n; l++)
        r2[c++] = t[i + l];
    return Br.start = e, Br.end = c, Br.size = n, ys(r2, o, Br), c;
  }
  function n0(r2, e) {
    DS(r2);
    let t = [], n = [];
    if (r2.positions) {
      let { positions: i, holeIndices: s } = r2;
      if (s) {
        let o = 0;
        for (let a = 0; a <= s.length; a++)
          o = r0(t, o, i, e, s[a - 1], s[a], a === 0 ? ac : e0), n.push(o);
        return n.pop(), { positions: t, holeIndices: n };
      }
      r2 = i;
    }
    if (Number.isFinite(r2[0]))
      return r0(t, 0, r2, e, 0, t.length, ac), t;
    if (!BS(r2)) {
      let i = 0;
      for (let [s, o] of r2.entries())
        i = t0(t, i, o, e, s === 0 ? ac : e0), n.push(i);
      return n.pop(), { positions: t, holeIndices: n };
    }
    return t0(t, 0, r2, e, ac), t;
  }
  function i0(r2, e, t) {
    let n = null;
    r2.holeIndices && (n = r2.holeIndices.map((s) => s / e));
    let i = r2.positions || r2;
    if (t) {
      let s = i.length;
      i = i.slice();
      let o = [];
      for (let a = 0; a < s; a += e) {
        o[0] = i[a], o[1] = i[a + 1];
        let c = t(o);
        i[a] = c[0], i[a + 1] = c[1];
      }
    }
    return (0, $g.default)(i, n, e);
  }
  var cc = class extends on {
    constructor(e) {
      let { fp64: t, IndexType: n = Uint32Array } = e;
      super(L(x({}, e), { attributes: { positions: { size: 3, type: t ? Float64Array : Float32Array }, vertexValid: { type: Uint8ClampedArray, size: 1 }, indices: { type: n, size: 1 } } }));
    }
    get(e) {
      let { attributes: t } = this;
      return e === "indices" ? t.indices && t.indices.subarray(0, this.vertexCount) : t[e];
    }
    updateGeometry(e) {
      super.updateGeometry(e);
      let t = this.buffers.indices;
      t && (this.vertexCount = (t.value || t).length);
    }
    normalizeGeometry(e) {
      if (this.normalize) {
        if (e = n0(e, this.positionSize), this.opts.resolution)
          return vs(e.positions || e, e.holeIndices, { size: this.positionSize, gridResolution: this.opts.resolution, edgeTypes: true });
        if (this.opts.wrapLongitude)
          return Xf(e.positions || e, e.holeIndices, { size: this.positionSize, maxLatitude: 86, edgeTypes: true });
      }
      return e;
    }
    getGeometrySize(e) {
      if (Array.isArray(e) && !Number.isFinite(e[0])) {
        let t = 0;
        for (let n of e)
          t += this.getGeometrySize(n);
        return t;
      }
      return (e.positions || e).length / this.positionSize;
    }
    getGeometryFromBuffer(e) {
      return this.normalize || !this.buffers.indices ? super.getGeometryFromBuffer(e) : () => null;
    }
    updateGeometryAttributes(e, t) {
      if (Array.isArray(e) && !Number.isFinite(e[0]))
        for (let n of e) {
          let i = this.getGeometrySize(n);
          t.geometrySize = i, this.updateGeometryAttributes(n, t), t.vertexStart += i, t.indexStart = this.indexStarts[t.geometryIndex + 1];
        }
      else
        this._updateIndices(e, t), this._updatePositions(e, t), this._updateVertexValid(e, t);
    }
    _updateIndices(e, { geometryIndex: t, vertexStart: n, indexStart: i }) {
      let { attributes: s, indexStarts: o, typedArrayManager: a } = this, c = s.indices;
      if (!c)
        return;
      let l = i, f = i0(e, this.positionSize, this.opts.preproject);
      c = a.allocate(c, i + f.length, { copy: true });
      for (let u = 0; u < f.length; u++)
        c[l++] = f[u] + n;
      o[t + 1] = i + f.length, s.indices = c;
    }
    _updatePositions(e, { vertexStart: t, geometrySize: n }) {
      let { attributes: { positions: i }, positionSize: s } = this;
      if (!i)
        return;
      let o = e.positions || e;
      for (let a = t, c = 0; c < n; a++, c++) {
        let l = o[c * s], f = o[c * s + 1], u = s > 2 ? o[c * s + 2] : 0;
        i[a * 3] = l, i[a * 3 + 1] = f, i[a * 3 + 2] = u;
      }
    }
    _updateVertexValid(e, { vertexStart: t, geometrySize: n }) {
      let { attributes: { vertexValid: i }, positionSize: s } = this, o = e && e.holeIndices;
      if (e && e.edgeTypes ? i.set(e.edgeTypes, t) : i.fill(1, t, t + n), o)
        for (let a = 0; a < o.length; a++)
          i[t + o[a] / s - 1] = 0;
      i[t + n - 1] = 0;
    }
  };
  var lc = `
attribute vec2 vertexPositions;
attribute float vertexValid;

uniform bool extruded;
uniform bool isWireframe;
uniform float elevationScale;
uniform float opacity;

varying vec4 vColor;

struct PolygonProps {
  vec4 fillColors;
  vec4 lineColors;
  vec3 positions;
  vec3 nextPositions;
  vec3 pickingColors;
  vec3 positions64Low;
  vec3 nextPositions64Low;
  float elevations;
};

vec3 project_offset_normal(vec3 vector) {
  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {
    return normalize(vector * project_uCommonUnitsPerWorldUnit);
  }
  return project_normal(vector);
}

void calculatePosition(PolygonProps props) {
#ifdef IS_SIDE_VERTEX
  if(vertexValid < 0.5){
    gl_Position = vec4(0.);
    return;
  }
#endif

  vec3 pos;
  vec3 pos64Low;
  vec3 normal;
  vec4 colors = isWireframe ? props.lineColors : props.fillColors;

  geometry.worldPosition = props.positions;
  geometry.worldPositionAlt = props.nextPositions;
  geometry.pickingColor = props.pickingColors;

#ifdef IS_SIDE_VERTEX
  pos = mix(props.positions, props.nextPositions, vertexPositions.x);
  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);
#else
  pos = props.positions;
  pos64Low = props.positions64Low;
#endif

  if (extruded) {
    pos.z += props.elevations * vertexPositions.y * elevationScale;

#ifdef IS_SIDE_VERTEX
    normal = vec3(
      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),
      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),
      0.0);
    normal = project_offset_normal(normal);
#else
    normal = vec3(0.0, 0.0, 1.0);
#endif
    geometry.normal = normal;
  }

  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  if (extruded) {
    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);
    vColor = vec4(lightColor, colors.a * opacity);
  } else {
    vColor = vec4(colors.rgb, colors.a * opacity);
  }
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;
  var s0 = `#define SHADER_NAME solid-polygon-layer-vertex-shader

attribute vec3 positions;
attribute vec3 positions64Low;
attribute float elevations;
attribute vec4 fillColors;
attribute vec4 lineColors;
attribute vec3 pickingColors;

`.concat(lc, `

void main(void) {
  PolygonProps props;

  props.positions = positions;
  props.positions64Low = positions64Low;
  props.elevations = elevations;
  props.fillColors = fillColors;
  props.lineColors = lineColors;
  props.pickingColors = pickingColors;

  calculatePosition(props);
}
`);
  var o0 = `#define SHADER_NAME solid-polygon-layer-vertex-shader-side
#define IS_SIDE_VERTEX


attribute vec3 instancePositions;
attribute vec3 nextPositions;
attribute vec3 instancePositions64Low;
attribute vec3 nextPositions64Low;
attribute float instanceElevations;
attribute vec4 instanceFillColors;
attribute vec4 instanceLineColors;
attribute vec3 instancePickingColors;

`.concat(lc, `

void main(void) {
  PolygonProps props;

  #if RING_WINDING_ORDER_CW == 1
    props.positions = instancePositions;
    props.positions64Low = instancePositions64Low;
    props.nextPositions = nextPositions;
    props.nextPositions64Low = nextPositions64Low;
  #else
    props.positions = nextPositions;
    props.positions64Low = nextPositions64Low;
    props.nextPositions = instancePositions;
    props.nextPositions64Low = instancePositions64Low;
  #endif
  props.elevations = instanceElevations;
  props.fillColors = instanceFillColors;
  props.lineColors = instanceLineColors;
  props.pickingColors = instancePickingColors;

  calculatePosition(props);
}
`);
  var a0 = `#define SHADER_NAME solid-polygon-layer-fragment-shader

precision highp float;

varying vec4 vColor;

void main(void) {
  gl_FragColor = vColor;

  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`;
  var fc = [0, 0, 0, 255];
  var VS = { filled: true, extruded: false, wireframe: false, _normalize: true, _windingOrder: "CW", elevationScale: { type: "number", min: 0, value: 1 }, getPolygon: { type: "accessor", value: (r2) => r2.polygon }, getElevation: { type: "accessor", value: 1e3 }, getFillColor: { type: "accessor", value: fc }, getLineColor: { type: "accessor", value: fc }, material: true };
  var uc = { enter: (r2, e) => e.length ? e.subarray(e.length - r2.length) : r2 };
  var ni = class extends ye {
    getShaders(e) {
      return super.getShaders({ vs: e === "top" ? s0 : o0, fs: a0, defines: { RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === "CCW" ? 0 : 1 }, modules: [Ie, Un, Oe] });
    }
    get wrapLongitude() {
      return false;
    }
    initializeState() {
      let { gl: e, viewport: t } = this.context, { coordinateSystem: n } = this.props;
      t.isGeospatial && n === j.DEFAULT && (n = j.LNGLAT), this.setState({ numInstances: 0, polygonTesselator: new cc({ preproject: n === j.LNGLAT && t.projectFlat, fp64: this.use64bitPositions(), IndexType: !e || _r(e, K.ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array }) });
      let i = this.getAttributeManager(), s = true;
      i.remove(["instancePickingColors"]), i.add({ indices: { size: 1, isIndexed: true, update: this.calculateIndices, noAlloc: s }, positions: { size: 3, type: 5130, fp64: this.use64bitPositions(), transition: uc, accessor: "getPolygon", update: this.calculatePositions, noAlloc: s, shaderAttributes: { positions: { vertexOffset: 0, divisor: 0 }, instancePositions: { vertexOffset: 0, divisor: 1 }, nextPositions: { vertexOffset: 1, divisor: 1 } } }, vertexValid: { size: 1, divisor: 1, type: 5121, update: this.calculateVertexValid, noAlloc: s }, elevations: { size: 1, transition: uc, accessor: "getElevation", shaderAttributes: { elevations: { divisor: 0 }, instanceElevations: { divisor: 1 } } }, fillColors: { alias: "colors", size: this.props.colorFormat.length, type: 5121, normalized: true, transition: uc, accessor: "getFillColor", defaultValue: fc, shaderAttributes: { fillColors: { divisor: 0 }, instanceFillColors: { divisor: 1 } } }, lineColors: { alias: "colors", size: this.props.colorFormat.length, type: 5121, normalized: true, transition: uc, accessor: "getLineColor", defaultValue: fc, shaderAttributes: { lineColors: { divisor: 0 }, instanceLineColors: { divisor: 1 } } }, pickingColors: { size: 3, type: 5121, accessor: (o, { index: a, target: c }) => this.encodePickingColor(o && o.__source ? o.__source.index : a, c), shaderAttributes: { pickingColors: { divisor: 0 }, instancePickingColors: { divisor: 1 } } } });
    }
    getPickingInfo(e) {
      let t = super.getPickingInfo(e), { index: n } = t, { data: i } = this.props;
      return i[0] && i[0].__source && (t.object = i.find((s) => s.__source.index === n)), t;
    }
    disablePickingIndex(e) {
      let { data: t } = this.props;
      if (t[0] && t[0].__source)
        for (let n = 0; n < t.length; n++)
          t[n].__source.index === e && this._disablePickingIndex(n);
      else
        this._disablePickingIndex(e);
    }
    draw({ uniforms: e }) {
      let { extruded: t, filled: n, wireframe: i, elevationScale: s } = this.props, { topModel: o, sideModel: a, polygonTesselator: c } = this.state, l = L(x({}, e), { extruded: Boolean(t), elevationScale: s });
      a && (a.setInstanceCount(c.instanceCount - 1), a.setUniforms(l), i && (a.setDrawMode(3), a.setUniforms({ isWireframe: true }).draw()), n && (a.setDrawMode(6), a.setUniforms({ isWireframe: false }).draw())), o && (o.setVertexCount(c.vertexCount), o.setUniforms(l).draw());
    }
    updateState(e) {
      super.updateState(e), this.updateGeometry(e);
      let { props: t, oldProps: n, changeFlags: i } = e, s = this.getAttributeManager();
      if (i.extensionsChanged || t.filled !== n.filled || t.extruded !== n.extruded) {
        var a;
        (a = this.state.models) === null || a === void 0 || a.forEach((c) => c.delete()), this.setState(this._getModels(this.context.gl)), s.invalidateAll();
      }
    }
    updateGeometry({ props: e, oldProps: t, changeFlags: n }) {
      if (n.dataChanged || n.updateTriggersChanged && (n.updateTriggersChanged.all || n.updateTriggersChanged.getPolygon)) {
        let { polygonTesselator: s } = this.state, o = e.data.attributes || {};
        s.updateGeometry({ data: e.data, normalize: e._normalize, geometryBuffer: o.getPolygon, buffers: o, getGeometry: e.getPolygon, positionFormat: e.positionFormat, wrapLongitude: e.wrapLongitude, resolution: this.context.viewport.resolution, fp64: this.use64bitPositions(), dataChanged: n.dataChanged }), this.setState({ numInstances: s.instanceCount, startIndices: s.vertexStarts }), n.dataChanged || this.getAttributeManager().invalidateAll();
      }
    }
    _getModels(e) {
      let { id: t, filled: n, extruded: i } = this.props, s, o;
      if (n) {
        let a = this.getShaders("top");
        a.defines.NON_INSTANCED_MODEL = 1, s = new xe(e, L(x({}, a), { id: "".concat(t, "-top"), drawMode: 4, attributes: { vertexPositions: new Float32Array([0, 1]) }, uniforms: { isWireframe: false, isSideVertex: false }, vertexCount: 0, isIndexed: true }));
      }
      return i && (o = new xe(e, L(x({}, this.getShaders("side")), { id: "".concat(t, "-side"), geometry: new Me({ drawMode: 1, vertexCount: 4, attributes: { vertexPositions: { size: 2, value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1]) } } }), instanceCount: 0, isInstanced: 1 })), o.userData.excludeAttributes = { indices: true }), { models: [o, s].filter(Boolean), topModel: s, sideModel: o };
    }
    calculateIndices(e) {
      let { polygonTesselator: t } = this.state;
      e.startIndices = t.indexStarts, e.value = t.get("indices");
    }
    calculatePositions(e) {
      let { polygonTesselator: t } = this.state;
      e.startIndices = t.vertexStarts, e.value = t.get("positions");
    }
    calculateVertexValid(e) {
      e.value = this.state.polygonTesselator.get("vertexValid");
    }
  };
  ni.layerName = "SolidPolygonLayer";
  ni.defaultProps = VS;
  function c0({ data: r2, getIndex: e, dataRange: t, replace: n }) {
    let { startRow: i = 0, endRow: s = 1 / 0 } = t, o = r2.length, a = o, c = o;
    for (let h = 0; h < o; h++) {
      let d = e(r2[h]);
      if (a > h && d >= i && (a = h), d >= s) {
        c = h;
        break;
      }
    }
    let l = a, f = c - a !== n.length, u = f && r2.slice(c);
    for (let h = 0; h < n.length; h++)
      r2[l++] = n[h];
    if (f) {
      for (let h = 0; h < u.length; h++)
        r2[l++] = u[h];
      r2.length = l;
    }
    return { startRow: a, endRow: a + n.length };
  }
  function l0(r2, e) {
    if (!r2)
      return null;
    let t = "startIndices" in r2 ? r2.startIndices[e] : e, n = r2.featureIds.value[t];
    return t !== -1 ? GS(r2, n, t) : null;
  }
  function GS(r2, e, t) {
    let n = { properties: x({}, r2.properties[e]) };
    for (let i in r2.numericProps)
      n.properties[i] = r2.numericProps[i].value[t];
    return n;
  }
  function f0(r2, e) {
    let t = { points: null, lines: null, polygons: null };
    for (let n in t) {
      let i = r2[n].globalFeatureIds.value;
      t[n] = new Uint8ClampedArray(i.length * 3);
      let s = [];
      for (let o = 0; o < i.length; o++)
        e(i[o], s), t[n][o * 3 + 0] = s[0], t[n][o * 3 + 1] = s[1], t[n][o * 3 + 2] = s[2];
    }
    return t;
  }
  var u0 = `#define SHADER_NAME multi-icon-layer-fragment-shader

precision highp float;

uniform float opacity;
uniform sampler2D iconsTexture;
uniform float gamma;
uniform bool sdf;
uniform float alphaCutoff;
uniform float buffer;
uniform float outlineBuffer;
uniform vec4 outlineColor;

varying vec4 vColor;
varying vec2 vTextureCoords;
varying vec2 uv;

void main(void) {
  geometry.uv = uv;

  if (!picking_uActive) {
    float alpha = texture2D(iconsTexture, vTextureCoords).a;
    vec4 color = vColor;
    if (sdf) {
      float distance = alpha;
      alpha = smoothstep(buffer - gamma, buffer + gamma, distance);

      if (outlineBuffer > 0.0) {
        float inFill = alpha;
        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);
        color = mix(outlineColor, vColor, inFill);
        alpha = inBorder;
      }
    }
    float a = alpha * color.a;
    
    if (a < alphaCutoff) {
      discard;
    }

    gl_FragColor = vec4(color.rgb, a * opacity);
  }

  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`;
  var h0 = 192 / 256;
  var d0 = [];
  var zS = { getIconOffsets: { type: "accessor", value: (r2) => r2.offsets }, alphaCutoff: 1e-3, smoothing: 0.1, outlineWidth: 0, outlineColor: { type: "color", value: [0, 0, 0, 255] } };
  var ii = class extends Nr {
    getShaders() {
      return L(x({}, super.getShaders()), { fs: u0 });
    }
    initializeState() {
      super.initializeState(), this.getAttributeManager().addInstanced({ instanceOffsets: { size: 2, accessor: "getIconOffsets" }, instancePickingColors: { type: 5121, size: 3, accessor: (t, { index: n, target: i }) => this.encodePickingColor(n, i) } });
    }
    updateState(e) {
      super.updateState(e);
      let { props: t, oldProps: n } = e, { outlineColor: i } = t;
      i !== n.outlineColor && (i = i.map((s) => s / 255), i[3] = Number.isFinite(i[3]) ? i[3] : 1, this.setState({ outlineColor: i })), !t.sdf && t.outlineWidth && F.warn("".concat(this.id, ": fontSettings.sdf is required to render outline"))();
    }
    draw(e) {
      let { sdf: t, smoothing: n, outlineWidth: i } = this.props, { outlineColor: s } = this.state;
      e.uniforms = L(x({}, e.uniforms), { buffer: h0, outlineBuffer: i ? Math.max(n, h0 * (1 - i)) : -1, gamma: n, sdf: Boolean(t), outlineColor: s }), super.draw(e);
    }
    getInstanceOffset(e) {
      return e ? Array.from(e).map((t) => super.getInstanceOffset(t)) : d0;
    }
    getInstanceColorMode(e) {
      return 1;
    }
    getInstanceIconFrame(e) {
      return e ? Array.from(e).map((t) => super.getInstanceIconFrame(t)) : d0;
    }
  };
  ii.layerName = "MultiIconLayer";
  ii.defaultProps = zS;
  var b0 = Mt(g0());
  var HS = 32;
  var XS = [];
  function YS(r2) {
    return Math.pow(2, Math.ceil(Math.log2(r2)));
  }
  function _0({ characterSet: r2, getFontWidth: e, fontHeight: t, buffer: n, maxCanvasWidth: i, mapping: s = {}, xOffset: o = 0, yOffset: a = 0 }) {
    let c = 0, l = o, f = 0;
    for (let h of r2)
      if (!s[h]) {
        let d = e(h, f++);
        l + d + n * 2 > i && (l = 0, c++), s[h] = { x: l + n, y: a + c * (t + n * 2) + n, width: d, height: t }, l += d + n * 2;
      }
    let u = t + n * 2;
    return { mapping: s, xOffset: l, yOffset: a + c * u, canvasHeight: YS(a + (c + 1) * u) };
  }
  function x0(r2, e, t, n) {
    let i = 0;
    for (let s = e; s < t; s++) {
      let o = r2[s], a = null, c = n && n[o];
      c && (a = c.width), i += a;
    }
    return i;
  }
  function y0(r2, e, t, n, i, s) {
    let o = e, a = 0;
    for (let c = e; c < t; c++) {
      let l = x0(r2, c, c + 1, i);
      a + l > n && (o < c && s.push(c), o = c, a = 0), a += l;
    }
    return a;
  }
  function qS(r2, e, t, n, i, s) {
    let o = e, a = e, c = e, l = 0;
    for (let f = e; f < t; f++)
      if ((r2[f] === " " || r2[f + 1] === " " || f + 1 === t) && (c = f + 1), c > a) {
        let u = x0(r2, a, c, i);
        l + u > n && (o < a && (s.push(a), o = a, l = 0), u > n && (u = y0(r2, a, c, n, i, s), o = s[s.length - 1])), a = c, l += u;
      }
    return l;
  }
  function ZS(r2, e, t, n, i = 0, s) {
    s === void 0 && (s = r2.length);
    let o = [];
    return e === "break-all" ? y0(r2, i, s, t, n, o) : qS(r2, i, s, t, n, o), o;
  }
  function KS(r2, e, t, n, i, s) {
    let o = 0, a = 0;
    for (let c = e; c < t; c++) {
      let l = r2[c], f = n[l];
      f ? (a || (a = f.height), i[c] = o + f.width / 2, o += f.width) : (F.warn("Missing character: ".concat(l, " (").concat(l.codePointAt(0), ")"))(), i[c] = o, o += HS);
    }
    s[0] = o, s[1] = a;
  }
  function eu(r2, e, t, n, i) {
    r2 = Array.from(r2);
    let s = r2.length, o = new Array(s), a = new Array(s), c = new Array(s), l = (t === "break-word" || t === "break-all") && isFinite(n) && n > 0, f = [0, 0], u = [], h = 0, d = 0, m = 0;
    for (let _ = 0; _ <= s; _++) {
      let E = r2[_];
      if ((E === `
` || _ === s) && (m = _), m > d) {
        let b = l ? ZS(r2, t, n, i, d, m) : XS;
        for (let T = 0; T <= b.length; T++) {
          let v = T === 0 ? d : b[T - 1], C = T < b.length ? b[T] : m;
          KS(r2, v, C, i, o, u);
          for (let S = v; S < C; S++)
            a[S] = h + u[1] / 2, c[S] = u[0];
          h = h + u[1] * e, f[0] = Math.max(f[0], u[0]);
        }
        d = m;
      }
      E === `
` && (o[d] = 0, a[d] = 0, c[d] = 0, d++);
    }
    return f[1] = h, { x: o, y: a, rowWidth: c, size: f };
  }
  function E0({ value: r2, length: e, stride: t, offset: n, startIndices: i, characterSet: s }) {
    let o = r2.BYTES_PER_ELEMENT, a = t ? t / o : 1, c = n ? n / o : 0, l = i[e] || Math.ceil((r2.length - c) / a), f = s && new Set(), u = new Array(e), h = r2;
    if (a > 1 || c > 0) {
      h = new r2.constructor(l);
      for (let d = 0; d < l; d++)
        h[d] = r2[d * a + c];
    }
    for (let d = 0; d < e; d++) {
      let m = i[d], _ = i[d + 1] || l, E = h.subarray(m, _);
      u[d] = String.fromCodePoint.apply(null, E), f && E.forEach(f.add, f);
    }
    if (f)
      for (let d of f)
        s.add(String.fromCodePoint(d));
    return { texts: u, characterCount: l };
  }
  var hc = class {
    constructor(e = 5) {
      this.limit = e, this.clear();
    }
    clear() {
      this._cache = {}, this._order = [];
    }
    get(e) {
      let t = this._cache[e];
      return t && (this._deleteOrder(e), this._appendOrder(e)), t;
    }
    set(e, t) {
      this._cache[e] ? (this.delete(e), this._cache[e] = t, this._appendOrder(e)) : (Object.keys(this._cache).length === this.limit && this.delete(this._order[0]), this._cache[e] = t, this._appendOrder(e));
    }
    delete(e) {
      this._cache[e] && (this._deleteCache(e), this._deleteOrder(e));
    }
    _deleteCache(e) {
      delete this._cache[e];
    }
    _deleteOrder(e) {
      let t = this._order.findIndex((n) => n === e);
      t >= 0 && this._order.splice(t, 1);
    }
    _appendOrder(e) {
      this._order.push(e);
    }
  };
  function QS() {
    let r2 = [];
    for (let e = 32; e < 128; e++)
      r2.push(String.fromCharCode(e));
    return r2;
  }
  var tu = QS();
  var ru = "Monaco, monospace";
  var nu = "normal";
  var iu = 64;
  var su = 4;
  var ou = 0.25;
  var au = 12;
  var T0 = 1024;
  var JS = 0.9;
  var v0 = 1.2;
  var $S = 3;
  var cu = new hc($S);
  var ew = ["fontFamily", "fontWeight", "characterSet", "fontSize", "sdf", "buffer", "cutoff", "radius"];
  function tw(r2, e) {
    let t = cu.get(r2);
    if (!t)
      return e;
    let n = [], i = t.mapping, s = Object.keys(i);
    s = new Set(s);
    let o = e;
    return o instanceof Array && (o = new Set(o)), o.forEach((a) => {
      s.has(a) || n.push(a);
    }), n;
  }
  function rw(r2, e) {
    for (let t = 0; t < r2.length; t++)
      e.data[4 * t + 3] = r2[t];
  }
  function A0(r2, e, t, n) {
    r2.font = "".concat(n, " ").concat(t, "px ").concat(e), r2.fillStyle = "#000", r2.textBaseline = "baseline", r2.textAlign = "left";
  }
  var dc = class {
    constructor() {
      this.props = { fontFamily: ru, fontWeight: nu, characterSet: tu, fontSize: iu, buffer: su, sdf: false, cutoff: ou, radius: au }, this._key = null, this._atlas = null;
    }
    get texture() {
      return this._atlas;
    }
    get mapping() {
      return this._atlas && this._atlas.mapping;
    }
    get scale() {
      return v0;
    }
    setProps(e = {}) {
      ew.forEach((o) => {
        o in e && (this.props[o] = e[o]);
      });
      let t = this._key;
      this._key = this._getKey();
      let n = tw(this._key, this.props.characterSet), i = cu.get(this._key);
      if (i && n.length === 0) {
        this._key !== t && (this._atlas = i);
        return;
      }
      let s = this._generateFontAtlas(this._key, n, i);
      this._atlas = s, cu.set(this._key, s);
    }
    _generateFontAtlas(e, t, n) {
      let { fontFamily: i, fontWeight: s, fontSize: o, buffer: a, sdf: c, radius: l, cutoff: f } = this.props, u = n && n.data;
      u || (u = document.createElement("canvas"), u.width = T0);
      let h = u.getContext("2d");
      A0(h, i, o, s);
      let { mapping: d, canvasHeight: m, xOffset: _, yOffset: E } = _0(x({ getFontWidth: (b) => h.measureText(b).width, fontHeight: o * v0, buffer: a, characterSet: t, maxCanvasWidth: T0 }, n && { mapping: n.mapping, xOffset: n.xOffset, yOffset: n.yOffset }));
      if (u.height !== m) {
        let b = h.getImageData(0, 0, u.width, u.height);
        u.height = m, h.putImageData(b, 0, 0);
      }
      if (A0(h, i, o, s), c) {
        let b = new b0.default(o, a, l, f, i, s), T = h.getImageData(0, 0, b.size, b.size);
        for (let v of t)
          rw(b.draw(v), T), h.putImageData(T, d[v].x - a, d[v].y + a);
      } else
        for (let b of t)
          h.fillText(b, d[b].x, d[b].y + o * JS);
      return { xOffset: _, yOffset: E, mapping: d, data: u, width: u.width, height: u.height };
    }
    _getKey() {
      let { fontFamily: e, fontWeight: t, fontSize: n, buffer: i, sdf: s, radius: o, cutoff: a } = this.props;
      return s ? "".concat(e, " ").concat(t, " ").concat(n, " ").concat(i, " ").concat(o, " ").concat(a) : "".concat(e, " ").concat(t, " ").concat(n, " ").concat(i);
    }
  };
  var S0 = `#define SHADER_NAME text-background-layer-vertex-shader

attribute vec2 positions;

attribute vec3 instancePositions;
attribute vec3 instancePositions64Low;
attribute vec4 instanceRects;
attribute float instanceSizes;
attribute float instanceAngles;
attribute vec2 instancePixelOffsets;
attribute float instanceLineWidths;
attribute vec4 instanceFillColors;
attribute vec4 instanceLineColors;
attribute vec3 instancePickingColors;

uniform bool billboard;
uniform float opacity;
uniform float sizeScale;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform vec4 padding;

varying vec4 vFillColor;
varying vec4 vLineColor;
varying float vLineWidth;
varying vec2 uv;
varying vec2 dimensions;

vec2 rotate_by_angle(vec2 vertex, float angle) {
  float angle_radian = radians(angle);
  float cos_angle = cos(angle_radian);
  float sin_angle = sin(angle_radian);
  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
  return rotationMatrix * vertex;
}

void main(void) {
  geometry.worldPosition = instancePositions;
  geometry.uv = positions;
  geometry.pickingColor = instancePickingColors;
  uv = positions;
  vLineWidth = instanceLineWidths;
  float sizePixels = clamp(
    project_size_to_pixel(instanceSizes * sizeScale),
    sizeMinPixels, sizeMaxPixels
  );

  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;

  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);
  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);
  pixelOffset += instancePixelOffsets;
  pixelOffset.y *= -1.0;

  if (billboard)  {
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
    vec3 offset = vec3(pixelOffset, 0.0);
    DECKGL_FILTER_SIZE(offset, geometry);
    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
  } else {
    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
    DECKGL_FILTER_SIZE(offset_common, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
  }
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);
  DECKGL_FILTER_COLOR(vFillColor, geometry);
  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);
  DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`;
  var w0 = `#define SHADER_NAME text-background-layer-fragment-shader

precision highp float;

uniform bool stroked;

varying vec4 vFillColor;
varying vec4 vLineColor;
varying float vLineWidth;
varying vec2 uv;
varying vec2 dimensions;

void main(void) {
  geometry.uv = uv;

  vec2 pixelPosition = uv * dimensions;
  if (stroked) {
    float distToEdge = min(
      min(pixelPosition.x, dimensions.x - pixelPosition.x),
      min(pixelPosition.y, dimensions.y - pixelPosition.y)
    );
    float isBorder = smoothedge(distToEdge, vLineWidth);
    gl_FragColor = mix(vFillColor, vLineColor, isBorder);
  } else {
    gl_FragColor = vFillColor;
  }

  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`;
  var nw = { billboard: true, sizeScale: 1, sizeUnits: "pixels", sizeMinPixels: 0, sizeMaxPixels: Number.MAX_SAFE_INTEGER, padding: { type: "array", value: [0, 0, 0, 0] }, getPosition: { type: "accessor", value: (r2) => r2.position }, getSize: { type: "accessor", value: 1 }, getAngle: { type: "accessor", value: 0 }, getPixelOffset: { type: "accessor", value: [0, 0] }, getBoundingRect: { type: "accessor", value: [0, 0, 0, 0] }, getFillColor: { type: "accessor", value: [0, 0, 0, 255] }, getLineColor: { type: "accessor", value: [0, 0, 0, 255] }, getLineWidth: { type: "accessor", value: 1 } };
  var oi = class extends ye {
    getShaders() {
      return super.getShaders({ vs: S0, fs: w0, modules: [Ie, Oe] });
    }
    initializeState() {
      this.getAttributeManager().addInstanced({ instancePositions: { size: 3, type: 5130, fp64: this.use64bitPositions(), transition: true, accessor: "getPosition" }, instanceSizes: { size: 1, transition: true, accessor: "getSize", defaultValue: 1 }, instanceAngles: { size: 1, transition: true, accessor: "getAngle" }, instanceRects: { size: 4, accessor: "getBoundingRect" }, instancePixelOffsets: { size: 2, transition: true, accessor: "getPixelOffset" }, instanceFillColors: { size: 4, transition: true, normalized: true, type: 5121, accessor: "getFillColor", defaultValue: [0, 0, 0, 255] }, instanceLineColors: { size: 4, transition: true, normalized: true, type: 5121, accessor: "getLineColor", defaultValue: [0, 0, 0, 255] }, instanceLineWidths: { size: 1, transition: true, accessor: "getLineWidth", defaultValue: 1 } });
    }
    updateState({ props: e, oldProps: t, changeFlags: n }) {
      if (super.updateState({ props: e, oldProps: t, changeFlags: n }), n.extensionsChanged) {
        var i;
        let { gl: s } = this.context;
        (i = this.state.model) === null || i === void 0 || i.delete(), this.state.model = this._getModel(s), this.getAttributeManager().invalidateAll();
      }
    }
    draw({ uniforms: e }) {
      let { viewport: t } = this.context, { billboard: n, sizeScale: i, sizeUnits: s, sizeMinPixels: o, sizeMaxPixels: a, getLineWidth: c } = this.props, { padding: l } = this.props, f = s === "pixels" ? t.metersPerPixel : 1;
      l.length < 4 && (l = [l[0], l[1], l[0], l[1]]), this.state.model.setUniforms(e).setUniforms({ billboard: n, stroked: Boolean(c), padding: l, sizeScale: i * f, sizeMinPixels: o, sizeMaxPixels: a }).draw();
    }
    _getModel(e) {
      let t = [0, 0, 1, 0, 1, 1, 0, 1];
      return new xe(e, L(x({}, this.getShaders()), { id: this.props.id, geometry: new Me({ drawMode: 6, vertexCount: 4, attributes: { positions: { size: 2, value: new Float32Array(t) } } }), isInstanced: true }));
    }
  };
  oi.layerName = "TextBackgroundLayer";
  oi.defaultProps = nw;
  var P0 = { fontSize: iu, buffer: su, sdf: false, radius: au, cutoff: ou, smoothing: 0.1 };
  var L0 = { start: 1, middle: 0, end: -1 };
  var C0 = { top: 1, center: 0, bottom: -1 };
  var lu = [0, 0, 0, 255];
  var iw = 1;
  var sw = ["fontSize", "buffer", "sdf", "radius", "cutoff"];
  var ow = { billboard: true, sizeScale: 1, sizeUnits: "pixels", sizeMinPixels: 0, sizeMaxPixels: Number.MAX_SAFE_INTEGER, background: false, getBackgroundColor: { type: "accessor", value: [255, 255, 255, 255] }, getBorderColor: { type: "accessor", value: lu }, getBorderWidth: { type: "accessor", value: 0 }, backgroundPadding: { type: "array", value: [0, 0, 0, 0] }, characterSet: { type: "object", value: tu }, fontFamily: ru, fontWeight: nu, lineHeight: iw, outlineWidth: { type: "number", value: 0, min: 0 }, outlineColor: { type: "color", value: lu }, fontSettings: {}, wordBreak: "break-word", maxWidth: { type: "number", value: -1 }, getText: { type: "accessor", value: (r2) => r2.text }, getPosition: { type: "accessor", value: (r2) => r2.position }, getColor: { type: "accessor", value: lu }, getSize: { type: "accessor", value: 32 }, getAngle: { type: "accessor", value: 0 }, getTextAnchor: { type: "accessor", value: "middle" }, getAlignmentBaseline: { type: "accessor", value: "center" }, getPixelOffset: { type: "accessor", value: [0, 0] }, backgroundColor: { deprecatedFor: ["background", "getBackgroundColor"] } };
  var wt = class extends zt {
    initializeState() {
      this.state = { styleVersion: 0, fontAtlasManager: new dc() };
    }
    updateState({ props: e, oldProps: t, changeFlags: n }) {
      let i = n.dataChanged || n.updateTriggersChanged && (n.updateTriggersChanged.all || n.updateTriggersChanged.getText), s = this.state.characterSet;
      i && this._updateText();
      let o = s !== this.state.characterSet || this._fontChanged(t, e);
      o && this._updateFontAtlas(t, e), (o || e.lineHeight !== t.lineHeight || e.wordBreak !== t.wordBreak || e.maxWidth !== t.maxWidth) && this.setState({ styleVersion: this.state.styleVersion + 1 });
    }
    getPickingInfo({ info: e }) {
      return e.object = e.index >= 0 ? this.props.data[e.index] : null, e;
    }
    _updateFontAtlas(e, t) {
      let { fontSettings: n, fontFamily: i, fontWeight: s } = t, { fontAtlasManager: o, characterSet: a } = this.state;
      o.setProps(L(x(x({}, P0), n), { characterSet: a, fontFamily: i, fontWeight: s }));
    }
    _fontChanged(e, t) {
      if (e.fontFamily !== t.fontFamily || e.fontWeight !== t.fontWeight)
        return true;
      if (e.fontSettings === t.fontSettings)
        return false;
      let n = e.fontSettings || {}, i = t.fontSettings || {};
      return sw.some((s) => n[s] !== i[s]);
    }
    _updateText() {
      let { data: e, characterSet: t } = this.props, n = e.attributes && e.attributes.getText, { getText: i } = this.props, { startIndices: s } = e, o, a = t === "auto" && new Set();
      if (n && s) {
        let { texts: c, characterCount: l } = E0(L(x({}, ArrayBuffer.isView(n) ? { value: n } : n), { length: e.length, startIndices: s, characterSet: a }));
        o = l, i = (f, { index: u }) => c[u];
      } else {
        let { iterable: c, objectInfo: l } = sr(e);
        s = [0], o = 0;
        for (let f of c) {
          l.index++;
          let u = Array.from(i(f, l) || "");
          a && u.forEach(a.add, a), o += u.length, s.push(o);
        }
      }
      this.setState({ getText: i, startIndices: s, numInstances: o, characterSet: a || t });
    }
    getBoundingRect(e, t) {
      let n = this.state.fontAtlasManager.mapping, { getText: i } = this.state, { wordBreak: s, maxWidth: o, lineHeight: a, getTextAnchor: c, getAlignmentBaseline: l } = this.props, f = i(e, t) || "", { size: [u, h] } = eu(f, a, s, o, n), d = L0[typeof c == "function" ? c(e, t) : c], m = C0[typeof l == "function" ? l(e, t) : l];
      return [(d - 1) * u / 2, (m - 1) * h / 2, u, h];
    }
    getIconOffsets(e, t) {
      let n = this.state.fontAtlasManager.mapping, { getText: i } = this.state, { wordBreak: s, maxWidth: o, lineHeight: a, getTextAnchor: c, getAlignmentBaseline: l } = this.props, f = i(e, t) || "", { x: u, y: h, rowWidth: d, size: [m, _] } = eu(f, a, s, o, n), E = L0[typeof c == "function" ? c(e, t) : c], b = C0[typeof l == "function" ? l(e, t) : l], T = u.length, v = new Array(T * 2), C = 0;
      for (let S = 0; S < T; S++) {
        let R = (1 - E) * (m - d[S]) / 2;
        v[C++] = (E - 1) * m / 2 + R + u[S], v[C++] = (b - 1) * _ / 2 + h[S];
      }
      return v;
    }
    renderLayers() {
      let { startIndices: e, numInstances: t, getText: n, fontAtlasManager: { scale: i, texture: s, mapping: o }, styleVersion: a } = this.state, { data: c, _dataDiff: l, getPosition: f, getColor: u, getSize: h, getAngle: d, getPixelOffset: m, getBackgroundColor: _, getBorderColor: E, getBorderWidth: b, backgroundPadding: T, background: v, billboard: C, fontSettings: S, outlineWidth: R, outlineColor: D, sizeScale: B, sizeUnits: N, sizeMinPixels: W, sizeMaxPixels: q, transitions: z, updateTriggers: V } = this.props, Y = this.getSubLayerClass("characters", ii), Se = this.getSubLayerClass("background", oi);
      return [v && new Se({ getFillColor: _, getLineColor: E, getLineWidth: b, padding: T, getPosition: f, getSize: h, getAngle: d, getPixelOffset: m, billboard: C, sizeScale: B / this.state.fontAtlasManager.props.fontSize, sizeUnits: N, sizeMinPixels: W, sizeMaxPixels: q, transitions: z && { getPosition: z.getPosition, getAngle: z.getAngle, getSize: z.getSize, getFillColor: z.getBackgroundColor, getLineColor: z.getBorderColor, getLineWidth: z.getBorderWidth, getPixelOffset: z.getPixelOffset } }, this.getSubLayerProps({ id: "background", updateTriggers: { getPosition: V.getPosition, getAngle: V.getAngle, getSize: V.getSize, getFillColor: V.getBackgroundColor, getLineColor: V.getBorderColor, getLineWidth: V.getBorderWidth, getPixelOffset: V.getPixelOffset, getBoundingRect: { getText: V.getText, getTextAnchor: V.getTextAnchor, getAlignmentBaseline: V.getAlignmentBaseline, styleVersion: a } } }), { data: c.attributes ? { length: c.length, attributes: c.attributes.background || {} } : c, _dataDiff: l, autoHighlight: false, getBoundingRect: this.getBoundingRect.bind(this) }), new Y({ sdf: S.sdf, smoothing: Number.isFinite(S.smoothing) ? S.smoothing : P0.smoothing, outlineWidth: R, outlineColor: D, iconAtlas: s, iconMapping: o, getPosition: f, getColor: u, getSize: h, getAngle: d, getPixelOffset: m, billboard: C, sizeScale: B * i, sizeUnits: N, sizeMinPixels: W * i, sizeMaxPixels: q * i, transitions: z && { getPosition: z.getPosition, getAngle: z.getAngle, getColor: z.getColor, getSize: z.getSize, getPixelOffset: z.getPixelOffset } }, this.getSubLayerProps({ id: "characters", updateTriggers: { getIcon: V.getText, getPosition: V.getPosition, getAngle: V.getAngle, getColor: V.getColor, getSize: V.getSize, getPixelOffset: V.getPixelOffset, getIconOffsets: { getText: V.getText, getTextAnchor: V.getTextAnchor, getAlignmentBaseline: V.getAlignmentBaseline, styleVersion: a } } }), { data: c, _dataDiff: l, startIndices: e, numInstances: t, getIconOffsets: this.getIconOffsets.bind(this), getIcon: n })];
    }
  };
  wt.layerName = "TextLayer";
  wt.defaultProps = ow;
  var Ls = { circle: { type: ei, props: { filled: "filled", stroked: "stroked", lineWidthMaxPixels: "lineWidthMaxPixels", lineWidthMinPixels: "lineWidthMinPixels", lineWidthScale: "lineWidthScale", lineWidthUnits: "lineWidthUnits", pointRadiusMaxPixels: "radiusMaxPixels", pointRadiusMinPixels: "radiusMinPixels", pointRadiusScale: "radiusScale", pointRadiusUnits: "radiusUnits", getFillColor: "getFillColor", getLineColor: "getLineColor", getLineWidth: "getLineWidth", getPointRadius: "getRadius" } }, icon: { type: Nr, props: { iconAtlas: "iconAtlas", iconMapping: "iconMapping", iconSizeMaxPixels: "sizeMaxPixels", iconSizeMinPixels: "sizeMinPixels", iconSizeScale: "sizeScale", iconSizeUnits: "sizeUnits", getIcon: "getIcon", getIconAngle: "getAngle", getIconColor: "getColor", getIconPixelOffset: "getPixelOffset", getIconSize: "getSize" } }, text: { type: wt, props: { textSizeMaxPixels: "sizeMaxPixels", textSizeMinPixels: "sizeMinPixels", textSizeScale: "sizeScale", textSizeUnits: "sizeUnits", textBackground: "background", textBackgroundPadding: "backgroundPadding", textFontFamily: "fontFamily", textFontWeight: "fontWeight", textLineHeight: "lineHeight", textMaxWidth: "maxWidth", textOutlineColor: "outlineColor", textOutlineWidth: "outlineWidth", textWordBreak: "wordBreak", textCharacterSet: "characterSet", getText: "getText", getTextAngle: "getAngle", getTextColor: "getColor", getTextPixelOffset: "getPixelOffset", getTextSize: "getSize", getTextAnchor: "getTextAnchor", getTextAlignmentBaseline: "getAlignmentBaseline", getTextBackgroundColor: "getBackgroundColor", getTextBorderColor: "getBorderColor", getTextBorderWidth: "getBorderWidth" } } };
  var Cs = { type: ti, props: { lineWidthUnits: "widthUnits", lineWidthScale: "widthScale", lineWidthMinPixels: "widthMinPixels", lineWidthMaxPixels: "widthMaxPixels", lineJointRounded: "jointRounded", lineCapRounded: "capRounded", lineMiterLimit: "miterLimit", getLineColor: "getColor", getLineWidth: "getWidth" } };
  var pc = { type: ni, props: { extruded: "extruded", filled: "filled", wireframe: "wireframe", elevationScale: "elevationScale", material: "material", getElevation: "getElevation", getFillColor: "getFillColor", getLineColor: "getLineColor" } };
  function ai({ type: r2, props: e }) {
    let t = {};
    for (let n in e)
      t[n] = r2.defaultProps[e[n]];
    return t;
  }
  function mc(r2, e) {
    let { transitions: t, updateTriggers: n } = r2.props, i = { updateTriggers: {}, transitions: t && { getPosition: t.geometry } };
    for (let s in e) {
      let o = e[s], a = r2.props[s];
      s.startsWith("get") && (a = r2.getSubLayerAccessor(a), i.updateTriggers[o] = n[s], t && (i.transitions[o] = t[s])), i[o] = a;
    }
    return i;
  }
  function R0(r2) {
    if (Array.isArray(r2))
      return r2;
    switch (F.assert(r2.type, "GeoJSON does not have type"), r2.type) {
      case "Feature":
        return [r2];
      case "FeatureCollection":
        return F.assert(Array.isArray(r2.features), "GeoJSON does not have features array"), r2.features;
      default:
        return [{ geometry: r2 }];
    }
  }
  function fu(r2, e, t = {}) {
    let n = { pointFeatures: [], lineFeatures: [], polygonFeatures: [], polygonOutlineFeatures: [] }, { startRow: i = 0, endRow: s = r2.length } = t;
    for (let o = i; o < s; o++) {
      let a = r2[o];
      F.assert(a && a.geometry, "GeoJSON does not have geometry");
      let { geometry: c } = a;
      if (c.type === "GeometryCollection") {
        F.assert(Array.isArray(c.geometries), "GeoJSON does not have geometries array");
        let { geometries: l } = c;
        for (let f = 0; f < l.length; f++) {
          let u = l[f];
          M0(u, n, e, a, o);
        }
      } else
        M0(c, n, e, a, o);
    }
    return n;
  }
  function M0(r2, e, t, n, i) {
    let { type: s, coordinates: o } = r2, { pointFeatures: a, lineFeatures: c, polygonFeatures: l, polygonOutlineFeatures: f } = e;
    if (!cw(s, o)) {
      F.warn("".concat(s, " coordinates are malformed"))();
      return;
    }
    switch (s) {
      case "Point":
        a.push(t({ geometry: r2 }, n, i));
        break;
      case "MultiPoint":
        o.forEach((u) => {
          a.push(t({ geometry: { type: "Point", coordinates: u } }, n, i));
        });
        break;
      case "LineString":
        c.push(t({ geometry: r2 }, n, i));
        break;
      case "MultiLineString":
        o.forEach((u) => {
          c.push(t({ geometry: { type: "LineString", coordinates: u } }, n, i));
        });
        break;
      case "Polygon":
        l.push(t({ geometry: r2 }, n, i)), o.forEach((u) => {
          f.push(t({ geometry: { type: "LineString", coordinates: u } }, n, i));
        });
        break;
      case "MultiPolygon":
        o.forEach((u) => {
          l.push(t({ geometry: { type: "Polygon", coordinates: u } }, n, i)), u.forEach((h) => {
            f.push(t({ geometry: { type: "LineString", coordinates: h } }, n, i));
          });
        });
        break;
      default:
    }
  }
  var aw = { Point: 1, MultiPoint: 2, LineString: 2, MultiLineString: 3, Polygon: 3, MultiPolygon: 4 };
  function cw(r2, e) {
    let t = aw[r2];
    for (F.assert(t, "Unknown GeoJSON type ".concat(r2)); e && --t > 0; )
      e = e[0];
    return e && Number.isFinite(e[0]);
  }
  function I0() {
    return { points: {}, lines: {}, polygons: {}, polygonsOutline: {} };
  }
  function gc(r2) {
    return r2.geometry.coordinates;
  }
  function O0(r2, e) {
    let t = I0(), { pointFeatures: n, lineFeatures: i, polygonFeatures: s, polygonOutlineFeatures: o } = r2;
    return t.points.data = n, t.points._dataDiff = e.pointFeatures && (() => e.pointFeatures), t.points.getPosition = gc, t.lines.data = i, t.lines._dataDiff = e.lineFeatures && (() => e.lineFeatures), t.lines.getPath = gc, t.polygons.data = s, t.polygons._dataDiff = e.polygonFeatures && (() => e.polygonFeatures), t.polygons.getPolygon = gc, t.polygonsOutline.data = o, t.polygonsOutline._dataDiff = e.polygonOutlineFeatures && (() => e.polygonOutlineFeatures), t.polygonsOutline.getPath = gc, t;
  }
  function N0(r2, e) {
    let t = I0(), { points: n, lines: i, polygons: s } = r2, o = f0(r2, e);
    return t.points.data = { length: n.positions.value.length / n.positions.size, attributes: { getPosition: n.positions, instancePickingColors: { size: 3, value: o.points } }, properties: n.properties, numericProps: n.numericProps, featureIds: n.featureIds }, t.lines.data = { length: i.pathIndices.value.length - 1, startIndices: i.pathIndices.value, attributes: { getPath: i.positions, instancePickingColors: { size: 3, value: o.lines } }, properties: i.properties, numericProps: i.numericProps, featureIds: i.featureIds }, t.lines._pathType = "open", t.polygons.data = { length: s.polygonIndices.value.length - 1, startIndices: s.polygonIndices.value, attributes: { getPolygon: s.positions, pickingColors: { size: 3, value: o.polygons } }, properties: s.properties, numericProps: s.numericProps, featureIds: s.featureIds }, t.polygons._normalize = false, s.triangles && (t.polygons.data.attributes.indices = s.triangles.value), t.polygonsOutline.data = { length: s.primitivePolygonIndices.value.length - 1, startIndices: s.primitivePolygonIndices.value, attributes: { getPath: s.positions, instancePickingColors: { size: 3, value: o.polygons } }, properties: s.properties, numericProps: s.numericProps, featureIds: s.featureIds }, t.polygonsOutline._pathType = "open", t;
  }
  var lw = L(x(x(x(x(x({}, ai(Ls.circle)), ai(Ls.icon)), ai(Ls.text)), ai(Cs)), ai(pc)), { stroked: true, filled: true, extruded: false, wireframe: false, iconAtlas: { type: "object", value: null }, iconMapping: { type: "object", value: {} }, getIcon: { type: "accessor", value: (r2) => r2.properties.icon }, getText: { type: "accessor", value: (r2) => r2.properties.text }, pointType: "circle", getRadius: { deprecatedFor: "getPointRadius" } });
  var cn = class extends zt {
    initializeState() {
      this.state = { layerProps: {}, features: {} }, this.props.getLineDashArray && F.removed("getLineDashArray", "PathStyleExtension")();
    }
    updateState({ props: e, changeFlags: t }) {
      if (!t.dataChanged)
        return;
      let { data: n } = this.props, i = n && "points" in n && "polygons" in n && "lines" in n;
      this.setState({ binary: i }), i ? this._updateStateBinary({ props: e, changeFlags: t }) : this._updateStateJSON({ props: e, changeFlags: t });
    }
    _updateStateBinary({ props: e, changeFlags: t }) {
      let n = N0(e.data, this.encodePickingColor);
      this.setState({ layerProps: n });
    }
    _updateStateJSON({ props: e, changeFlags: t }) {
      let n = R0(e.data), i = this.getSubLayerRow.bind(this), s = {}, o = {};
      if (Array.isArray(t.dataChanged)) {
        let c = this.state.features;
        for (let l in c)
          s[l] = c[l].slice(), o[l] = [];
        for (let l of t.dataChanged) {
          let f = fu(n, i, l);
          for (let u in c)
            o[u].push(c0({ data: s[u], getIndex: (h) => h.__source.index, dataRange: l, replace: f[u] }));
        }
      } else
        s = fu(n, i);
      let a = O0(s, o);
      this.setState({ features: s, featuresDiff: o, layerProps: a });
    }
    _updateAutoHighlight(e) {
      let t = "".concat(this.id, "-points-"), n = e.sourceLayer.id.startsWith(t);
      for (let i of this.getSubLayers())
        i.id.startsWith(t) === n && i.updateAutoHighlight(e);
    }
    _renderPolygonLayer() {
      let { extruded: e, wireframe: t } = this.props, { layerProps: n } = this.state, i = "polygons-fill", s = this.shouldRenderSubLayer(i, n.polygons.data) && this.getSubLayerClass(i, pc.type);
      if (s) {
        let o = mc(this, pc.props), a = e && t;
        return a || delete o.getLineColor, o.updateTriggers.lineColors = a, new s(o, this.getSubLayerProps({ id: i, updateTriggers: o.updateTriggers }), n.polygons);
      }
      return null;
    }
    _renderLineLayers() {
      let { extruded: e, stroked: t } = this.props, { layerProps: n } = this.state, i = "polygons-stroke", s = "linestrings", o = !e && t && this.shouldRenderSubLayer(i, n.polygonsOutline.data) && this.getSubLayerClass(i, Cs.type), a = this.shouldRenderSubLayer(s, n.lines.data) && this.getSubLayerClass(s, Cs.type);
      if (o || a) {
        let c = mc(this, Cs.props);
        return [o && new o(c, this.getSubLayerProps({ id: i, updateTriggers: c.updateTriggers }), n.polygonsOutline), a && new a(c, this.getSubLayerProps({ id: s, updateTriggers: c.updateTriggers }), n.lines)];
      }
      return null;
    }
    _renderPointLayers() {
      let { pointType: e } = this.props, { layerProps: t, binary: n } = this.state, { highlightedObjectIndex: i } = this.props;
      !n && Number.isFinite(i) && (i = t.points.data.findIndex((a) => a.__source.index === i));
      let s = new Set(e.split("+")), o = [];
      for (let a of s) {
        let c = "points-".concat(a), l = Ls[a], f = l && this.shouldRenderSubLayer(c, t.points.data) && this.getSubLayerClass(c, l.type);
        if (f) {
          let u = mc(this, l.props);
          o.push(new f(u, this.getSubLayerProps({ id: c, updateTriggers: u.updateTriggers, highlightedObjectIndex: i }), t.points));
        }
      }
      return o;
    }
    renderLayers() {
      let { extruded: e } = this.props, t = this._renderPolygonLayer(), n = this._renderLineLayers(), i = this._renderPointLayers();
      return [!e && t, n, i, e && t];
    }
    getSubLayerAccessor(e) {
      let { binary: t } = this.state;
      return !t || typeof e != "function" ? super.getSubLayerAccessor(e) : (n, i) => {
        let { data: s, index: o } = i, a = l0(s, o);
        return e(a, i);
      };
    }
  };
  cn.layerName = "GeoJsonLayer";
  cn.defaultProps = lw;
  var _c = class {
    constructor({ x: e, y: t, z: n, onTileLoad: i, onTileError: s }) {
      this.x = e, this.y = t, this.z = n, this.isVisible = false, this.isSelected = false, this.parent = null, this.children = [], this.content = null, this._isLoaded = false, this._isCancelled = false, this.onTileLoad = i, this.onTileError = s;
    }
    get data() {
      return this._isLoaded ? this.content : this._loader;
    }
    get isLoaded() {
      return this._isLoaded;
    }
    get isLoading() {
      return Boolean(this._loader);
    }
    get isCancelled() {
      return this._isCancelled;
    }
    get byteLength() {
      let e = this.content ? this.content.byteLength : 0;
      return Number.isFinite(e) || F.error("byteLength not defined in tile data")(), e;
    }
    async _loadData(e, t) {
      let { x: n, y: i, z: s, bbox: o } = this;
      this._abortController = new AbortController();
      let { signal: a } = this._abortController, c = await t.scheduleRequest(this, (u) => u.isSelected ? 1 : -1);
      if (!c) {
        this._isCancelled = true;
        return;
      }
      if (this._isCancelled) {
        c.done();
        return;
      }
      let l, f;
      try {
        l = await e({ x: n, y: i, z: s, bbox: o, signal: a });
      } catch (u) {
        f = u || true;
      } finally {
        c.done(), this._isCancelled && !l ? this._isLoaded = false : (this._isLoaded = true, this._isCancelled = false);
      }
      !this._isLoaded || (f ? this.onTileError(f, this) : (this.content = l, this.onTileLoad(this)));
    }
    loadData(e, t) {
      !e || (this._isCancelled = false, this._loader = this._loadData(e, t), this._loader.finally(() => {
        this._loader = void 0;
      }));
    }
    abort() {
      this.isLoaded || (this._isCancelled = true, this._abortController.abort());
    }
  };
  var ge = Object.freeze({ OUTSIDE: -1, INTERSECTING: 0, INSIDE: 1 });
  var F0 = new M();
  var fw = new M();
  var Ur = class {
    constructor(e = [0, 0, 0], t = [0, 0, 0], n = null) {
      n = n || F0.copy(e).add(t).scale(0.5), this.center = new M(n), this.halfDiagonal = new M(t).subtract(this.center), this.minimum = new M(e), this.maximum = new M(t);
    }
    clone() {
      return new Ur(this.minimum, this.maximum, this.center);
    }
    equals(e) {
      return this === e || Boolean(e) && this.minimum.equals(e.minimum) && this.maximum.equals(e.maximum);
    }
    transform(e) {
      return this.center.transformAsPoint(e), this.halfDiagonal.transform(e), this.minimum.transform(e), this.maximum.transform(e), this;
    }
    intersectPlane(e) {
      let { halfDiagonal: t } = this, n = fw.from(e.normal), i = t.x * Math.abs(n.x) + t.y * Math.abs(n.y) + t.z * Math.abs(n.z), s = this.center.dot(n) + e.distance;
      return s - i > 0 ? ge.INSIDE : s + i < 0 ? ge.OUTSIDE : ge.INTERSECTING;
    }
    distanceTo(e) {
      return Math.sqrt(this.distanceSquaredTo(e));
    }
    distanceSquaredTo(e) {
      let t = F0.from(e).subtract(this.center), { halfDiagonal: n } = this, i = 0, s;
      return s = Math.abs(t.x) - n.x, s > 0 && (i += s * s), s = Math.abs(t.y) - n.y, s > 0 && (i += s * s), s = Math.abs(t.z) - n.z, s > 0 && (i += s * s), i;
    }
  };
  var Rs = new M();
  var D0 = new M();
  var or = class {
    constructor(e = [0, 0, 0], t = 0) {
      this.radius = -0, this.center = new M(), this.fromCenterRadius(e, t);
    }
    fromCenterRadius(e, t) {
      return this.center.from(e), this.radius = t, this;
    }
    fromCornerPoints(e, t) {
      return t = Rs.from(t), this.center = new M().from(e).add(t).scale(0.5), this.radius = this.center.distance(t), this;
    }
    equals(e) {
      return this === e || Boolean(e) && this.center.equals(e.center) && this.radius === e.radius;
    }
    clone() {
      return new or(this.center, this.radius);
    }
    union(e) {
      let t = this.center, n = this.radius, i = e.center, s = e.radius, o = Rs.copy(i).subtract(t), a = o.magnitude();
      if (n >= a + s)
        return this.clone();
      if (s >= a + n)
        return e.clone();
      let c = (n + a + s) * 0.5;
      return D0.copy(o).scale((-n + c) / a).add(t), this.center.copy(D0), this.radius = c, this;
    }
    expand(e) {
      e = Rs.from(e);
      let t = e.subtract(this.center).magnitude();
      return t > this.radius && (this.radius = t), this;
    }
    transform(e) {
      this.center.transform(e);
      let t = Wp(Rs, e);
      return this.radius = Math.max(t[0], Math.max(t[1], t[2])) * this.radius, this;
    }
    distanceSquaredTo(e) {
      return e = Rs.from(e), e.subtract(this.center).lengthSquared() - this.radius * this.radius;
    }
    distanceTo(e) {
      return Math.sqrt(this.distanceSquaredTo(e));
    }
    intersectPlane(e) {
      let t = this.center, n = this.radius, s = e.normal.dot(t) + e.distance;
      return s < -n ? ge.OUTSIDE : s < n ? ge.INTERSECTING : ge.INSIDE;
    }
  };
  var nW = new M();
  var iW = new M();
  var sW = new M();
  var oW = new M();
  var aW = new M();
  var cW = new M();
  var lW = new M();
  var B0 = new M();
  var U0 = new M();
  var $e = class {
    constructor(e = [0, 0, 1], t = 0) {
      this.normal = new M(), this.distance = -0, this.fromNormalDistance(e, t);
    }
    fromNormalDistance(e, t) {
      return ue(Number.isFinite(t)), this.normal.from(e).normalize(), this.distance = t, this;
    }
    fromPointNormal(e, t) {
      e = B0.from(e), this.normal.from(t).normalize();
      let n = -this.normal.dot(e);
      return this.distance = n, this;
    }
    fromCoefficients(e, t, n, i) {
      return this.normal.set(e, t, n), ue(Ke(this.normal.len(), 1)), this.distance = i, this;
    }
    clone(e) {
      return new $e(this.normal, this.distance);
    }
    equals(e) {
      return Ke(this.distance, e.distance) && Ke(this.normal, e.normal);
    }
    getPointDistance(e) {
      return this.normal.dot(e) + this.distance;
    }
    transform(e) {
      let t = U0.copy(this.normal).transformAsVector(e).normalize(), n = this.normal.scale(-this.distance).transform(e);
      return this.fromPointNormal(n, t);
    }
    projectPointOntoPlane(e, t = [0, 0, 0]) {
      e = B0.from(e);
      let n = this.getPointDistance(e), i = U0.copy(this.normal).scale(n);
      return e.subtract(i).to(t);
    }
  };
  var k0 = [new M([1, 0, 0]), new M([0, 1, 0]), new M([0, 0, 1])];
  var V0 = new M();
  var uw = new M();
  var _W = new $e(new M(1, 0, 0), 0);
  var Pt = class {
    static get MASK_OUTSIDE() {
      return 4294967295;
    }
    static get MASK_INSIDE() {
      return 0;
    }
    static get MASK_INDETERMINATE() {
      return 2147483647;
    }
    constructor(e = []) {
      this.planes = e, ue(this.planes.every((t) => t instanceof $e));
    }
    fromBoundingSphere(e) {
      this.planes.length = 2 * k0.length;
      let t = e.center, n = e.radius, i = 0;
      for (let s of k0) {
        let o = this.planes[i], a = this.planes[i + 1];
        o || (o = this.planes[i] = new $e()), a || (a = this.planes[i + 1] = new $e());
        let c = V0.copy(s).scale(-n).add(t), l = -s.dot(c);
        o.fromPointNormal(c, s);
        let f = V0.copy(s).scale(n).add(t), u = uw.copy(s).negate(), h = -u.dot(f);
        a.fromPointNormal(f, u), i += 2;
      }
      return this;
    }
    computeVisibility(e) {
      ue(e);
      let t = ge.INSIDE;
      for (let n of this.planes)
        switch (e.intersectPlane(n)) {
          case ge.OUTSIDE:
            return ge.OUTSIDE;
          case ge.INTERSECTING:
            t = ge.INTERSECTING;
            break;
          default:
        }
      return t;
    }
    computeVisibilityWithPlaneMask(e, t) {
      if (ue(e, "boundingVolume is required."), ue(Number.isFinite(t), "parentPlaneMask is required."), t === Pt.MASK_OUTSIDE || t === Pt.MASK_INSIDE)
        return t;
      let n = Pt.MASK_INSIDE, i = this.planes;
      for (let s = 0; s < this.planes.length; ++s) {
        let o = s < 31 ? 1 << s : 0;
        if (s < 31 && (t & o) == 0)
          continue;
        let a = i[s], c = e.intersectPlane(a);
        if (c === ge.OUTSIDE)
          return Pt.MASK_OUTSIDE;
        c === ge.INTERSECTING && (n |= o);
      }
      return n;
    }
  };
  var TW = new M();
  var vW = new M();
  var AW = new M();
  var SW = new M();
  var wW = new M();
  var IW = new M();
  var OW = new M();
  var NW = new M();
  var FW = new M();
  var DW = new M();
  var BW = new M();
  var UW = new M();
  var kW = new M();
  var VW = new M();
  var GW = new M();
  var zW = new M();
  var jW = new M();
  var WW = 4 / 3 * Math.PI;
  var qW = new Ae();
  var ZW = new Ae();
  var KW = new Ae();
  var QW = new Ae();
  var JW = new Ae();
  var i7 = new M();
  var s7 = new M();
  var o7 = new M();
  var a7 = new M();
  var c7 = new M();
  var l7 = new Ae();
  var f7 = { diagonal: new Ae(), unitary: new Ae() };
  var uu = 512;
  var G0 = 3;
  var ln = class {
    constructor(e, t, n) {
      this.x = e, this.y = t, this.z = n;
    }
    get children() {
      if (!this._children) {
        let e = this.x * 2, t = this.y * 2, n = this.z + 1;
        this._children = [new ln(e, t, n), new ln(e, t + 1, n), new ln(e + 1, t, n), new ln(e + 1, t + 1, n)];
      }
      return this._children;
    }
    update(e) {
      let { viewport: t, cullingVolume: n, elevationBounds: i, minZ: s, maxZ: o, offset: a, project: c } = e, l = this.getBoundingVolume(i, a, c);
      if (n.computeVisibility(l) < 0)
        return false;
      if (!this.childVisible) {
        let { z: u } = this;
        if (u < o && u >= s) {
          let h = l.distanceTo(t.cameraPosition) * t.scale / t.height;
          u += Math.floor(Math.log2(h));
        }
        if (u >= o)
          return this.selected = true, true;
      }
      this.selected = false, this.childVisible = true;
      for (let u of this.children)
        u.update(e);
      return true;
    }
    getSelected(e = []) {
      if (this.selected && e.push(this), this._children)
        for (let t of this._children)
          t.getSelected(e);
      return e;
    }
    getBoundingVolume(e, t, n) {
      if (n) {
        let c = ci(this.x, this.y, this.z), l = ci(this.x + 1, this.y + 1, this.z), f = ci(this.x + 0.5, this.y + 0.5, this.z);
        c.z = e[1], l.z = e[1], f.z = e[0];
        let u = n(c), h = n(l), d = new M(n(f)), m = Math.max(d.distance(u), d.distance(h));
        return new or(d, m);
      }
      let i = Math.pow(2, this.z), s = uu / i, o = this.x * s + t * uu, a = uu - (this.y + 1) * s;
      return new Ur([o, a, e[0]], [o + s, a + s, e[1]]);
    }
  };
  function z0(r2, e, t) {
    let n = r2.resolution ? r2.projectPosition : null, i = Object.values(r2.getFrustumPlanes()).map(({ normal: h, distance: d }) => new $e(h.clone().negate(), d)), s = new Pt(i), o = r2.distanceScales.unitsPerMeter[2], a = t && t[0] * o || 0, c = t && t[1] * o || 0, l = r2.pitch <= 60 ? e : 0, f = new ln(0, 0, 0), u = { viewport: r2, project: n, cullingVolume: s, elevationBounds: [a, c], minZ: l, maxZ: e, offset: 0 };
    if (f.update(u), r2.subViewports && r2.subViewports.length > 1) {
      for (u.offset = -1; f.update(u) && !(--u.offset < -G0); )
        ;
      for (u.offset = 1; f.update(u) && !(++u.offset > G0); )
        ;
    }
    return f.getSelected();
  }
  var ar = 512;
  var j0 = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
  var W0 = { type: "url", value: null, validate: (r2, e) => e.optional && r2 === null || typeof r2 == "string" || Array.isArray(r2) && r2.every((t) => typeof t == "string"), equals: (r2, e) => {
    if (r2 === e)
      return true;
    if (!Array.isArray(r2) || !Array.isArray(e))
      return false;
    let t = r2.length;
    if (t !== e.length)
      return false;
    for (let n = 0; n < t; n++)
      if (r2[n] !== e[n])
        return false;
    return true;
  } };
  function H0(r2, e) {
    let t = [e.transformPoint([r2[0], r2[1]]), e.transformPoint([r2[2], r2[1]]), e.transformPoint([r2[0], r2[3]]), e.transformPoint([r2[2], r2[3]])];
    return [Math.min(...t.map((i) => i[0])), Math.min(...t.map((i) => i[1])), Math.max(...t.map((i) => i[0])), Math.max(...t.map((i) => i[1]))];
  }
  function X0(r2, e) {
    if (!r2 || !r2.length)
      return null;
    if (Array.isArray(r2)) {
      let s = Math.abs(e.x + e.y) % r2.length;
      r2 = r2[s];
    }
    let { x: t, y: n, z: i } = e;
    return r2.replace("{x}", t).replace("{y}", n).replace("{z}", i).replace("{-y}", Math.pow(2, i) - n - 1);
  }
  function mw(r2, e, t) {
    let n;
    if (e && e.length === 2) {
      let [i, s] = e, o = r2.getBounds({ z: i }), a = r2.getBounds({ z: s });
      n = [Math.min(o[0], a[0]), Math.min(o[1], a[1]), Math.max(o[2], a[2]), Math.max(o[3], a[3])];
    } else
      n = r2.getBounds();
    return r2.isGeospatial ? [Math.max(n[0], t[0]), Math.max(n[1], t[1]), Math.min(n[2], t[2]), Math.min(n[3], t[3])] : [Math.max(Math.min(n[0], t[2]), t[0]), Math.max(Math.min(n[1], t[3]), t[1]), Math.min(Math.max(n[2], t[0]), t[2]), Math.min(Math.max(n[3], t[1]), t[3])];
  }
  function gw(r2, e, t) {
    return t ? H0(r2, t).map((i) => i * e / ar) : r2.map((n) => n * e / ar);
  }
  function hu(r2, e) {
    return Math.pow(2, r2) * ar / e;
  }
  function ci(r2, e, t) {
    let n = hu(t, ar), i = r2 / n * 360 - 180, s = Math.PI - 2 * Math.PI * e / n, o = 180 / Math.PI * Math.atan(0.5 * (Math.exp(s) - Math.exp(-s)));
    return [i, o];
  }
  function Y0(r2, e, t, n) {
    let i = hu(t, n);
    return [r2 / i * ar, e / i * ar];
  }
  function q0(r2, e, t, n, i = ar) {
    if (r2.isGeospatial) {
      let [l, f] = ci(e, t, n), [u, h] = ci(e + 1, t + 1, n);
      return { west: l, north: f, east: u, south: h };
    }
    let [s, o] = Y0(e, t, n, i), [a, c] = Y0(e + 1, t + 1, n, i);
    return { left: s, top: o, right: a, bottom: c };
  }
  function _w(r2, e, t, n, i) {
    let s = mw(r2, null, n), o = hu(e, t), [a, c, l, f] = gw(s, o, i), u = [];
    for (let h = Math.floor(a); h < l; h++)
      for (let d = Math.floor(c); d < f; d++)
        u.push({ x: h, y: d, z: e });
    return u;
  }
  function Z0({ viewport: r2, maxZoom: e, minZoom: t, zRange: n, extent: i, tileSize: s = ar, modelMatrix: o, modelMatrixInverse: a, zoomOffset: c = 0 }) {
    let l = r2.isGeospatial ? Math.round(r2.zoom + Math.log2(ar / s)) + c : Math.ceil(r2.zoom) + c;
    if (Number.isFinite(t) && l < t) {
      if (!i)
        return [];
      l = t;
    }
    Number.isFinite(e) && l > e && (l = e);
    let f = i;
    return o && a && i && !r2.isGeospatial && (f = H0(i, o)), r2.isGeospatial ? z0(r2, l, n, i || j0) : _w(r2, l, s, f || j0, a);
  }
  var xw = 0;
  var K0 = 1;
  var Q0 = 3;
  var yw = 4;
  var J0 = 5;
  var Ew = "never";
  var xc = "best-available";
  var bw = 5;
  var yc = class {
    constructor(e) {
      this.opts = e, this._getTileData = e.getTileData, this.onTileError = e.onTileError, this.onTileLoad = (t) => {
        e.onTileLoad(t), this.opts.maxCacheByteSize && (this._cacheByteSize += t.byteLength, this._resizeCache());
      }, this.onTileUnload = e.onTileUnload, this._requestScheduler = new Ei({ maxRequests: e.maxRequests, throttleRequests: e.maxRequests > 0 }), this._cache = new Map(), this._tiles = [], this._dirty = false, this._cacheByteSize = 0, this._viewport = null, this._selectedTiles = null, this._frameNumber = 0, this.setOptions(e);
    }
    get tiles() {
      return this._tiles;
    }
    get selectedTiles() {
      return this._selectedTiles;
    }
    get isLoaded() {
      return this._selectedTiles.every((e) => e.isLoaded);
    }
    setOptions(e) {
      Object.assign(this.opts, e), Number.isFinite(e.maxZoom) && (this._maxZoom = Math.floor(e.maxZoom)), Number.isFinite(e.minZoom) && (this._minZoom = Math.ceil(e.minZoom));
    }
    finalize() {
      for (let e of this._cache.values())
        e.isLoading && e.abort();
    }
    update(e, { zRange: t, modelMatrix: n } = {}) {
      let i = new ce(n), s = !i.equals(this._modelMatrix);
      if (!e.equals(this._viewport) || s) {
        s && (this._modelMatrixInverse = n && i.clone().invert(), this._modelMatrix = n && i), this._viewport = e;
        let a = this.getTileIndices({ viewport: e, maxZoom: this._maxZoom, minZoom: this._minZoom, zRange: t, modelMatrix: this._modelMatrix, modelMatrixInverse: this._modelMatrixInverse });
        this._selectedTiles = a.map((c) => this._getTile(c, true)), this._dirty && this._rebuildTree();
      }
      let o = this.updateTileStates();
      return this._dirty && this._resizeCache(), o && this._frameNumber++, this._frameNumber;
    }
    getTileIndices({ viewport: e, maxZoom: t, minZoom: n, zRange: i, modelMatrix: s, modelMatrixInverse: o }) {
      let { tileSize: a, extent: c, zoomOffset: l } = this.opts;
      return Z0({ viewport: e, maxZoom: t, minZoom: n, zRange: i, tileSize: a, extent: c, modelMatrix: s, modelMatrixInverse: o, zoomOffset: l });
    }
    getTileMetadata({ x: e, y: t, z: n }) {
      let { tileSize: i } = this.opts;
      return { bbox: q0(this._viewport, e, t, n, i) };
    }
    getParentIndex(e) {
      return e.x = Math.floor(e.x / 2), e.y = Math.floor(e.y / 2), e.z -= 1, e;
    }
    updateTileStates() {
      this._updateTileStates(this.selectedTiles);
      let { maxRequests: e } = this.opts, t = [], n = 0, i = false;
      for (let s of this._cache.values()) {
        let o = Boolean(s.state & K0);
        s.isVisible !== o && (i = true, s.isVisible = o), s.isSelected = s.state === J0, s.isLoading && (n++, s.isSelected || t.push(s));
      }
      if (e > 0)
        for (; n > e && t.length > 0; )
          t.shift().abort(), n--;
      return i;
    }
    _rebuildTree() {
      let { _cache: e } = this;
      for (let t of e.values())
        t.parent = null, t.children.length = 0;
      for (let t of e.values()) {
        let n = this._getNearestAncestor(t.x, t.y, t.z);
        t.parent = n, n && n.children.push(t);
      }
    }
    _updateTileStates(e) {
      let { _cache: t } = this, n = this.opts.refinementStrategy || xc;
      for (let i of t.values())
        i.state = xw;
      for (let i of e)
        i.state = J0;
      if (n !== Ew) {
        for (let i of e)
          vw(i, n);
        for (let i of e)
          Tw(i) && $0(i);
      }
    }
    _resizeCache() {
      let { _cache: e, opts: t } = this, n = t.maxCacheSize || (t.maxCacheByteSize ? 1 / 0 : bw * this.selectedTiles.length), i = t.maxCacheByteSize || 1 / 0;
      if (e.size > n || this._cacheByteSize > i) {
        for (let [o, a] of e)
          if (a.isVisible || (this._cacheByteSize -= t.maxCacheByteSize ? a.byteLength : 0, e.delete(o), this.onTileUnload(a)), e.size <= n && this._cacheByteSize <= i)
            break;
        this._rebuildTree(), this._dirty = true;
      }
      this._dirty && (this._tiles = Array.from(this._cache.values()).sort((o, a) => o.z - a.z), this._dirty = false);
    }
    _getTile({ x: e, y: t, z: n }, i) {
      let s = "".concat(e, ",").concat(t, ",").concat(n), o = this._cache.get(s);
      return !o && i ? (o = new _c({ x: e, y: t, z: n, onTileLoad: this.onTileLoad, onTileError: this.onTileError }), Object.assign(o, this.getTileMetadata(o)), o.loadData(this._getTileData, this._requestScheduler), this._cache.set(s, o), this._dirty = true) : o && o.isCancelled && !o.isLoading && o.loadData(this._getTileData, this._requestScheduler), o;
    }
    _getNearestAncestor(e, t, n) {
      let { _minZoom: i = 0 } = this, s = { x: e, y: t, z: n };
      for (; s.z > i; ) {
        s = this.getParentIndex(s);
        let o = this._getTile(s);
        if (o)
          return o;
      }
      return null;
    }
  };
  function Tw(r2) {
    let e = r2;
    for (; e; ) {
      if (e.state & K0 === 0)
        return true;
      if (e.isLoaded)
        return false;
      e = e.parent;
    }
    return true;
  }
  function vw(r2, e) {
    let t, n = Q0;
    for (; t = r2.parent; ) {
      if (r2.isLoaded && (n = yw, e === xc))
        return;
      t.state = Math.max(t.state, n), r2 = t;
    }
  }
  function $0(r2) {
    for (let e of r2.children)
      e.state = Math.max(e.state, Q0), e.isLoaded || $0(e);
  }
  var Aw = { data: [], dataComparator: W0.equals, renderSubLayers: { type: "function", value: (r2) => new cn(r2), compare: false }, getTileData: { type: "function", optional: true, value: null, compare: false }, onViewportLoad: { type: "function", optional: true, value: null, compare: false }, onTileLoad: { type: "function", value: (r2) => {
  }, compare: false }, onTileUnload: { type: "function", value: (r2) => {
  }, compare: false }, onTileError: { type: "function", value: (r2) => console.error(r2), compare: false }, extent: { type: "array", optional: true, value: null, compare: true }, tileSize: 512, maxZoom: null, minZoom: 0, maxCacheSize: null, maxCacheByteSize: null, refinementStrategy: xc, zRange: null, maxRequests: 6, zoomOffset: 0 };
  var fn = class extends zt {
    initializeState() {
      this.state = { tileset: null, isLoaded: false };
    }
    finalizeState() {
      var e;
      (e = this.state.tileset) === null || e === void 0 || e.finalize();
    }
    get isLoaded() {
      let { tileset: e } = this.state;
      return e.selectedTiles.every((t) => t.layers && t.layers.every((n) => n.isLoaded));
    }
    shouldUpdateState({ changeFlags: e }) {
      return e.somethingChanged;
    }
    updateState({ props: e, changeFlags: t }) {
      let { tileset: n } = this.state;
      !n || t.dataChanged || t.updateTriggersChanged && (t.updateTriggersChanged.all || t.updateTriggersChanged.getTileData) ? (n && n.finalize(), n = new yc(L(x({}, this._getTilesetOptions(e)), { getTileData: this.getTileData.bind(this), onTileLoad: this._onTileLoad.bind(this), onTileError: this._onTileError.bind(this), onTileUnload: this._onTileUnload.bind(this) })), this.setState({ tileset: n })) : (t.propsChanged || t.updateTriggersChanged) && (n.setOptions(this._getTilesetOptions(e)), this.state.tileset.tiles.forEach((s) => {
        s.layers = null;
      })), this._updateTileset();
    }
    _getTilesetOptions(e) {
      let { tileSize: t, maxCacheSize: n, maxCacheByteSize: i, refinementStrategy: s, extent: o, maxZoom: a, minZoom: c, maxRequests: l, zoomOffset: f } = e;
      return { maxCacheSize: n, maxCacheByteSize: i, maxZoom: a, minZoom: c, tileSize: t, refinementStrategy: s, extent: o, maxRequests: l, zoomOffset: f };
    }
    _updateTileset() {
      let { tileset: e } = this.state, { zRange: t, modelMatrix: n } = this.props, i = e.update(this.context.viewport, { zRange: t, modelMatrix: n }), { isLoaded: s } = e, o = this.state.isLoaded !== s, a = this.state.frameNumber !== i;
      s && (o || a) && this._onViewportLoad(), a && this.setState({ frameNumber: i }), this.state.isLoaded = s;
    }
    _onViewportLoad() {
      let { tileset: e } = this.state, { onViewportLoad: t } = this.props;
      t && t(e.selectedTiles);
    }
    _onTileLoad(e) {
      this.getCurrentLayer().props.onTileLoad(e), e.isVisible && this.setNeedsUpdate();
    }
    _onTileError(e, t) {
      let n = this.getCurrentLayer();
      n.props.onTileError(e), n._updateTileset(), t.isVisible && this.setNeedsUpdate();
    }
    _onTileUnload(e) {
      this.getCurrentLayer().props.onTileUnload(e);
    }
    getTileData(e) {
      let { data: t } = this.props, { getTileData: n, fetch: i } = this.getCurrentLayer().props, { signal: s } = e;
      return e.url = X0(t, e), n ? n(e) : e.url ? i(e.url, { propName: "data", layer: this, signal: s }) : null;
    }
    renderSubLayers(e) {
      return this.props.renderSubLayers(e);
    }
    getHighlightedObjectIndex() {
      return -1;
    }
    getPickingInfo({ info: e, sourceLayer: t }) {
      return e.tile = t.props.tile, e;
    }
    _updateAutoHighlight(e) {
      e.sourceLayer && e.sourceLayer.updateAutoHighlight(e);
    }
    renderLayers() {
      let { visible: e } = this.props;
      return this.state.tileset.tiles.map((t) => {
        let n = this.getHighlightedObjectIndex(t);
        if (t.isLoaded)
          if (t.layers)
            t.layers[0] && t.layers[0].props.highlightedObjectIndex !== n && (t.layers = t.layers.map((i) => i.clone({ highlightedObjectIndex: n })));
          else {
            let i = this.renderSubLayers(L(x({}, this.props), { id: "".concat(this.id, "-").concat(t.x, "-").concat(t.y, "-").concat(t.z), data: t.data, visible: e, _offset: 0, tile: t }));
            t.layers = nr(i, Boolean).map((s) => s.clone({ tile: t, highlightedObjectIndex: n }));
          }
        return t.layers;
      });
    }
    filterSubLayer({ layer: e }) {
      return e.props.tile.isVisible;
    }
  };
  fn.layerName = "TileLayer";
  fn.defaultProps = Aw;
  var de = { DEPTH_BUFFER_BIT: 256, STENCIL_BUFFER_BIT: 1024, COLOR_BUFFER_BIT: 16384, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, ZERO: 0, ONE: 1, SRC_COLOR: 768, ONE_MINUS_SRC_COLOR: 769, SRC_ALPHA: 770, ONE_MINUS_SRC_ALPHA: 771, DST_ALPHA: 772, ONE_MINUS_DST_ALPHA: 773, DST_COLOR: 774, ONE_MINUS_DST_COLOR: 775, SRC_ALPHA_SATURATE: 776, CONSTANT_COLOR: 32769, ONE_MINUS_CONSTANT_COLOR: 32770, CONSTANT_ALPHA: 32771, ONE_MINUS_CONSTANT_ALPHA: 32772, FUNC_ADD: 32774, FUNC_SUBTRACT: 32778, FUNC_REVERSE_SUBTRACT: 32779, BLEND_EQUATION: 32777, BLEND_EQUATION_RGB: 32777, BLEND_EQUATION_ALPHA: 34877, BLEND_DST_RGB: 32968, BLEND_SRC_RGB: 32969, BLEND_DST_ALPHA: 32970, BLEND_SRC_ALPHA: 32971, BLEND_COLOR: 32773, ARRAY_BUFFER_BINDING: 34964, ELEMENT_ARRAY_BUFFER_BINDING: 34965, LINE_WIDTH: 2849, ALIASED_POINT_SIZE_RANGE: 33901, ALIASED_LINE_WIDTH_RANGE: 33902, CULL_FACE_MODE: 2885, FRONT_FACE: 2886, DEPTH_RANGE: 2928, DEPTH_WRITEMASK: 2930, DEPTH_CLEAR_VALUE: 2931, DEPTH_FUNC: 2932, STENCIL_CLEAR_VALUE: 2961, STENCIL_FUNC: 2962, STENCIL_FAIL: 2964, STENCIL_PASS_DEPTH_FAIL: 2965, STENCIL_PASS_DEPTH_PASS: 2966, STENCIL_REF: 2967, STENCIL_VALUE_MASK: 2963, STENCIL_WRITEMASK: 2968, STENCIL_BACK_FUNC: 34816, STENCIL_BACK_FAIL: 34817, STENCIL_BACK_PASS_DEPTH_FAIL: 34818, STENCIL_BACK_PASS_DEPTH_PASS: 34819, STENCIL_BACK_REF: 36003, STENCIL_BACK_VALUE_MASK: 36004, STENCIL_BACK_WRITEMASK: 36005, VIEWPORT: 2978, SCISSOR_BOX: 3088, COLOR_CLEAR_VALUE: 3106, COLOR_WRITEMASK: 3107, UNPACK_ALIGNMENT: 3317, PACK_ALIGNMENT: 3333, MAX_TEXTURE_SIZE: 3379, MAX_VIEWPORT_DIMS: 3386, SUBPIXEL_BITS: 3408, RED_BITS: 3410, GREEN_BITS: 3411, BLUE_BITS: 3412, ALPHA_BITS: 3413, DEPTH_BITS: 3414, STENCIL_BITS: 3415, POLYGON_OFFSET_UNITS: 10752, POLYGON_OFFSET_FACTOR: 32824, TEXTURE_BINDING_2D: 32873, SAMPLE_BUFFERS: 32936, SAMPLES: 32937, SAMPLE_COVERAGE_VALUE: 32938, SAMPLE_COVERAGE_INVERT: 32939, COMPRESSED_TEXTURE_FORMATS: 34467, VENDOR: 7936, RENDERER: 7937, VERSION: 7938, IMPLEMENTATION_COLOR_READ_TYPE: 35738, IMPLEMENTATION_COLOR_READ_FORMAT: 35739, BROWSER_DEFAULT_WEBGL: 37444, STATIC_DRAW: 35044, STREAM_DRAW: 35040, DYNAMIC_DRAW: 35048, ARRAY_BUFFER: 34962, ELEMENT_ARRAY_BUFFER: 34963, BUFFER_SIZE: 34660, BUFFER_USAGE: 34661, CURRENT_VERTEX_ATTRIB: 34342, VERTEX_ATTRIB_ARRAY_ENABLED: 34338, VERTEX_ATTRIB_ARRAY_SIZE: 34339, VERTEX_ATTRIB_ARRAY_STRIDE: 34340, VERTEX_ATTRIB_ARRAY_TYPE: 34341, VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922, VERTEX_ATTRIB_ARRAY_POINTER: 34373, VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975, CULL_FACE: 2884, FRONT: 1028, BACK: 1029, FRONT_AND_BACK: 1032, BLEND: 3042, DEPTH_TEST: 2929, DITHER: 3024, POLYGON_OFFSET_FILL: 32823, SAMPLE_ALPHA_TO_COVERAGE: 32926, SAMPLE_COVERAGE: 32928, SCISSOR_TEST: 3089, STENCIL_TEST: 2960, NO_ERROR: 0, INVALID_ENUM: 1280, INVALID_VALUE: 1281, INVALID_OPERATION: 1282, OUT_OF_MEMORY: 1285, CONTEXT_LOST_WEBGL: 37442, CW: 2304, CCW: 2305, DONT_CARE: 4352, FASTEST: 4353, NICEST: 4354, GENERATE_MIPMAP_HINT: 33170, BYTE: 5120, UNSIGNED_BYTE: 5121, SHORT: 5122, UNSIGNED_SHORT: 5123, INT: 5124, UNSIGNED_INT: 5125, FLOAT: 5126, DOUBLE: 5130, DEPTH_COMPONENT: 6402, ALPHA: 6406, RGB: 6407, RGBA: 6408, LUMINANCE: 6409, LUMINANCE_ALPHA: 6410, UNSIGNED_SHORT_4_4_4_4: 32819, UNSIGNED_SHORT_5_5_5_1: 32820, UNSIGNED_SHORT_5_6_5: 33635, FRAGMENT_SHADER: 35632, VERTEX_SHADER: 35633, COMPILE_STATUS: 35713, DELETE_STATUS: 35712, LINK_STATUS: 35714, VALIDATE_STATUS: 35715, ATTACHED_SHADERS: 35717, ACTIVE_ATTRIBUTES: 35721, ACTIVE_UNIFORMS: 35718, MAX_VERTEX_ATTRIBS: 34921, MAX_VERTEX_UNIFORM_VECTORS: 36347, MAX_VARYING_VECTORS: 36348, MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661, MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660, MAX_TEXTURE_IMAGE_UNITS: 34930, MAX_FRAGMENT_UNIFORM_VECTORS: 36349, SHADER_TYPE: 35663, SHADING_LANGUAGE_VERSION: 35724, CURRENT_PROGRAM: 35725, NEVER: 512, ALWAYS: 519, LESS: 513, EQUAL: 514, LEQUAL: 515, GREATER: 516, GEQUAL: 518, NOTEQUAL: 517, KEEP: 7680, REPLACE: 7681, INCR: 7682, DECR: 7683, INVERT: 5386, INCR_WRAP: 34055, DECR_WRAP: 34056, NEAREST: 9728, LINEAR: 9729, NEAREST_MIPMAP_NEAREST: 9984, LINEAR_MIPMAP_NEAREST: 9985, NEAREST_MIPMAP_LINEAR: 9986, LINEAR_MIPMAP_LINEAR: 9987, TEXTURE_MAG_FILTER: 10240, TEXTURE_MIN_FILTER: 10241, TEXTURE_WRAP_S: 10242, TEXTURE_WRAP_T: 10243, TEXTURE_2D: 3553, TEXTURE: 5890, TEXTURE_CUBE_MAP: 34067, TEXTURE_BINDING_CUBE_MAP: 34068, TEXTURE_CUBE_MAP_POSITIVE_X: 34069, TEXTURE_CUBE_MAP_NEGATIVE_X: 34070, TEXTURE_CUBE_MAP_POSITIVE_Y: 34071, TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072, TEXTURE_CUBE_MAP_POSITIVE_Z: 34073, TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074, MAX_CUBE_MAP_TEXTURE_SIZE: 34076, TEXTURE0: 33984, ACTIVE_TEXTURE: 34016, REPEAT: 10497, CLAMP_TO_EDGE: 33071, MIRRORED_REPEAT: 33648, TEXTURE_WIDTH: 4096, TEXTURE_HEIGHT: 4097, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, INT_VEC2: 35667, INT_VEC3: 35668, INT_VEC4: 35669, BOOL: 35670, BOOL_VEC2: 35671, BOOL_VEC3: 35672, BOOL_VEC4: 35673, FLOAT_MAT2: 35674, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, SAMPLER_2D: 35678, SAMPLER_CUBE: 35680, LOW_FLOAT: 36336, MEDIUM_FLOAT: 36337, HIGH_FLOAT: 36338, LOW_INT: 36339, MEDIUM_INT: 36340, HIGH_INT: 36341, FRAMEBUFFER: 36160, RENDERBUFFER: 36161, RGBA4: 32854, RGB5_A1: 32855, RGB565: 36194, DEPTH_COMPONENT16: 33189, STENCIL_INDEX: 6401, STENCIL_INDEX8: 36168, DEPTH_STENCIL: 34041, RENDERBUFFER_WIDTH: 36162, RENDERBUFFER_HEIGHT: 36163, RENDERBUFFER_INTERNAL_FORMAT: 36164, RENDERBUFFER_RED_SIZE: 36176, RENDERBUFFER_GREEN_SIZE: 36177, RENDERBUFFER_BLUE_SIZE: 36178, RENDERBUFFER_ALPHA_SIZE: 36179, RENDERBUFFER_DEPTH_SIZE: 36180, RENDERBUFFER_STENCIL_SIZE: 36181, FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048, FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049, FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050, FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051, COLOR_ATTACHMENT0: 36064, DEPTH_ATTACHMENT: 36096, STENCIL_ATTACHMENT: 36128, DEPTH_STENCIL_ATTACHMENT: 33306, NONE: 0, FRAMEBUFFER_COMPLETE: 36053, FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054, FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055, FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057, FRAMEBUFFER_UNSUPPORTED: 36061, FRAMEBUFFER_BINDING: 36006, RENDERBUFFER_BINDING: 36007, READ_FRAMEBUFFER: 36008, DRAW_FRAMEBUFFER: 36009, MAX_RENDERBUFFER_SIZE: 34024, INVALID_FRAMEBUFFER_OPERATION: 1286, UNPACK_FLIP_Y_WEBGL: 37440, UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441, UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443, READ_BUFFER: 3074, UNPACK_ROW_LENGTH: 3314, UNPACK_SKIP_ROWS: 3315, UNPACK_SKIP_PIXELS: 3316, PACK_ROW_LENGTH: 3330, PACK_SKIP_ROWS: 3331, PACK_SKIP_PIXELS: 3332, TEXTURE_BINDING_3D: 32874, UNPACK_SKIP_IMAGES: 32877, UNPACK_IMAGE_HEIGHT: 32878, MAX_3D_TEXTURE_SIZE: 32883, MAX_ELEMENTS_VERTICES: 33e3, MAX_ELEMENTS_INDICES: 33001, MAX_TEXTURE_LOD_BIAS: 34045, MAX_FRAGMENT_UNIFORM_COMPONENTS: 35657, MAX_VERTEX_UNIFORM_COMPONENTS: 35658, MAX_ARRAY_TEXTURE_LAYERS: 35071, MIN_PROGRAM_TEXEL_OFFSET: 35076, MAX_PROGRAM_TEXEL_OFFSET: 35077, MAX_VARYING_COMPONENTS: 35659, FRAGMENT_SHADER_DERIVATIVE_HINT: 35723, RASTERIZER_DISCARD: 35977, VERTEX_ARRAY_BINDING: 34229, MAX_VERTEX_OUTPUT_COMPONENTS: 37154, MAX_FRAGMENT_INPUT_COMPONENTS: 37157, MAX_SERVER_WAIT_TIMEOUT: 37137, MAX_ELEMENT_INDEX: 36203, RED: 6403, RGB8: 32849, RGBA8: 32856, RGB10_A2: 32857, TEXTURE_3D: 32879, TEXTURE_WRAP_R: 32882, TEXTURE_MIN_LOD: 33082, TEXTURE_MAX_LOD: 33083, TEXTURE_BASE_LEVEL: 33084, TEXTURE_MAX_LEVEL: 33085, TEXTURE_COMPARE_MODE: 34892, TEXTURE_COMPARE_FUNC: 34893, SRGB: 35904, SRGB8: 35905, SRGB8_ALPHA8: 35907, COMPARE_REF_TO_TEXTURE: 34894, RGBA32F: 34836, RGB32F: 34837, RGBA16F: 34842, RGB16F: 34843, TEXTURE_2D_ARRAY: 35866, TEXTURE_BINDING_2D_ARRAY: 35869, R11F_G11F_B10F: 35898, RGB9_E5: 35901, RGBA32UI: 36208, RGB32UI: 36209, RGBA16UI: 36214, RGB16UI: 36215, RGBA8UI: 36220, RGB8UI: 36221, RGBA32I: 36226, RGB32I: 36227, RGBA16I: 36232, RGB16I: 36233, RGBA8I: 36238, RGB8I: 36239, RED_INTEGER: 36244, RGB_INTEGER: 36248, RGBA_INTEGER: 36249, R8: 33321, RG8: 33323, R16F: 33325, R32F: 33326, RG16F: 33327, RG32F: 33328, R8I: 33329, R8UI: 33330, R16I: 33331, R16UI: 33332, R32I: 33333, R32UI: 33334, RG8I: 33335, RG8UI: 33336, RG16I: 33337, RG16UI: 33338, RG32I: 33339, RG32UI: 33340, R8_SNORM: 36756, RG8_SNORM: 36757, RGB8_SNORM: 36758, RGBA8_SNORM: 36759, RGB10_A2UI: 36975, TEXTURE_IMMUTABLE_FORMAT: 37167, TEXTURE_IMMUTABLE_LEVELS: 33503, UNSIGNED_INT_2_10_10_10_REV: 33640, UNSIGNED_INT_10F_11F_11F_REV: 35899, UNSIGNED_INT_5_9_9_9_REV: 35902, FLOAT_32_UNSIGNED_INT_24_8_REV: 36269, UNSIGNED_INT_24_8: 34042, HALF_FLOAT: 5131, RG: 33319, RG_INTEGER: 33320, INT_2_10_10_10_REV: 36255, CURRENT_QUERY: 34917, QUERY_RESULT: 34918, QUERY_RESULT_AVAILABLE: 34919, ANY_SAMPLES_PASSED: 35887, ANY_SAMPLES_PASSED_CONSERVATIVE: 36202, MAX_DRAW_BUFFERS: 34852, DRAW_BUFFER0: 34853, DRAW_BUFFER1: 34854, DRAW_BUFFER2: 34855, DRAW_BUFFER3: 34856, DRAW_BUFFER4: 34857, DRAW_BUFFER5: 34858, DRAW_BUFFER6: 34859, DRAW_BUFFER7: 34860, DRAW_BUFFER8: 34861, DRAW_BUFFER9: 34862, DRAW_BUFFER10: 34863, DRAW_BUFFER11: 34864, DRAW_BUFFER12: 34865, DRAW_BUFFER13: 34866, DRAW_BUFFER14: 34867, DRAW_BUFFER15: 34868, MAX_COLOR_ATTACHMENTS: 36063, COLOR_ATTACHMENT1: 36065, COLOR_ATTACHMENT2: 36066, COLOR_ATTACHMENT3: 36067, COLOR_ATTACHMENT4: 36068, COLOR_ATTACHMENT5: 36069, COLOR_ATTACHMENT6: 36070, COLOR_ATTACHMENT7: 36071, COLOR_ATTACHMENT8: 36072, COLOR_ATTACHMENT9: 36073, COLOR_ATTACHMENT10: 36074, COLOR_ATTACHMENT11: 36075, COLOR_ATTACHMENT12: 36076, COLOR_ATTACHMENT13: 36077, COLOR_ATTACHMENT14: 36078, COLOR_ATTACHMENT15: 36079, SAMPLER_3D: 35679, SAMPLER_2D_SHADOW: 35682, SAMPLER_2D_ARRAY: 36289, SAMPLER_2D_ARRAY_SHADOW: 36292, SAMPLER_CUBE_SHADOW: 36293, INT_SAMPLER_2D: 36298, INT_SAMPLER_3D: 36299, INT_SAMPLER_CUBE: 36300, INT_SAMPLER_2D_ARRAY: 36303, UNSIGNED_INT_SAMPLER_2D: 36306, UNSIGNED_INT_SAMPLER_3D: 36307, UNSIGNED_INT_SAMPLER_CUBE: 36308, UNSIGNED_INT_SAMPLER_2D_ARRAY: 36311, MAX_SAMPLES: 36183, SAMPLER_BINDING: 35097, PIXEL_PACK_BUFFER: 35051, PIXEL_UNPACK_BUFFER: 35052, PIXEL_PACK_BUFFER_BINDING: 35053, PIXEL_UNPACK_BUFFER_BINDING: 35055, COPY_READ_BUFFER: 36662, COPY_WRITE_BUFFER: 36663, COPY_READ_BUFFER_BINDING: 36662, COPY_WRITE_BUFFER_BINDING: 36663, FLOAT_MAT2x3: 35685, FLOAT_MAT2x4: 35686, FLOAT_MAT3x2: 35687, FLOAT_MAT3x4: 35688, FLOAT_MAT4x2: 35689, FLOAT_MAT4x3: 35690, UNSIGNED_INT_VEC2: 36294, UNSIGNED_INT_VEC3: 36295, UNSIGNED_INT_VEC4: 36296, UNSIGNED_NORMALIZED: 35863, SIGNED_NORMALIZED: 36764, VERTEX_ATTRIB_ARRAY_INTEGER: 35069, VERTEX_ATTRIB_ARRAY_DIVISOR: 35070, TRANSFORM_FEEDBACK_BUFFER_MODE: 35967, MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 35968, TRANSFORM_FEEDBACK_VARYINGS: 35971, TRANSFORM_FEEDBACK_BUFFER_START: 35972, TRANSFORM_FEEDBACK_BUFFER_SIZE: 35973, TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 35976, MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 35978, MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 35979, INTERLEAVED_ATTRIBS: 35980, SEPARATE_ATTRIBS: 35981, TRANSFORM_FEEDBACK_BUFFER: 35982, TRANSFORM_FEEDBACK_BUFFER_BINDING: 35983, TRANSFORM_FEEDBACK: 36386, TRANSFORM_FEEDBACK_PAUSED: 36387, TRANSFORM_FEEDBACK_ACTIVE: 36388, TRANSFORM_FEEDBACK_BINDING: 36389, FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 33296, FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 33297, FRAMEBUFFER_ATTACHMENT_RED_SIZE: 33298, FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 33299, FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 33300, FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 33301, FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 33302, FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 33303, FRAMEBUFFER_DEFAULT: 33304, DEPTH24_STENCIL8: 35056, DRAW_FRAMEBUFFER_BINDING: 36006, READ_FRAMEBUFFER_BINDING: 36010, RENDERBUFFER_SAMPLES: 36011, FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 36052, FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 36182, UNIFORM_BUFFER: 35345, UNIFORM_BUFFER_BINDING: 35368, UNIFORM_BUFFER_START: 35369, UNIFORM_BUFFER_SIZE: 35370, MAX_VERTEX_UNIFORM_BLOCKS: 35371, MAX_FRAGMENT_UNIFORM_BLOCKS: 35373, MAX_COMBINED_UNIFORM_BLOCKS: 35374, MAX_UNIFORM_BUFFER_BINDINGS: 35375, MAX_UNIFORM_BLOCK_SIZE: 35376, MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 35377, MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 35379, UNIFORM_BUFFER_OFFSET_ALIGNMENT: 35380, ACTIVE_UNIFORM_BLOCKS: 35382, UNIFORM_TYPE: 35383, UNIFORM_SIZE: 35384, UNIFORM_BLOCK_INDEX: 35386, UNIFORM_OFFSET: 35387, UNIFORM_ARRAY_STRIDE: 35388, UNIFORM_MATRIX_STRIDE: 35389, UNIFORM_IS_ROW_MAJOR: 35390, UNIFORM_BLOCK_BINDING: 35391, UNIFORM_BLOCK_DATA_SIZE: 35392, UNIFORM_BLOCK_ACTIVE_UNIFORMS: 35394, UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 35395, UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 35396, UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 35398, OBJECT_TYPE: 37138, SYNC_CONDITION: 37139, SYNC_STATUS: 37140, SYNC_FLAGS: 37141, SYNC_FENCE: 37142, SYNC_GPU_COMMANDS_COMPLETE: 37143, UNSIGNALED: 37144, SIGNALED: 37145, ALREADY_SIGNALED: 37146, TIMEOUT_EXPIRED: 37147, CONDITION_SATISFIED: 37148, WAIT_FAILED: 37149, SYNC_FLUSH_COMMANDS_BIT: 1, COLOR: 6144, DEPTH: 6145, STENCIL: 6146, MIN: 32775, MAX: 32776, DEPTH_COMPONENT24: 33190, STREAM_READ: 35041, STREAM_COPY: 35042, STATIC_READ: 35045, STATIC_COPY: 35046, DYNAMIC_READ: 35049, DYNAMIC_COPY: 35050, DEPTH_COMPONENT32F: 36012, DEPTH32F_STENCIL8: 36013, INVALID_INDEX: 4294967295, TIMEOUT_IGNORED: -1, MAX_CLIENT_WAIT_TIMEOUT_WEBGL: 37447, VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 35070, UNMASKED_VENDOR_WEBGL: 37445, UNMASKED_RENDERER_WEBGL: 37446, MAX_TEXTURE_MAX_ANISOTROPY_EXT: 34047, TEXTURE_MAX_ANISOTROPY_EXT: 34046, COMPRESSED_RGB_S3TC_DXT1_EXT: 33776, COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777, COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778, COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779, COMPRESSED_R11_EAC: 37488, COMPRESSED_SIGNED_R11_EAC: 37489, COMPRESSED_RG11_EAC: 37490, COMPRESSED_SIGNED_RG11_EAC: 37491, COMPRESSED_RGB8_ETC2: 37492, COMPRESSED_RGBA8_ETC2_EAC: 37493, COMPRESSED_SRGB8_ETC2: 37494, COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495, COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496, COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497, COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840, COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842, COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841, COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843, COMPRESSED_RGB_ETC1_WEBGL: 36196, COMPRESSED_RGB_ATC_WEBGL: 35986, COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35986, COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798, UNSIGNED_INT_24_8_WEBGL: 34042, HALF_FLOAT_OES: 36193, RGBA32F_EXT: 34836, RGB32F_EXT: 34837, FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 33297, UNSIGNED_NORMALIZED_EXT: 35863, MIN_EXT: 32775, MAX_EXT: 32776, SRGB_EXT: 35904, SRGB_ALPHA_EXT: 35906, SRGB8_ALPHA8_EXT: 35907, FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: 33296, FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 35723, COLOR_ATTACHMENT0_WEBGL: 36064, COLOR_ATTACHMENT1_WEBGL: 36065, COLOR_ATTACHMENT2_WEBGL: 36066, COLOR_ATTACHMENT3_WEBGL: 36067, COLOR_ATTACHMENT4_WEBGL: 36068, COLOR_ATTACHMENT5_WEBGL: 36069, COLOR_ATTACHMENT6_WEBGL: 36070, COLOR_ATTACHMENT7_WEBGL: 36071, COLOR_ATTACHMENT8_WEBGL: 36072, COLOR_ATTACHMENT9_WEBGL: 36073, COLOR_ATTACHMENT10_WEBGL: 36074, COLOR_ATTACHMENT11_WEBGL: 36075, COLOR_ATTACHMENT12_WEBGL: 36076, COLOR_ATTACHMENT13_WEBGL: 36077, COLOR_ATTACHMENT14_WEBGL: 36078, COLOR_ATTACHMENT15_WEBGL: 36079, DRAW_BUFFER0_WEBGL: 34853, DRAW_BUFFER1_WEBGL: 34854, DRAW_BUFFER2_WEBGL: 34855, DRAW_BUFFER3_WEBGL: 34856, DRAW_BUFFER4_WEBGL: 34857, DRAW_BUFFER5_WEBGL: 34858, DRAW_BUFFER6_WEBGL: 34859, DRAW_BUFFER7_WEBGL: 34860, DRAW_BUFFER8_WEBGL: 34861, DRAW_BUFFER9_WEBGL: 34862, DRAW_BUFFER10_WEBGL: 34863, DRAW_BUFFER11_WEBGL: 34864, DRAW_BUFFER12_WEBGL: 34865, DRAW_BUFFER13_WEBGL: 34866, DRAW_BUFFER14_WEBGL: 34867, DRAW_BUFFER15_WEBGL: 34868, MAX_COLOR_ATTACHMENTS_WEBGL: 36063, MAX_DRAW_BUFFERS_WEBGL: 34852, VERTEX_ARRAY_BINDING_OES: 34229, QUERY_COUNTER_BITS_EXT: 34916, CURRENT_QUERY_EXT: 34917, QUERY_RESULT_EXT: 34918, QUERY_RESULT_AVAILABLE_EXT: 34919, TIME_ELAPSED_EXT: 35007, TIMESTAMP_EXT: 36392, GPU_DISJOINT_EXT: 36795 };
  var Ms = class extends wt {
    constructor(e) {
      super(e);
    }
  };
  Ms.layerName = "WxTileIsolineText";
  Ms.defaultProps = { pickable: false, billboard: false, parameters: { depthTest: false }, fontFamily: "Sans-serif", getSize: 12, fontSettings: { sdf: true }, outlineWidth: 0.5, outlineColor: [200, 200, 200], getColor: (r2) => r2.color, getAngle: (r2) => r2.angle };
  var Sw = { comment1: ["degC: ['K', 1, 273.15] -> degC = K * 1 + 273.15", 0], comment2: ["hPa: ['Pa', 100]' -> hPa = Pa * 100 + 0 (0 - could be ommited)", 0], K: ["K", 1], F: ["K", 0.5555555555, 255.372222222], C: ["K", 1, 273.15], degC: ["K", 1, 273.15], "kg/m^2/s": ["kg/m^2/s", 1], "Kg m**-2 s**-1": ["kg/m^2/s", 1], "W/m^2": ["W/m^2", 1], "W m**2": ["W/m^2", 1], "m/s": ["m/s", 1], "m s**-1": ["m/s", 1], knot: ["m/s", 0.514444], knots: ["m/s", 0.514444], "km/h": ["m/s", 0.27777777777], s: ["s", 1], sec: ["s", 1], h: ["s", 3600], min: ["s", 60], m: ["m", 1], cm: ["m", 0.01], inch: ["m", 0.0254], Pa: ["Pa", 1], hPa: ["Pa", 100] };
  var ww = { none: ["#00000000", "#00000000"], rainbow: ["#f00", "#ff0", "#0f0", "#0ff", "#00f", "#f0f"], rainbow2: ["#f00", "#ff0", "#0f0", "#0ff", "#00f", "#f0f", "#f00"], rainbowzerro: ["#ff000000", "#f00", "#ff0", "#0f0", "#0ff", "#00f", "#f0f"], bluebird: ["#00f", "#f0f", "#0ff", "#80f", "#88f"], bluebirdzerro: ["#0000ff00", "#00f", "#f0f", "#0ff", "#80f", "#88f"], bw: ["#000", "#fff"], wb: ["#fff", "#000"], redish: ["#f0f", "#f00", "#ff0"], greenish: ["#ff0", "#0f0", "#0ff"], blueish: ["#f0f", "#00f", "#0ff"], hspastel: ["#AC6EA4FF", "#8E92BDFF", "#ACD4DEFF", "#E9DC8EFF", "#E7A97DFF", "#E59074FF", "#BE7E68FF", "#A88F86FF"] };
  var e_ = { base: { parent: void 0, name: "base", fill: "gradient", isolineColor: "inverted", isolineText: true, vectorType: "arrows", vectorColor: "inverted", streamLineColor: "#777", streamLineSpeedFactor: 1, streamLineStatic: false, showBelowMin: true, showAboveMax: true, colorScheme: "rainbow", colors: void 0, colorMap: void 0, levels: void 0, blurRadius: 0, addDegrees: 0, units: "", extraUnits: void 0 }, custom: { parent: void 0, name: "custom", fill: "gradient", isolineColor: "inverted", isolineText: true, vectorType: "arrows", vectorColor: "inverted", streamLineColor: "#777", streamLineSpeedFactor: 1, streamLineStatic: false, showBelowMin: true, showAboveMax: true, colorScheme: "rainbow", colors: void 0, colorMap: void 0, levels: void 0, blurRadius: 0, addDegrees: 0, units: "", extraUnits: void 0 } };
  var du;
  var t_;
  var r_;
  function n_({ colorStyles: r2 = {}, units: e = {}, colorSchemes: t = {} } = {}) {
    window.wxlogging && console.log("WxTile lib setup: start"), du = Object.assign({}, Sw, e), t_ = Object.assign({}, t, ww), r_ = Pw(r2), window.wxlogging && console.log("WxTile lib setup: styles unrolled"), document.fonts.load("32px barbs"), document.fonts.load("32px arrows"), window.wxlogging && console.log("WxTile lib setup is done" + JSON.stringify({ colorStyles: r2, units: e, colorSchemes: t }));
  }
  function i_() {
    return r_;
  }
  function s_() {
    return t_;
  }
  function Ec(r2, e, t) {
    let n = t ? Object.assign({}, du, t) : du;
    if (!n || !r2 || !e || r2 === e || !n[r2] || !n[e] || n[r2][0] !== n[e][0]) {
      window.wxlogging && console.log(r2 === e ? "Trivial converter:" : "Inconvertible units. Default converter is used:", r2, " -> ", e);
      let o = (a) => a;
      return o.trivial = true, o;
    }
    window.wxlogging && console.log("Converter: From:", r2, " To:", e);
    let i = n[r2][1] / n[e][1], s = (n[r2][2] || 0) / n[e][1] - (n[e][2] || 0) / n[e][1];
    return s ? (o) => i * o + s : (o) => i * o;
  }
  function Pw(r2) {
    let e = Object.assign({}, e_);
    for (let i in r2) {
      let s = r2[i];
      if (Array.isArray(s))
        for (let o = 0; o < s.length; ++o)
          e[i + "[" + o + "]"] = Object.assign({}, s[o]);
      else
        e[i] = Object.assign({}, s);
    }
    let t = (i, s) => {
      if (s === "base")
        return e_.base;
      let o = i[s];
      (!o.parent || !(o.parent in i)) && (o.parent = "base");
      let a = t(i, o.parent);
      return Object.assign(o, Object.assign({}, a, o, { parent: "base" }));
    }, n = {};
    for (let i in e)
      n[i] = t(e, i);
    return n;
  }
  function o_(r2) {
    let e = r2 >> 0 & 255, t = r2 >> 8 & 255, n = r2 >> 16 & 255, i = e.toString(16), s = t.toString(16), o = n.toString(16);
    return i = i.length === 2 ? i : "0" + i, s = s.length === 2 ? s : "0" + s, o = o.length === 2 ? o : "0" + o, "#" + i + s + o;
  }
  function ht(r2) {
    if (r2[0] === "#") {
      if (r2.length === 4)
        return +("0xff" + r2[3] + r2[3] + r2[2] + r2[2] + r2[1] + r2[1]);
      if (r2.length === 7)
        return +("0xff" + r2[5] + r2[6] + r2[3] + r2[4] + r2[1] + r2[2]);
      if (r2.length === 9)
        return +("0x" + r2[7] + r2[8] + r2[5] + r2[6] + r2[3] + r2[4] + r2[1] + r2[2]);
    }
    return window.wxlogging && console.log("wrong color format", r2), 0;
  }
  async function pu(r2) {
    return (await fetch(r2)).json();
  }
  function mu(r2, e, t) {
    let n = r2 >> 0 & 255, i = r2 >> 8 & 255, s = r2 >> 16 & 255, o = r2 >>> 24, a = e >> 0 & 255, c = e >> 8 & 255, l = e >> 16 & 255, f = e >>> 24, u = n + t * (a - n), h = i + t * (c - i), d = s + t * (l - s), m = o + t * (f - o);
    return u | h << 8 | d << 16 | m << 24;
  }
  function a_(r2, e, t) {
    let n = [];
    for (let i = 0; i < t; ++i)
      n.push(i * (e - r2) / (t - 1) + r2);
    return n;
  }
  function li(r2) {
    let e = r2 >> 0 & 255, t = r2 >> 8 & 255, n = r2 >> 16 & 255;
    return [e, t, n];
  }
  var c_ = `#define SHADER_NAME bitmap-layer-vertex-shader

attribute vec2 texCoords;
attribute vec3 positions;
attribute vec3 positions64Low;

varying vec2 vTexCoord;
varying vec2 vTexPos;

uniform float coordinateConversion;

const vec3 pickingColor = vec3(1.0, 0.0, 0.0);

void main(void) {
  geometry.worldPosition = positions;
  geometry.uv = texCoords;
  geometry.pickingColor = pickingColor;

  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  vTexCoord = texCoords;

  if(coordinateConversion < -0.5) {
    vTexPos = geometry.position.xy;
  } else if(coordinateConversion > 0.5) {
    vTexPos = geometry.worldPosition.xy;
  }

  vec4 color = vec4(0.0);
  DECKGL_FILTER_COLOR(color, geometry);
}`;
  var l_ = `// #version 300 es
/**
 * Pack the top 12 bits of two normalized floats into 3 8-bit (rgb) values
 * This enables addressing 4096x4096 individual pixels
 *
 * returns vec3 encoded RGB colors
 *  result.r - top 8 bits of u
 *  result.g - top 8 bits of v
 *  result.b - next 4 bits of u and v: (u + v * 16)
 */

 #define SHADER_NAME bitmap-layer-fragment-shader

precision highp float;

uniform sampler2D bitmapTexture;

varying vec2 vTexCoord;
varying vec2 vTexPos;

uniform float desaturate;
uniform vec4 transparentColor;
uniform vec3 tintColor;
uniform float opacity;

uniform float coordinateConversion;
uniform vec4 bounds;

 /* projection utils */
const float TILE_SIZE = 256.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / PI / 2.0;

 // from degrees to Web Mercator
vec2 lnglat_to_mercator(vec2 lnglat) {
  float x = lnglat.x;
  float y = clamp(lnglat.y, -89.9, 89.9);
  return vec2(radians(x) + PI, PI + log(tan(PI * 0.25 + radians(y) * 0.5))) * WORLD_SCALE;
}

 // from Web Mercator to degrees
vec2 mercator_to_lnglat(vec2 xy) {
  xy /= WORLD_SCALE;
  return degrees(vec2(xy.x - PI, atan(exp(xy.y - PI)) * 2.0 - PI * 0.5));
}
 /* End projection utils */

 // apply desaturation
vec3 color_desaturate(vec3 color) {
  float luminance = (color.r + color.g + color.b) * 0.333333333;
  return mix(color, vec3(luminance), desaturate);
}

 // apply tint
vec3 color_tint(vec3 color) {
  return color * tintColor;
}

 // blend with background color
vec4 apply_opacity(vec3 color, float alpha) {
  return mix(transparentColor, vec4(color, 1.0), alpha);
}

vec2 getUV(vec2 pos) {
  return vec2((pos.x - bounds[0]) / (bounds[2] - bounds[0]), (pos.y - bounds[3]) / (bounds[1] - bounds[3]));
}

vec3 packUVsIntoRGB(vec2 uv) {
  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction
  vec2 uv8bit = floor(uv * 256.);

  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits
  // Scale and clamp to 0-1 range
  vec2 uvFraction = fract(uv * 256.);
  vec2 uvFraction4bit = floor(uvFraction * 16.);

  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates
  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;

  return vec3(uv8bit, fractions) / 255.;
}

const float tileSzExInv = 1.0 / 258.0;
const float tileM = 256.0 / 258.0;
const vec2 one = vec2(tileSzExInv, tileSzExInv);

uniform sampler2D clutTextureUniform;
uniform float shift; // the wize of isoline
uniform int isoline;
uniform vec3 isolineColor;
uniform bool fill;

float GetPackedData(vec2 texCoord) {
  vec4 tex = texture2D(bitmapTexture, texCoord);
  return (tex.r * 255.0 + tex.g * 255.0 * 256.0) / 65535.0;
}

vec4 CLUT(float pos) {
  // upper pixel is a CLUT component
  return texture2D(clutTextureUniform, vec2(pos, 0.0));
}

int isolineIndex(float pos) {
  // bottom pixel is an Isoline index, so if central index != neighbore index then the pixel is on isoline
  float bottomPixel = texture2D(clutTextureUniform, vec2(pos, 1.0)).r;
  return int(bottomPixel * 255.0);
}

void main(void) {

  vec2 uv = vTexCoord;
  if(coordinateConversion < -0.5) {
    vec2 lnglat = mercator_to_lnglat(vTexPos);
    uv = getUV(lnglat);
  } else if(coordinateConversion > 0.5) {
    vec2 commonPos = lnglat_to_mercator(vTexPos);
    uv = getUV(commonPos);
  }

  uv = uv * tileM + one; // 256 -> 258 shifted

  if(picking_uActive) {
    gl_FragColor = texture2D(bitmapTexture, uv);
    return;
  }

  vec2 uvC = uv; // central pixel

  // check for NODATA
  vec2 ucCfloor = floor(uvC * 258.0) / 258.0;
  vec4 dataCheck1 = texture2D(bitmapTexture, ucCfloor);
  vec4 dataCheck2 = texture2D(bitmapTexture, ucCfloor + vec2(1.0, 1.0) / 258.0);
  if((dataCheck1.r == 0.0 && dataCheck1.g == 0.0) || (dataCheck2.r == 0.0 && dataCheck2.g == 0.0))
    discard;

  // calc Right pixel coord 
  vec2 uvR = uvC + vec2(shift, 0.0);
  // calc Bottom pixel coord 
  vec2 uvB = uvC + vec2(0.0, shift);

  vec4 bitmapColor = vec4(0.0); // result Color

  float packedC = GetPackedData(uvC); // central data
  vec4 colorC = CLUT(packedC);
  if(fill) {
    bitmapColor = colorC;
  }

  // return;
  if(isoline != 0) {
    int isoC = isolineIndex(packedC);

    float packedR = GetPackedData(uvR); // central
    int isoR = isolineIndex(packedR);

    float packedD = GetPackedData(uvB); // central
    int isoD = isolineIndex(packedD);

    if(isoC != isoD || isoC != isoR) {
      bitmapColor = vec4(isolineColor, 1.0); // isoline != 1 or 2

      if(isoline == 1)
        bitmapColor = vec4(1.0 - colorC.r, 1.0 - colorC.g, 1.0 - colorC.b, colorC.a);
      if(isoline == 2)
        bitmapColor = vec4(colorC.r, colorC.g, colorC.b, colorC.a);
    }
  }

  gl_FragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * opacity);

  geometry.uv = uvC;
  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`;
  var Is = class extends an {
    constructor(e) {
      super(e);
    }
    updateState(e) {
      super.updateState(e);
      let { style: t } = this.props.data, n = t.fill !== "none", i = ht(t.isolineColor), s = { none: 0, inverted: 1, fill: 2 }[t.isolineColor] || 3, { desaturate: o, transparentColor: a, tintColor: c, bounds: l } = this.props;
      this.state.model.setUniforms({ clutTextureUniform: this.props.data.clutTextureUniform, bitmapTexture: this.props.data.imageTextureUniform, fill: n, isoline: s, isolineColor: li(i), desaturate: o, transparentColor: a.map((f) => f / 255), tintColor: c.slice(0, 3).map((f) => f / 255), bounds: l });
    }
    getShaders() {
      return { vs: c_, fs: l_, modules: [Ie, Oe] };
    }
    draw(e) {
      let { uniforms: t, moduleParameters: n } = e, { model: i, coordinateConversion: s, disablePicking: o } = this.state, { context: a } = this;
      if (n.pickingActive && o || !i)
        return;
      let c = a.viewport, l = c.getCameraPosition(), f = c.center, u = Math.sqrt((l[0] - f[0]) ** 2 + (l[1] - f[1]) ** 2 + (l[2] - f[2]) ** 2);
      i.setUniforms(L(x({}, t), { shift: u / 5e4, coordinateConversion: s })), this.state.model.draw(e);
    }
  };
  Is.layerName = "WxTileFill";
  Is.defaultProps = { desaturate: { type: "number", min: 0, max: 1, value: 0 }, transparentColor: { type: "color", value: [0, 0, 0, 0] }, tintColor: { type: "color", value: [255, 255, 255] }, opacity: { type: "number", min: 0, max: 1, value: 1 } };
  var Os = class extends wt {
    constructor(e) {
      super(e);
    }
  };
  Os.layerName = "WxTileVector";
  Os.defaultProps = { pickable: false, billboard: false, parameters: { depthTest: false }, fontFamily: "arrows", fontWeight: "bold", getSize: 30, fontSettings: { sdf: true }, outlineWidth: 0.2, outlineColor: [200, 200, 200], getColor: (r2) => r2.color, getAngle: (r2) => r2.angle };
  function Rw(r2, e, t) {
    return r2 > t ? t : r2 < e ? e : r2;
  }
  var gu = class {
    constructor(e, t, [n, i], s) {
      let o = i - n;
      this.levelIndex = new Uint32Array(65536), this.colorsI = new Uint32Array(65536);
      let a = [];
      this.DataToStyle = Ec(t, e.units, e.extraUnits), this.DataToStyle.trivial && (e.units = t), s && (this.DataToKnots = Ec(t, "knot"));
      let c = Ec(e.units, t, e.extraUnits), l = (_) => ~~(65535 * Rw((c(_) - n) / (i - n), 0, 1));
      if (Array.isArray(e.colorMap)) {
        e.colorMap.sort((_, E) => _[0] < E[0] ? -1 : _[0] > E[0] ? 1 : 0);
        for (let [_] of e.colorMap)
          a.push(l(_));
      } else {
        if (e.levels || (e.levels = a_(this.DataToStyle(n), this.DataToStyle(i), 10)), e.levels.sort((_, E) => _ < E ? -1 : _ > E ? 1 : 0), !e.colors) {
          let _ = s_();
          e.colorScheme && e.colorScheme in _ ? e.colors = _[e.colorScheme] : e.colors = _.wb;
        }
        for (let _ of e.levels)
          a.push(l(_));
      }
      let f = 65536, u = Mw(f, e);
      this.ticks = u.ticks;
      let h = u.ticks[0].data, m = u.ticks[u.ticks.length - 1].data - h;
      for (let _ = 0; _ < 65536; ++_) {
        let E = o * _ / 65535 + n, b = this.DataToStyle(E), T = Math.round((f - 1) * (b - h) / m);
        T <= 0 ? this.colorsI[_] = e.showBelowMin ? u.colors[0] : 0 : T >= f ? this.colorsI[_] = e.showAboveMax ? u.colors[f - 1] : 0 : this.colorsI[_] = u.colors[T];
      }
      this.colorsI[0] = 0;
      for (let _ = 0; _ < a[0]; ++_)
        this.levelIndex[_] = 0;
      for (let _ = 0; _ < a.length - 1; _++)
        for (let E = a[_]; E < a[_ + 1] + 1; ++E)
          this.levelIndex[E] = _;
      for (let _ = a[a.length - 1]; _ < 65536; ++_)
        this.levelIndex[_] = a.length - 1;
    }
  };
  function f_(r2) {
    var t;
    if (r2 !== 0 && -0.1 < r2 && r2 < 0.1)
      return r2.toExponential(2);
    let e = r2.toString();
    return ((t = e.split(".")[1]) == null ? void 0 : t.length) > 2 ? r2.toFixed(2) : e;
  }
  function Mw(r2, e) {
    let t = { size: r2, showBelowMin: e.showBelowMin, showAboveMax: e.showAboveMax, units: e.units, colors: new Uint32Array(r2), ticks: [] }, { colorMap: n, levels: i, colors: s } = e, o = e.fill !== "solid";
    if (n) {
      let h = n[0][0], d = n[n.length - 1][0] - h;
      for (let [m, _] of n) {
        let E = ~~((m - h) / d * (r2 - 1)), b = { data: m, dataString: f_(m), color: _, pos: E };
        t.ticks.push(b);
      }
      for (let m = 0; m < n.length - 1; m++) {
        let _ = t.ticks[m].pos, E = t.ticks[m + 1].pos, b = ht(n[m][1]), T = o ? ht(n[m + 1][1]) : 0;
        for (let v = _; v < E; ++v)
          t.colors[v] = o ? mu(b, T, (v - _) / (E - _)) : b;
      }
      return t.colors[r2 - 1] = ht(n[n.length - 1][1]), t;
    }
    if (!s || !i)
      return t;
    let a = 0, c = 0, l = -1;
    for (let h = 0; h < r2; ++h) {
      let d = h * (s.length - 1) / r2;
      l !== ~~d && (l = ~~d, a = ht(s[l]), c = s.length > l + 1 ? ht(s[l + 1]) : a), t.colors[h] = o ? mu(a, c, d - l) : a;
    }
    t.colors[r2 - 1] = ht(s[s.length - 1]);
    let f = i[0], u = (r2 - 1) / (i[i.length - 1] - f);
    for (let h of i) {
      let d = ~~((h - f) * u), m = { data: h, dataString: f_(h), color: o_(t.colors[d]), pos: d };
      t.ticks.push(m);
    }
    return t;
  }
  var _u = 256;
  var Iw = 2 * Math.PI * 6378137 / _u;
  var bc = 2 * Math.PI * 6378137 / 2;
  function Ow(r2, e) {
    let t = r2 / bc * 180, n = e / bc * 180;
    return n = 180 / Math.PI * (2 * Math.atan(Math.exp(n * Math.PI / 180)) - Math.PI / 2), [n, t];
  }
  function Nw(r2, e, t) {
    let n = Fw(t), i = r2 * n - bc, s = e * n - bc;
    return [i, s];
  }
  function Fw(r2) {
    return Iw / Math.pow(2, r2);
  }
  function Tc(r2, e, t) {
    let [n, i] = Ow(...Nw(r2, e, t));
    return [i, -n];
  }
  function vc(r2, e) {
    return [r2 * _u, e * _u];
  }
  var Dw = {};
  var Bw = {};
  var Uw = {};
  var kw = {};
  var Vw = {};
  var Gw = {};
  var zw = {};
  var jw = {};
  var Ww = {};
  var Hw = {};
  var Xw = {};
  var Yw = {};
  var qw = {};
  var Zw = {};
  var Kw = {};
  var Qw = {};
  var Jw = { addDegrees: 0, blurRadius: 0, colors: ["#00B3FFFF", "#1D9ACFFF", "#277DA1FF", "#577590FF", "#4D908EFF", "#43AA8BFF", "#90BE6DFF", "#F9C74FFF", "#F9844AFF", "#F8961EFF", "#F3722CFF", "#F94144FF", "#FD0C10FF"], colorScheme: "rainbow", fill: "gradient", isolineColor: "inverted", isolineText: true, levels: [0, 4, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28], name: "Sea Surface Temperature", parent: "base", showAboveMax: true, showBelowMin: true, streamLineColor: "#777", streamLineSpeedFactor: 1, streamLineStatic: false, units: "C", vectorColor: "none", vectorType: "none" };
  var $w = {};
  var eP = { addDegrees: 0, blurRadius: 0, colors: ["#AC6EA4FF", "#8E92BDFF", "#ACD4DEFF", "#E9DC8EFF", "#E7A97DFF", "#E59074FF", "#BE7E68FF", "#A88F86FF"], colorScheme: "rainbow", fill: "gradient", isolineColor: "inverted", isolineText: true, levels: [0, 0.5, 1, 2, 3, 4, 6, 8], name: "Significant wave height", parent: "base", showAboveMax: true, showBelowMin: true, streamLineColor: "#777", streamLineSpeedFactor: 1, streamLineStatic: false, units: "", vectorColor: "none", vectorType: "none" };
  var tP = { addDegrees: 0, blurRadius: 0, colors: ["#6947F4FF", "#58D9F6FF", "#F3F76EFF", "#EC3737FF"], colorScheme: "rainbow", fill: "gradient", isolineColor: "none", isolineText: true, levels: [-30, 0, 20, 40], name: "Temperature pcolour", parent: "base", showAboveMax: true, showBelowMin: true, streamLineColor: "#777", streamLineSpeedFactor: 1, streamLineStatic: false, units: "C", vectorColor: "inverted", vectorType: "arrows" };
  var rP = { addDegrees: 0, blurRadius: 0, colors: ["#277DA1FF", "#577590FF", "#4D908EFF", "#43AA8BFF", "#90BE6DFF", "#F9C74FFF", "#F9844AFF", "#F8961EFF", "#F3722CFF", "#F94144FF"], colorScheme: "rainbow", fill: "gradient", isolineColor: "none", isolineText: true, levels: [1, 3, 5, 7, 9, 11, 13, 15, 17, 20, 24], name: "Wave period", parent: "base", showAboveMax: true, showBelowMin: true, streamLineColor: "#777", streamLineSpeedFactor: 1, streamLineStatic: false, units: "s", vectorColor: "inverted", vectorType: "arrows" };
  var nP = { addDegrees: 0, blurRadius: 0, colors: ["#577590FF", "#43AA8BFF", "#90BE6DFF", "#F9C74FFF", "#F8961EFF", "#F3722CFF", "#F94144FF", "#ED070BFF", "#670464FF"], colorScheme: "rainbow", fill: "gradient", isolineColor: "none", isolineText: true, levels: [0, 0.5, 1.5, 3.3, 5.5, 14, 18, 28, 33], name: "Wind Speed", parent: "base", showAboveMax: true, showBelowMin: true, streamLineColor: "#777", streamLineSpeedFactor: 1, streamLineStatic: false, units: "m/s", vectorColor: "none", vectorType: "none" };
  var iP = { addDegrees: 0, blurRadius: 0, colorMap: [[0, "#577590FF"], [0.5, "#43AA8BFF"], [1.5, "#90BE6DFF"], [3.3, "#F9C74FFF"], [5.5, "#F8961EFF"], [14, "#F3722CFF"], [18, "#F94144FF"], [28, "#ED070BFF"], [33, "#670464FF"]], colorScheme: "rainbow", fill: "gradient", isolineColor: "none", isolineText: true, name: "Wind Speed map", parent: "base", showAboveMax: true, showBelowMin: true, streamLineColor: "#777", streamLineSpeedFactor: 1, streamLineStatic: false, units: "m/s", vectorColor: "none", vectorType: "none" };
  var sP = { addDegrees: 0, blurRadius: 0, colors: ["#577590FF", "#43AA8BFF", "#90BE6DFF", "#F9C74FFF", "#F8961EFF", "#F3722CFF", "#F94144FF", "#ED070BFF", "#670464FF"], colorScheme: "rainbow", fill: "gradient", isolineColor: "none", isolineText: true, levels: [0, 1, 3, 6.5, 10, 30, 35, 55, 65], name: "Wind Speed barbs", parent: "base", showAboveMax: true, showBelowMin: true, streamLineColor: "none", streamLineSpeedFactor: 1, streamLineStatic: false, units: "knots", vectorColor: "#777", vectorType: "barbs" };
  var oP = { fill: "solid", name: "Sea Surface Temperature solid", parent: "Sea Surface Temperature" };
  var aP = { fill: "gradient", isolineColor: "inverted", isolineText: false, name: "Wind Speed2", parent: "Wind Speed", vectorColor: "inverted", vectorType: "arrows" };
  var cP = { addDegrees: 0, blurRadius: 0, colorScheme: "rainbow", fill: "gradient", isolineColor: "inverted", isolineText: true, name: "base", parent: "base", showAboveMax: true, showBelowMin: true, streamLineColor: "#777", streamLineSpeedFactor: 1, streamLineStatic: false, units: "", vectorColor: "inverted", vectorType: "arrows" };
  var u_ = { "Atmospheric pressure": Dw, base: Bw, "Chlorophyll-A": Uw, "Cloud cover": kw, "Current speed": Vw, precipitation: Gw, "Forecast Rain/Precip": zw, "Rain Radar reflectivity": jw, "rain.base": Ww, "rain.Classic.IRIS": Hw, "rain.EWIS": Xw, "rain.radar": Yw, "rain.radar.metocean": qw, "rain.radar.metocean.gradient": Zw, "rain.radar.metservice": Kw, "rain.radar.metservice.gradient": Qw, "Sea Surface Temperature": Jw, "Sea Surface Temperature pcolour": $w, "Significant wave height": eP, "Temperature pcolour": tP, "Wave period": rP, "Wind Speed": nP, "Wind Speed map": iP, "Wind Speed barbs": sP, temper2m: oP, "Wind Speed2": aP, direction: cP };
  var lP = "'degC': ['K', 1, 273.15] -> degC = K * 1 + 273.15";
  var fP = "'hPa': ['Pa', 1000]' -> hPa = Pa * 1000 + 0 (0 - could be ommited)";
  var uP = ["K", 1];
  var hP = ["K", 1];
  var dP = ["K", 0.5555555555, 255.372222222];
  var pP = ["K", 1, 273.15];
  var mP = ["K", 1, 273.15];
  var gP = ["kg/m^2/s", 1];
  var _P = ["kg/m^2/s", 1];
  var xP = ["kg/m^2/s", 1];
  var yP = ["kg/m^2/s", 1];
  var EP = ["kg/m^2/s", 1];
  var bP = ["W/m^2", 1];
  var TP = ["W/m^2", 1];
  var vP = ["W/m^2", 1];
  var AP = ["W/m^2", 1];
  var SP = ["W/m^2", 1];
  var wP = ["m/s", 1];
  var PP = ["m/s", 1];
  var LP = ["m/s", 1];
  var CP = ["m/s", 1];
  var RP = ["m/s", 0.514444];
  var MP = ["m/s", 0.514444];
  var IP = ["m/s", 0.27777777777];
  var OP = ["m/s", 0.27777777777];
  var NP = ["m/s", 0.27777777777];
  var FP = ["s", 1];
  var DP = ["s", 1];
  var BP = ["s", 3600];
  var UP = ["s", 60];
  var kP = ["m", 1];
  var VP = ["m", 0.01];
  var GP = ["m", 0.0254];
  var zP = ["Pa", 1];
  var jP = ["Pa", 1e3];
  var WP = ["degree", 1];
  var HP = ["degree", 57.3];
  var h_ = { comment1: lP, comment2: fP, K: uP, kelvin: hP, F: dP, C: pP, degC: mP, "kg/m^2/s": gP, "Kg/m^2/s": _P, "Kg m**-2 s**-1": xP, "Kg m^-2 s^-1": yP, "Kg m^{-2} s^-1": EP, "W/m^2": bP, "W m^-2": TP, "W m^{-2}": vP, "W/m**2": AP, "W m**-2": SP, "m/s": wP, "m s**-1": PP, "m s^-1": LP, "m.s^{-1}": CP, knot: RP, knots: MP, "km/h": IP, "km h^-1": OP, "km h**-1": NP, s: FP, sec: DP, h: BP, min: UP, m: kP, cm: VP, inch: GP, Pa: zP, hPa: jP, degree: WP, radian: HP };
  var XP = ["#00000000", "#00000000"];
  var YP = ["#ff0000ff", "#ffff00ff", "#00ff00ff", "#00ffffff", "#0000ffff", "#ff00ffff"];
  var qP = ["#ff000000", "#ff0000ff", "#ffff00ff", "#00ff00ff", "#00ffffff", "#0000ffff", "#ff00ffff"];
  var ZP = ["#ff0000ff", "#ffff00ff", "#00ff00ff", "#00ffffff", "#0000ffff", "#ff00ffff", "#ff0000ff"];
  var KP = ["#0000ffff", "#ff00ffff", "#00ffffff", "#9000ffff", "#9090ffff"];
  var QP = ["#0000ff00", "#0000ffff", "#ff00ffff", "#00ffffff", "#9000ffff", "#9090ffff"];
  var JP = ["#000000ff", "#ffffffff"];
  var $P = ["#ffffffff", "#000000ff"];
  var eL = ["#ff00ffff", "#ff0000ff", "#ffff00ff"];
  var tL = ["#ffff00ff", "#00ff00ff", "#00ffffff"];
  var rL = ["#ff00ffff", "#0000ffff", "#00ffffff"];
  var nL = ["#AC6EA4FF", "#8E92BDFF", "#ACD4DEFF", "#E9DC8EFF", "#E7A97DFF", "#E59074FF", "#BE7E68FF", "#A88F86FF"];
  var d_ = { none: XP, rainbow: YP, rainbowzerro: qP, rainbow2: ZP, bluebird: KP, bluebirdzerro: QP, bw: JP, wb: $P, redish: eL, greenish: tL, blueish: rL, hspastel: nL };
  async function xu(r2, e) {
    e[e.length - 1] != "/" && (e += "/");
    let t = (await pu(r2 + e + "instances.json")).reverse()[0] + "/", n = await pu(r2 + e + t + "meta.json");
    return { URITime: r2 + e + t + "{variable}/{time}/{z}/{x}/{y}.png", meta: n };
  }
  async function sL(r2 = {}) {
    let e = x({ colorStyles: u_, units: h_, colorSchemes: d_ }, r2);
    return n_(e), document.fonts.ready;
  }
  var kr = class extends fn {
    constructor(e) {
      super(e);
    }
    updateState(e) {
      super.updateState(e), e.changeFlags.propsChanged && this._prepareStateAndCLUT();
    }
    onHover(e, t) {
      !e.picked || this.onClick(e, t);
    }
    onClick(e, t) {
      let { coordinate: n, color: i } = e, { min: s, max: o, CLUT: a } = this.state, c = (o - s) / 65535, l = i[0] + i[1] * 256, f = c * l + s, u = a.DataToStyle(f), h = "lonLat:" + n + "<br>clut:" + u + " var: " + f + " color:" + i, d = document.getElementById("infoPanel");
      if (!d) {
        console.log(h);
        return;
      }
      d.innerHTML = h;
    }
    renderSubLayers(e) {
      let { tile: t, id: n, data: i } = e;
      if (!i)
        return null;
      let { west: s, south: o, east: a, north: c } = t.bbox, { wxprops: l, desaturate: f, transparentColor: u, tintColor: h, opacity: d } = this.props, { style: m } = l, { clutTextureUniform: _ } = this.state, { imageTextureUniform: E } = i;
      return [new Is({ id: n + "-fill", data: { clutTextureUniform: _, imageTextureUniform: E, style: m }, bounds: [s, o, a, c], image: null, pickable: true, opacity: d, desaturate: f, transparentColor: u, tintColor: h }), new Ms({ id: n + "-isotext", data: i.isoData, opacity: d }), i.vectorData && new Os({ id: n + "-vector", data: i.vectorData, fontFamily: m.vectorType, opacity: d })];
    }
    async getTileData(e) {
      let { data: t, wxprops: n } = this.props, { x: i, y: s, z: o, signal: a, bbox: c } = e, { boundaries: l } = n.meta, f = (S) => !(c.west > S.east || S.west > c.east || c.south > S.north || S.south > c.north);
      if ((l == null ? void 0 : l.boundaries180) && !l.boundaries180.some(f))
        return null;
      let { fetch: u } = this.getCurrentLayer().props;
      if (this.state.emptyTilesCache.has(i + ":" + s + ":" + o))
        return null;
      let h = (S) => t.replace("{variable}", S).replace("{x}", i + "").replace("{y}", s + "").replace("{z}", o + "").replace("{-y}", Math.pow(2, o) - s - 1 + ""), d = { width: 258, height: 258, format: de.RGBA, type: de.UNSIGNED_BYTE, dataFormat: de.RGBA, parameters: { [de.TEXTURE_WRAP_S]: de.CLAMP_TO_EDGE, [de.TEXTURE_WRAP_T]: de.CLAMP_TO_EDGE, [de.TEXTURE_MIN_FILTER]: de.LINEAR, [de.TEXTURE_MAG_FILTER]: de.LINEAR }, mipmaps: false }, m, _, E, b, T = (S) => u(h(S), { layer: this, signal: a });
      try {
        n.variables instanceof Array ? ([m, _] = await Promise.all(n.variables.map(T)), E = this._createVelocitiesImage(m, _), b = this._createVectorData(E, m, _, e)) : (E = await T(n.variables), b = this._createDegree(E, e));
      } catch {
        return this.state.emptyTilesCache.add(i + ":" + s + ":" + o), null;
      }
      let v = this._createIsolines(E, e), C = new Q(this.context.gl, L(x({}, d), { data: new Uint8Array(E.data.buffer) }));
      return { image: E, imageU: m, imageV: _, isoData: v, vectorData: b, imageTextureUniform: C };
    }
    _prepareStateAndCLUT() {
      let { style: e, variables: t, meta: n } = this.props.wxprops, { min: i, max: s, units: o } = n.variablesMeta[t instanceof Array ? t[0] : t];
      if (t instanceof Array) {
        let _ = n.variablesMeta[t[1]];
        s = 1.42 * Math.max(-i, s, -_.min, _.max), i = 0;
      }
      let a = new gu(e, o, [i, s], t instanceof Array), { colorsI: c, levelIndex: l } = a, f = 5, u = 65536 >> f, h = new Uint32Array(u * 2);
      for (let _ = 0; _ < u; ++_) {
        let E = _ << f;
        h[_] = c[E], h[u + _] = l[E];
      }
      let d = new Q(this.context.gl, { data: new Uint8Array(h.buffer), width: u, height: 2, format: de.RGBA, parameters: { [de.TEXTURE_WRAP_S]: de.CLAMP_TO_EDGE, [de.TEXTURE_WRAP_T]: de.CLAMP_TO_EDGE, [de.TEXTURE_MIN_FILTER]: de.NEAREST, [de.TEXTURE_MAG_FILTER]: de.NEAREST }, mipmaps: false }), m = new Set();
      this.setState({ emptyTilesCache: m, clutTextureUniform: d, min: i, max: s, CLUT: a });
    }
    _createIsolines(e, { x: t, y: n, z: i }) {
      let { style: s } = this.props.wxprops;
      if (!s.isolineText || s.isolineColor === "none" || !s.isolineText)
        return [];
      let { state: o } = this, a = o.CLUT, { levelIndex: c } = a, l = new Uint16Array(e.data.buffer), f = [], [u, h] = vc(t, n), d = (o.max - o.min) / 65535;
      for (let m = 0, _ = 0; m < 256; m += 5)
        for (let E = 0; E < 256; E += 5) {
          let b = ((m + 1) * 258 + (E + 1)) * 2, T = l[b], v = l[b + 2], C = l[b + 258 * 2];
          if (!T || !v || !C)
            continue;
          let S = c[T], R = c[v], D = c[C];
          if (S !== R || S !== D) {
            if (++_ % 2)
              continue;
            let B = Math.max(S, R, D), N = a.ticks[B].data, W = a.DataToStyle(o.min + d * T), q = a.DataToStyle(o.min + d * v), z = a.DataToStyle(o.min + d * C), V = 0.5 + (S !== R ? (W - N) / (W - q) : 0), Y = 0.5 + (S !== D ? (W - N) / (W - z) : 0), Se = Tc(u + E + V, h + m + Y, i), jt = a.ticks[B].dataString, cr = li(s.isolineColor === "inverted" ? ~a.colorsI[T] : a.colorsI[T]), Wt = Math.atan2(T - v, T - C) * 57.3;
            (-90 > Wt || Wt > 90) && (Wt += 180), f.push({ position: Se, text: jt, angle: Wt, color: cr });
          }
        }
      return f;
    }
    _createDegree(e, { x: t, y: n, z: i }) {
      let { meta: s, variables: o } = this.props.wxprops;
      if (o instanceof Array)
        return;
      let { min: a, max: c, units: l } = s.variablesMeta[o];
      if (l !== "degree")
        return;
      let { style: f } = this.props.wxprops;
      if (f.vectorColor === "none")
        return;
      let u = this.state.CLUT, h = new Uint16Array(e.data.buffer), d = (c - a) / 65535, [m, _] = vc(t, n), E = [], b = 16;
      for (let T = b / 2; T < 256; T += b)
        for (let v = b / 2; v < 256; v += b) {
          let C = (v + 1 + (T + 1) * 258) * 2, S = h[C];
          if (!S)
            continue;
          let R = 180 - (a + d * h[C] + f.addDegrees), D = "F", B = Tc(m + v + 0.5, _ + T + 0.5, i), N = li(f.vectorColor === "inverted" ? ~u.colorsI[S] : f.vectorColor === "fill" ? u.colorsI[S] : ht(f.vectorColor));
          E.push({ position: B, text: D, angle: R, color: N });
        }
      return E;
    }
    _createVelocitiesImage(e, t) {
      let { meta: n, variables: i } = this.props.wxprops, s = new ImageData(258, 258);
      if (!(i instanceof Array))
        return s;
      let [o, a] = i.map((E) => n.variablesMeta[E]), { min: c, max: l } = this.state, f = (l - c) / 65535, u = (a.max - a.min) / 65535, h = (o.max - o.min) / 65535, d = new Uint16Array(s.data.buffer), m = new Uint16Array(e.data.buffer), _ = new Uint16Array(t.data.buffer);
      for (let E = 0; E < 258 * 258 * 2; E += 2) {
        if (d[E + 1] = 65280, !m[E] || !_[E]) {
          d[E] = 0;
          continue;
        }
        let b = o.min + h * m[E], T = a.min + u * _[E];
        d[E] = Math.sqrt(T * T + b * b) / f;
      }
      return s;
    }
    _createVectorData(e, t, n, { x: i, y: s, z: o }) {
      let { meta: a, variables: c } = this.props.wxprops, l = this.state.CLUT, { style: f } = this.props.wxprops;
      if (!(c instanceof Array) || !l.DataToKnots || f.vectorColor === "none")
        return [];
      let { min: u, max: h } = this.state, [d, m] = c.map((N) => a.variablesMeta[N]), _ = new Uint16Array(e.data.buffer), E = new Uint16Array(t.data.buffer), b = new Uint16Array(n.data.buffer), T = (h - u) / 65535, v = (m.max - m.min) / 65535, C = (d.max - d.min) / 65535, [S, R] = vc(i, s), D = [], B = 32;
      for (let N = B / 2; N < 256; N += B)
        for (let W = B / 2; W < 256; W += B) {
          let q = (W + 1 + (N + 1) * 258) * 2;
          if (!_[q])
            continue;
          let z = d.min + C * E[q], V = m.min + v * b[q], Y = Math.atan2(-z, V) * 57.3 + f.addDegrees, Se = u + T * _[q], jt = c[0].includes("current") ? 5 : 0.2, cr = Math.min(l.DataToKnots(Se) * jt, 25) + 65, Wt = String.fromCharCode(cr), Ac = Tc(S + W, R + N, o), Sc = li(f.vectorColor === "inverted" ? ~l.colorsI[_[q]] : f.vectorColor === "fill" ? l.colorsI[_[q]] : ht(f.vectorColor));
          D.push({ position: Ac, text: Wt, angle: Y, color: Sc });
        }
      return D;
    }
  };
  kr.layerName = "WxTilesLayer";
  kr.defaultProps = { minZoom: 0, tileSize: 256, pickable: true, loadOptions: { image: { type: "data", decode: true } }, transparentColor: { type: "color", value: [0, 0, 0, 0] }, opacity: { type: "number", min: 0, max: 1, value: 1 }, desaturate: { type: "number", min: 0, max: 1, value: 0 }, tintColor: { type: "color", value: [255, 255, 255] } };
  async function oL(r2, e, t) {
    let [n, i, s] = e, { URITime: o, meta: a } = await xu(r2, n);
    return { id: `wxtiles/${n}/${i}/`, wxprops: { meta: a, variables: i, style: i_()[s], URITime: o }, data: o.replace("{time}", a.times[0]), maxZoom: a.maxZoom, loadOptions: { fetch: t, image: { decode: true, type: "data" } } };
  }
  function p_({ map: r2, gl: e, deck: t }) {
    if (r2.__deck)
      return r2.__deck;
    let n = t && t.props._customRender, i = { useDevicePixels: true, _customRender: () => {
      r2.triggerRepaint(), n && n();
    }, parameters: { depthMask: true, depthTest: true, blendFunc: [770, 771, 1, 771], blendEquation: 32774 }, userData: { isExternal: false, mapboxLayers: new Set() } };
    return t ? (t.setProps(i), t.props.userData.isExternal = true) : (Object.assign(i, { gl: e, width: false, height: false, touchAction: "unset", viewState: yu(r2) }), t = new Ir(i), r2.on("move", () => fL(t, r2)), r2.on("remove", () => {
      t.finalize(), r2.__deck = null;
    })), t.props.userData.mapboxVersion = cL(r2), r2.__deck = t, r2.on("render", () => {
      t.layerManager && lL(t, r2);
    }), t;
  }
  function m_(r2, e) {
    r2.props.userData.mapboxLayers.add(e), Eu(r2);
  }
  function g_(r2, e) {
    r2.props.userData.mapboxLayers.delete(e), Eu(r2);
  }
  function __(r2, e) {
    Eu(r2);
  }
  function x_(r2, e, t) {
    let { currentViewport: n } = r2.props.userData;
    n || (n = y_(r2, e, true), r2.props.userData.currentViewport = n), !!r2.layerManager && r2._drawLayers("mapbox-repaint", { viewports: [n], layers: E_(r2, (i) => b_(t.id, i)), clearCanvas: false });
  }
  function yu(r2) {
    let { lng: e, lat: t } = r2.getCenter();
    return { longitude: e, latitude: t, zoom: r2.getZoom(), bearing: r2.getBearing(), pitch: r2.getPitch() };
  }
  function cL(r2) {
    let e = 0, t = 0;
    return r2.version && ([e, t] = r2.version.split(".").slice(0, 2).map(Number)), { major: e, minor: t };
  }
  function y_(r2, e, t = true) {
    let { mapboxVersion: n } = r2.props.userData;
    return new Je(Object.assign({ x: 0, y: 0, width: r2.width, height: r2.height, repeat: true }, yu(e), t ? { nearZMultiplier: n.major === 1 && n.minor >= 3 || n.major >= 2 ? 0.02 : 1 / (r2.height || 1) } : { nearZMultiplier: 0.1 }));
  }
  function lL(r2, e) {
    let { mapboxLayers: t, isExternal: n } = r2.props.userData;
    if (n) {
      let i = Array.from(t, (o) => o.id), s = E_(r2, (o) => {
        for (let a of i)
          if (b_(a, o))
            return false;
        return true;
      });
      s.length > 0 && r2._drawLayers("mapbox-repaint", { viewports: [y_(r2, e, false)], layers: s, clearCanvas: false });
    }
    r2.props.userData.currentViewport = null;
  }
  function fL(r2, e) {
    r2.setProps({ viewState: yu(e) }), r2.needsRedraw({ clearRedrawFlags: true });
  }
  function E_(r2, e) {
    return r2.layerManager.getLayers().filter(e);
  }
  function b_(r2, e) {
    let t = e;
    for (; t; ) {
      if (t.id === r2)
        return true;
      t = t.parent;
    }
    return false;
  }
  function Eu(r2) {
    if (r2.props.userData.isExternal)
      return;
    let e = [];
    r2.props.userData.mapboxLayers.forEach((t) => {
      let n = t.props.type, i = new n(t.props);
      e.push(i);
    }), r2.setProps({ layers: e });
  }
  var Ns = class {
    constructor(e) {
      if (!e.id)
        throw new Error("Layer must have an unique id");
      this.id = e.id, this.type = "custom", this.renderingMode = e.renderingMode || "3d", this.map = null, this.deck = null, this.props = e;
    }
    onAdd(e, t) {
      this.map = e, this.deck = p_({ map: e, gl: t, deck: this.props.deck }), m_(this.deck, this);
    }
    onRemove() {
      g_(this.deck, this);
    }
    setProps(e) {
      Object.assign(this.props, e, { id: this.id }), this.deck && __(this.deck, this);
    }
    render(e, t) {
      x_(this.deck, this.map, this);
    }
  };
  var uL = (r2, e, t = r2.getStyle().layers[r2.getStyle().layers.length - 1].id) => {
    let n = r2.getStyle().layers[0].id, i = -1, s, o = () => {
    }, a = async () => {
      let { cancel: l, layerId: f, promise: u } = c(i);
      o(), o = l, await u, r2.moveLayer(f, t), s && r2.removeLayer(s), s = f, o = () => {
      };
    }, c = (l) => {
      let f = e.wxprops.URITime.replace("{time}", e.wxprops.meta.times[l]), u = e.id + l, h = new Promise((d, m) => {
        let _ = new Ns(L(x({ type: kr }, e), { id: u, data: f, onViewportLoad: d }));
        r2.addLayer(_, n);
      });
      return { layerId: u, promise: h, cancel: () => {
        r2.removeLayer(u);
      } };
    };
    return { nextTimestep: async () => (i = (++i + e.wxprops.meta.times.length) % e.wxprops.meta.times.length, await a(), i), prevTimestep: async () => (i = (--i + e.wxprops.meta.times.length) % e.wxprops.meta.times.length, await a(), i), goToTimestep: async (l) => {
      l !== i && (i = (l + e.wxprops.meta.times.length) % e.wxprops.meta.times.length, await a());
    }, cancel: () => {
      o(), o = () => {
      };
    }, remove: () => {
      o(), o = () => {
      }, s && r2.removeLayer(s), s = void 0;
    } };
  };

  // src/wxtiles-mapbox-gl.ts
  var import_mapbox_gl = __toModule(require_mapbox_gl());
  var import_mapbox_gl2 = __toModule(require_mapbox_gl());
  import_mapbox_gl.default.accessToken = "pk.eyJ1IjoibWV0b2NlYW4iLCJhIjoia1hXZjVfSSJ9.rQPq6XLE0VhVPtcD9Cfw6A";
  (async () => {
    const map = new import_mapbox_gl2.Map({
      container: "map",
      style: "mapbox://styles/mapbox/streets-v9",
      center: [175, -40],
      zoom: 7
    });
    await sL();
    map.on("load", async () => {
      map.addSource("pointLayerSource", {
        type: "geojson",
        data: {
          type: "FeatureCollection",
          features: [
            {
              type: "Feature",
              geometry: {
                type: "Point",
                coordinates: [-74.52, 40]
              },
              properties: {
                name: "my point hehe"
              }
            },
            {
              type: "Feature",
              geometry: {
                type: "Point",
                coordinates: [-74.46, 40]
              },
              properties: {
                name: "Boo"
              }
            }
          ]
        }
      });
      map.addLayer({
        id: "pointLayer",
        type: "symbol",
        source: "pointLayerSource",
        layout: {
          "icon-image": "star-11",
          "icon-size": 1,
          "icon-allow-overlap": true,
          "icon-ignore-placement": false,
          "icon-padding": 1,
          "icon-optional": false,
          "text-field": "{name}",
          "text-anchor": "top",
          "text-offset": [0, 1],
          "text-optional": true,
          "text-font": ["Lato Bold", "Arial Unicode MS Bold"],
          "text-size": {
            stops: [
              [0, 0],
              [3, 0],
              [3.0001, 13]
            ]
          },
          "text-letter-spacing": 0.05,
          "text-line-height": 1
        },
        paint: {
          "text-halo-color": "#303030",
          "text-color": "#F5F5F5",
          "text-halo-width": 1.5,
          "text-halo-blur": 1
        }
      });
      const params = ["ecwmf.global", "air.temperature.at-2m", "temper2m"];
      const wxProps = await oL("https://tiles.metoceanapi.com/data/", params);
      wxProps.opacity = 0.7;
      const layer = uL(map, wxProps);
      let isPlaying = false;
      const play = async () => {
        do {
          await layer.nextTimestep();
        } while (isPlaying);
      };
      const nextButton = document.getElementById("next");
      const prevButton = document.getElementById("prev");
      const playButton = document.getElementById("play");
      const removeButton = document.getElementById("remove");
      removeButton?.addEventListener("click", () => layer.remove());
      nextButton?.addEventListener("click", () => layer.nextTimestep());
      prevButton?.addEventListener("click", () => layer.prevTimestep());
      playButton?.addEventListener("click", () => {
        layer.cancel();
        isPlaying = !isPlaying;
        isPlaying && play();
        playButton.innerHTML = isPlaying ? "Stop" : "Play";
      });
      layer.nextTimestep();
    });
  })();
})();
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
//# sourceMappingURL=wxtiles-mapbox-gl.js.map
